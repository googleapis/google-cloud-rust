// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/)
/// configuration for API handlers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiConfigHandler {
    /// Action to take when users access resources that require
    /// authentication. Defaults to `redirect`.
    pub auth_fail_action: crate::model::AuthFailAction,

    /// Level of login required to access this resource. Defaults to
    /// `optional`.
    pub login: crate::model::LoginRequirement,

    /// Path to the script from the application root directory.
    pub script: std::string::String,

    /// Security (HTTPS) enforcement for this URL.
    pub security_level: crate::model::SecurityLevel,

    /// URL to serve the endpoint at.
    pub url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiConfigHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_fail_action][crate::model::ApiConfigHandler::auth_fail_action].
    pub fn set_auth_fail_action<T: std::convert::Into<crate::model::AuthFailAction>>(
        mut self,
        v: T,
    ) -> Self {
        self.auth_fail_action = v.into();
        self
    }

    /// Sets the value of [login][crate::model::ApiConfigHandler::login].
    pub fn set_login<T: std::convert::Into<crate::model::LoginRequirement>>(
        mut self,
        v: T,
    ) -> Self {
        self.login = v.into();
        self
    }

    /// Sets the value of [script][crate::model::ApiConfigHandler::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::ApiConfigHandler::security_level].
    pub fn set_security_level<T: std::convert::Into<crate::model::SecurityLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [url][crate::model::ApiConfigHandler::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for ApiConfigHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ApiConfigHandler"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiConfigHandler {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auth_fail_action,
            __login,
            __script,
            __security_level,
            __url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiConfigHandler")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authFailAction" => Ok(__FieldTag::__auth_fail_action),
                            "auth_fail_action" => Ok(__FieldTag::__auth_fail_action),
                            "login" => Ok(__FieldTag::__login),
                            "script" => Ok(__FieldTag::__script),
                            "securityLevel" => Ok(__FieldTag::__security_level),
                            "security_level" => Ok(__FieldTag::__security_level),
                            "url" => Ok(__FieldTag::__url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiConfigHandler;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiConfigHandler")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auth_fail_action => {
                            if !fields.insert(__FieldTag::__auth_fail_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_fail_action",
                                ));
                            }
                            result.auth_fail_action = map
                                .next_value::<std::option::Option<crate::model::AuthFailAction>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__login => {
                            if !fields.insert(__FieldTag::__login) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for login",
                                ));
                            }
                            result.login = map
                                .next_value::<std::option::Option<crate::model::LoginRequirement>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            result.script = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_level => {
                            if !fields.insert(__FieldTag::__security_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_level",
                                ));
                            }
                            result.security_level = map
                                .next_value::<std::option::Option<crate::model::SecurityLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiConfigHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auth_fail_action) {
            state.serialize_entry("authFailAction", &self.auth_fail_action)?;
        }
        if !wkt::internal::is_default(&self.login) {
            state.serialize_entry("login", &self.login)?;
        }
        if !self.script.is_empty() {
            state.serialize_entry("script", &self.script)?;
        }
        if !wkt::internal::is_default(&self.security_level) {
            state.serialize_entry("securityLevel", &self.security_level)?;
        }
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiConfigHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiConfigHandler");
        debug_struct.field("auth_fail_action", &self.auth_fail_action);
        debug_struct.field("login", &self.login);
        debug_struct.field("script", &self.script);
        debug_struct.field("security_level", &self.security_level);
        debug_struct.field("url", &self.url);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Custom static error page to be served when an error occurs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorHandler {
    /// Error condition this handler applies to.
    pub error_code: crate::model::error_handler::ErrorCode,

    /// Static file content to be served for this error.
    pub static_file: std::string::String,

    /// MIME type of file. Defaults to `text/html`.
    pub mime_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::ErrorHandler::error_code].
    pub fn set_error_code<T: std::convert::Into<crate::model::error_handler::ErrorCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [static_file][crate::model::ErrorHandler::static_file].
    pub fn set_static_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.static_file = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::ErrorHandler::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for ErrorHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ErrorHandler"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorHandler {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_code,
            __static_file,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorHandler")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorCode" => Ok(__FieldTag::__error_code),
                            "error_code" => Ok(__FieldTag::__error_code),
                            "staticFile" => Ok(__FieldTag::__static_file),
                            "static_file" => Ok(__FieldTag::__static_file),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorHandler;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorHandler")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_code => {
                            if !fields.insert(__FieldTag::__error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_code",
                                ));
                            }
                            result.error_code = map.next_value::<std::option::Option<crate::model::error_handler::ErrorCode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__static_file => {
                            if !fields.insert(__FieldTag::__static_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_file",
                                ));
                            }
                            result.static_file = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.error_code) {
            state.serialize_entry("errorCode", &self.error_code)?;
        }
        if !self.static_file.is_empty() {
            state.serialize_entry("staticFile", &self.static_file)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ErrorHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorHandler");
        debug_struct.field("error_code", &self.error_code);
        debug_struct.field("static_file", &self.static_file);
        debug_struct.field("mime_type", &self.mime_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ErrorHandler].
pub mod error_handler {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// Not specified. ERROR_CODE_DEFAULT is assumed.
        Unspecified,
        /// All other error types.
        Default,
        /// Application has exceeded a resource quota.
        OverQuota,
        /// Client blocked by the application's Denial of Service protection
        /// configuration.
        DosApiDenial,
        /// Deadline reached before the application responds.
        Timeout,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(0),
                Self::OverQuota => std::option::Option::Some(1),
                Self::DosApiDenial => std::option::Option::Some(2),
                Self::Timeout => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("ERROR_CODE_DEFAULT"),
                Self::OverQuota => std::option::Option::Some("ERROR_CODE_OVER_QUOTA"),
                Self::DosApiDenial => std::option::Option::Some("ERROR_CODE_DOS_API_DENIAL"),
                Self::Timeout => std::option::Option::Some("ERROR_CODE_TIMEOUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Default,
                1 => Self::OverQuota,
                2 => Self::DosApiDenial,
                3 => Self::Timeout,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "ERROR_CODE_DEFAULT" => Self::Default,
                "ERROR_CODE_OVER_QUOTA" => Self::OverQuota,
                "ERROR_CODE_DOS_API_DENIAL" => Self::DosApiDenial,
                "ERROR_CODE_TIMEOUT" => Self::Timeout,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(0),
                Self::OverQuota => serializer.serialize_i32(1),
                Self::DosApiDenial => serializer.serialize_i32(2),
                Self::Timeout => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.appengine.v1.ErrorHandler.ErrorCode",
            ))
        }
    }
}

/// URL pattern and description of how the URL should be handled. App Engine can
/// handle URLs by executing application code or by serving static files
/// uploaded with the version, such as images, CSS, or JavaScript.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UrlMap {
    /// URL prefix. Uses regular expression syntax, which means regexp
    /// special characters must be escaped, but should not contain groupings.
    /// All URLs that begin with this prefix are handled by this handler, using the
    /// portion of the URL after the prefix as part of the file path.
    pub url_regex: std::string::String,

    /// Security (HTTPS) enforcement for this URL.
    pub security_level: crate::model::SecurityLevel,

    /// Level of login required to access this resource. Not supported for Node.js
    /// in the App Engine standard environment.
    pub login: crate::model::LoginRequirement,

    /// Action to take when users access resources that require
    /// authentication. Defaults to `redirect`.
    pub auth_fail_action: crate::model::AuthFailAction,

    /// `30x` code to use when performing redirects for the `secure` field.
    /// Defaults to `302`.
    pub redirect_http_response_code: crate::model::url_map::RedirectHttpResponseCode,

    /// Type of handler for this URL pattern.
    pub handler_type: std::option::Option<crate::model::url_map::HandlerType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UrlMap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url_regex][crate::model::UrlMap::url_regex].
    pub fn set_url_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url_regex = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::UrlMap::security_level].
    pub fn set_security_level<T: std::convert::Into<crate::model::SecurityLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [login][crate::model::UrlMap::login].
    pub fn set_login<T: std::convert::Into<crate::model::LoginRequirement>>(
        mut self,
        v: T,
    ) -> Self {
        self.login = v.into();
        self
    }

    /// Sets the value of [auth_fail_action][crate::model::UrlMap::auth_fail_action].
    pub fn set_auth_fail_action<T: std::convert::Into<crate::model::AuthFailAction>>(
        mut self,
        v: T,
    ) -> Self {
        self.auth_fail_action = v.into();
        self
    }

    /// Sets the value of [redirect_http_response_code][crate::model::UrlMap::redirect_http_response_code].
    pub fn set_redirect_http_response_code<
        T: std::convert::Into<crate::model::url_map::RedirectHttpResponseCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redirect_http_response_code = v.into();
        self
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type].
    ///
    /// Note that all the setters affecting `handler_type` are mutually
    /// exclusive.
    pub fn set_handler_type<
        T: std::convert::Into<std::option::Option<crate::model::url_map::HandlerType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type = v.into();
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `StaticFiles`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_files(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticFilesHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::StaticFiles(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `StaticFiles`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_static_files<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticFilesHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::StaticFiles(v.into()));
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `Script`, `None` if the field is not set or
    /// holds a different branch.
    pub fn script(&self) -> std::option::Option<&std::boxed::Box<crate::model::ScriptHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::Script(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `Script`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_script<T: std::convert::Into<std::boxed::Box<crate::model::ScriptHandler>>>(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::Script(v.into()));
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `ApiEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn api_endpoint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ApiEndpointHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::ApiEndpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `ApiEndpoint`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_api_endpoint<
        T: std::convert::Into<std::boxed::Box<crate::model::ApiEndpointHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::ApiEndpoint(v.into()));
        self
    }
}

impl wkt::message::Message for UrlMap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UrlMap"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UrlMap {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url_regex,
            __static_files,
            __script,
            __api_endpoint,
            __security_level,
            __login,
            __auth_fail_action,
            __redirect_http_response_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UrlMap")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "urlRegex" => Ok(__FieldTag::__url_regex),
                            "url_regex" => Ok(__FieldTag::__url_regex),
                            "staticFiles" => Ok(__FieldTag::__static_files),
                            "static_files" => Ok(__FieldTag::__static_files),
                            "script" => Ok(__FieldTag::__script),
                            "apiEndpoint" => Ok(__FieldTag::__api_endpoint),
                            "api_endpoint" => Ok(__FieldTag::__api_endpoint),
                            "securityLevel" => Ok(__FieldTag::__security_level),
                            "security_level" => Ok(__FieldTag::__security_level),
                            "login" => Ok(__FieldTag::__login),
                            "authFailAction" => Ok(__FieldTag::__auth_fail_action),
                            "auth_fail_action" => Ok(__FieldTag::__auth_fail_action),
                            "redirectHttpResponseCode" => {
                                Ok(__FieldTag::__redirect_http_response_code)
                            }
                            "redirect_http_response_code" => {
                                Ok(__FieldTag::__redirect_http_response_code)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UrlMap;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UrlMap")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url_regex => {
                            if !fields.insert(__FieldTag::__url_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url_regex",
                                ));
                            }
                            result.url_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__static_files => {
                            if !fields.insert(__FieldTag::__static_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_files",
                                ));
                            }
                            if result.handler_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `handler_type`, a oneof with full ID .google.appengine.v1.UrlMap.static_files, latest field was staticFiles",
                                ));
                            }
                            result.handler_type = std::option::Option::Some(
                                crate::model::url_map::HandlerType::StaticFiles(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StaticFilesHandler>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            if result.handler_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `handler_type`, a oneof with full ID .google.appengine.v1.UrlMap.script, latest field was script",
                                ));
                            }
                            result.handler_type = std::option::Option::Some(
                                crate::model::url_map::HandlerType::Script(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ScriptHandler>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__api_endpoint => {
                            if !fields.insert(__FieldTag::__api_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_endpoint",
                                ));
                            }
                            if result.handler_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `handler_type`, a oneof with full ID .google.appengine.v1.UrlMap.api_endpoint, latest field was apiEndpoint",
                                ));
                            }
                            result.handler_type = std::option::Option::Some(
                                crate::model::url_map::HandlerType::ApiEndpoint(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ApiEndpointHandler>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__security_level => {
                            if !fields.insert(__FieldTag::__security_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_level",
                                ));
                            }
                            result.security_level = map
                                .next_value::<std::option::Option<crate::model::SecurityLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__login => {
                            if !fields.insert(__FieldTag::__login) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for login",
                                ));
                            }
                            result.login = map
                                .next_value::<std::option::Option<crate::model::LoginRequirement>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auth_fail_action => {
                            if !fields.insert(__FieldTag::__auth_fail_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_fail_action",
                                ));
                            }
                            result.auth_fail_action = map
                                .next_value::<std::option::Option<crate::model::AuthFailAction>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redirect_http_response_code => {
                            if !fields.insert(__FieldTag::__redirect_http_response_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect_http_response_code",
                                ));
                            }
                            result.redirect_http_response_code = map
                                .next_value::<std::option::Option<
                                    crate::model::url_map::RedirectHttpResponseCode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UrlMap {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url_regex.is_empty() {
            state.serialize_entry("urlRegex", &self.url_regex)?;
        }
        if let Some(value) = self.static_files() {
            state.serialize_entry("staticFiles", value)?;
        }
        if let Some(value) = self.script() {
            state.serialize_entry("script", value)?;
        }
        if let Some(value) = self.api_endpoint() {
            state.serialize_entry("apiEndpoint", value)?;
        }
        if !wkt::internal::is_default(&self.security_level) {
            state.serialize_entry("securityLevel", &self.security_level)?;
        }
        if !wkt::internal::is_default(&self.login) {
            state.serialize_entry("login", &self.login)?;
        }
        if !wkt::internal::is_default(&self.auth_fail_action) {
            state.serialize_entry("authFailAction", &self.auth_fail_action)?;
        }
        if !wkt::internal::is_default(&self.redirect_http_response_code) {
            state.serialize_entry(
                "redirectHttpResponseCode",
                &self.redirect_http_response_code,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UrlMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UrlMap");
        debug_struct.field("url_regex", &self.url_regex);
        debug_struct.field("security_level", &self.security_level);
        debug_struct.field("login", &self.login);
        debug_struct.field("auth_fail_action", &self.auth_fail_action);
        debug_struct.field(
            "redirect_http_response_code",
            &self.redirect_http_response_code,
        );
        debug_struct.field("handler_type", &self.handler_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UrlMap].
pub mod url_map {
    #[allow(unused_imports)]
    use super::*;

    /// Redirect codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RedirectHttpResponseCode {
        /// Not specified. `302` is assumed.
        Unspecified,
        /// `301 Moved Permanently` code.
        RedirectHttpResponseCode301,
        /// `302 Moved Temporarily` code.
        RedirectHttpResponseCode302,
        /// `303 See Other` code.
        RedirectHttpResponseCode303,
        /// `307 Temporary Redirect` code.
        RedirectHttpResponseCode307,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RedirectHttpResponseCode::value] or
        /// [RedirectHttpResponseCode::name].
        UnknownValue(redirect_http_response_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod redirect_http_response_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RedirectHttpResponseCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RedirectHttpResponseCode301 => std::option::Option::Some(1),
                Self::RedirectHttpResponseCode302 => std::option::Option::Some(2),
                Self::RedirectHttpResponseCode303 => std::option::Option::Some(3),
                Self::RedirectHttpResponseCode307 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED")
                }
                Self::RedirectHttpResponseCode301 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_301")
                }
                Self::RedirectHttpResponseCode302 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_302")
                }
                Self::RedirectHttpResponseCode303 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_303")
                }
                Self::RedirectHttpResponseCode307 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_307")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RedirectHttpResponseCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RedirectHttpResponseCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RedirectHttpResponseCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RedirectHttpResponseCode301,
                2 => Self::RedirectHttpResponseCode302,
                3 => Self::RedirectHttpResponseCode303,
                4 => Self::RedirectHttpResponseCode307,
                _ => Self::UnknownValue(redirect_http_response_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RedirectHttpResponseCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED" => Self::Unspecified,
                "REDIRECT_HTTP_RESPONSE_CODE_301" => Self::RedirectHttpResponseCode301,
                "REDIRECT_HTTP_RESPONSE_CODE_302" => Self::RedirectHttpResponseCode302,
                "REDIRECT_HTTP_RESPONSE_CODE_303" => Self::RedirectHttpResponseCode303,
                "REDIRECT_HTTP_RESPONSE_CODE_307" => Self::RedirectHttpResponseCode307,
                _ => Self::UnknownValue(redirect_http_response_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RedirectHttpResponseCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RedirectHttpResponseCode301 => serializer.serialize_i32(1),
                Self::RedirectHttpResponseCode302 => serializer.serialize_i32(2),
                Self::RedirectHttpResponseCode303 => serializer.serialize_i32(3),
                Self::RedirectHttpResponseCode307 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RedirectHttpResponseCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<RedirectHttpResponseCode>::new(
                    ".google.appengine.v1.UrlMap.RedirectHttpResponseCode",
                ),
            )
        }
    }

    /// Type of handler for this URL pattern.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HandlerType {
        /// Returns the contents of a file, such as an image, as the response.
        StaticFiles(std::boxed::Box<crate::model::StaticFilesHandler>),
        /// Executes a script to handle the requests that match this URL
        /// pattern. Only the `auto` value is supported for Node.js in the
        /// App Engine standard environment, for example `"script": "auto"`.
        Script(std::boxed::Box<crate::model::ScriptHandler>),
        /// Uses API Endpoints to handle requests.
        ApiEndpoint(std::boxed::Box<crate::model::ApiEndpointHandler>),
    }
}

/// Files served directly to the user for a given URL, such as images, CSS
/// stylesheets, or JavaScript source files. Static file handlers describe which
/// files in the application directory are static files, and which URLs serve
/// them.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StaticFilesHandler {
    /// Path to the static files matched by the URL pattern, from the
    /// application root directory. The path can refer to text matched in groupings
    /// in the URL pattern.
    pub path: std::string::String,

    /// Regular expression that matches the file paths for all files that should be
    /// referenced by this handler.
    pub upload_path_regex: std::string::String,

    /// HTTP headers to use for all responses from these URLs.
    pub http_headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// MIME type used to serve all files served by this handler.
    ///
    /// Defaults to file-specific MIME types, which are derived from each file's
    /// filename extension.
    pub mime_type: std::string::String,

    /// Time a static file served by this handler should be cached
    /// by web proxies and browsers.
    pub expiration: std::option::Option<wkt::Duration>,

    /// Whether this handler should match the request if the file
    /// referenced by the handler does not exist.
    pub require_matching_file: bool,

    /// Whether files should also be uploaded as code data. By default, files
    /// declared in static file handlers are uploaded as static
    /// data and are only served to end users; they cannot be read by the
    /// application. If enabled, uploads are charged against both your code and
    /// static data storage resource quotas.
    pub application_readable: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticFilesHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::StaticFilesHandler::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [upload_path_regex][crate::model::StaticFilesHandler::upload_path_regex].
    pub fn set_upload_path_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.upload_path_regex = v.into();
        self
    }

    /// Sets the value of [http_headers][crate::model::StaticFilesHandler::http_headers].
    pub fn set_http_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.http_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [mime_type][crate::model::StaticFilesHandler::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [expiration][crate::model::StaticFilesHandler::expiration].
    pub fn set_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration][crate::model::StaticFilesHandler::expiration].
    pub fn set_or_clear_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [require_matching_file][crate::model::StaticFilesHandler::require_matching_file].
    pub fn set_require_matching_file<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_matching_file = v.into();
        self
    }

    /// Sets the value of [application_readable][crate::model::StaticFilesHandler::application_readable].
    pub fn set_application_readable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.application_readable = v.into();
        self
    }
}

impl wkt::message::Message for StaticFilesHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.StaticFilesHandler"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StaticFilesHandler {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __upload_path_regex,
            __http_headers,
            __mime_type,
            __expiration,
            __require_matching_file,
            __application_readable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StaticFilesHandler")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "uploadPathRegex" => Ok(__FieldTag::__upload_path_regex),
                            "upload_path_regex" => Ok(__FieldTag::__upload_path_regex),
                            "httpHeaders" => Ok(__FieldTag::__http_headers),
                            "http_headers" => Ok(__FieldTag::__http_headers),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "expiration" => Ok(__FieldTag::__expiration),
                            "requireMatchingFile" => Ok(__FieldTag::__require_matching_file),
                            "require_matching_file" => Ok(__FieldTag::__require_matching_file),
                            "applicationReadable" => Ok(__FieldTag::__application_readable),
                            "application_readable" => Ok(__FieldTag::__application_readable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StaticFilesHandler;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StaticFilesHandler")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upload_path_regex => {
                            if !fields.insert(__FieldTag::__upload_path_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upload_path_regex",
                                ));
                            }
                            result.upload_path_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_headers => {
                            if !fields.insert(__FieldTag::__http_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_headers",
                                ));
                            }
                            result.http_headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration => {
                            if !fields.insert(__FieldTag::__expiration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration",
                                ));
                            }
                            result.expiration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__require_matching_file => {
                            if !fields.insert(__FieldTag::__require_matching_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_matching_file",
                                ));
                            }
                            result.require_matching_file = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__application_readable => {
                            if !fields.insert(__FieldTag::__application_readable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_readable",
                                ));
                            }
                            result.application_readable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StaticFilesHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.upload_path_regex.is_empty() {
            state.serialize_entry("uploadPathRegex", &self.upload_path_regex)?;
        }
        if !self.http_headers.is_empty() {
            state.serialize_entry("httpHeaders", &self.http_headers)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if self.expiration.is_some() {
            state.serialize_entry("expiration", &self.expiration)?;
        }
        if !wkt::internal::is_default(&self.require_matching_file) {
            state.serialize_entry("requireMatchingFile", &self.require_matching_file)?;
        }
        if !wkt::internal::is_default(&self.application_readable) {
            state.serialize_entry("applicationReadable", &self.application_readable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StaticFilesHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StaticFilesHandler");
        debug_struct.field("path", &self.path);
        debug_struct.field("upload_path_regex", &self.upload_path_regex);
        debug_struct.field("http_headers", &self.http_headers);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("expiration", &self.expiration);
        debug_struct.field("require_matching_file", &self.require_matching_file);
        debug_struct.field("application_readable", &self.application_readable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Executes a script to handle the request that matches the URL pattern.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScriptHandler {
    /// Path to the script from the application root directory.
    pub script_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScriptHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_path][crate::model::ScriptHandler::script_path].
    pub fn set_script_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_path = v.into();
        self
    }
}

impl wkt::message::Message for ScriptHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ScriptHandler"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScriptHandler {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __script_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScriptHandler")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scriptPath" => Ok(__FieldTag::__script_path),
                            "script_path" => Ok(__FieldTag::__script_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScriptHandler;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScriptHandler")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__script_path => {
                            if !fields.insert(__FieldTag::__script_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_path",
                                ));
                            }
                            result.script_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScriptHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.script_path.is_empty() {
            state.serialize_entry("scriptPath", &self.script_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScriptHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScriptHandler");
        debug_struct.field("script_path", &self.script_path);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Uses Google Cloud Endpoints to handle requests.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiEndpointHandler {
    /// Path to the script from the application root directory.
    pub script_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiEndpointHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_path][crate::model::ApiEndpointHandler::script_path].
    pub fn set_script_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_path = v.into();
        self
    }
}

impl wkt::message::Message for ApiEndpointHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ApiEndpointHandler"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiEndpointHandler {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __script_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiEndpointHandler")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scriptPath" => Ok(__FieldTag::__script_path),
                            "script_path" => Ok(__FieldTag::__script_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiEndpointHandler;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiEndpointHandler")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__script_path => {
                            if !fields.insert(__FieldTag::__script_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_path",
                                ));
                            }
                            result.script_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiEndpointHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.script_path.is_empty() {
            state.serialize_entry("scriptPath", &self.script_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApiEndpointHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiEndpointHandler");
        debug_struct.field("script_path", &self.script_path);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances. Only applicable for
/// instances in App Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HealthCheck {
    /// Whether to explicitly disable health checks for this instance.
    pub disable_health_check: bool,

    /// Host header to send when performing an HTTP health check.
    /// Example: "myapp.appspot.com"
    pub host: std::string::String,

    /// Number of consecutive successful health checks required before receiving
    /// traffic.
    pub healthy_threshold: u32,

    /// Number of consecutive failed health checks required before removing
    /// traffic.
    pub unhealthy_threshold: u32,

    /// Number of consecutive failed health checks required before an instance is
    /// restarted.
    pub restart_threshold: u32,

    /// Interval between health checks.
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the health check is considered failed.
    pub timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HealthCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_health_check][crate::model::HealthCheck::disable_health_check].
    pub fn set_disable_health_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_health_check = v.into();
        self
    }

    /// Sets the value of [host][crate::model::HealthCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [healthy_threshold][crate::model::HealthCheck::healthy_threshold].
    pub fn set_healthy_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.healthy_threshold = v.into();
        self
    }

    /// Sets the value of [unhealthy_threshold][crate::model::HealthCheck::unhealthy_threshold].
    pub fn set_unhealthy_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.unhealthy_threshold = v.into();
        self
    }

    /// Sets the value of [restart_threshold][crate::model::HealthCheck::restart_threshold].
    pub fn set_restart_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.restart_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::HealthCheck::check_interval].
    pub fn set_check_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_interval][crate::model::HealthCheck::check_interval].
    pub fn set_or_clear_check_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::HealthCheck::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::HealthCheck::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HealthCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.HealthCheck"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HealthCheck {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disable_health_check,
            __host,
            __healthy_threshold,
            __unhealthy_threshold,
            __restart_threshold,
            __check_interval,
            __timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HealthCheck")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disableHealthCheck" => Ok(__FieldTag::__disable_health_check),
                            "disable_health_check" => Ok(__FieldTag::__disable_health_check),
                            "host" => Ok(__FieldTag::__host),
                            "healthyThreshold" => Ok(__FieldTag::__healthy_threshold),
                            "healthy_threshold" => Ok(__FieldTag::__healthy_threshold),
                            "unhealthyThreshold" => Ok(__FieldTag::__unhealthy_threshold),
                            "unhealthy_threshold" => Ok(__FieldTag::__unhealthy_threshold),
                            "restartThreshold" => Ok(__FieldTag::__restart_threshold),
                            "restart_threshold" => Ok(__FieldTag::__restart_threshold),
                            "checkInterval" => Ok(__FieldTag::__check_interval),
                            "check_interval" => Ok(__FieldTag::__check_interval),
                            "timeout" => Ok(__FieldTag::__timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HealthCheck;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HealthCheck")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disable_health_check => {
                            if !fields.insert(__FieldTag::__disable_health_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_health_check",
                                ));
                            }
                            result.disable_health_check = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__healthy_threshold => {
                            if !fields.insert(__FieldTag::__healthy_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for healthy_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.healthy_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unhealthy_threshold => {
                            if !fields.insert(__FieldTag::__unhealthy_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unhealthy_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.unhealthy_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__restart_threshold => {
                            if !fields.insert(__FieldTag::__restart_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restart_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.restart_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__check_interval => {
                            if !fields.insert(__FieldTag::__check_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for check_interval",
                                ));
                            }
                            result.check_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disable_health_check) {
            state.serialize_entry("disableHealthCheck", &self.disable_health_check)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !wkt::internal::is_default(&self.healthy_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("healthyThreshold", &__With(&self.healthy_threshold))?;
        }
        if !wkt::internal::is_default(&self.unhealthy_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("unhealthyThreshold", &__With(&self.unhealthy_threshold))?;
        }
        if !wkt::internal::is_default(&self.restart_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("restartThreshold", &__With(&self.restart_threshold))?;
        }
        if self.check_interval.is_some() {
            state.serialize_entry("checkInterval", &self.check_interval)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HealthCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HealthCheck");
        debug_struct.field("disable_health_check", &self.disable_health_check);
        debug_struct.field("host", &self.host);
        debug_struct.field("healthy_threshold", &self.healthy_threshold);
        debug_struct.field("unhealthy_threshold", &self.unhealthy_threshold);
        debug_struct.field("restart_threshold", &self.restart_threshold);
        debug_struct.field("check_interval", &self.check_interval);
        debug_struct.field("timeout", &self.timeout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Readiness checking configuration for VM instances. Unhealthy instances
/// are removed from traffic rotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReadinessCheck {
    /// The request path.
    pub path: std::string::String,

    /// Host header to send when performing a HTTP Readiness check.
    /// Example: "myapp.appspot.com"
    pub host: std::string::String,

    /// Number of consecutive failed checks required before removing
    /// traffic.
    pub failure_threshold: u32,

    /// Number of consecutive successful checks required before receiving
    /// traffic.
    pub success_threshold: u32,

    /// Interval between health checks.
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the check is considered failed.
    pub timeout: std::option::Option<wkt::Duration>,

    /// A maximum time limit on application initialization, measured from moment
    /// the application successfully replies to a healthcheck until it is ready to
    /// serve traffic.
    pub app_start_timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadinessCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::ReadinessCheck::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [host][crate::model::ReadinessCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::ReadinessCheck::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::ReadinessCheck::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::ReadinessCheck::check_interval].
    pub fn set_check_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_interval][crate::model::ReadinessCheck::check_interval].
    pub fn set_or_clear_check_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::ReadinessCheck::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::ReadinessCheck::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [app_start_timeout][crate::model::ReadinessCheck::app_start_timeout].
    pub fn set_app_start_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.app_start_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_start_timeout][crate::model::ReadinessCheck::app_start_timeout].
    pub fn set_or_clear_app_start_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.app_start_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReadinessCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ReadinessCheck"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReadinessCheck {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __host,
            __failure_threshold,
            __success_threshold,
            __check_interval,
            __timeout,
            __app_start_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadinessCheck")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "host" => Ok(__FieldTag::__host),
                            "failureThreshold" => Ok(__FieldTag::__failure_threshold),
                            "failure_threshold" => Ok(__FieldTag::__failure_threshold),
                            "successThreshold" => Ok(__FieldTag::__success_threshold),
                            "success_threshold" => Ok(__FieldTag::__success_threshold),
                            "checkInterval" => Ok(__FieldTag::__check_interval),
                            "check_interval" => Ok(__FieldTag::__check_interval),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "appStartTimeout" => Ok(__FieldTag::__app_start_timeout),
                            "app_start_timeout" => Ok(__FieldTag::__app_start_timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReadinessCheck;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadinessCheck")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_threshold => {
                            if !fields.insert(__FieldTag::__failure_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failure_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__success_threshold => {
                            if !fields.insert(__FieldTag::__success_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.success_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__check_interval => {
                            if !fields.insert(__FieldTag::__check_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for check_interval",
                                ));
                            }
                            result.check_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__app_start_timeout => {
                            if !fields.insert(__FieldTag::__app_start_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_start_timeout",
                                ));
                            }
                            result.app_start_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReadinessCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !wkt::internal::is_default(&self.failure_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureThreshold", &__With(&self.failure_threshold))?;
        }
        if !wkt::internal::is_default(&self.success_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successThreshold", &__With(&self.success_threshold))?;
        }
        if self.check_interval.is_some() {
            state.serialize_entry("checkInterval", &self.check_interval)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if self.app_start_timeout.is_some() {
            state.serialize_entry("appStartTimeout", &self.app_start_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReadinessCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReadinessCheck");
        debug_struct.field("path", &self.path);
        debug_struct.field("host", &self.host);
        debug_struct.field("failure_threshold", &self.failure_threshold);
        debug_struct.field("success_threshold", &self.success_threshold);
        debug_struct.field("check_interval", &self.check_interval);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("app_start_timeout", &self.app_start_timeout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LivenessCheck {
    /// The request path.
    pub path: std::string::String,

    /// Host header to send when performing a HTTP Liveness check.
    /// Example: "myapp.appspot.com"
    pub host: std::string::String,

    /// Number of consecutive failed checks required before considering the
    /// VM unhealthy.
    pub failure_threshold: u32,

    /// Number of consecutive successful checks required before considering
    /// the VM healthy.
    pub success_threshold: u32,

    /// Interval between health checks.
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the check is considered failed.
    pub timeout: std::option::Option<wkt::Duration>,

    /// The initial delay before starting to execute the checks.
    pub initial_delay: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LivenessCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::LivenessCheck::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [host][crate::model::LivenessCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::LivenessCheck::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::LivenessCheck::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::LivenessCheck::check_interval].
    pub fn set_check_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_interval][crate::model::LivenessCheck::check_interval].
    pub fn set_or_clear_check_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::LivenessCheck::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::LivenessCheck::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initial_delay][crate::model::LivenessCheck::initial_delay].
    pub fn set_initial_delay<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_delay = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_delay][crate::model::LivenessCheck::initial_delay].
    pub fn set_or_clear_initial_delay<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_delay = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LivenessCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.LivenessCheck"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LivenessCheck {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __host,
            __failure_threshold,
            __success_threshold,
            __check_interval,
            __timeout,
            __initial_delay,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LivenessCheck")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "host" => Ok(__FieldTag::__host),
                            "failureThreshold" => Ok(__FieldTag::__failure_threshold),
                            "failure_threshold" => Ok(__FieldTag::__failure_threshold),
                            "successThreshold" => Ok(__FieldTag::__success_threshold),
                            "success_threshold" => Ok(__FieldTag::__success_threshold),
                            "checkInterval" => Ok(__FieldTag::__check_interval),
                            "check_interval" => Ok(__FieldTag::__check_interval),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "initialDelay" => Ok(__FieldTag::__initial_delay),
                            "initial_delay" => Ok(__FieldTag::__initial_delay),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LivenessCheck;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LivenessCheck")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_threshold => {
                            if !fields.insert(__FieldTag::__failure_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failure_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__success_threshold => {
                            if !fields.insert(__FieldTag::__success_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success_threshold",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.success_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__check_interval => {
                            if !fields.insert(__FieldTag::__check_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for check_interval",
                                ));
                            }
                            result.check_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__initial_delay => {
                            if !fields.insert(__FieldTag::__initial_delay) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_delay",
                                ));
                            }
                            result.initial_delay =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LivenessCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !wkt::internal::is_default(&self.failure_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureThreshold", &__With(&self.failure_threshold))?;
        }
        if !wkt::internal::is_default(&self.success_threshold) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successThreshold", &__With(&self.success_threshold))?;
        }
        if self.check_interval.is_some() {
            state.serialize_entry("checkInterval", &self.check_interval)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if self.initial_delay.is_some() {
            state.serialize_entry("initialDelay", &self.initial_delay)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LivenessCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LivenessCheck");
        debug_struct.field("path", &self.path);
        debug_struct.field("host", &self.host);
        debug_struct.field("failure_threshold", &self.failure_threshold);
        debug_struct.field("success_threshold", &self.success_threshold);
        debug_struct.field("check_interval", &self.check_interval);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("initial_delay", &self.initial_delay);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Third-party Python runtime library that is required by the application.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Library {
    /// Name of the library. Example: "django".
    pub name: std::string::String,

    /// Version of the library to select, or "latest".
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Library {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Library::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Library::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Library {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Library"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Library {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Library")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Library;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Library")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Library {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Library {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Library");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Applications.GetApplication`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetApplicationRequest {
    /// Name of the Application resource to get. Example: `apps/myapp`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetApplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetApplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetApplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetApplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetApplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetApplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetApplicationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Applications.CreateApplication`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateApplicationRequest {
    /// Application configuration.
    pub application: std::option::Option<crate::model::Application>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application][crate::model::CreateApplicationRequest::application].
    pub fn set_application<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application][crate::model::CreateApplicationRequest::application].
    pub fn set_or_clear_application<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateApplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateApplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __application,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateApplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "application" => Ok(__FieldTag::__application),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateApplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateApplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__application => {
                            if !fields.insert(__FieldTag::__application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application",
                                ));
                            }
                            result.application =
                                map.next_value::<std::option::Option<crate::model::Application>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateApplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.application.is_some() {
            state.serialize_entry("application", &self.application)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateApplicationRequest");
        debug_struct.field("application", &self.application);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Applications.UpdateApplication`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateApplicationRequest {
    /// Name of the Application resource to update. Example: `apps/myapp`.
    pub name: std::string::String,

    /// An Application containing the updated resource.
    pub application: std::option::Option<crate::model::Application>,

    /// Required. Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [application][crate::model::UpdateApplicationRequest::application].
    pub fn set_application<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application][crate::model::UpdateApplicationRequest::application].
    pub fn set_or_clear_application<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateApplicationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateApplicationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateApplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateApplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __application,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateApplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "application" => Ok(__FieldTag::__application),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateApplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateApplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__application => {
                            if !fields.insert(__FieldTag::__application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application",
                                ));
                            }
                            result.application =
                                map.next_value::<std::option::Option<crate::model::Application>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateApplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.application.is_some() {
            state.serialize_entry("application", &self.application)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateApplicationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("application", &self.application);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'Applications.RepairApplication'.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepairApplicationRequest {
    /// Name of the application to repair. Example: `apps/myapp`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RepairApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RepairApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.RepairApplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepairApplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepairApplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepairApplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepairApplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepairApplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepairApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepairApplicationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Services.ListServices`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServicesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServicesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `Services.ListServices`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The services belonging to the requested application.
    pub services: std::vec::Vec<crate::model::Service>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServicesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServicesResponse");
        debug_struct.field("services", &self.services);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Services.GetService`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Name of the resource requested. Example: `apps/myapp/services/default`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Services.UpdateService`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Name of the resource to update. Example: `apps/myapp/services/default`.
    pub name: std::string::String,

    /// A Service resource containing the updated service. Only fields set in the
    /// field mask will be updated.
    pub service: std::option::Option<crate::model::Service>,

    /// Required. Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Set to `true` to gradually shift traffic to one or more versions that you
    /// specify. By default, traffic is shifted immediately.
    /// For gradual traffic migration, the target versions
    /// must be located within instances that are configured for both
    /// [warmup requests](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#InboundServiceType)
    /// and
    /// [automatic scaling](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#AutomaticScaling).
    /// You must specify the
    /// [`shardBy`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services#ShardBy)
    /// field in the Service resource. Gradual traffic migration is not
    /// supported in the App Engine flexible environment. For examples, see
    /// [Migrating and Splitting Traffic](https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic).
    pub migrate_traffic: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migrate_traffic][crate::model::UpdateServiceRequest::migrate_traffic].
    pub fn set_migrate_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.migrate_traffic = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __service,
            __update_mask,
            __migrate_traffic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "service" => Ok(__FieldTag::__service),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "migrateTraffic" => Ok(__FieldTag::__migrate_traffic),
                            "migrate_traffic" => Ok(__FieldTag::__migrate_traffic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__migrate_traffic => {
                            if !fields.insert(__FieldTag::__migrate_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrate_traffic",
                                ));
                            }
                            result.migrate_traffic = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.migrate_traffic) {
            state.serialize_entry("migrateTraffic", &self.migrate_traffic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateServiceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("service", &self.service);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migrate_traffic", &self.migrate_traffic);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Services.DeleteService`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Name of the resource requested. Example: `apps/myapp/services/default`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteServiceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Versions.ListVersions`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Name of the parent Service resource. Example:
    /// `apps/myapp/services/default`.
    pub parent: std::string::String,

    /// Controls the set of fields returned in the `List` response.
    pub view: crate::model::VersionView,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListVersionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::VersionView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `Versions.ListVersions`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The versions belonging to the requested service.
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versions" => Ok(__FieldTag::__versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Version>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsResponse");
        debug_struct.field("versions", &self.versions);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Versions.GetVersion`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1`.
    pub name: std::string::String,

    /// Controls the set of fields returned in the `Get` response.
    pub view: crate::model::VersionView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetVersionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::VersionView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Versions.CreateVersion`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Name of the parent resource to create this version under. Example:
    /// `apps/myapp/services/default`.
    pub parent: std::string::String,

    /// Application deployment configuration.
    pub version: std::option::Option<crate::model::Version>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("version", &self.version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Versions.UpdateVersion`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/services/default/versions/1`.
    pub name: std::string::String,

    /// A Version containing the updated resource. Only fields set in the field
    /// mask will be updated.
    pub version: std::option::Option<crate::model::Version>,

    /// Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Versions.DeleteVersion`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVersionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Instances.ListInstances`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Name of the parent Version resource. Example:
    /// `apps/myapp/services/default/versions/v1`.
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `Instances.ListInstances`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The instances belonging to the requested version.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInstancesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInstancesResponse");
        debug_struct.field("instances", &self.instances);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Instances.GetInstance`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInstanceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Instances.DeleteInstance`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInstanceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Instances.DebugInstance`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DebugInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    pub name: std::string::String,

    /// Public SSH key to add to the instance. Examples:
    ///
    /// * `[USERNAME]:ssh-rsa [KEY_VALUE] [USERNAME]`
    /// * `[USERNAME]:ssh-rsa [KEY_VALUE] google-ssh {"userName":"[USERNAME]","expireOn":"[EXPIRE_TIME]"}`
    ///
    /// For more information, see
    /// [Adding and Removing SSH Keys](https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys).
    pub ssh_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DebugInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DebugInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssh_key][crate::model::DebugInstanceRequest::ssh_key].
    pub fn set_ssh_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssh_key = v.into();
        self
    }
}

impl wkt::message::Message for DebugInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DebugInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DebugInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ssh_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DebugInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sshKey" => Ok(__FieldTag::__ssh_key),
                            "ssh_key" => Ok(__FieldTag::__ssh_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DebugInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DebugInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_key => {
                            if !fields.insert(__FieldTag::__ssh_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_key",
                                ));
                            }
                            result.ssh_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DebugInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ssh_key.is_empty() {
            state.serialize_entry("sshKey", &self.ssh_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DebugInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DebugInstanceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ssh_key", &self.ssh_key);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Firewall.ListIngressRules`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIngressRulesRequest {
    /// Name of the Firewall collection to retrieve.
    /// Example: `apps/myapp/firewall/ingressRules`.
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    /// A valid IP Address. If set, only rules matching this address will be
    /// returned. The first returned rule will be the rule that fires on requests
    /// from this IP.
    pub matching_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIngressRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIngressRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIngressRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIngressRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [matching_address][crate::model::ListIngressRulesRequest::matching_address].
    pub fn set_matching_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matching_address = v.into();
        self
    }
}

impl wkt::message::Message for ListIngressRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListIngressRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIngressRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __matching_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIngressRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "matchingAddress" => Ok(__FieldTag::__matching_address),
                            "matching_address" => Ok(__FieldTag::__matching_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIngressRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIngressRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matching_address => {
                            if !fields.insert(__FieldTag::__matching_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matching_address",
                                ));
                            }
                            result.matching_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIngressRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.matching_address.is_empty() {
            state.serialize_entry("matchingAddress", &self.matching_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIngressRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIngressRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("matching_address", &self.matching_address);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `Firewall.ListIngressRules`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIngressRulesResponse {
    /// The ingress FirewallRules for this application.
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIngressRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_rules][crate::model::ListIngressRulesResponse::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIngressRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIngressRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListIngressRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIngressRulesResponse {
    type PageItem = crate::model::FirewallRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ingress_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIngressRulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ingress_rules,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIngressRulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ingressRules" => Ok(__FieldTag::__ingress_rules),
                            "ingress_rules" => Ok(__FieldTag::__ingress_rules),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIngressRulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIngressRulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ingress_rules => {
                            if !fields.insert(__FieldTag::__ingress_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingress_rules",
                                ));
                            }
                            result.ingress_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FirewallRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIngressRulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ingress_rules.is_empty() {
            state.serialize_entry("ingressRules", &self.ingress_rules)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIngressRulesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIngressRulesResponse");
        debug_struct.field("ingress_rules", &self.ingress_rules);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Firewall.BatchUpdateIngressRules`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateIngressRulesRequest {
    /// Name of the Firewall collection to set.
    /// Example: `apps/myapp/firewall/ingressRules`.
    pub name: std::string::String,

    /// A list of FirewallRules to replace the existing set.
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateIngressRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchUpdateIngressRulesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ingress_rules][crate::model::BatchUpdateIngressRulesRequest::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateIngressRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BatchUpdateIngressRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateIngressRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ingress_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateIngressRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ingressRules" => Ok(__FieldTag::__ingress_rules),
                            "ingress_rules" => Ok(__FieldTag::__ingress_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateIngressRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateIngressRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ingress_rules => {
                            if !fields.insert(__FieldTag::__ingress_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingress_rules",
                                ));
                            }
                            result.ingress_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FirewallRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateIngressRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ingress_rules.is_empty() {
            state.serialize_entry("ingressRules", &self.ingress_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateIngressRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateIngressRulesRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ingress_rules", &self.ingress_rules);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `Firewall.UpdateAllIngressRules`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateIngressRulesResponse {
    /// The full list of ingress FirewallRules for this application.
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateIngressRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_rules][crate::model::BatchUpdateIngressRulesResponse::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateIngressRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BatchUpdateIngressRulesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateIngressRulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ingress_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateIngressRulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ingressRules" => Ok(__FieldTag::__ingress_rules),
                            "ingress_rules" => Ok(__FieldTag::__ingress_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateIngressRulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateIngressRulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ingress_rules => {
                            if !fields.insert(__FieldTag::__ingress_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingress_rules",
                                ));
                            }
                            result.ingress_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FirewallRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateIngressRulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ingress_rules.is_empty() {
            state.serialize_entry("ingressRules", &self.ingress_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateIngressRulesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateIngressRulesResponse");
        debug_struct.field("ingress_rules", &self.ingress_rules);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Firewall.CreateIngressRule`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIngressRuleRequest {
    /// Name of the parent Firewall collection in which to create a new rule.
    /// Example: `apps/myapp/firewall/ingressRules`.
    pub parent: std::string::String,

    /// A FirewallRule containing the new resource.
    ///
    /// The user may optionally provide a position at which the new rule will be
    /// placed. The positions define a sequential list starting at 1. If a rule
    /// already exists at the given position, rules greater than the provided
    /// position will be moved forward by one.
    ///
    /// If no position is provided, the server will place the rule as the second to
    /// last rule in the sequence before the required default allow-all or deny-all
    /// rule.
    pub rule: std::option::Option<crate::model::FirewallRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIngressRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::CreateIngressRuleRequest::rule].
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::CreateIngressRuleRequest::rule].
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateIngressRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIngressRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIngressRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "rule" => Ok(__FieldTag::__rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIngressRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIngressRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule",
                                ));
                            }
                            result.rule = map
                                .next_value::<std::option::Option<crate::model::FirewallRule>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateIngressRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.rule.is_some() {
            state.serialize_entry("rule", &self.rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateIngressRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateIngressRuleRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("rule", &self.rule);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Firewall.GetIngressRule`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIngressRuleRequest {
    /// Name of the Firewall resource to retrieve.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetIngressRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIngressRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIngressRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIngressRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIngressRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIngressRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetIngressRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetIngressRuleRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Firewall.UpdateIngressRule`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateIngressRuleRequest {
    /// Name of the Firewall resource to update.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    pub name: std::string::String,

    /// A FirewallRule containing the updated resource
    pub rule: std::option::Option<crate::model::FirewallRule>,

    /// Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::UpdateIngressRuleRequest::rule].
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::UpdateIngressRuleRequest::rule].
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIngressRuleRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIngressRuleRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateIngressRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateIngressRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __rule,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIngressRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "rule" => Ok(__FieldTag::__rule),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateIngressRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIngressRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule",
                                ));
                            }
                            result.rule = map
                                .next_value::<std::option::Option<crate::model::FirewallRule>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateIngressRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.rule.is_some() {
            state.serialize_entry("rule", &self.rule)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateIngressRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateIngressRuleRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("rule", &self.rule);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `Firewall.DeleteIngressRule`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIngressRuleRequest {
    /// Name of the Firewall resource to delete.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteIngressRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIngressRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIngressRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIngressRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIngressRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIngressRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteIngressRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteIngressRuleRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `AuthorizedDomains.ListAuthorizedDomains`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAuthorizedDomainsRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedDomainsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedDomainsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedDomainsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedDomainsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedDomainsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedDomainsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAuthorizedDomainsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAuthorizedDomainsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAuthorizedDomainsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAuthorizedDomainsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAuthorizedDomainsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAuthorizedDomainsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAuthorizedDomainsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `AuthorizedDomains.ListAuthorizedDomains`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAuthorizedDomainsResponse {
    /// The authorized domains belonging to the user.
    pub domains: std::vec::Vec<crate::model::AuthorizedDomain>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedDomainsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domains][crate::model::ListAuthorizedDomainsResponse::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedDomain>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedDomainsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedDomainsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedDomainsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedDomainsResponse {
    type PageItem = crate::model::AuthorizedDomain;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domains
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAuthorizedDomainsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domains,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAuthorizedDomainsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domains" => Ok(__FieldTag::__domains),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAuthorizedDomainsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAuthorizedDomainsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domains => {
                            if !fields.insert(__FieldTag::__domains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domains",
                                ));
                            }
                            result.domains =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuthorizedDomain>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAuthorizedDomainsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domains.is_empty() {
            state.serialize_entry("domains", &self.domains)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAuthorizedDomainsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAuthorizedDomainsResponse");
        debug_struct.field("domains", &self.domains);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `AuthorizedCertificates.ListAuthorizedCertificates`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAuthorizedCertificatesRequest {
    /// Name of the parent `Application` resource. Example: `apps/myapp`.
    pub parent: std::string::String,

    /// Controls the set of fields returned in the `LIST` response.
    pub view: crate::model::AuthorizedCertificateView,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedCertificatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedCertificatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAuthorizedCertificatesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AuthorizedCertificateView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedCertificatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedCertificatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedCertificatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedCertificatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAuthorizedCertificatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAuthorizedCertificatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAuthorizedCertificatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAuthorizedCertificatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::AuthorizedCertificateView>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAuthorizedCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAuthorizedCertificatesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAuthorizedCertificatesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `AuthorizedCertificates.ListAuthorizedCertificates`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAuthorizedCertificatesResponse {
    /// The SSL certificates the user is authorized to administer.
    pub certificates: std::vec::Vec<crate::model::AuthorizedCertificate>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedCertificatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificates][crate::model::ListAuthorizedCertificatesResponse::certificates].
    pub fn set_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        use std::iter::Iterator;
        self.certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedCertificatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedCertificatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedCertificatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedCertificatesResponse {
    type PageItem = crate::model::AuthorizedCertificate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAuthorizedCertificatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificates,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAuthorizedCertificatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificates" => Ok(__FieldTag::__certificates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAuthorizedCertificatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAuthorizedCertificatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificates => {
                            if !fields.insert(__FieldTag::__certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificates",
                                ));
                            }
                            result.certificates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuthorizedCertificate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAuthorizedCertificatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certificates.is_empty() {
            state.serialize_entry("certificates", &self.certificates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAuthorizedCertificatesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAuthorizedCertificatesResponse");
        debug_struct.field("certificates", &self.certificates);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `AuthorizedCertificates.GetAuthorizedCertificate`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAuthorizedCertificateRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    pub name: std::string::String,

    /// Controls the set of fields returned in the `GET` response.
    pub view: crate::model::AuthorizedCertificateView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAuthorizedCertificateRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AuthorizedCertificateView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetAuthorizedCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAuthorizedCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAuthorizedCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAuthorizedCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAuthorizedCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::AuthorizedCertificateView>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAuthorizedCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAuthorizedCertificateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAuthorizedCertificateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `AuthorizedCertificates.CreateAuthorizedCertificate`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAuthorizedCertificateRequest {
    /// Name of the parent `Application` resource. Example: `apps/myapp`.
    pub parent: std::string::String,

    /// SSL certificate data.
    pub certificate: std::option::Option<crate::model::AuthorizedCertificate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAuthorizedCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::CreateAuthorizedCertificateRequest::certificate].
    pub fn set_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate][crate::model::CreateAuthorizedCertificateRequest::certificate].
    pub fn set_or_clear_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateAuthorizedCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAuthorizedCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAuthorizedCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificate" => Ok(__FieldTag::__certificate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAuthorizedCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAuthorizedCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate = map.next_value::<std::option::Option<crate::model::AuthorizedCertificate>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAuthorizedCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.certificate.is_some() {
            state.serialize_entry("certificate", &self.certificate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAuthorizedCertificateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAuthorizedCertificateRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("certificate", &self.certificate);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `AuthorizedCertificates.UpdateAuthorizedCertificate`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAuthorizedCertificateRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    pub name: std::string::String,

    /// An `AuthorizedCertificate` containing the updated resource. Only fields set
    /// in the field mask will be updated.
    pub certificate: std::option::Option<crate::model::AuthorizedCertificate>,

    /// Standard field mask for the set of fields to be updated. Updates are only
    /// supported on the `certificate_raw_data` and `display_name` fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::UpdateAuthorizedCertificateRequest::certificate].
    pub fn set_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate][crate::model::UpdateAuthorizedCertificateRequest::certificate].
    pub fn set_or_clear_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAuthorizedCertificateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAuthorizedCertificateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateAuthorizedCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAuthorizedCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __certificate,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAuthorizedCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "certificate" => Ok(__FieldTag::__certificate),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAuthorizedCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAuthorizedCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate = map.next_value::<std::option::Option<crate::model::AuthorizedCertificate>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAuthorizedCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.certificate.is_some() {
            state.serialize_entry("certificate", &self.certificate)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAuthorizedCertificateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAuthorizedCertificateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("certificate", &self.certificate);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `AuthorizedCertificates.DeleteAuthorizedCertificate`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAuthorizedCertificateRequest {
    /// Name of the resource to delete. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteAuthorizedCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAuthorizedCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAuthorizedCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAuthorizedCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAuthorizedCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAuthorizedCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAuthorizedCertificateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAuthorizedCertificateRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `DomainMappings.ListDomainMappings`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDomainMappingsRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainMappingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDomainMappingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDomainMappingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDomainMappingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainMappingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListDomainMappingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDomainMappingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDomainMappingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDomainMappingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDomainMappingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDomainMappingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDomainMappingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDomainMappingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `DomainMappings.ListDomainMappings`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDomainMappingsResponse {
    /// The domain mappings for the application.
    pub domain_mappings: std::vec::Vec<crate::model::DomainMapping>,

    /// Continuation token for fetching the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainMappingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain_mappings][crate::model::ListDomainMappingsResponse::domain_mappings].
    pub fn set_domain_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DomainMapping>,
    {
        use std::iter::Iterator;
        self.domain_mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDomainMappingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainMappingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListDomainMappingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDomainMappingsResponse {
    type PageItem = crate::model::DomainMapping;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domain_mappings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDomainMappingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domain_mappings,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDomainMappingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domainMappings" => Ok(__FieldTag::__domain_mappings),
                            "domain_mappings" => Ok(__FieldTag::__domain_mappings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDomainMappingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDomainMappingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domain_mappings => {
                            if !fields.insert(__FieldTag::__domain_mappings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_mappings",
                                ));
                            }
                            result.domain_mappings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DomainMapping>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDomainMappingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domain_mappings.is_empty() {
            state.serialize_entry("domainMappings", &self.domain_mappings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDomainMappingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDomainMappingsResponse");
        debug_struct.field("domain_mappings", &self.domain_mappings);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `DomainMappings.GetDomainMapping`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDomainMappingRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/domainMappings/example.com`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetDomainMappingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDomainMappingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDomainMappingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDomainMappingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDomainMappingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDomainMappingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDomainMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDomainMappingRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `DomainMappings.CreateDomainMapping`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDomainMappingRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    pub parent: std::string::String,

    /// Domain mapping configuration.
    pub domain_mapping: std::option::Option<crate::model::DomainMapping>,

    /// Whether the domain creation should override any existing mappings for this
    /// domain. By default, overrides are rejected.
    pub override_strategy: crate::model::DomainOverrideStrategy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDomainMappingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [domain_mapping][crate::model::CreateDomainMappingRequest::domain_mapping].
    pub fn set_domain_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain_mapping][crate::model::CreateDomainMappingRequest::domain_mapping].
    pub fn set_or_clear_domain_mapping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = v.map(|x| x.into());
        self
    }

    /// Sets the value of [override_strategy][crate::model::CreateDomainMappingRequest::override_strategy].
    pub fn set_override_strategy<T: std::convert::Into<crate::model::DomainOverrideStrategy>>(
        mut self,
        v: T,
    ) -> Self {
        self.override_strategy = v.into();
        self
    }
}

impl wkt::message::Message for CreateDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateDomainMappingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDomainMappingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __domain_mapping,
            __override_strategy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDomainMappingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "domainMapping" => Ok(__FieldTag::__domain_mapping),
                            "domain_mapping" => Ok(__FieldTag::__domain_mapping),
                            "overrideStrategy" => Ok(__FieldTag::__override_strategy),
                            "override_strategy" => Ok(__FieldTag::__override_strategy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDomainMappingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDomainMappingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain_mapping => {
                            if !fields.insert(__FieldTag::__domain_mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_mapping",
                                ));
                            }
                            result.domain_mapping = map
                                .next_value::<std::option::Option<crate::model::DomainMapping>>()?;
                        }
                        __FieldTag::__override_strategy => {
                            if !fields.insert(__FieldTag::__override_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_strategy",
                                ));
                            }
                            result.override_strategy = map.next_value::<std::option::Option<crate::model::DomainOverrideStrategy>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDomainMappingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.domain_mapping.is_some() {
            state.serialize_entry("domainMapping", &self.domain_mapping)?;
        }
        if !wkt::internal::is_default(&self.override_strategy) {
            state.serialize_entry("overrideStrategy", &self.override_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDomainMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDomainMappingRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("domain_mapping", &self.domain_mapping);
        debug_struct.field("override_strategy", &self.override_strategy);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `DomainMappings.UpdateDomainMapping`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDomainMappingRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/domainMappings/example.com`.
    pub name: std::string::String,

    /// A domain mapping containing the updated resource. Only fields set
    /// in the field mask will be updated.
    pub domain_mapping: std::option::Option<crate::model::DomainMapping>,

    /// Required. Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [domain_mapping][crate::model::UpdateDomainMappingRequest::domain_mapping].
    pub fn set_domain_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain_mapping][crate::model::UpdateDomainMappingRequest::domain_mapping].
    pub fn set_or_clear_domain_mapping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDomainMappingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDomainMappingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateDomainMappingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDomainMappingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __domain_mapping,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDomainMappingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "domainMapping" => Ok(__FieldTag::__domain_mapping),
                            "domain_mapping" => Ok(__FieldTag::__domain_mapping),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDomainMappingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDomainMappingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain_mapping => {
                            if !fields.insert(__FieldTag::__domain_mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_mapping",
                                ));
                            }
                            result.domain_mapping = map
                                .next_value::<std::option::Option<crate::model::DomainMapping>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDomainMappingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.domain_mapping.is_some() {
            state.serialize_entry("domainMapping", &self.domain_mapping)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDomainMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDomainMappingRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("domain_mapping", &self.domain_mapping);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `DomainMappings.DeleteDomainMapping`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDomainMappingRequest {
    /// Name of the resource to delete. Example:
    /// `apps/myapp/domainMappings/example.com`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteDomainMappingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDomainMappingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDomainMappingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDomainMappingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDomainMappingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDomainMappingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDomainMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDomainMappingRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An Application resource contains the top-level configuration of an App
/// Engine application.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Application {
    /// Full path to the Application resource in the API.
    /// Example: `apps/myapp`.
    ///
    /// @OutputOnly
    pub name: std::string::String,

    /// Identifier of the Application resource. This identifier is equivalent
    /// to the project ID of the Google Cloud Platform project where you want to
    /// deploy your application.
    /// Example: `myapp`.
    pub id: std::string::String,

    /// HTTP path dispatch rules for requests to the application that do not
    /// explicitly target a service or version. Rules are order-dependent.
    /// Up to 20 dispatch rules can be supported.
    pub dispatch_rules: std::vec::Vec<crate::model::UrlDispatchRule>,

    /// Google Apps authentication domain that controls which users can access
    /// this application.
    ///
    /// Defaults to open access for any Google Account.
    pub auth_domain: std::string::String,

    /// Location from which this application runs. Application instances
    /// run out of the data centers in the specified location, which is also where
    /// all of the application's end user content is stored.
    ///
    /// Defaults to `us-central`.
    ///
    /// View the list of
    /// [supported locations](https://cloud.google.com/appengine/docs/locations).
    pub location_id: std::string::String,

    /// Google Cloud Storage bucket that can be used for storing files
    /// associated with this application. This bucket is associated with the
    /// application and can be used by the gcloud deployment commands.
    ///
    /// @OutputOnly
    pub code_bucket: std::string::String,

    /// Cookie expiration policy for this application.
    pub default_cookie_expiration: std::option::Option<wkt::Duration>,

    /// Serving status of this application.
    pub serving_status: crate::model::application::ServingStatus,

    /// Hostname used to reach this application, as resolved by App Engine.
    ///
    /// @OutputOnly
    pub default_hostname: std::string::String,

    /// Google Cloud Storage bucket that can be used by this application to store
    /// content.
    ///
    /// @OutputOnly
    pub default_bucket: std::string::String,

    /// The service account associated with the application.
    /// This is the app-level default identity. If no identity provided during
    /// create version, Admin API will fallback to this one.
    pub service_account: std::string::String,

    pub iap: std::option::Option<crate::model::application::IdentityAwareProxy>,

    /// The Google Container Registry domain used for storing managed build docker
    /// images for this application.
    pub gcr_domain: std::string::String,

    /// The type of the Cloud Firestore or Cloud Datastore database associated with
    /// this application.
    pub database_type: crate::model::application::DatabaseType,

    /// The feature specific settings to be used in the application.
    pub feature_settings: std::option::Option<crate::model::application::FeatureSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Application {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Application::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Application::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [dispatch_rules][crate::model::Application::dispatch_rules].
    pub fn set_dispatch_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UrlDispatchRule>,
    {
        use std::iter::Iterator;
        self.dispatch_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auth_domain][crate::model::Application::auth_domain].
    pub fn set_auth_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.auth_domain = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::Application::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [code_bucket][crate::model::Application::code_bucket].
    pub fn set_code_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code_bucket = v.into();
        self
    }

    /// Sets the value of [default_cookie_expiration][crate::model::Application::default_cookie_expiration].
    pub fn set_default_cookie_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_cookie_expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_cookie_expiration][crate::model::Application::default_cookie_expiration].
    pub fn set_or_clear_default_cookie_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_cookie_expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serving_status][crate::model::Application::serving_status].
    pub fn set_serving_status<T: std::convert::Into<crate::model::application::ServingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_status = v.into();
        self
    }

    /// Sets the value of [default_hostname][crate::model::Application::default_hostname].
    pub fn set_default_hostname<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_hostname = v.into();
        self
    }

    /// Sets the value of [default_bucket][crate::model::Application::default_bucket].
    pub fn set_default_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_bucket = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Application::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [iap][crate::model::Application::iap].
    pub fn set_iap<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::application::IdentityAwareProxy>,
    {
        self.iap = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [iap][crate::model::Application::iap].
    pub fn set_or_clear_iap<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::application::IdentityAwareProxy>,
    {
        self.iap = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcr_domain][crate::model::Application::gcr_domain].
    pub fn set_gcr_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcr_domain = v.into();
        self
    }

    /// Sets the value of [database_type][crate::model::Application::database_type].
    pub fn set_database_type<T: std::convert::Into<crate::model::application::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_type = v.into();
        self
    }

    /// Sets the value of [feature_settings][crate::model::Application::feature_settings].
    pub fn set_feature_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::application::FeatureSettings>,
    {
        self.feature_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feature_settings][crate::model::Application::feature_settings].
    pub fn set_or_clear_feature_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::application::FeatureSettings>,
    {
        self.feature_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Application {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Application"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Application {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __dispatch_rules,
            __auth_domain,
            __location_id,
            __code_bucket,
            __default_cookie_expiration,
            __serving_status,
            __default_hostname,
            __default_bucket,
            __service_account,
            __iap,
            __gcr_domain,
            __database_type,
            __feature_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Application")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "dispatchRules" => Ok(__FieldTag::__dispatch_rules),
                            "dispatch_rules" => Ok(__FieldTag::__dispatch_rules),
                            "authDomain" => Ok(__FieldTag::__auth_domain),
                            "auth_domain" => Ok(__FieldTag::__auth_domain),
                            "locationId" => Ok(__FieldTag::__location_id),
                            "location_id" => Ok(__FieldTag::__location_id),
                            "codeBucket" => Ok(__FieldTag::__code_bucket),
                            "code_bucket" => Ok(__FieldTag::__code_bucket),
                            "defaultCookieExpiration" => {
                                Ok(__FieldTag::__default_cookie_expiration)
                            }
                            "default_cookie_expiration" => {
                                Ok(__FieldTag::__default_cookie_expiration)
                            }
                            "servingStatus" => Ok(__FieldTag::__serving_status),
                            "serving_status" => Ok(__FieldTag::__serving_status),
                            "defaultHostname" => Ok(__FieldTag::__default_hostname),
                            "default_hostname" => Ok(__FieldTag::__default_hostname),
                            "defaultBucket" => Ok(__FieldTag::__default_bucket),
                            "default_bucket" => Ok(__FieldTag::__default_bucket),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "iap" => Ok(__FieldTag::__iap),
                            "gcrDomain" => Ok(__FieldTag::__gcr_domain),
                            "gcr_domain" => Ok(__FieldTag::__gcr_domain),
                            "databaseType" => Ok(__FieldTag::__database_type),
                            "database_type" => Ok(__FieldTag::__database_type),
                            "featureSettings" => Ok(__FieldTag::__feature_settings),
                            "feature_settings" => Ok(__FieldTag::__feature_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Application;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Application")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dispatch_rules => {
                            if !fields.insert(__FieldTag::__dispatch_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dispatch_rules",
                                ));
                            }
                            result.dispatch_rules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UrlDispatchRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auth_domain => {
                            if !fields.insert(__FieldTag::__auth_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_domain",
                                ));
                            }
                            result.auth_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_id => {
                            if !fields.insert(__FieldTag::__location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_id",
                                ));
                            }
                            result.location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code_bucket => {
                            if !fields.insert(__FieldTag::__code_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code_bucket",
                                ));
                            }
                            result.code_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_cookie_expiration => {
                            if !fields.insert(__FieldTag::__default_cookie_expiration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_cookie_expiration",
                                ));
                            }
                            result.default_cookie_expiration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__serving_status => {
                            if !fields.insert(__FieldTag::__serving_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_status",
                                ));
                            }
                            result.serving_status = map.next_value::<std::option::Option<crate::model::application::ServingStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_hostname => {
                            if !fields.insert(__FieldTag::__default_hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_hostname",
                                ));
                            }
                            result.default_hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_bucket => {
                            if !fields.insert(__FieldTag::__default_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_bucket",
                                ));
                            }
                            result.default_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iap => {
                            if !fields.insert(__FieldTag::__iap) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iap",
                                ));
                            }
                            result.iap = map.next_value::<std::option::Option<
                                crate::model::application::IdentityAwareProxy,
                            >>()?;
                        }
                        __FieldTag::__gcr_domain => {
                            if !fields.insert(__FieldTag::__gcr_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcr_domain",
                                ));
                            }
                            result.gcr_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_type => {
                            if !fields.insert(__FieldTag::__database_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_type",
                                ));
                            }
                            result.database_type = map.next_value::<std::option::Option<crate::model::application::DatabaseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__feature_settings => {
                            if !fields.insert(__FieldTag::__feature_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_settings",
                                ));
                            }
                            result.feature_settings = map.next_value::<std::option::Option<crate::model::application::FeatureSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Application {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.dispatch_rules.is_empty() {
            state.serialize_entry("dispatchRules", &self.dispatch_rules)?;
        }
        if !self.auth_domain.is_empty() {
            state.serialize_entry("authDomain", &self.auth_domain)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self.code_bucket.is_empty() {
            state.serialize_entry("codeBucket", &self.code_bucket)?;
        }
        if self.default_cookie_expiration.is_some() {
            state.serialize_entry("defaultCookieExpiration", &self.default_cookie_expiration)?;
        }
        if !wkt::internal::is_default(&self.serving_status) {
            state.serialize_entry("servingStatus", &self.serving_status)?;
        }
        if !self.default_hostname.is_empty() {
            state.serialize_entry("defaultHostname", &self.default_hostname)?;
        }
        if !self.default_bucket.is_empty() {
            state.serialize_entry("defaultBucket", &self.default_bucket)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.iap.is_some() {
            state.serialize_entry("iap", &self.iap)?;
        }
        if !self.gcr_domain.is_empty() {
            state.serialize_entry("gcrDomain", &self.gcr_domain)?;
        }
        if !wkt::internal::is_default(&self.database_type) {
            state.serialize_entry("databaseType", &self.database_type)?;
        }
        if self.feature_settings.is_some() {
            state.serialize_entry("featureSettings", &self.feature_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Application {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Application");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("dispatch_rules", &self.dispatch_rules);
        debug_struct.field("auth_domain", &self.auth_domain);
        debug_struct.field("location_id", &self.location_id);
        debug_struct.field("code_bucket", &self.code_bucket);
        debug_struct.field("default_cookie_expiration", &self.default_cookie_expiration);
        debug_struct.field("serving_status", &self.serving_status);
        debug_struct.field("default_hostname", &self.default_hostname);
        debug_struct.field("default_bucket", &self.default_bucket);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("iap", &self.iap);
        debug_struct.field("gcr_domain", &self.gcr_domain);
        debug_struct.field("database_type", &self.database_type);
        debug_struct.field("feature_settings", &self.feature_settings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Application].
pub mod application {
    #[allow(unused_imports)]
    use super::*;

    /// Identity-Aware Proxy
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IdentityAwareProxy {
        /// Whether the serving infrastructure will authenticate and
        /// authorize all incoming requests.
        ///
        /// If true, the `oauth2_client_id` and `oauth2_client_secret`
        /// fields must be non-empty.
        pub enabled: bool,

        /// OAuth2 client ID to use for the authentication flow.
        pub oauth2_client_id: std::string::String,

        /// OAuth2 client secret to use for the authentication flow.
        ///
        /// For security reasons, this value cannot be retrieved via the API.
        /// Instead, the SHA-256 hash of the value is returned in the
        /// `oauth2_client_secret_sha256` field.
        ///
        /// @InputOnly
        pub oauth2_client_secret: std::string::String,

        /// Hex-encoded SHA-256 hash of the client secret.
        ///
        /// @OutputOnly
        pub oauth2_client_secret_sha256: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IdentityAwareProxy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::application::IdentityAwareProxy::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [oauth2_client_id][crate::model::application::IdentityAwareProxy::oauth2_client_id].
        pub fn set_oauth2_client_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_id = v.into();
            self
        }

        /// Sets the value of [oauth2_client_secret][crate::model::application::IdentityAwareProxy::oauth2_client_secret].
        pub fn set_oauth2_client_secret<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_secret = v.into();
            self
        }

        /// Sets the value of [oauth2_client_secret_sha256][crate::model::application::IdentityAwareProxy::oauth2_client_secret_sha256].
        pub fn set_oauth2_client_secret_sha256<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_secret_sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for IdentityAwareProxy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Application.IdentityAwareProxy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IdentityAwareProxy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __oauth2_client_id,
                __oauth2_client_secret,
                __oauth2_client_secret_sha256,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IdentityAwareProxy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "oauth2ClientId" => Ok(__FieldTag::__oauth2_client_id),
                                "oauth2_client_id" => Ok(__FieldTag::__oauth2_client_id),
                                "oauth2ClientSecret" => Ok(__FieldTag::__oauth2_client_secret),
                                "oauth2_client_secret" => Ok(__FieldTag::__oauth2_client_secret),
                                "oauth2ClientSecretSha256" => {
                                    Ok(__FieldTag::__oauth2_client_secret_sha256)
                                }
                                "oauth2_client_secret_sha256" => {
                                    Ok(__FieldTag::__oauth2_client_secret_sha256)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IdentityAwareProxy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IdentityAwareProxy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__oauth2_client_id => {
                                if !fields.insert(__FieldTag::__oauth2_client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oauth2_client_id",
                                    ));
                                }
                                result.oauth2_client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__oauth2_client_secret => {
                                if !fields.insert(__FieldTag::__oauth2_client_secret) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oauth2_client_secret",
                                    ));
                                }
                                result.oauth2_client_secret = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__oauth2_client_secret_sha256 => {
                                if !fields.insert(__FieldTag::__oauth2_client_secret_sha256) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oauth2_client_secret_sha256",
                                    ));
                                }
                                result.oauth2_client_secret_sha256 = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IdentityAwareProxy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self.oauth2_client_id.is_empty() {
                state.serialize_entry("oauth2ClientId", &self.oauth2_client_id)?;
            }
            if !self.oauth2_client_secret.is_empty() {
                state.serialize_entry("oauth2ClientSecret", &self.oauth2_client_secret)?;
            }
            if !self.oauth2_client_secret_sha256.is_empty() {
                state.serialize_entry(
                    "oauth2ClientSecretSha256",
                    &self.oauth2_client_secret_sha256,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IdentityAwareProxy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IdentityAwareProxy");
            debug_struct.field("enabled", &self.enabled);
            debug_struct.field("oauth2_client_id", &self.oauth2_client_id);
            debug_struct.field("oauth2_client_secret", &self.oauth2_client_secret);
            debug_struct.field(
                "oauth2_client_secret_sha256",
                &self.oauth2_client_secret_sha256,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The feature specific settings to be used in the application. These define
    /// behaviors that are user configurable.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FeatureSettings {
        /// Boolean value indicating if split health checks should be used instead
        /// of the legacy health checks. At an app.yaml level, this means defaulting
        /// to 'readiness_check' and 'liveness_check' values instead of
        /// 'health_check' ones. Once the legacy 'health_check' behavior is
        /// deprecated, and this value is always true, this setting can
        /// be removed.
        pub split_health_checks: bool,

        /// If true, use [Container-Optimized OS](https://cloud.google.com/container-optimized-os/)
        /// base image for VMs, rather than a base Debian image.
        pub use_container_optimized_os: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FeatureSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [split_health_checks][crate::model::application::FeatureSettings::split_health_checks].
        pub fn set_split_health_checks<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.split_health_checks = v.into();
            self
        }

        /// Sets the value of [use_container_optimized_os][crate::model::application::FeatureSettings::use_container_optimized_os].
        pub fn set_use_container_optimized_os<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_container_optimized_os = v.into();
            self
        }
    }

    impl wkt::message::Message for FeatureSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Application.FeatureSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FeatureSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __split_health_checks,
                __use_container_optimized_os,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FeatureSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "splitHealthChecks" => Ok(__FieldTag::__split_health_checks),
                                "split_health_checks" => Ok(__FieldTag::__split_health_checks),
                                "useContainerOptimizedOs" => {
                                    Ok(__FieldTag::__use_container_optimized_os)
                                }
                                "use_container_optimized_os" => {
                                    Ok(__FieldTag::__use_container_optimized_os)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FeatureSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FeatureSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__split_health_checks => {
                                if !fields.insert(__FieldTag::__split_health_checks) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for split_health_checks",
                                    ));
                                }
                                result.split_health_checks = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__use_container_optimized_os => {
                                if !fields.insert(__FieldTag::__use_container_optimized_os) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for use_container_optimized_os",
                                    ));
                                }
                                result.use_container_optimized_os = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FeatureSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.split_health_checks) {
                state.serialize_entry("splitHealthChecks", &self.split_health_checks)?;
            }
            if !wkt::internal::is_default(&self.use_container_optimized_os) {
                state
                    .serialize_entry("useContainerOptimizedOs", &self.use_container_optimized_os)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FeatureSettings {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FeatureSettings");
            debug_struct.field("split_health_checks", &self.split_health_checks);
            debug_struct.field(
                "use_container_optimized_os",
                &self.use_container_optimized_os,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServingStatus {
        /// Serving status is unspecified.
        Unspecified,
        /// Application is serving.
        Serving,
        /// Application has been disabled by the user.
        UserDisabled,
        /// Application has been disabled by the system.
        SystemDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ServingStatus::value] or
        /// [ServingStatus::name].
        UnknownValue(serving_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod serving_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ServingStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Serving => std::option::Option::Some(1),
                Self::UserDisabled => std::option::Option::Some(2),
                Self::SystemDisabled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Serving => std::option::Option::Some("SERVING"),
                Self::UserDisabled => std::option::Option::Some("USER_DISABLED"),
                Self::SystemDisabled => std::option::Option::Some("SYSTEM_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ServingStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ServingStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ServingStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Serving,
                2 => Self::UserDisabled,
                3 => Self::SystemDisabled,
                _ => Self::UnknownValue(serving_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ServingStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "SERVING" => Self::Serving,
                "USER_DISABLED" => Self::UserDisabled,
                "SYSTEM_DISABLED" => Self::SystemDisabled,
                _ => Self::UnknownValue(serving_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ServingStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Serving => serializer.serialize_i32(1),
                Self::UserDisabled => serializer.serialize_i32(2),
                Self::SystemDisabled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ServingStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServingStatus>::new(
                ".google.appengine.v1.Application.ServingStatus",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Database type is unspecified.
        Unspecified,
        /// Cloud Datastore
        CloudDatastore,
        /// Cloud Firestore Native
        CloudFirestore,
        /// Cloud Firestore in Datastore Mode
        CloudDatastoreCompatibility,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudDatastore => std::option::Option::Some(1),
                Self::CloudFirestore => std::option::Option::Some(2),
                Self::CloudDatastoreCompatibility => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::CloudDatastore => std::option::Option::Some("CLOUD_DATASTORE"),
                Self::CloudFirestore => std::option::Option::Some("CLOUD_FIRESTORE"),
                Self::CloudDatastoreCompatibility => {
                    std::option::Option::Some("CLOUD_DATASTORE_COMPATIBILITY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudDatastore,
                2 => Self::CloudFirestore,
                3 => Self::CloudDatastoreCompatibility,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_DATASTORE" => Self::CloudDatastore,
                "CLOUD_FIRESTORE" => Self::CloudFirestore,
                "CLOUD_DATASTORE_COMPATIBILITY" => Self::CloudDatastoreCompatibility,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudDatastore => serializer.serialize_i32(1),
                Self::CloudFirestore => serializer.serialize_i32(2),
                Self::CloudDatastoreCompatibility => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.appengine.v1.Application.DatabaseType",
            ))
        }
    }
}

/// Rules to match an HTTP request and dispatch that request to a service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UrlDispatchRule {
    /// Domain name to match against. The wildcard "`*`" is supported if
    /// specified before a period: "`*.`".
    ///
    /// Defaults to matching all domains: "`*`".
    pub domain: std::string::String,

    /// Pathname within the host. Must start with a "`/`". A
    /// single "`*`" can be included at the end of the path.
    ///
    /// The sum of the lengths of the domain and path may not
    /// exceed 100 characters.
    pub path: std::string::String,

    /// Resource ID of a service in this application that should
    /// serve the matched request. The service must already
    /// exist. Example: `default`.
    pub service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UrlDispatchRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::UrlDispatchRule::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [path][crate::model::UrlDispatchRule::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UrlDispatchRule::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for UrlDispatchRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UrlDispatchRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UrlDispatchRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domain,
            __path,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UrlDispatchRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domain" => Ok(__FieldTag::__domain),
                            "path" => Ok(__FieldTag::__path),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UrlDispatchRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UrlDispatchRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UrlDispatchRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UrlDispatchRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UrlDispatchRule");
        debug_struct.field("domain", &self.domain);
        debug_struct.field("path", &self.path);
        debug_struct.field("service", &self.service);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// App Engine admin service audit log.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuditData {
    /// Detailed information about methods that require it. Does not include
    /// simple Get, List or Delete methods because all significant information
    /// (resource name, number of returned elements for List operations) is already
    /// included in parent audit log message.
    pub method: std::option::Option<crate::model::audit_data::Method>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuditData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::AuditData::method].
    ///
    /// Note that all the setters affecting `method` are mutually
    /// exclusive.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::audit_data::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::AuditData::method]
    /// if it holds a `UpdateService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateServiceMethod>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::audit_data::Method::UpdateService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::AuditData::method]
    /// to hold a `UpdateService`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_update_service<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateServiceMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::audit_data::Method::UpdateService(v.into()));
        self
    }

    /// The value of [method][crate::model::AuditData::method]
    /// if it holds a `CreateVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_version(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateVersionMethod>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::audit_data::Method::CreateVersion(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::AuditData::method]
    /// to hold a `CreateVersion`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_create_version<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateVersionMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::audit_data::Method::CreateVersion(v.into()));
        self
    }
}

impl wkt::message::Message for AuditData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuditData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuditData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_service,
            __create_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuditData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateService" => Ok(__FieldTag::__update_service),
                            "update_service" => Ok(__FieldTag::__update_service),
                            "createVersion" => Ok(__FieldTag::__create_version),
                            "create_version" => Ok(__FieldTag::__create_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuditData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuditData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_service => {
                            if !fields.insert(__FieldTag::__update_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_service",
                                ));
                            }
                            if result.method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `method`, a oneof with full ID .google.appengine.v1.AuditData.update_service, latest field was updateService",
                                ));
                            }
                            result.method = std::option::Option::Some(
                                crate::model::audit_data::Method::UpdateService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpdateServiceMethod>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_version => {
                            if !fields.insert(__FieldTag::__create_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_version",
                                ));
                            }
                            if result.method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `method`, a oneof with full ID .google.appengine.v1.AuditData.create_version, latest field was createVersion",
                                ));
                            }
                            result.method = std::option::Option::Some(
                                crate::model::audit_data::Method::CreateVersion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateVersionMethod>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuditData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.update_service() {
            state.serialize_entry("updateService", value)?;
        }
        if let Some(value) = self.create_version() {
            state.serialize_entry("createVersion", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuditData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuditData");
        debug_struct.field("method", &self.method);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AuditData].
pub mod audit_data {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed information about methods that require it. Does not include
    /// simple Get, List or Delete methods because all significant information
    /// (resource name, number of returned elements for List operations) is already
    /// included in parent audit log message.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Method {
        /// Detailed information about UpdateService call.
        UpdateService(std::boxed::Box<crate::model::UpdateServiceMethod>),
        /// Detailed information about CreateVersion call.
        CreateVersion(std::boxed::Box<crate::model::CreateVersionMethod>),
    }
}

/// Detailed information about UpdateService call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateServiceMethod {
    /// Update service request.
    pub request: std::option::Option<crate::model::UpdateServiceRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceMethod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::UpdateServiceMethod::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpdateServiceRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::UpdateServiceMethod::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpdateServiceRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServiceMethod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateServiceMethod"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateServiceMethod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateServiceMethod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateServiceMethod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateServiceMethod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::UpdateServiceRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateServiceMethod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateServiceMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateServiceMethod");
        debug_struct.field("request", &self.request);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Detailed information about CreateVersion call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionMethod {
    /// Create version request.
    pub request: std::option::Option<crate::model::CreateVersionRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionMethod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::CreateVersionMethod::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateVersionRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::CreateVersionMethod::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateVersionRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionMethod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionMethod"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionMethod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionMethod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionMethod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionMethod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::CreateVersionRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionMethod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVersionMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionMethod");
        debug_struct.field("request", &self.request);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An SSL certificate that a user has been authorized to administer. A user
/// is authorized to administer any certificate that applies to one of their
/// authorized domains.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthorizedCertificate {
    /// Full path to the `AuthorizedCertificate` resource in the API. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    ///
    /// @OutputOnly
    pub name: std::string::String,

    /// Relative name of the certificate. This is a unique value autogenerated
    /// on `AuthorizedCertificate` resource creation. Example: `12345`.
    ///
    /// @OutputOnly
    pub id: std::string::String,

    /// The user-specified display name of the certificate. This is not
    /// guaranteed to be unique. Example: `My Certificate`.
    pub display_name: std::string::String,

    /// Topmost applicable domains of this certificate. This certificate
    /// applies to these domains and their subdomains. Example: `example.com`.
    ///
    /// @OutputOnly
    pub domain_names: std::vec::Vec<std::string::String>,

    /// The time when this certificate expires. To update the renewal time on this
    /// certificate, upload an SSL certificate with a different expiration time
    /// using [`AuthorizedCertificates.UpdateAuthorizedCertificate`]().
    ///
    /// @OutputOnly
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The SSL certificate serving the `AuthorizedCertificate` resource. This
    /// must be obtained independently from a certificate authority.
    pub certificate_raw_data: std::option::Option<crate::model::CertificateRawData>,

    /// Only applicable if this certificate is managed by App Engine. Managed
    /// certificates are tied to the lifecycle of a `DomainMapping` and cannot be
    /// updated or deleted via the `AuthorizedCertificates` API. If this
    /// certificate is manually administered by the user, this field will be empty.
    ///
    /// @OutputOnly
    pub managed_certificate: std::option::Option<crate::model::ManagedCertificate>,

    /// The full paths to user visible Domain Mapping resources that have this
    /// certificate mapped. Example: `apps/myapp/domainMappings/example.com`.
    ///
    /// This may not represent the full list of mapped domain mappings if the user
    /// does not have `VIEWER` permissions on all of the applications that have
    /// this certificate mapped. See `domain_mappings_count` for a complete count.
    ///
    /// Only returned by `GET` or `LIST` requests when specifically requested by
    /// the `view=FULL_CERTIFICATE` option.
    ///
    /// @OutputOnly
    pub visible_domain_mappings: std::vec::Vec<std::string::String>,

    /// Aggregate count of the domain mappings with this certificate mapped. This
    /// count includes domain mappings on applications for which the user does not
    /// have `VIEWER` permissions.
    ///
    /// Only returned by `GET` or `LIST` requests when specifically requested by
    /// the `view=FULL_CERTIFICATE` option.
    ///
    /// @OutputOnly
    pub domain_mappings_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedCertificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedCertificate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AuthorizedCertificate::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AuthorizedCertificate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [domain_names][crate::model::AuthorizedCertificate::domain_names].
    pub fn set_domain_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.domain_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expire_time][crate::model::AuthorizedCertificate::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::AuthorizedCertificate::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [certificate_raw_data][crate::model::AuthorizedCertificate::certificate_raw_data].
    pub fn set_certificate_raw_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateRawData>,
    {
        self.certificate_raw_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_raw_data][crate::model::AuthorizedCertificate::certificate_raw_data].
    pub fn set_or_clear_certificate_raw_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateRawData>,
    {
        self.certificate_raw_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [managed_certificate][crate::model::AuthorizedCertificate::managed_certificate].
    pub fn set_managed_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedCertificate>,
    {
        self.managed_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [managed_certificate][crate::model::AuthorizedCertificate::managed_certificate].
    pub fn set_or_clear_managed_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedCertificate>,
    {
        self.managed_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [visible_domain_mappings][crate::model::AuthorizedCertificate::visible_domain_mappings].
    pub fn set_visible_domain_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.visible_domain_mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [domain_mappings_count][crate::model::AuthorizedCertificate::domain_mappings_count].
    pub fn set_domain_mappings_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.domain_mappings_count = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizedCertificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuthorizedCertificate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthorizedCertificate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __display_name,
            __domain_names,
            __expire_time,
            __certificate_raw_data,
            __managed_certificate,
            __visible_domain_mappings,
            __domain_mappings_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthorizedCertificate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "domainNames" => Ok(__FieldTag::__domain_names),
                            "domain_names" => Ok(__FieldTag::__domain_names),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "certificateRawData" => Ok(__FieldTag::__certificate_raw_data),
                            "certificate_raw_data" => Ok(__FieldTag::__certificate_raw_data),
                            "managedCertificate" => Ok(__FieldTag::__managed_certificate),
                            "managed_certificate" => Ok(__FieldTag::__managed_certificate),
                            "visibleDomainMappings" => Ok(__FieldTag::__visible_domain_mappings),
                            "visible_domain_mappings" => Ok(__FieldTag::__visible_domain_mappings),
                            "domainMappingsCount" => Ok(__FieldTag::__domain_mappings_count),
                            "domain_mappings_count" => Ok(__FieldTag::__domain_mappings_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthorizedCertificate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthorizedCertificate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain_names => {
                            if !fields.insert(__FieldTag::__domain_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_names",
                                ));
                            }
                            result.domain_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__certificate_raw_data => {
                            if !fields.insert(__FieldTag::__certificate_raw_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_raw_data",
                                ));
                            }
                            result.certificate_raw_data = map.next_value::<std::option::Option<crate::model::CertificateRawData>>()?
                                ;
                        }
                        __FieldTag::__managed_certificate => {
                            if !fields.insert(__FieldTag::__managed_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_certificate",
                                ));
                            }
                            result.managed_certificate = map.next_value::<std::option::Option<crate::model::ManagedCertificate>>()?
                                ;
                        }
                        __FieldTag::__visible_domain_mappings => {
                            if !fields.insert(__FieldTag::__visible_domain_mappings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visible_domain_mappings",
                                ));
                            }
                            result.visible_domain_mappings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__domain_mappings_count => {
                            if !fields.insert(__FieldTag::__domain_mappings_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_mappings_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.domain_mappings_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthorizedCertificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.domain_names.is_empty() {
            state.serialize_entry("domainNames", &self.domain_names)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.certificate_raw_data.is_some() {
            state.serialize_entry("certificateRawData", &self.certificate_raw_data)?;
        }
        if self.managed_certificate.is_some() {
            state.serialize_entry("managedCertificate", &self.managed_certificate)?;
        }
        if !self.visible_domain_mappings.is_empty() {
            state.serialize_entry("visibleDomainMappings", &self.visible_domain_mappings)?;
        }
        if !wkt::internal::is_default(&self.domain_mappings_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("domainMappingsCount", &__With(&self.domain_mappings_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthorizedCertificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthorizedCertificate");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("domain_names", &self.domain_names);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("certificate_raw_data", &self.certificate_raw_data);
        debug_struct.field("managed_certificate", &self.managed_certificate);
        debug_struct.field("visible_domain_mappings", &self.visible_domain_mappings);
        debug_struct.field("domain_mappings_count", &self.domain_mappings_count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An SSL certificate obtained from a certificate authority.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateRawData {
    /// PEM encoded x.509 public key certificate. This field is set once on
    /// certificate creation. Must include the header and footer. Example:
    pub public_certificate: std::string::String,

    /// Unencrypted PEM encoded RSA private key. This field is set once on
    /// certificate creation and then encrypted. The key size must be 2048
    /// bits or fewer. Must include the header and footer. Example:
    ///
    /// @InputOnly
    pub private_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateRawData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_certificate][crate::model::CertificateRawData::public_certificate].
    pub fn set_public_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_certificate = v.into();
        self
    }

    /// Sets the value of [private_key][crate::model::CertificateRawData::private_key].
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }
}

impl wkt::message::Message for CertificateRawData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CertificateRawData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateRawData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __public_certificate,
            __private_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateRawData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "publicCertificate" => Ok(__FieldTag::__public_certificate),
                            "public_certificate" => Ok(__FieldTag::__public_certificate),
                            "privateKey" => Ok(__FieldTag::__private_key),
                            "private_key" => Ok(__FieldTag::__private_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateRawData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateRawData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__public_certificate => {
                            if !fields.insert(__FieldTag::__public_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_certificate",
                                ));
                            }
                            result.public_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_key => {
                            if !fields.insert(__FieldTag::__private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key",
                                ));
                            }
                            result.private_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateRawData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.public_certificate.is_empty() {
            state.serialize_entry("publicCertificate", &self.public_certificate)?;
        }
        if !self.private_key.is_empty() {
            state.serialize_entry("privateKey", &self.private_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CertificateRawData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CertificateRawData");
        debug_struct.field("public_certificate", &self.public_certificate);
        debug_struct.field("private_key", &self.private_key);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A certificate managed by App Engine.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedCertificate {
    /// Time at which the certificate was last renewed. The renewal process is
    /// fully managed. Certificate renewal will automatically occur before the
    /// certificate expires. Renewal errors can be tracked via `ManagementStatus`.
    ///
    /// @OutputOnly
    pub last_renewal_time: std::option::Option<wkt::Timestamp>,

    /// Status of certificate management. Refers to the most recent certificate
    /// acquisition or renewal attempt.
    ///
    /// @OutputOnly
    pub status: crate::model::ManagementStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedCertificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_renewal_time][crate::model::ManagedCertificate::last_renewal_time].
    pub fn set_last_renewal_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_renewal_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_renewal_time][crate::model::ManagedCertificate::last_renewal_time].
    pub fn set_or_clear_last_renewal_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_renewal_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::ManagedCertificate::status].
    pub fn set_status<T: std::convert::Into<crate::model::ManagementStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ManagedCertificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ManagedCertificate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagedCertificate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_renewal_time,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedCertificate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastRenewalTime" => Ok(__FieldTag::__last_renewal_time),
                            "last_renewal_time" => Ok(__FieldTag::__last_renewal_time),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagedCertificate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedCertificate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_renewal_time => {
                            if !fields.insert(__FieldTag::__last_renewal_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_renewal_time",
                                ));
                            }
                            result.last_renewal_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::ManagementStatus>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagedCertificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_renewal_time.is_some() {
            state.serialize_entry("lastRenewalTime", &self.last_renewal_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ManagedCertificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedCertificate");
        debug_struct.field("last_renewal_time", &self.last_renewal_time);
        debug_struct.field("status", &self.status);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Code and application artifacts used to deploy a version to App Engine.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Deployment {
    /// Manifest of the files stored in Google Cloud Storage that are included
    /// as part of this version. All files must be readable using the
    /// credentials supplied with this call.
    pub files: std::collections::HashMap<std::string::String, crate::model::FileInfo>,

    /// The Docker image for the container that runs the version.
    /// Only applicable for instances running in the App Engine flexible environment.
    pub container: std::option::Option<crate::model::ContainerInfo>,

    /// The zip file for this deployment, if this is a zip deployment.
    pub zip: std::option::Option<crate::model::ZipInfo>,

    /// Options for any Google Cloud Build builds created as a part of this
    /// deployment.
    ///
    /// These options will only be used if a new build is created, such as when
    /// deploying to the App Engine flexible environment using files or zip.
    pub cloud_build_options: std::option::Option<crate::model::CloudBuildOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [files][crate::model::Deployment::files].
    pub fn set_files<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileInfo>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [container][crate::model::Deployment::container].
    pub fn set_container<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContainerInfo>,
    {
        self.container = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container][crate::model::Deployment::container].
    pub fn set_or_clear_container<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContainerInfo>,
    {
        self.container = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zip][crate::model::Deployment::zip].
    pub fn set_zip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ZipInfo>,
    {
        self.zip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zip][crate::model::Deployment::zip].
    pub fn set_or_clear_zip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ZipInfo>,
    {
        self.zip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_build_options][crate::model::Deployment::cloud_build_options].
    pub fn set_cloud_build_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudBuildOptions>,
    {
        self.cloud_build_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_build_options][crate::model::Deployment::cloud_build_options].
    pub fn set_or_clear_cloud_build_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudBuildOptions>,
    {
        self.cloud_build_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Deployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Deployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __files,
            __container,
            __zip,
            __cloud_build_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Deployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "files" => Ok(__FieldTag::__files),
                            "container" => Ok(__FieldTag::__container),
                            "zip" => Ok(__FieldTag::__zip),
                            "cloudBuildOptions" => Ok(__FieldTag::__cloud_build_options),
                            "cloud_build_options" => Ok(__FieldTag::__cloud_build_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Deployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Deployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__files => {
                            if !fields.insert(__FieldTag::__files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files",
                                ));
                            }
                            result.files = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::FileInfo,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container => {
                            if !fields.insert(__FieldTag::__container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container",
                                ));
                            }
                            result.container = map
                                .next_value::<std::option::Option<crate::model::ContainerInfo>>()?;
                        }
                        __FieldTag::__zip => {
                            if !fields.insert(__FieldTag::__zip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zip",
                                ));
                            }
                            result.zip =
                                map.next_value::<std::option::Option<crate::model::ZipInfo>>()?;
                        }
                        __FieldTag::__cloud_build_options => {
                            if !fields.insert(__FieldTag::__cloud_build_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_build_options",
                                ));
                            }
                            result.cloud_build_options = map
                                .next_value::<std::option::Option<crate::model::CloudBuildOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Deployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.files.is_empty() {
            state.serialize_entry("files", &self.files)?;
        }
        if self.container.is_some() {
            state.serialize_entry("container", &self.container)?;
        }
        if self.zip.is_some() {
            state.serialize_entry("zip", &self.zip)?;
        }
        if self.cloud_build_options.is_some() {
            state.serialize_entry("cloudBuildOptions", &self.cloud_build_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Deployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Deployment");
        debug_struct.field("files", &self.files);
        debug_struct.field("container", &self.container);
        debug_struct.field("zip", &self.zip);
        debug_struct.field("cloud_build_options", &self.cloud_build_options);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Single source file that is part of the version to be deployed. Each source
/// file that is deployed must be specified separately.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileInfo {
    /// URL source to use to fetch this file. Must be a URL to a resource in
    /// Google Cloud Storage in the form
    /// 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
    pub source_url: std::string::String,

    /// The SHA1 hash of the file, in hex.
    pub sha1_sum: std::string::String,

    /// The MIME type of the file.
    ///
    /// Defaults to the value from Google Cloud Storage.
    pub mime_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_url][crate::model::FileInfo::source_url].
    pub fn set_source_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_url = v.into();
        self
    }

    /// Sets the value of [sha1_sum][crate::model::FileInfo::sha1_sum].
    pub fn set_sha1_sum<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_sum = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::FileInfo::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for FileInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.FileInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_url,
            __sha1_sum,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceUrl" => Ok(__FieldTag::__source_url),
                            "source_url" => Ok(__FieldTag::__source_url),
                            "sha1Sum" => Ok(__FieldTag::__sha1_sum),
                            "sha1_sum" => Ok(__FieldTag::__sha1_sum),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_url => {
                            if !fields.insert(__FieldTag::__source_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_url",
                                ));
                            }
                            result.source_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sha1_sum => {
                            if !fields.insert(__FieldTag::__sha1_sum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha1_sum",
                                ));
                            }
                            result.sha1_sum = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_url.is_empty() {
            state.serialize_entry("sourceUrl", &self.source_url)?;
        }
        if !self.sha1_sum.is_empty() {
            state.serialize_entry("sha1Sum", &self.sha1_sum)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FileInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FileInfo");
        debug_struct.field("source_url", &self.source_url);
        debug_struct.field("sha1_sum", &self.sha1_sum);
        debug_struct.field("mime_type", &self.mime_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Docker image that is used to create a container and start a VM instance for
/// the version that you deploy. Only applicable for instances running in the App
/// Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContainerInfo {
    /// URI to the hosted container image in Google Container Registry. The URI
    /// must be fully qualified and include a tag or digest.
    /// Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
    pub image: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::ContainerInfo::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }
}

impl wkt::message::Message for ContainerInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ContainerInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContainerInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "image" => Ok(__FieldTag::__image),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContainerInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            result.image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContainerInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image.is_empty() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ContainerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContainerInfo");
        debug_struct.field("image", &self.image);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options for the build operations performed as a part of the version
/// deployment. Only applicable for App Engine flexible environment when creating
/// a version using source code directly.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudBuildOptions {
    /// Path to the yaml file used in deployment, used to determine runtime
    /// configuration details.
    ///
    /// Required for flexible environment builds.
    ///
    /// See <https://cloud.google.com/appengine/docs/standard/python/config/appref>
    /// for more details.
    pub app_yaml_path: std::string::String,

    /// The Cloud Build timeout used as part of any dependent builds performed by
    /// version creation. Defaults to 10 minutes.
    pub cloud_build_timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBuildOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [app_yaml_path][crate::model::CloudBuildOptions::app_yaml_path].
    pub fn set_app_yaml_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_yaml_path = v.into();
        self
    }

    /// Sets the value of [cloud_build_timeout][crate::model::CloudBuildOptions::cloud_build_timeout].
    pub fn set_cloud_build_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cloud_build_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_build_timeout][crate::model::CloudBuildOptions::cloud_build_timeout].
    pub fn set_or_clear_cloud_build_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cloud_build_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudBuildOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CloudBuildOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudBuildOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __app_yaml_path,
            __cloud_build_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudBuildOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "appYamlPath" => Ok(__FieldTag::__app_yaml_path),
                            "app_yaml_path" => Ok(__FieldTag::__app_yaml_path),
                            "cloudBuildTimeout" => Ok(__FieldTag::__cloud_build_timeout),
                            "cloud_build_timeout" => Ok(__FieldTag::__cloud_build_timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudBuildOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudBuildOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__app_yaml_path => {
                            if !fields.insert(__FieldTag::__app_yaml_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_yaml_path",
                                ));
                            }
                            result.app_yaml_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_build_timeout => {
                            if !fields.insert(__FieldTag::__cloud_build_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_build_timeout",
                                ));
                            }
                            result.cloud_build_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudBuildOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.app_yaml_path.is_empty() {
            state.serialize_entry("appYamlPath", &self.app_yaml_path)?;
        }
        if self.cloud_build_timeout.is_some() {
            state.serialize_entry("cloudBuildTimeout", &self.cloud_build_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudBuildOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudBuildOptions");
        debug_struct.field("app_yaml_path", &self.app_yaml_path);
        debug_struct.field("cloud_build_timeout", &self.cloud_build_timeout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The zip file information for a zip deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZipInfo {
    /// URL of the zip file to deploy from. Must be a URL to a resource in
    /// Google Cloud Storage in the form
    /// 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
    pub source_url: std::string::String,

    /// An estimate of the number of files in a zip for a zip deployment.
    /// If set, must be greater than or equal to the actual number of files.
    /// Used for optimizing performance; if not provided, deployment may be slow.
    pub files_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZipInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_url][crate::model::ZipInfo::source_url].
    pub fn set_source_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_url = v.into();
        self
    }

    /// Sets the value of [files_count][crate::model::ZipInfo::files_count].
    pub fn set_files_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.files_count = v.into();
        self
    }
}

impl wkt::message::Message for ZipInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ZipInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ZipInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_url,
            __files_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZipInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceUrl" => Ok(__FieldTag::__source_url),
                            "source_url" => Ok(__FieldTag::__source_url),
                            "filesCount" => Ok(__FieldTag::__files_count),
                            "files_count" => Ok(__FieldTag::__files_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ZipInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZipInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_url => {
                            if !fields.insert(__FieldTag::__source_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_url",
                                ));
                            }
                            result.source_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__files_count => {
                            if !fields.insert(__FieldTag::__files_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.files_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ZipInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_url.is_empty() {
            state.serialize_entry("sourceUrl", &self.source_url)?;
        }
        if !wkt::internal::is_default(&self.files_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("filesCount", &__With(&self.files_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ZipInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ZipInfo");
        debug_struct.field("source_url", &self.source_url);
        debug_struct.field("files_count", &self.files_count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A domain that a user has been authorized to administer. To authorize use
/// of a domain, verify ownership via
/// [Search Console](https://search.google.com/search-console/welcome).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthorizedDomain {
    /// Full path to the `AuthorizedDomain` resource in the API. Example:
    /// `apps/myapp/authorizedDomains/example.com`.
    ///
    /// @OutputOnly
    pub name: std::string::String,

    /// Fully qualified domain name of the domain authorized for use. Example:
    /// `example.com`.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedDomain {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedDomain::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AuthorizedDomain::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizedDomain {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuthorizedDomain"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthorizedDomain {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthorizedDomain")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthorizedDomain;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthorizedDomain")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthorizedDomain {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthorizedDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthorizedDomain");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A domain serving an App Engine application.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DomainMapping {
    /// Full path to the `DomainMapping` resource in the API. Example:
    /// `apps/myapp/domainMapping/example.com`.
    ///
    /// @OutputOnly
    pub name: std::string::String,

    /// Relative name of the domain serving the application. Example:
    /// `example.com`.
    pub id: std::string::String,

    /// SSL configuration for this domain. If unconfigured, this domain will not
    /// serve with SSL.
    pub ssl_settings: std::option::Option<crate::model::SslSettings>,

    /// The resource records required to configure this domain mapping. These
    /// records must be added to the domain's DNS configuration in order to
    /// serve the application via this domain mapping.
    ///
    /// @OutputOnly
    pub resource_records: std::vec::Vec<crate::model::ResourceRecord>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DomainMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DomainMapping::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::DomainMapping::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [ssl_settings][crate::model::DomainMapping::ssl_settings].
    pub fn set_ssl_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslSettings>,
    {
        self.ssl_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_settings][crate::model::DomainMapping::ssl_settings].
    pub fn set_or_clear_ssl_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslSettings>,
    {
        self.ssl_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_records][crate::model::DomainMapping::resource_records].
    pub fn set_resource_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceRecord>,
    {
        use std::iter::Iterator;
        self.resource_records = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DomainMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DomainMapping"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DomainMapping {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __ssl_settings,
            __resource_records,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DomainMapping")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "sslSettings" => Ok(__FieldTag::__ssl_settings),
                            "ssl_settings" => Ok(__FieldTag::__ssl_settings),
                            "resourceRecords" => Ok(__FieldTag::__resource_records),
                            "resource_records" => Ok(__FieldTag::__resource_records),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DomainMapping;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DomainMapping")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_settings => {
                            if !fields.insert(__FieldTag::__ssl_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_settings",
                                ));
                            }
                            result.ssl_settings =
                                map.next_value::<std::option::Option<crate::model::SslSettings>>()?;
                        }
                        __FieldTag::__resource_records => {
                            if !fields.insert(__FieldTag::__resource_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_records",
                                ));
                            }
                            result.resource_records =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceRecord>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DomainMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.ssl_settings.is_some() {
            state.serialize_entry("sslSettings", &self.ssl_settings)?;
        }
        if !self.resource_records.is_empty() {
            state.serialize_entry("resourceRecords", &self.resource_records)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DomainMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DomainMapping");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("ssl_settings", &self.ssl_settings);
        debug_struct.field("resource_records", &self.resource_records);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SSL configuration for a `DomainMapping` resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SslSettings {
    /// ID of the `AuthorizedCertificate` resource configuring SSL for the
    /// application. Clearing this field will remove SSL support.
    ///
    /// By default, a managed certificate is automatically created for every
    /// domain mapping. To omit SSL support or to configure SSL manually, specify
    /// `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must
    /// be authorized to administer the `AuthorizedCertificate` resource to
    /// manually map it to a `DomainMapping` resource.
    /// Example: `12345`.
    pub certificate_id: std::string::String,

    /// SSL management type for this domain. If `AUTOMATIC`, a managed certificate
    /// is automatically provisioned. If `MANUAL`, `certificate_id` must be
    /// manually specified in order to configure SSL for this domain.
    pub ssl_management_type: crate::model::ssl_settings::SslManagementType,

    /// ID of the managed `AuthorizedCertificate` resource currently being
    /// provisioned, if applicable. Until the new managed certificate has been
    /// successfully provisioned, the previous SSL state will be preserved. Once
    /// the provisioning process completes, the `certificate_id` field will reflect
    /// the new managed certificate and this field will be left empty. To remove
    /// SSL support while there is still a pending managed certificate, clear the
    /// `certificate_id` field with an `UpdateDomainMappingRequest`.
    ///
    /// @OutputOnly
    pub pending_managed_certificate_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_id][crate::model::SslSettings::certificate_id].
    pub fn set_certificate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.certificate_id = v.into();
        self
    }

    /// Sets the value of [ssl_management_type][crate::model::SslSettings::ssl_management_type].
    pub fn set_ssl_management_type<
        T: std::convert::Into<crate::model::ssl_settings::SslManagementType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_management_type = v.into();
        self
    }

    /// Sets the value of [pending_managed_certificate_id][crate::model::SslSettings::pending_managed_certificate_id].
    pub fn set_pending_managed_certificate_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pending_managed_certificate_id = v.into();
        self
    }
}

impl wkt::message::Message for SslSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.SslSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_id,
            __ssl_management_type,
            __pending_managed_certificate_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateId" => Ok(__FieldTag::__certificate_id),
                            "certificate_id" => Ok(__FieldTag::__certificate_id),
                            "sslManagementType" => Ok(__FieldTag::__ssl_management_type),
                            "ssl_management_type" => Ok(__FieldTag::__ssl_management_type),
                            "pendingManagedCertificateId" => {
                                Ok(__FieldTag::__pending_managed_certificate_id)
                            }
                            "pending_managed_certificate_id" => {
                                Ok(__FieldTag::__pending_managed_certificate_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_id => {
                            if !fields.insert(__FieldTag::__certificate_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_id",
                                ));
                            }
                            result.certificate_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_management_type => {
                            if !fields.insert(__FieldTag::__ssl_management_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_management_type",
                                ));
                            }
                            result.ssl_management_type =
                                map.next_value::<std::option::Option<
                                    crate::model::ssl_settings::SslManagementType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pending_managed_certificate_id => {
                            if !fields.insert(__FieldTag::__pending_managed_certificate_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_managed_certificate_id",
                                ));
                            }
                            result.pending_managed_certificate_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certificate_id.is_empty() {
            state.serialize_entry("certificateId", &self.certificate_id)?;
        }
        if !wkt::internal::is_default(&self.ssl_management_type) {
            state.serialize_entry("sslManagementType", &self.ssl_management_type)?;
        }
        if !self.pending_managed_certificate_id.is_empty() {
            state.serialize_entry(
                "pendingManagedCertificateId",
                &self.pending_managed_certificate_id,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SslSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslSettings");
        debug_struct.field("certificate_id", &self.certificate_id);
        debug_struct.field("ssl_management_type", &self.ssl_management_type);
        debug_struct.field(
            "pending_managed_certificate_id",
            &self.pending_managed_certificate_id,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SslSettings].
pub mod ssl_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The SSL management type for this domain.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslManagementType {
        /// Defaults to `AUTOMATIC`.
        Unspecified,
        /// SSL support for this domain is configured automatically. The mapped SSL
        /// certificate will be automatically renewed.
        Automatic,
        /// SSL support for this domain is configured manually by the user. Either
        /// the domain has no SSL support or a user-obtained SSL certificate has been
        /// explictly mapped to this domain.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslManagementType::value] or
        /// [SslManagementType::name].
        UnknownValue(ssl_management_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_management_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslManagementType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_MANAGEMENT_TYPE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslManagementType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslManagementType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslManagementType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(ssl_management_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslManagementType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_MANAGEMENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(ssl_management_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslManagementType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslManagementType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslManagementType>::new(
                ".google.appengine.v1.SslSettings.SslManagementType",
            ))
        }
    }
}

/// A DNS resource record.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceRecord {
    /// Relative name of the object affected by this record. Only applicable for
    /// `CNAME` records. Example: 'www'.
    pub name: std::string::String,

    /// Data for this record. Values vary by record type, as defined in RFC 1035
    /// (section 5) and RFC 1034 (section 3.6.1).
    pub rrdata: std::string::String,

    /// Resource record type. Example: `AAAA`.
    pub r#type: crate::model::resource_record::RecordType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceRecord::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rrdata][crate::model::ResourceRecord::rrdata].
    pub fn set_rrdata<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rrdata = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ResourceRecord::type].
    pub fn set_type<T: std::convert::Into<crate::model::resource_record::RecordType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for ResourceRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ResourceRecord"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __rrdata,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "rrdata" => Ok(__FieldTag::__rrdata),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rrdata => {
                            if !fields.insert(__FieldTag::__rrdata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rrdata",
                                ));
                            }
                            result.rrdata = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::resource_record::RecordType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.rrdata.is_empty() {
            state.serialize_entry("rrdata", &self.rrdata)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceRecord");
        debug_struct.field("name", &self.name);
        debug_struct.field("rrdata", &self.rrdata);
        debug_struct.field("r#type", &self.r#type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ResourceRecord].
pub mod resource_record {
    #[allow(unused_imports)]
    use super::*;

    /// A resource record type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RecordType {
        /// An unknown resource record.
        Unspecified,
        /// An A resource record. Data is an IPv4 address.
        A,
        /// An AAAA resource record. Data is an IPv6 address.
        Aaaa,
        /// A CNAME resource record. Data is a domain name to be aliased.
        Cname,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RecordType::value] or
        /// [RecordType::name].
        UnknownValue(record_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod record_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RecordType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::A => std::option::Option::Some(1),
                Self::Aaaa => std::option::Option::Some(2),
                Self::Cname => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECORD_TYPE_UNSPECIFIED"),
                Self::A => std::option::Option::Some("A"),
                Self::Aaaa => std::option::Option::Some("AAAA"),
                Self::Cname => std::option::Option::Some("CNAME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RecordType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RecordType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RecordType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::A,
                2 => Self::Aaaa,
                3 => Self::Cname,
                _ => Self::UnknownValue(record_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RecordType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECORD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "A" => Self::A,
                "AAAA" => Self::Aaaa,
                "CNAME" => Self::Cname,
                _ => Self::UnknownValue(record_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RecordType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::A => serializer.serialize_i32(1),
                Self::Aaaa => serializer.serialize_i32(2),
                Self::Cname => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RecordType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RecordType>::new(
                ".google.appengine.v1.ResourceRecord.RecordType",
            ))
        }
    }
}

/// A single firewall rule that is evaluated against incoming traffic
/// and provides an action to take on matched requests.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallRule {
    /// A positive integer between [1, Int32.MaxValue-1] that defines the order of
    /// rule evaluation. Rules with the lowest priority are evaluated first.
    ///
    /// A default rule at priority Int32.MaxValue matches all IPv4 and IPv6 traffic
    /// when no previous rule matches. Only the action of this rule can be modified
    /// by the user.
    pub priority: i32,

    /// The action to take on matched requests.
    pub action: crate::model::firewall_rule::Action,

    /// IP address or range, defined using CIDR notation, of requests that this
    /// rule applies to. You can use the wildcard character "*" to match all IPs
    /// equivalent to "0/0" and "::/0" together.
    /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
    /// or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
    pub source_range: std::string::String,

    /// An optional string description of this rule.
    /// This field has a maximum length of 100 characters.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [priority][crate::model::FirewallRule::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [action][crate::model::FirewallRule::action].
    pub fn set_action<T: std::convert::Into<crate::model::firewall_rule::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [source_range][crate::model::FirewallRule::source_range].
    pub fn set_source_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_range = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FirewallRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for FirewallRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.FirewallRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FirewallRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __priority,
            __action,
            __source_range,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "priority" => Ok(__FieldTag::__priority),
                            "action" => Ok(__FieldTag::__action),
                            "sourceRange" => Ok(__FieldTag::__source_range),
                            "source_range" => Ok(__FieldTag::__source_range),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FirewallRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map.next_value::<std::option::Option<crate::model::firewall_rule::Action>>()?.unwrap_or_default();
                        }
                        __FieldTag::__source_range => {
                            if !fields.insert(__FieldTag::__source_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_range",
                                ));
                            }
                            result.source_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FirewallRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !wkt::internal::is_default(&self.action) {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.source_range.is_empty() {
            state.serialize_entry("sourceRange", &self.source_range)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FirewallRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FirewallRule");
        debug_struct.field("priority", &self.priority);
        debug_struct.field("action", &self.action);
        debug_struct.field("source_range", &self.source_range);
        debug_struct.field("description", &self.description);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FirewallRule].
pub mod firewall_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Available actions to take on matching requests.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        UnspecifiedAction,
        /// Matching requests are allowed.
        Allow,
        /// Matching requests are denied.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::UnspecifiedAction => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::UnspecifiedAction => std::option::Option::Some("UNSPECIFIED_ACTION"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::UnspecifiedAction,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED_ACTION" => Self::UnspecifiedAction,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::UnspecifiedAction => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.appengine.v1.FirewallRule.Action",
            ))
        }
    }
}

/// An Instance resource is the computing unit that App Engine uses to
/// automatically scale an application.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Output only. Full path to the Instance resource in the API.
    /// Example: `apps/myapp/services/default/versions/v1/instances/instance-1`.
    pub name: std::string::String,

    /// Output only. Relative name of the instance within the version.
    /// Example: `instance-1`.
    pub id: std::string::String,

    /// Output only. App Engine release this instance is running on.
    pub app_engine_release: std::string::String,

    /// Output only. Availability of the instance.
    pub availability: crate::model::instance::Availability,

    /// Output only. Name of the virtual machine where this instance lives. Only applicable
    /// for instances in App Engine flexible environment.
    pub vm_name: std::string::String,

    /// Output only. Zone where the virtual machine is located. Only applicable for instances
    /// in App Engine flexible environment.
    pub vm_zone_name: std::string::String,

    /// Output only. Virtual machine ID of this instance. Only applicable for instances in
    /// App Engine flexible environment.
    pub vm_id: std::string::String,

    /// Output only. Time that this instance was started.
    ///
    /// @OutputOnly
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of requests since this instance was started.
    pub requests: i32,

    /// Output only. Number of errors since this instance was started.
    pub errors: i32,

    /// Output only. Average queries per second (QPS) over the last minute.
    pub qps: f32,

    /// Output only. Average latency (ms) over the last minute.
    pub average_latency: i32,

    /// Output only. Total memory in use (bytes).
    pub memory_usage: i64,

    /// Output only. Status of the virtual machine where this instance lives. Only applicable
    /// for instances in App Engine flexible environment.
    pub vm_status: std::string::String,

    /// Output only. Whether this instance is in debug mode. Only applicable for instances in
    /// App Engine flexible environment.
    pub vm_debug_enabled: bool,

    /// Output only. The IP address of this instance. Only applicable for instances in App
    /// Engine flexible environment.
    pub vm_ip: std::string::String,

    /// Output only. The liveness health check of this instance. Only applicable for instances
    /// in App Engine flexible environment.
    pub vm_liveness: crate::model::instance::liveness::LivenessState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [app_engine_release][crate::model::Instance::app_engine_release].
    pub fn set_app_engine_release<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_release = v.into();
        self
    }

    /// Sets the value of [availability][crate::model::Instance::availability].
    pub fn set_availability<T: std::convert::Into<crate::model::instance::Availability>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::Instance::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_zone_name][crate::model::Instance::vm_zone_name].
    pub fn set_vm_zone_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone_name = v.into();
        self
    }

    /// Sets the value of [vm_id][crate::model::Instance::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Instance::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Instance::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requests][crate::model::Instance::requests].
    pub fn set_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.requests = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Instance::errors].
    pub fn set_errors<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.errors = v.into();
        self
    }

    /// Sets the value of [qps][crate::model::Instance::qps].
    pub fn set_qps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.qps = v.into();
        self
    }

    /// Sets the value of [average_latency][crate::model::Instance::average_latency].
    pub fn set_average_latency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.average_latency = v.into();
        self
    }

    /// Sets the value of [memory_usage][crate::model::Instance::memory_usage].
    pub fn set_memory_usage<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.memory_usage = v.into();
        self
    }

    /// Sets the value of [vm_status][crate::model::Instance::vm_status].
    pub fn set_vm_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_status = v.into();
        self
    }

    /// Sets the value of [vm_debug_enabled][crate::model::Instance::vm_debug_enabled].
    pub fn set_vm_debug_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vm_debug_enabled = v.into();
        self
    }

    /// Sets the value of [vm_ip][crate::model::Instance::vm_ip].
    pub fn set_vm_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_ip = v.into();
        self
    }

    /// Sets the value of [vm_liveness][crate::model::Instance::vm_liveness].
    pub fn set_vm_liveness<
        T: std::convert::Into<crate::model::instance::liveness::LivenessState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_liveness = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __app_engine_release,
            __availability,
            __vm_name,
            __vm_zone_name,
            __vm_id,
            __start_time,
            __requests,
            __errors,
            __qps,
            __average_latency,
            __memory_usage,
            __vm_status,
            __vm_debug_enabled,
            __vm_ip,
            __vm_liveness,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "appEngineRelease" => Ok(__FieldTag::__app_engine_release),
                            "app_engine_release" => Ok(__FieldTag::__app_engine_release),
                            "availability" => Ok(__FieldTag::__availability),
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "vmZoneName" => Ok(__FieldTag::__vm_zone_name),
                            "vm_zone_name" => Ok(__FieldTag::__vm_zone_name),
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "requests" => Ok(__FieldTag::__requests),
                            "errors" => Ok(__FieldTag::__errors),
                            "qps" => Ok(__FieldTag::__qps),
                            "averageLatency" => Ok(__FieldTag::__average_latency),
                            "average_latency" => Ok(__FieldTag::__average_latency),
                            "memoryUsage" => Ok(__FieldTag::__memory_usage),
                            "memory_usage" => Ok(__FieldTag::__memory_usage),
                            "vmStatus" => Ok(__FieldTag::__vm_status),
                            "vm_status" => Ok(__FieldTag::__vm_status),
                            "vmDebugEnabled" => Ok(__FieldTag::__vm_debug_enabled),
                            "vm_debug_enabled" => Ok(__FieldTag::__vm_debug_enabled),
                            "vmIp" => Ok(__FieldTag::__vm_ip),
                            "vm_ip" => Ok(__FieldTag::__vm_ip),
                            "vmLiveness" => Ok(__FieldTag::__vm_liveness),
                            "vm_liveness" => Ok(__FieldTag::__vm_liveness),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_release => {
                            if !fields.insert(__FieldTag::__app_engine_release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_release",
                                ));
                            }
                            result.app_engine_release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability => {
                            if !fields.insert(__FieldTag::__availability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability",
                                ));
                            }
                            result.availability = map.next_value::<std::option::Option<crate::model::instance::Availability>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_zone_name => {
                            if !fields.insert(__FieldTag::__vm_zone_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_zone_name",
                                ));
                            }
                            result.vm_zone_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.requests = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.errors = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__qps => {
                            if !fields.insert(__FieldTag::__qps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qps",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.qps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__average_latency => {
                            if !fields.insert(__FieldTag::__average_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_latency",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_latency =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_usage => {
                            if !fields.insert(__FieldTag::__memory_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_usage",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_usage = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vm_status => {
                            if !fields.insert(__FieldTag::__vm_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_status",
                                ));
                            }
                            result.vm_status = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_debug_enabled => {
                            if !fields.insert(__FieldTag::__vm_debug_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_debug_enabled",
                                ));
                            }
                            result.vm_debug_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_ip => {
                            if !fields.insert(__FieldTag::__vm_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_ip",
                                ));
                            }
                            result.vm_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_liveness => {
                            if !fields.insert(__FieldTag::__vm_liveness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_liveness",
                                ));
                            }
                            result.vm_liveness = map
                                .next_value::<std::option::Option<
                                    crate::model::instance::liveness::LivenessState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.app_engine_release.is_empty() {
            state.serialize_entry("appEngineRelease", &self.app_engine_release)?;
        }
        if !wkt::internal::is_default(&self.availability) {
            state.serialize_entry("availability", &self.availability)?;
        }
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.vm_zone_name.is_empty() {
            state.serialize_entry("vmZoneName", &self.vm_zone_name)?;
        }
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !wkt::internal::is_default(&self.requests) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("requests", &__With(&self.requests))?;
        }
        if !wkt::internal::is_default(&self.errors) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("errors", &__With(&self.errors))?;
        }
        if !wkt::internal::is_default(&self.qps) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("qps", &__With(&self.qps))?;
        }
        if !wkt::internal::is_default(&self.average_latency) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("averageLatency", &__With(&self.average_latency))?;
        }
        if !wkt::internal::is_default(&self.memory_usage) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryUsage", &__With(&self.memory_usage))?;
        }
        if !self.vm_status.is_empty() {
            state.serialize_entry("vmStatus", &self.vm_status)?;
        }
        if !wkt::internal::is_default(&self.vm_debug_enabled) {
            state.serialize_entry("vmDebugEnabled", &self.vm_debug_enabled)?;
        }
        if !self.vm_ip.is_empty() {
            state.serialize_entry("vmIp", &self.vm_ip)?;
        }
        if !wkt::internal::is_default(&self.vm_liveness) {
            state.serialize_entry("vmLiveness", &self.vm_liveness)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Instance");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("app_engine_release", &self.app_engine_release);
        debug_struct.field("availability", &self.availability);
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("vm_zone_name", &self.vm_zone_name);
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("requests", &self.requests);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("qps", &self.qps);
        debug_struct.field("average_latency", &self.average_latency);
        debug_struct.field("memory_usage", &self.memory_usage);
        debug_struct.field("vm_status", &self.vm_status);
        debug_struct.field("vm_debug_enabled", &self.vm_debug_enabled);
        debug_struct.field("vm_ip", &self.vm_ip);
        debug_struct.field("vm_liveness", &self.vm_liveness);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Wrapper for LivenessState enum.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Liveness {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Liveness {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Liveness {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Instance.Liveness"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Liveness {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Liveness")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Liveness;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Liveness")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Liveness {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Liveness {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Liveness");

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Liveness].
    pub mod liveness {
        #[allow(unused_imports)]
        use super::*;

        /// Liveness health check status for Flex instances.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LivenessState {
            /// There is no liveness health check for the instance. Only applicable for
            /// instances in App Engine standard environment.
            Unspecified,
            /// The health checking system is aware of the instance but its health is
            /// not known at the moment.
            Unknown,
            /// The instance is reachable i.e. a connection to the application health
            /// checking endpoint can be established, and conforms to the requirements
            /// defined by the health check.
            Healthy,
            /// The instance is reachable, but does not conform to the requirements
            /// defined by the health check.
            Unhealthy,
            /// The instance is being drained. The existing connections to the instance
            /// have time to complete, but the new ones are being refused.
            Draining,
            /// The instance is unreachable i.e. a connection to the application health
            /// checking endpoint cannot be established, or the server does not respond
            /// within the specified timeout.
            Timeout,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LivenessState::value] or
            /// [LivenessState::name].
            UnknownValue(liveness_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod liveness_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LivenessState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Unknown => std::option::Option::Some(1),
                    Self::Healthy => std::option::Option::Some(2),
                    Self::Unhealthy => std::option::Option::Some(3),
                    Self::Draining => std::option::Option::Some(4),
                    Self::Timeout => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LIVENESS_STATE_UNSPECIFIED"),
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::Healthy => std::option::Option::Some("HEALTHY"),
                    Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
                    Self::Draining => std::option::Option::Some("DRAINING"),
                    Self::Timeout => std::option::Option::Some("TIMEOUT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LivenessState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LivenessState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LivenessState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Unknown,
                    2 => Self::Healthy,
                    3 => Self::Unhealthy,
                    4 => Self::Draining,
                    5 => Self::Timeout,
                    _ => Self::UnknownValue(liveness_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LivenessState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LIVENESS_STATE_UNSPECIFIED" => Self::Unspecified,
                    "UNKNOWN" => Self::Unknown,
                    "HEALTHY" => Self::Healthy,
                    "UNHEALTHY" => Self::Unhealthy,
                    "DRAINING" => Self::Draining,
                    "TIMEOUT" => Self::Timeout,
                    _ => Self::UnknownValue(liveness_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LivenessState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Unknown => serializer.serialize_i32(1),
                    Self::Healthy => serializer.serialize_i32(2),
                    Self::Unhealthy => serializer.serialize_i32(3),
                    Self::Draining => serializer.serialize_i32(4),
                    Self::Timeout => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LivenessState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LivenessState>::new(
                    ".google.appengine.v1.Instance.Liveness.LivenessState",
                ))
            }
        }
    }

    /// Availability of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Availability {
        Unspecified,
        Resident,
        Dynamic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Availability::value] or
        /// [Availability::name].
        UnknownValue(availability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod availability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Availability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Resident => std::option::Option::Some(1),
                Self::Dynamic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Resident => std::option::Option::Some("RESIDENT"),
                Self::Dynamic => std::option::Option::Some("DYNAMIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Availability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Availability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Availability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Resident,
                2 => Self::Dynamic,
                _ => Self::UnknownValue(availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Availability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "RESIDENT" => Self::Resident,
                "DYNAMIC" => Self::Dynamic,
                _ => Self::UnknownValue(availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Availability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Resident => serializer.serialize_i32(1),
                Self::Dynamic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Availability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Availability>::new(
                ".google.appengine.v1.Instance.Availability",
            ))
        }
    }
}

/// Metadata for the given [google.cloud.location.Location][google.cloud.location.Location].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// App Engine standard environment is available in the given location.
    ///
    /// @OutputOnly
    pub standard_environment_available: bool,

    /// App Engine flexible environment is available in the given location.
    ///
    /// @OutputOnly
    pub flexible_environment_available: bool,

    /// Output only. [Search API](https://cloud.google.com/appengine/docs/standard/python/search)
    /// is available in the given location.
    pub search_api_available: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [standard_environment_available][crate::model::LocationMetadata::standard_environment_available].
    pub fn set_standard_environment_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.standard_environment_available = v.into();
        self
    }

    /// Sets the value of [flexible_environment_available][crate::model::LocationMetadata::flexible_environment_available].
    pub fn set_flexible_environment_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.flexible_environment_available = v.into();
        self
    }

    /// Sets the value of [search_api_available][crate::model::LocationMetadata::search_api_available].
    pub fn set_search_api_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.search_api_available = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __standard_environment_available,
            __flexible_environment_available,
            __search_api_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "standardEnvironmentAvailable" => {
                                Ok(__FieldTag::__standard_environment_available)
                            }
                            "standard_environment_available" => {
                                Ok(__FieldTag::__standard_environment_available)
                            }
                            "flexibleEnvironmentAvailable" => {
                                Ok(__FieldTag::__flexible_environment_available)
                            }
                            "flexible_environment_available" => {
                                Ok(__FieldTag::__flexible_environment_available)
                            }
                            "searchApiAvailable" => Ok(__FieldTag::__search_api_available),
                            "search_api_available" => Ok(__FieldTag::__search_api_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__standard_environment_available => {
                            if !fields.insert(__FieldTag::__standard_environment_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_environment_available",
                                ));
                            }
                            result.standard_environment_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flexible_environment_available => {
                            if !fields.insert(__FieldTag::__flexible_environment_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flexible_environment_available",
                                ));
                            }
                            result.flexible_environment_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__search_api_available => {
                            if !fields.insert(__FieldTag::__search_api_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_api_available",
                                ));
                            }
                            result.search_api_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.standard_environment_available) {
            state.serialize_entry(
                "standardEnvironmentAvailable",
                &self.standard_environment_available,
            )?;
        }
        if !wkt::internal::is_default(&self.flexible_environment_available) {
            state.serialize_entry(
                "flexibleEnvironmentAvailable",
                &self.flexible_environment_available,
            )?;
        }
        if !wkt::internal::is_default(&self.search_api_available) {
            state.serialize_entry("searchApiAvailable", &self.search_api_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field(
            "standard_environment_available",
            &self.standard_environment_available,
        );
        debug_struct.field(
            "flexible_environment_available",
            &self.flexible_environment_available,
        );
        debug_struct.field("search_api_available", &self.search_api_available);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A NetworkSettings resource is a container for ingress settings for a version
/// or service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkSettings {
    /// The ingress settings for version or service.
    pub ingress_traffic_allowed: crate::model::network_settings::IngressTrafficAllowed,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_traffic_allowed][crate::model::NetworkSettings::ingress_traffic_allowed].
    pub fn set_ingress_traffic_allowed<
        T: std::convert::Into<crate::model::network_settings::IngressTrafficAllowed>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ingress_traffic_allowed = v.into();
        self
    }
}

impl wkt::message::Message for NetworkSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.NetworkSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ingress_traffic_allowed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ingressTrafficAllowed" => Ok(__FieldTag::__ingress_traffic_allowed),
                            "ingress_traffic_allowed" => Ok(__FieldTag::__ingress_traffic_allowed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ingress_traffic_allowed => {
                            if !fields.insert(__FieldTag::__ingress_traffic_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingress_traffic_allowed",
                                ));
                            }
                            result.ingress_traffic_allowed = map
                                .next_value::<std::option::Option<
                                    crate::model::network_settings::IngressTrafficAllowed,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ingress_traffic_allowed) {
            state.serialize_entry("ingressTrafficAllowed", &self.ingress_traffic_allowed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkSettings");
        debug_struct.field("ingress_traffic_allowed", &self.ingress_traffic_allowed);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NetworkSettings].
pub mod network_settings {
    #[allow(unused_imports)]
    use super::*;

    /// If unspecified, INGRESS_TRAFFIC_ALLOWED_ALL will be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IngressTrafficAllowed {
        /// Unspecified
        Unspecified,
        /// Allow HTTP traffic from public and private sources.
        All,
        /// Allow HTTP traffic from only private VPC sources.
        InternalOnly,
        /// Allow HTTP traffic from private VPC sources and through load balancers.
        InternalAndLb,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IngressTrafficAllowed::value] or
        /// [IngressTrafficAllowed::name].
        UnknownValue(ingress_traffic_allowed::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ingress_traffic_allowed {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IngressTrafficAllowed {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::InternalOnly => std::option::Option::Some(2),
                Self::InternalAndLb => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED")
                }
                Self::All => std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_ALL"),
                Self::InternalOnly => {
                    std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY")
                }
                Self::InternalAndLb => {
                    std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IngressTrafficAllowed {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IngressTrafficAllowed {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IngressTrafficAllowed {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::InternalOnly,
                3 => Self::InternalAndLb,
                _ => Self::UnknownValue(ingress_traffic_allowed::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IngressTrafficAllowed {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED" => Self::Unspecified,
                "INGRESS_TRAFFIC_ALLOWED_ALL" => Self::All,
                "INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY" => Self::InternalOnly,
                "INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB" => Self::InternalAndLb,
                _ => Self::UnknownValue(ingress_traffic_allowed::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IngressTrafficAllowed {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::InternalOnly => serializer.serialize_i32(2),
                Self::InternalAndLb => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IngressTrafficAllowed {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IngressTrafficAllowed>::new(
                ".google.appengine.v1.NetworkSettings.IngressTrafficAllowed",
            ))
        }
    }
}

/// Metadata for the given [google.longrunning.Operation][google.longrunning.Operation].
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadataV1 {
    /// API method that initiated this operation. Example:
    /// `google.appengine.v1.Versions.CreateVersion`.
    ///
    /// @OutputOnly
    pub method: std::string::String,

    /// Time that this operation was created.
    ///
    /// @OutputOnly
    pub insert_time: std::option::Option<wkt::Timestamp>,

    /// Time that this operation completed.
    ///
    /// @OutputOnly
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// User who requested this operation.
    ///
    /// @OutputOnly
    pub user: std::string::String,

    /// Name of the resource that this operation is acting on. Example:
    /// `apps/myapp/services/default`.
    ///
    /// @OutputOnly
    pub target: std::string::String,

    /// Ephemeral message that may change every time the operation is polled.
    /// @OutputOnly
    pub ephemeral_message: std::string::String,

    /// Durable messages that persist on every operation poll.
    /// @OutputOnly
    pub warning: std::vec::Vec<std::string::String>,

    /// Metadata specific to the type of operation in progress.
    /// @OutputOnly
    pub method_metadata: std::option::Option<crate::model::operation_metadata_v_1::MethodMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadataV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::OperationMetadataV1::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [insert_time][crate::model::OperationMetadataV1::insert_time].
    pub fn set_insert_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.insert_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insert_time][crate::model::OperationMetadataV1::insert_time].
    pub fn set_or_clear_insert_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.insert_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadataV1::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadataV1::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::OperationMetadataV1::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadataV1::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [ephemeral_message][crate::model::OperationMetadataV1::ephemeral_message].
    pub fn set_ephemeral_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ephemeral_message = v.into();
        self
    }

    /// Sets the value of [warning][crate::model::OperationMetadataV1::warning].
    pub fn set_warning<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warning = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [method_metadata][crate::model::OperationMetadataV1::method_metadata].
    ///
    /// Note that all the setters affecting `method_metadata` are mutually
    /// exclusive.
    pub fn set_method_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::operation_metadata_v_1::MethodMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method_metadata = v.into();
        self
    }

    /// The value of [method_metadata][crate::model::OperationMetadataV1::method_metadata]
    /// if it holds a `CreateVersionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_version_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateVersionMetadataV1>> {
        #[allow(unreachable_patterns)]
        self.method_metadata.as_ref().and_then(|v| match v {
            crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method_metadata][crate::model::OperationMetadataV1::method_metadata]
    /// to hold a `CreateVersionMetadata`.
    ///
    /// Note that all the setters affecting `method_metadata` are
    /// mutually exclusive.
    pub fn set_create_version_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateVersionMetadataV1>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method_metadata = std::option::Option::Some(
            crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadataV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.OperationMetadataV1"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadataV1 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __method,
            __insert_time,
            __end_time,
            __user,
            __target,
            __ephemeral_message,
            __warning,
            __create_version_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadataV1")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "method" => Ok(__FieldTag::__method),
                            "insertTime" => Ok(__FieldTag::__insert_time),
                            "insert_time" => Ok(__FieldTag::__insert_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "user" => Ok(__FieldTag::__user),
                            "target" => Ok(__FieldTag::__target),
                            "ephemeralMessage" => Ok(__FieldTag::__ephemeral_message),
                            "ephemeral_message" => Ok(__FieldTag::__ephemeral_message),
                            "warning" => Ok(__FieldTag::__warning),
                            "createVersionMetadata" => Ok(__FieldTag::__create_version_metadata),
                            "create_version_metadata" => Ok(__FieldTag::__create_version_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadataV1;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadataV1")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method",
                                ));
                            }
                            result.method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insert_time => {
                            if !fields.insert(__FieldTag::__insert_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insert_time",
                                ));
                            }
                            result.insert_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ephemeral_message => {
                            if !fields.insert(__FieldTag::__ephemeral_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ephemeral_message",
                                ));
                            }
                            result.ephemeral_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warning => {
                            if !fields.insert(__FieldTag::__warning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warning",
                                ));
                            }
                            result.warning = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_version_metadata => {
                            if !fields.insert(__FieldTag::__create_version_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_version_metadata",
                                ));
                            }
                            if result.method_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `method_metadata`, a oneof with full ID .google.appengine.v1.OperationMetadataV1.create_version_metadata, latest field was createVersionMetadata",
                                ));
                            }
                            result.method_metadata = std::option::Option::Some(
                                crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CreateVersionMetadataV1>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadataV1 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.method.is_empty() {
            state.serialize_entry("method", &self.method)?;
        }
        if self.insert_time.is_some() {
            state.serialize_entry("insertTime", &self.insert_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.ephemeral_message.is_empty() {
            state.serialize_entry("ephemeralMessage", &self.ephemeral_message)?;
        }
        if !self.warning.is_empty() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if let Some(value) = self.create_version_metadata() {
            state.serialize_entry("createVersionMetadata", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadataV1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadataV1");
        debug_struct.field("method", &self.method);
        debug_struct.field("insert_time", &self.insert_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("user", &self.user);
        debug_struct.field("target", &self.target);
        debug_struct.field("ephemeral_message", &self.ephemeral_message);
        debug_struct.field("warning", &self.warning);
        debug_struct.field("method_metadata", &self.method_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationMetadataV1].
pub mod operation_metadata_v_1 {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata specific to the type of operation in progress.
    /// @OutputOnly
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MethodMetadata {
        CreateVersionMetadata(std::boxed::Box<crate::model::CreateVersionMetadataV1>),
    }
}

/// Metadata for the given [google.longrunning.Operation][google.longrunning.Operation] during a
/// [google.appengine.v1.CreateVersionRequest][google.appengine.v1.CreateVersionRequest].
///
/// [google.appengine.v1.CreateVersionRequest]: crate::model::CreateVersionRequest
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionMetadataV1 {
    /// The Cloud Build ID if one was created as part of the version create.
    /// @OutputOnly
    pub cloud_build_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionMetadataV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_build_id][crate::model::CreateVersionMetadataV1::cloud_build_id].
    pub fn set_cloud_build_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_build_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionMetadataV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionMetadataV1"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionMetadataV1 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_build_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionMetadataV1")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudBuildId" => Ok(__FieldTag::__cloud_build_id),
                            "cloud_build_id" => Ok(__FieldTag::__cloud_build_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionMetadataV1;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionMetadataV1")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_build_id => {
                            if !fields.insert(__FieldTag::__cloud_build_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_build_id",
                                ));
                            }
                            result.cloud_build_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionMetadataV1 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_build_id.is_empty() {
            state.serialize_entry("cloudBuildId", &self.cloud_build_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVersionMetadataV1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionMetadataV1");
        debug_struct.field("cloud_build_id", &self.cloud_build_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Service resource is a logical component of an application that can share
/// state and communicate in a secure fashion with other services.
/// For example, an application that handles customer requests might
/// include separate services to handle tasks such as backend data
/// analysis or API requests from mobile devices. Each service has a
/// collection of versions that define a specific set of code used to
/// implement the functionality of that service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Service {
    /// Full path to the Service resource in the API.
    /// Example: `apps/myapp/services/default`.
    ///
    /// @OutputOnly
    pub name: std::string::String,

    /// Relative name of the service within the application.
    /// Example: `default`.
    ///
    /// @OutputOnly
    pub id: std::string::String,

    /// Mapping that defines fractional HTTP traffic diversion to
    /// different versions within the service.
    pub split: std::option::Option<crate::model::TrafficSplit>,

    /// A set of labels to apply to this service. Labels are key/value pairs that
    /// describe the service and all resources that belong to it (e.g.,
    /// versions). The labels can be used to search and group resources, and are
    /// propagated to the usage and billing reports, enabling fine-grain analysis
    /// of costs. An example of using labels is to tag resources belonging to
    /// different environments (e.g., "env=prod", "env=qa").
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Ingress settings for this service. Will apply to all versions.
    pub network_settings: std::option::Option<crate::model::NetworkSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Service::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [split][crate::model::Service::split].
    pub fn set_split<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TrafficSplit>,
    {
        self.split = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [split][crate::model::Service::split].
    pub fn set_or_clear_split<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TrafficSplit>,
    {
        self.split = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Service::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network_settings][crate::model::Service::network_settings].
    pub fn set_network_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkSettings>,
    {
        self.network_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_settings][crate::model::Service::network_settings].
    pub fn set_or_clear_network_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkSettings>,
    {
        self.network_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Service"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Service {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __split,
            __labels,
            __network_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Service")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "split" => Ok(__FieldTag::__split),
                            "labels" => Ok(__FieldTag::__labels),
                            "networkSettings" => Ok(__FieldTag::__network_settings),
                            "network_settings" => Ok(__FieldTag::__network_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Service;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Service")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__split => {
                            if !fields.insert(__FieldTag::__split) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for split",
                                ));
                            }
                            result.split = map
                                .next_value::<std::option::Option<crate::model::TrafficSplit>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_settings => {
                            if !fields.insert(__FieldTag::__network_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_settings",
                                ));
                            }
                            result.network_settings = map
                                .next_value::<std::option::Option<crate::model::NetworkSettings>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Service {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.split.is_some() {
            state.serialize_entry("split", &self.split)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.network_settings.is_some() {
            state.serialize_entry("networkSettings", &self.network_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Service {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Service");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("split", &self.split);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("network_settings", &self.network_settings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Traffic routing configuration for versions within a single service. Traffic
/// splits define how traffic directed to the service is assigned to versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TrafficSplit {
    /// Mechanism used to determine which version a request is sent to.
    /// The traffic selection algorithm will
    /// be stable for either type until allocations are changed.
    pub shard_by: crate::model::traffic_split::ShardBy,

    /// Mapping from version IDs within the service to fractional
    /// (0.000, 1] allocations of traffic for that version. Each version can
    /// be specified only once, but some versions in the service may not
    /// have any traffic allocation. Services that have traffic allocated
    /// cannot be deleted until either the service is deleted or
    /// their traffic allocation is removed. Allocations must sum to 1.
    /// Up to two decimal place precision is supported for IP-based splits and
    /// up to three decimal places is supported for cookie-based splits.
    pub allocations: std::collections::HashMap<std::string::String, f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shard_by][crate::model::TrafficSplit::shard_by].
    pub fn set_shard_by<T: std::convert::Into<crate::model::traffic_split::ShardBy>>(
        mut self,
        v: T,
    ) -> Self {
        self.shard_by = v.into();
        self
    }

    /// Sets the value of [allocations][crate::model::TrafficSplit::allocations].
    pub fn set_allocations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.allocations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TrafficSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.TrafficSplit"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrafficSplit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shard_by,
            __allocations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrafficSplit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shardBy" => Ok(__FieldTag::__shard_by),
                            "shard_by" => Ok(__FieldTag::__shard_by),
                            "allocations" => Ok(__FieldTag::__allocations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrafficSplit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrafficSplit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shard_by => {
                            if !fields.insert(__FieldTag::__shard_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shard_by",
                                ));
                            }
                            result.shard_by = map.next_value::<std::option::Option<crate::model::traffic_split::ShardBy>>()?.unwrap_or_default();
                        }
                        __FieldTag::__allocations => {
                            if !fields.insert(__FieldTag::__allocations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocations",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allocations = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrafficSplit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.shard_by) {
            state.serialize_entry("shardBy", &self.shard_by)?;
        }
        if !self.allocations.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("allocations", &__With(&self.allocations))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TrafficSplit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrafficSplit");
        debug_struct.field("shard_by", &self.shard_by);
        debug_struct.field("allocations", &self.allocations);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TrafficSplit].
pub mod traffic_split {
    #[allow(unused_imports)]
    use super::*;

    /// Available sharding mechanisms.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ShardBy {
        /// Diversion method unspecified.
        Unspecified,
        /// Diversion based on a specially named cookie, "GOOGAPPUID." The cookie
        /// must be set by the application itself or no diversion will occur.
        Cookie,
        /// Diversion based on applying the modulus operation to a fingerprint
        /// of the IP address.
        Ip,
        /// Diversion based on weighted random assignment. An incoming request is
        /// randomly routed to a version in the traffic split, with probability
        /// proportional to the version's traffic share.
        Random,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ShardBy::value] or
        /// [ShardBy::name].
        UnknownValue(shard_by::UnknownValue),
    }

    #[doc(hidden)]
    pub mod shard_by {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ShardBy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cookie => std::option::Option::Some(1),
                Self::Ip => std::option::Option::Some(2),
                Self::Random => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Cookie => std::option::Option::Some("COOKIE"),
                Self::Ip => std::option::Option::Some("IP"),
                Self::Random => std::option::Option::Some("RANDOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ShardBy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ShardBy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ShardBy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cookie,
                2 => Self::Ip,
                3 => Self::Random,
                _ => Self::UnknownValue(shard_by::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ShardBy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "COOKIE" => Self::Cookie,
                "IP" => Self::Ip,
                "RANDOM" => Self::Random,
                _ => Self::UnknownValue(shard_by::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ShardBy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cookie => serializer.serialize_i32(1),
                Self::Ip => serializer.serialize_i32(2),
                Self::Random => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ShardBy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ShardBy>::new(
                ".google.appengine.v1.TrafficSplit.ShardBy",
            ))
        }
    }
}

/// A Version resource is a specific set of source code and configuration files
/// that are deployed into a service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// Full path to the Version resource in the API.  Example:
    /// `apps/myapp/services/default/versions/v1`.
    ///
    /// @OutputOnly
    pub name: std::string::String,

    /// Relative name of the version within the service.  Example: `v1`.
    /// Version names can contain only lowercase letters, numbers, or hyphens.
    /// Reserved names: "default", "latest", and any name with the prefix "ah-".
    pub id: std::string::String,

    /// Before an application can receive email or XMPP messages, the application
    /// must be configured to enable the service.
    pub inbound_services: std::vec::Vec<crate::model::InboundServiceType>,

    /// Instance class that is used to run this version. Valid values are:
    ///
    /// * AutomaticScaling: `F1`, `F2`, `F4`, `F4_1G`
    /// * ManualScaling or BasicScaling: `B1`, `B2`, `B4`, `B8`, `B4_1G`
    ///
    /// Defaults to `F1` for AutomaticScaling and `B1` for ManualScaling or
    /// BasicScaling.
    pub instance_class: std::string::String,

    /// Extra network settings.
    /// Only applicable in the App Engine flexible environment.
    pub network: std::option::Option<crate::model::Network>,

    /// The Google Compute Engine zones that are supported by this version in the
    /// App Engine flexible environment. Deprecated.
    pub zones: std::vec::Vec<std::string::String>,

    /// Machine resources for this version.
    /// Only applicable in the App Engine flexible environment.
    pub resources: std::option::Option<crate::model::Resources>,

    /// Desired runtime. Example: `python27`.
    pub runtime: std::string::String,

    /// The channel of the runtime to use. Only available for some
    /// runtimes. Defaults to the `default` channel.
    pub runtime_channel: std::string::String,

    /// Whether multiple requests can be dispatched to this version at once.
    pub threadsafe: bool,

    /// Whether to deploy this version in a container on a virtual machine.
    pub vm: bool,

    /// Allows App Engine second generation runtimes to access the legacy bundled
    /// services.
    pub app_engine_apis: bool,

    /// Metadata settings that are supplied to this version to enable
    /// beta runtime features.
    pub beta_settings: std::collections::HashMap<std::string::String, std::string::String>,

    /// App Engine execution environment for this version.
    ///
    /// Defaults to `standard`.
    pub env: std::string::String,

    /// Current serving status of this version. Only the versions with a
    /// `SERVING` status create instances and can be billed.
    ///
    /// `SERVING_STATUS_UNSPECIFIED` is an invalid value. Defaults to `SERVING`.
    pub serving_status: crate::model::ServingStatus,

    /// Email address of the user who created this version.
    ///
    /// @OutputOnly
    pub created_by: std::string::String,

    /// Time that this version was created.
    ///
    /// @OutputOnly
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Total size in bytes of all the files that are included in this version
    /// and currently hosted on the App Engine disk.
    ///
    /// @OutputOnly
    pub disk_usage_bytes: i64,

    /// The version of the API in the given runtime environment. Please see the
    /// app.yaml reference for valid values at
    /// <https://cloud.google.com/appengine/docs/standard/>\<language\>/config/appref
    pub runtime_api_version: std::string::String,

    /// The path or name of the app's main executable.
    pub runtime_main_executable_path: std::string::String,

    /// The identity that the deployed version will run as.
    /// Admin API will use the App Engine Appspot service account as default if
    /// this field is neither provided in app.yaml file nor through CLI flag.
    pub service_account: std::string::String,

    /// An ordered list of URL-matching patterns that should be applied to incoming
    /// requests. The first matching URL handles the request and other request
    /// handlers are not attempted.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub handlers: std::vec::Vec<crate::model::UrlMap>,

    /// Custom static error pages. Limited to 10KB per page.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub error_handlers: std::vec::Vec<crate::model::ErrorHandler>,

    /// Configuration for third-party Python runtime libraries that are required
    /// by the application.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub libraries: std::vec::Vec<crate::model::Library>,

    /// Serving configuration for
    /// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/).
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub api_config: std::option::Option<crate::model::ApiConfigHandler>,

    /// Environment variables available to the application.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Environment variables available to the build environment.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub build_env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Duration that static files should be cached by web proxies and browsers.
    /// Only applicable if the corresponding
    /// [StaticFilesHandler](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#StaticFilesHandler)
    /// does not specify its own expiration time.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub default_expiration: std::option::Option<wkt::Duration>,

    /// Configures health checking for instances. Unhealthy instances are
    /// stopped and replaced with new instances.
    /// Only applicable in the App Engine flexible environment.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub health_check: std::option::Option<crate::model::HealthCheck>,

    /// Configures readiness health checking for instances.
    /// Unhealthy instances are not put into the backend traffic rotation.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub readiness_check: std::option::Option<crate::model::ReadinessCheck>,

    /// Configures liveness health checking for instances.
    /// Unhealthy instances are stopped and replaced with new instances
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub liveness_check: std::option::Option<crate::model::LivenessCheck>,

    /// Files that match this pattern will not be built into this version.
    /// Only applicable for Go runtimes.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub nobuild_files_regex: std::string::String,

    /// Code and application artifacts that make up this version.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Serving URL for this version. Example:
    /// `https://myversion-dot-myservice-dot-myapp.appspot.com`
    ///
    /// @OutputOnly
    pub version_url: std::string::String,

    /// Cloud Endpoints configuration.
    ///
    /// If endpoints_api_service is set, the Cloud Endpoints Extensible Service
    /// Proxy will be provided to serve the API implemented by the app.
    pub endpoints_api_service: std::option::Option<crate::model::EndpointsApiService>,

    /// The entrypoint for the application.
    pub entrypoint: std::option::Option<crate::model::Entrypoint>,

    /// Enables VPC connectivity for standard apps.
    pub vpc_access_connector: std::option::Option<crate::model::VpcAccessConnector>,

    /// Controls how instances are created, scaled, and reaped.
    ///
    /// Defaults to `AutomaticScaling`.
    pub scaling: std::option::Option<crate::model::version::Scaling>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Version::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [inbound_services][crate::model::Version::inbound_services].
    pub fn set_inbound_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InboundServiceType>,
    {
        use std::iter::Iterator;
        self.inbound_services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_class][crate::model::Version::instance_class].
    pub fn set_instance_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_class = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Version::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::Version::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zones][crate::model::Version::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resources][crate::model::Version::resources].
    pub fn set_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Resources>,
    {
        self.resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resources][crate::model::Version::resources].
    pub fn set_or_clear_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Resources>,
    {
        self.resources = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime][crate::model::Version::runtime].
    pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime = v.into();
        self
    }

    /// Sets the value of [runtime_channel][crate::model::Version::runtime_channel].
    pub fn set_runtime_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_channel = v.into();
        self
    }

    /// Sets the value of [threadsafe][crate::model::Version::threadsafe].
    pub fn set_threadsafe<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.threadsafe = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::Version::vm].
    pub fn set_vm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [app_engine_apis][crate::model::Version::app_engine_apis].
    pub fn set_app_engine_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.app_engine_apis = v.into();
        self
    }

    /// Sets the value of [beta_settings][crate::model::Version::beta_settings].
    pub fn set_beta_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.beta_settings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [env][crate::model::Version::env].
    pub fn set_env<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.env = v.into();
        self
    }

    /// Sets the value of [serving_status][crate::model::Version::serving_status].
    pub fn set_serving_status<T: std::convert::Into<crate::model::ServingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_status = v.into();
        self
    }

    /// Sets the value of [created_by][crate::model::Version::created_by].
    pub fn set_created_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.created_by = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Version::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_usage_bytes][crate::model::Version::disk_usage_bytes].
    pub fn set_disk_usage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_usage_bytes = v.into();
        self
    }

    /// Sets the value of [runtime_api_version][crate::model::Version::runtime_api_version].
    pub fn set_runtime_api_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_api_version = v.into();
        self
    }

    /// Sets the value of [runtime_main_executable_path][crate::model::Version::runtime_main_executable_path].
    pub fn set_runtime_main_executable_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_main_executable_path = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Version::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [handlers][crate::model::Version::handlers].
    pub fn set_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UrlMap>,
    {
        use std::iter::Iterator;
        self.handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_handlers][crate::model::Version::error_handlers].
    pub fn set_error_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorHandler>,
    {
        use std::iter::Iterator;
        self.error_handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [libraries][crate::model::Version::libraries].
    pub fn set_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Library>,
    {
        use std::iter::Iterator;
        self.libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [api_config][crate::model::Version::api_config].
    pub fn set_api_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiConfigHandler>,
    {
        self.api_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_config][crate::model::Version::api_config].
    pub fn set_or_clear_api_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiConfigHandler>,
    {
        self.api_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [env_variables][crate::model::Version::env_variables].
    pub fn set_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [build_env_variables][crate::model::Version::build_env_variables].
    pub fn set_build_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [default_expiration][crate::model::Version::default_expiration].
    pub fn set_default_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_expiration][crate::model::Version::default_expiration].
    pub fn set_or_clear_default_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [health_check][crate::model::Version::health_check].
    pub fn set_health_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HealthCheck>,
    {
        self.health_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [health_check][crate::model::Version::health_check].
    pub fn set_or_clear_health_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HealthCheck>,
    {
        self.health_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [readiness_check][crate::model::Version::readiness_check].
    pub fn set_readiness_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReadinessCheck>,
    {
        self.readiness_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [readiness_check][crate::model::Version::readiness_check].
    pub fn set_or_clear_readiness_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReadinessCheck>,
    {
        self.readiness_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [liveness_check][crate::model::Version::liveness_check].
    pub fn set_liveness_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LivenessCheck>,
    {
        self.liveness_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [liveness_check][crate::model::Version::liveness_check].
    pub fn set_or_clear_liveness_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LivenessCheck>,
    {
        self.liveness_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nobuild_files_regex][crate::model::Version::nobuild_files_regex].
    pub fn set_nobuild_files_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nobuild_files_regex = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::Version::deployment].
    pub fn set_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deployment][crate::model::Version::deployment].
    pub fn set_or_clear_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version_url][crate::model::Version::version_url].
    pub fn set_version_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_url = v.into();
        self
    }

    /// Sets the value of [endpoints_api_service][crate::model::Version::endpoints_api_service].
    pub fn set_endpoints_api_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EndpointsApiService>,
    {
        self.endpoints_api_service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoints_api_service][crate::model::Version::endpoints_api_service].
    pub fn set_or_clear_endpoints_api_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EndpointsApiService>,
    {
        self.endpoints_api_service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entrypoint][crate::model::Version::entrypoint].
    pub fn set_entrypoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entrypoint>,
    {
        self.entrypoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entrypoint][crate::model::Version::entrypoint].
    pub fn set_or_clear_entrypoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entrypoint>,
    {
        self.entrypoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_access_connector][crate::model::Version::vpc_access_connector].
    pub fn set_vpc_access_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccessConnector>,
    {
        self.vpc_access_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_access_connector][crate::model::Version::vpc_access_connector].
    pub fn set_or_clear_vpc_access_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccessConnector>,
    {
        self.vpc_access_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scaling][crate::model::Version::scaling].
    ///
    /// Note that all the setters affecting `scaling` are mutually
    /// exclusive.
    pub fn set_scaling<
        T: std::convert::Into<std::option::Option<crate::model::version::Scaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling = v.into();
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `AutomaticScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automatic_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::AutomaticScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `AutomaticScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_automatic_scaling<
        T: std::convert::Into<std::boxed::Box<crate::model::AutomaticScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::AutomaticScaling(v.into()));
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `BasicScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::BasicScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `BasicScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_basic_scaling<T: std::convert::Into<std::boxed::Box<crate::model::BasicScaling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::BasicScaling(v.into()));
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `ManualScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn manual_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManualScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::ManualScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `ManualScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_manual_scaling<
        T: std::convert::Into<std::boxed::Box<crate::model::ManualScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::ManualScaling(v.into()));
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Version"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __automatic_scaling,
            __basic_scaling,
            __manual_scaling,
            __inbound_services,
            __instance_class,
            __network,
            __zones,
            __resources,
            __runtime,
            __runtime_channel,
            __threadsafe,
            __vm,
            __app_engine_apis,
            __beta_settings,
            __env,
            __serving_status,
            __created_by,
            __create_time,
            __disk_usage_bytes,
            __runtime_api_version,
            __runtime_main_executable_path,
            __service_account,
            __handlers,
            __error_handlers,
            __libraries,
            __api_config,
            __env_variables,
            __build_env_variables,
            __default_expiration,
            __health_check,
            __readiness_check,
            __liveness_check,
            __nobuild_files_regex,
            __deployment,
            __version_url,
            __endpoints_api_service,
            __entrypoint,
            __vpc_access_connector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "automaticScaling" => Ok(__FieldTag::__automatic_scaling),
                            "automatic_scaling" => Ok(__FieldTag::__automatic_scaling),
                            "basicScaling" => Ok(__FieldTag::__basic_scaling),
                            "basic_scaling" => Ok(__FieldTag::__basic_scaling),
                            "manualScaling" => Ok(__FieldTag::__manual_scaling),
                            "manual_scaling" => Ok(__FieldTag::__manual_scaling),
                            "inboundServices" => Ok(__FieldTag::__inbound_services),
                            "inbound_services" => Ok(__FieldTag::__inbound_services),
                            "instanceClass" => Ok(__FieldTag::__instance_class),
                            "instance_class" => Ok(__FieldTag::__instance_class),
                            "network" => Ok(__FieldTag::__network),
                            "zones" => Ok(__FieldTag::__zones),
                            "resources" => Ok(__FieldTag::__resources),
                            "runtime" => Ok(__FieldTag::__runtime),
                            "runtimeChannel" => Ok(__FieldTag::__runtime_channel),
                            "runtime_channel" => Ok(__FieldTag::__runtime_channel),
                            "threadsafe" => Ok(__FieldTag::__threadsafe),
                            "vm" => Ok(__FieldTag::__vm),
                            "appEngineApis" => Ok(__FieldTag::__app_engine_apis),
                            "app_engine_apis" => Ok(__FieldTag::__app_engine_apis),
                            "betaSettings" => Ok(__FieldTag::__beta_settings),
                            "beta_settings" => Ok(__FieldTag::__beta_settings),
                            "env" => Ok(__FieldTag::__env),
                            "servingStatus" => Ok(__FieldTag::__serving_status),
                            "serving_status" => Ok(__FieldTag::__serving_status),
                            "createdBy" => Ok(__FieldTag::__created_by),
                            "created_by" => Ok(__FieldTag::__created_by),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "diskUsageBytes" => Ok(__FieldTag::__disk_usage_bytes),
                            "disk_usage_bytes" => Ok(__FieldTag::__disk_usage_bytes),
                            "runtimeApiVersion" => Ok(__FieldTag::__runtime_api_version),
                            "runtime_api_version" => Ok(__FieldTag::__runtime_api_version),
                            "runtimeMainExecutablePath" => {
                                Ok(__FieldTag::__runtime_main_executable_path)
                            }
                            "runtime_main_executable_path" => {
                                Ok(__FieldTag::__runtime_main_executable_path)
                            }
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "handlers" => Ok(__FieldTag::__handlers),
                            "errorHandlers" => Ok(__FieldTag::__error_handlers),
                            "error_handlers" => Ok(__FieldTag::__error_handlers),
                            "libraries" => Ok(__FieldTag::__libraries),
                            "apiConfig" => Ok(__FieldTag::__api_config),
                            "api_config" => Ok(__FieldTag::__api_config),
                            "envVariables" => Ok(__FieldTag::__env_variables),
                            "env_variables" => Ok(__FieldTag::__env_variables),
                            "buildEnvVariables" => Ok(__FieldTag::__build_env_variables),
                            "build_env_variables" => Ok(__FieldTag::__build_env_variables),
                            "defaultExpiration" => Ok(__FieldTag::__default_expiration),
                            "default_expiration" => Ok(__FieldTag::__default_expiration),
                            "healthCheck" => Ok(__FieldTag::__health_check),
                            "health_check" => Ok(__FieldTag::__health_check),
                            "readinessCheck" => Ok(__FieldTag::__readiness_check),
                            "readiness_check" => Ok(__FieldTag::__readiness_check),
                            "livenessCheck" => Ok(__FieldTag::__liveness_check),
                            "liveness_check" => Ok(__FieldTag::__liveness_check),
                            "nobuildFilesRegex" => Ok(__FieldTag::__nobuild_files_regex),
                            "nobuild_files_regex" => Ok(__FieldTag::__nobuild_files_regex),
                            "deployment" => Ok(__FieldTag::__deployment),
                            "versionUrl" => Ok(__FieldTag::__version_url),
                            "version_url" => Ok(__FieldTag::__version_url),
                            "endpointsApiService" => Ok(__FieldTag::__endpoints_api_service),
                            "endpoints_api_service" => Ok(__FieldTag::__endpoints_api_service),
                            "entrypoint" => Ok(__FieldTag::__entrypoint),
                            "vpcAccessConnector" => Ok(__FieldTag::__vpc_access_connector),
                            "vpc_access_connector" => Ok(__FieldTag::__vpc_access_connector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automatic_scaling => {
                            if !fields.insert(__FieldTag::__automatic_scaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automatic_scaling",
                                ));
                            }
                            if result.scaling.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `scaling`, a oneof with full ID .google.appengine.v1.Version.automatic_scaling, latest field was automaticScaling",
                                ));
                            }
                            result.scaling = std::option::Option::Some(
                                crate::model::version::Scaling::AutomaticScaling(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AutomaticScaling>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__basic_scaling => {
                            if !fields.insert(__FieldTag::__basic_scaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for basic_scaling",
                                ));
                            }
                            if result.scaling.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `scaling`, a oneof with full ID .google.appengine.v1.Version.basic_scaling, latest field was basicScaling",
                                ));
                            }
                            result.scaling = std::option::Option::Some(
                                crate::model::version::Scaling::BasicScaling(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BasicScaling>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__manual_scaling => {
                            if !fields.insert(__FieldTag::__manual_scaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_scaling",
                                ));
                            }
                            if result.scaling.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `scaling`, a oneof with full ID .google.appengine.v1.Version.manual_scaling, latest field was manualScaling",
                                ));
                            }
                            result.scaling = std::option::Option::Some(
                                crate::model::version::Scaling::ManualScaling(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ManualScaling>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__inbound_services => {
                            if !fields.insert(__FieldTag::__inbound_services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inbound_services",
                                ));
                            }
                            result.inbound_services = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InboundServiceType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_class => {
                            if !fields.insert(__FieldTag::__instance_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_class",
                                ));
                            }
                            result.instance_class = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network =
                                map.next_value::<std::option::Option<crate::model::Network>>()?;
                        }
                        __FieldTag::__zones => {
                            if !fields.insert(__FieldTag::__zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zones",
                                ));
                            }
                            result.zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources =
                                map.next_value::<std::option::Option<crate::model::Resources>>()?;
                        }
                        __FieldTag::__runtime => {
                            if !fields.insert(__FieldTag::__runtime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime",
                                ));
                            }
                            result.runtime = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_channel => {
                            if !fields.insert(__FieldTag::__runtime_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_channel",
                                ));
                            }
                            result.runtime_channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__threadsafe => {
                            if !fields.insert(__FieldTag::__threadsafe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threadsafe",
                                ));
                            }
                            result.threadsafe = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm => {
                            if !fields.insert(__FieldTag::__vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm",
                                ));
                            }
                            result.vm = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_apis => {
                            if !fields.insert(__FieldTag::__app_engine_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_apis",
                                ));
                            }
                            result.app_engine_apis = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__beta_settings => {
                            if !fields.insert(__FieldTag::__beta_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for beta_settings",
                                ));
                            }
                            result.beta_settings = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serving_status => {
                            if !fields.insert(__FieldTag::__serving_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_status",
                                ));
                            }
                            result.serving_status = map
                                .next_value::<std::option::Option<crate::model::ServingStatus>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__created_by => {
                            if !fields.insert(__FieldTag::__created_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_by",
                                ));
                            }
                            result.created_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__disk_usage_bytes => {
                            if !fields.insert(__FieldTag::__disk_usage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_usage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_usage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__runtime_api_version => {
                            if !fields.insert(__FieldTag::__runtime_api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_api_version",
                                ));
                            }
                            result.runtime_api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_main_executable_path => {
                            if !fields.insert(__FieldTag::__runtime_main_executable_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_main_executable_path",
                                ));
                            }
                            result.runtime_main_executable_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__handlers => {
                            if !fields.insert(__FieldTag::__handlers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for handlers",
                                ));
                            }
                            result.handlers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::UrlMap>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_handlers => {
                            if !fields.insert(__FieldTag::__error_handlers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_handlers",
                                ));
                            }
                            result.error_handlers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorHandler>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__libraries => {
                            if !fields.insert(__FieldTag::__libraries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for libraries",
                                ));
                            }
                            result.libraries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Library>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__api_config => {
                            if !fields.insert(__FieldTag::__api_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_config",
                                ));
                            }
                            result.api_config = map
                                .next_value::<std::option::Option<crate::model::ApiConfigHandler>>(
                                )?;
                        }
                        __FieldTag::__env_variables => {
                            if !fields.insert(__FieldTag::__env_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env_variables",
                                ));
                            }
                            result.env_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_env_variables => {
                            if !fields.insert(__FieldTag::__build_env_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_env_variables",
                                ));
                            }
                            result.build_env_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_expiration => {
                            if !fields.insert(__FieldTag::__default_expiration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_expiration",
                                ));
                            }
                            result.default_expiration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__health_check => {
                            if !fields.insert(__FieldTag::__health_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check",
                                ));
                            }
                            result.health_check =
                                map.next_value::<std::option::Option<crate::model::HealthCheck>>()?;
                        }
                        __FieldTag::__readiness_check => {
                            if !fields.insert(__FieldTag::__readiness_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for readiness_check",
                                ));
                            }
                            result.readiness_check = map
                                .next_value::<std::option::Option<crate::model::ReadinessCheck>>(
                                )?;
                        }
                        __FieldTag::__liveness_check => {
                            if !fields.insert(__FieldTag::__liveness_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for liveness_check",
                                ));
                            }
                            result.liveness_check = map
                                .next_value::<std::option::Option<crate::model::LivenessCheck>>()?;
                        }
                        __FieldTag::__nobuild_files_regex => {
                            if !fields.insert(__FieldTag::__nobuild_files_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nobuild_files_regex",
                                ));
                            }
                            result.nobuild_files_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            result.deployment =
                                map.next_value::<std::option::Option<crate::model::Deployment>>()?;
                        }
                        __FieldTag::__version_url => {
                            if !fields.insert(__FieldTag::__version_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_url",
                                ));
                            }
                            result.version_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoints_api_service => {
                            if !fields.insert(__FieldTag::__endpoints_api_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints_api_service",
                                ));
                            }
                            result.endpoints_api_service = map.next_value::<std::option::Option<crate::model::EndpointsApiService>>()?
                                ;
                        }
                        __FieldTag::__entrypoint => {
                            if !fields.insert(__FieldTag::__entrypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entrypoint",
                                ));
                            }
                            result.entrypoint =
                                map.next_value::<std::option::Option<crate::model::Entrypoint>>()?;
                        }
                        __FieldTag::__vpc_access_connector => {
                            if !fields.insert(__FieldTag::__vpc_access_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_access_connector",
                                ));
                            }
                            result.vpc_access_connector = map.next_value::<std::option::Option<crate::model::VpcAccessConnector>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if let Some(value) = self.automatic_scaling() {
            state.serialize_entry("automaticScaling", value)?;
        }
        if let Some(value) = self.basic_scaling() {
            state.serialize_entry("basicScaling", value)?;
        }
        if let Some(value) = self.manual_scaling() {
            state.serialize_entry("manualScaling", value)?;
        }
        if !self.inbound_services.is_empty() {
            state.serialize_entry("inboundServices", &self.inbound_services)?;
        }
        if !self.instance_class.is_empty() {
            state.serialize_entry("instanceClass", &self.instance_class)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if self.resources.is_some() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self.runtime.is_empty() {
            state.serialize_entry("runtime", &self.runtime)?;
        }
        if !self.runtime_channel.is_empty() {
            state.serialize_entry("runtimeChannel", &self.runtime_channel)?;
        }
        if !wkt::internal::is_default(&self.threadsafe) {
            state.serialize_entry("threadsafe", &self.threadsafe)?;
        }
        if !wkt::internal::is_default(&self.vm) {
            state.serialize_entry("vm", &self.vm)?;
        }
        if !wkt::internal::is_default(&self.app_engine_apis) {
            state.serialize_entry("appEngineApis", &self.app_engine_apis)?;
        }
        if !self.beta_settings.is_empty() {
            state.serialize_entry("betaSettings", &self.beta_settings)?;
        }
        if !self.env.is_empty() {
            state.serialize_entry("env", &self.env)?;
        }
        if !wkt::internal::is_default(&self.serving_status) {
            state.serialize_entry("servingStatus", &self.serving_status)?;
        }
        if !self.created_by.is_empty() {
            state.serialize_entry("createdBy", &self.created_by)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.disk_usage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskUsageBytes", &__With(&self.disk_usage_bytes))?;
        }
        if !self.runtime_api_version.is_empty() {
            state.serialize_entry("runtimeApiVersion", &self.runtime_api_version)?;
        }
        if !self.runtime_main_executable_path.is_empty() {
            state.serialize_entry(
                "runtimeMainExecutablePath",
                &self.runtime_main_executable_path,
            )?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.handlers.is_empty() {
            state.serialize_entry("handlers", &self.handlers)?;
        }
        if !self.error_handlers.is_empty() {
            state.serialize_entry("errorHandlers", &self.error_handlers)?;
        }
        if !self.libraries.is_empty() {
            state.serialize_entry("libraries", &self.libraries)?;
        }
        if self.api_config.is_some() {
            state.serialize_entry("apiConfig", &self.api_config)?;
        }
        if !self.env_variables.is_empty() {
            state.serialize_entry("envVariables", &self.env_variables)?;
        }
        if !self.build_env_variables.is_empty() {
            state.serialize_entry("buildEnvVariables", &self.build_env_variables)?;
        }
        if self.default_expiration.is_some() {
            state.serialize_entry("defaultExpiration", &self.default_expiration)?;
        }
        if self.health_check.is_some() {
            state.serialize_entry("healthCheck", &self.health_check)?;
        }
        if self.readiness_check.is_some() {
            state.serialize_entry("readinessCheck", &self.readiness_check)?;
        }
        if self.liveness_check.is_some() {
            state.serialize_entry("livenessCheck", &self.liveness_check)?;
        }
        if !self.nobuild_files_regex.is_empty() {
            state.serialize_entry("nobuildFilesRegex", &self.nobuild_files_regex)?;
        }
        if self.deployment.is_some() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if !self.version_url.is_empty() {
            state.serialize_entry("versionUrl", &self.version_url)?;
        }
        if self.endpoints_api_service.is_some() {
            state.serialize_entry("endpointsApiService", &self.endpoints_api_service)?;
        }
        if self.entrypoint.is_some() {
            state.serialize_entry("entrypoint", &self.entrypoint)?;
        }
        if self.vpc_access_connector.is_some() {
            state.serialize_entry("vpcAccessConnector", &self.vpc_access_connector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Version");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("inbound_services", &self.inbound_services);
        debug_struct.field("instance_class", &self.instance_class);
        debug_struct.field("network", &self.network);
        debug_struct.field("zones", &self.zones);
        debug_struct.field("resources", &self.resources);
        debug_struct.field("runtime", &self.runtime);
        debug_struct.field("runtime_channel", &self.runtime_channel);
        debug_struct.field("threadsafe", &self.threadsafe);
        debug_struct.field("vm", &self.vm);
        debug_struct.field("app_engine_apis", &self.app_engine_apis);
        debug_struct.field("beta_settings", &self.beta_settings);
        debug_struct.field("env", &self.env);
        debug_struct.field("serving_status", &self.serving_status);
        debug_struct.field("created_by", &self.created_by);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("disk_usage_bytes", &self.disk_usage_bytes);
        debug_struct.field("runtime_api_version", &self.runtime_api_version);
        debug_struct.field(
            "runtime_main_executable_path",
            &self.runtime_main_executable_path,
        );
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("handlers", &self.handlers);
        debug_struct.field("error_handlers", &self.error_handlers);
        debug_struct.field("libraries", &self.libraries);
        debug_struct.field("api_config", &self.api_config);
        debug_struct.field("env_variables", &self.env_variables);
        debug_struct.field("build_env_variables", &self.build_env_variables);
        debug_struct.field("default_expiration", &self.default_expiration);
        debug_struct.field("health_check", &self.health_check);
        debug_struct.field("readiness_check", &self.readiness_check);
        debug_struct.field("liveness_check", &self.liveness_check);
        debug_struct.field("nobuild_files_regex", &self.nobuild_files_regex);
        debug_struct.field("deployment", &self.deployment);
        debug_struct.field("version_url", &self.version_url);
        debug_struct.field("endpoints_api_service", &self.endpoints_api_service);
        debug_struct.field("entrypoint", &self.entrypoint);
        debug_struct.field("vpc_access_connector", &self.vpc_access_connector);
        debug_struct.field("scaling", &self.scaling);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Version].
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// Controls how instances are created, scaled, and reaped.
    ///
    /// Defaults to `AutomaticScaling`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scaling {
        /// Automatic scaling is based on request rate, response latencies, and other
        /// application metrics. Instances are dynamically created and destroyed as
        /// needed in order to handle traffic.
        AutomaticScaling(std::boxed::Box<crate::model::AutomaticScaling>),
        /// A service with basic scaling will create an instance when the application
        /// receives a request. The instance will be turned down when the app becomes
        /// idle. Basic scaling is ideal for work that is intermittent or driven by
        /// user activity.
        BasicScaling(std::boxed::Box<crate::model::BasicScaling>),
        /// A service with manual scaling runs continuously, allowing you to perform
        /// complex initialization and rely on the state of its memory over time.
        /// Manually scaled versions are sometimes referred to as "backends".
        ManualScaling(std::boxed::Box<crate::model::ManualScaling>),
    }
}

/// [Cloud Endpoints](https://cloud.google.com/endpoints) configuration.
/// The Endpoints API Service provides tooling for serving Open API and gRPC
/// endpoints via an NGINX proxy. Only valid for App Engine Flexible environment
/// deployments.
///
/// The fields here refer to the name and configuration ID of a "service"
/// resource in the [Service Management API](https://cloud.google.com/service-management/overview).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EndpointsApiService {
    /// Endpoints service name which is the name of the "service" resource in the
    /// Service Management API. For example "myapi.endpoints.myproject.cloud.goog"
    pub name: std::string::String,

    /// Endpoints service configuration ID as specified by the Service Management
    /// API. For example "2016-09-19r1".
    ///
    /// By default, the rollout strategy for Endpoints is `RolloutStrategy.FIXED`.
    /// This means that Endpoints starts up with a particular configuration ID.
    /// When a new configuration is rolled out, Endpoints must be given the new
    /// configuration ID. The `config_id` field is used to give the configuration
    /// ID and is required in this case.
    ///
    /// Endpoints also has a rollout strategy called `RolloutStrategy.MANAGED`.
    /// When using this, Endpoints fetches the latest configuration and does not
    /// need the configuration ID. In this case, `config_id` must be omitted.
    pub config_id: std::string::String,

    /// Endpoints rollout strategy. If `FIXED`, `config_id` must be specified. If
    /// `MANAGED`, `config_id` must be omitted.
    pub rollout_strategy: crate::model::endpoints_api_service::RolloutStrategy,

    /// Enable or disable trace sampling. By default, this is set to false for
    /// enabled.
    pub disable_trace_sampling: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointsApiService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EndpointsApiService::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::EndpointsApiService::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }

    /// Sets the value of [rollout_strategy][crate::model::EndpointsApiService::rollout_strategy].
    pub fn set_rollout_strategy<
        T: std::convert::Into<crate::model::endpoints_api_service::RolloutStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_strategy = v.into();
        self
    }

    /// Sets the value of [disable_trace_sampling][crate::model::EndpointsApiService::disable_trace_sampling].
    pub fn set_disable_trace_sampling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_trace_sampling = v.into();
        self
    }
}

impl wkt::message::Message for EndpointsApiService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.EndpointsApiService"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EndpointsApiService {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config_id,
            __rollout_strategy,
            __disable_trace_sampling,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EndpointsApiService")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "configId" => Ok(__FieldTag::__config_id),
                            "config_id" => Ok(__FieldTag::__config_id),
                            "rolloutStrategy" => Ok(__FieldTag::__rollout_strategy),
                            "rollout_strategy" => Ok(__FieldTag::__rollout_strategy),
                            "disableTraceSampling" => Ok(__FieldTag::__disable_trace_sampling),
                            "disable_trace_sampling" => Ok(__FieldTag::__disable_trace_sampling),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EndpointsApiService;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EndpointsApiService")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_id => {
                            if !fields.insert(__FieldTag::__config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_id",
                                ));
                            }
                            result.config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_strategy => {
                            if !fields.insert(__FieldTag::__rollout_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_strategy",
                                ));
                            }
                            result.rollout_strategy = map
                                .next_value::<std::option::Option<
                                    crate::model::endpoints_api_service::RolloutStrategy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_trace_sampling => {
                            if !fields.insert(__FieldTag::__disable_trace_sampling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_trace_sampling",
                                ));
                            }
                            result.disable_trace_sampling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EndpointsApiService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.config_id.is_empty() {
            state.serialize_entry("configId", &self.config_id)?;
        }
        if !wkt::internal::is_default(&self.rollout_strategy) {
            state.serialize_entry("rolloutStrategy", &self.rollout_strategy)?;
        }
        if !wkt::internal::is_default(&self.disable_trace_sampling) {
            state.serialize_entry("disableTraceSampling", &self.disable_trace_sampling)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EndpointsApiService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EndpointsApiService");
        debug_struct.field("name", &self.name);
        debug_struct.field("config_id", &self.config_id);
        debug_struct.field("rollout_strategy", &self.rollout_strategy);
        debug_struct.field("disable_trace_sampling", &self.disable_trace_sampling);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EndpointsApiService].
pub mod endpoints_api_service {
    #[allow(unused_imports)]
    use super::*;

    /// Available rollout strategies.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutStrategy {
        /// Not specified. Defaults to `FIXED`.
        UnspecifiedRolloutStrategy,
        /// Endpoints service configuration ID will be fixed to the configuration ID
        /// specified by `config_id`.
        Fixed,
        /// Endpoints service configuration ID will be updated with each rollout.
        Managed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutStrategy::value] or
        /// [RolloutStrategy::name].
        UnknownValue(rollout_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::UnspecifiedRolloutStrategy => std::option::Option::Some(0),
                Self::Fixed => std::option::Option::Some(1),
                Self::Managed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::UnspecifiedRolloutStrategy => {
                    std::option::Option::Some("UNSPECIFIED_ROLLOUT_STRATEGY")
                }
                Self::Fixed => std::option::Option::Some("FIXED"),
                Self::Managed => std::option::Option::Some("MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::UnspecifiedRolloutStrategy,
                1 => Self::Fixed,
                2 => Self::Managed,
                _ => Self::UnknownValue(rollout_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED_ROLLOUT_STRATEGY" => Self::UnspecifiedRolloutStrategy,
                "FIXED" => Self::Fixed,
                "MANAGED" => Self::Managed,
                _ => Self::UnknownValue(rollout_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::UnspecifiedRolloutStrategy => serializer.serialize_i32(0),
                Self::Fixed => serializer.serialize_i32(1),
                Self::Managed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutStrategy>::new(
                ".google.appengine.v1.EndpointsApiService.RolloutStrategy",
            ))
        }
    }
}

/// Automatic scaling is based on request rate, response latencies, and other
/// application metrics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomaticScaling {
    /// The time period that the
    /// [Autoscaler](https://cloud.google.com/compute/docs/autoscaler/)
    /// should wait before it starts collecting information from a new instance.
    /// This prevents the autoscaler from collecting information when the instance
    /// is initializing, during which the collected usage would not be reliable.
    /// Only applicable in the App Engine flexible environment.
    pub cool_down_period: std::option::Option<wkt::Duration>,

    /// Target scaling by CPU usage.
    pub cpu_utilization: std::option::Option<crate::model::CpuUtilization>,

    /// Number of concurrent requests an automatic scaling instance can accept
    /// before the scheduler spawns a new instance.
    ///
    /// Defaults to a runtime-specific value.
    pub max_concurrent_requests: i32,

    /// Maximum number of idle instances that should be maintained for this
    /// version.
    pub max_idle_instances: i32,

    /// Maximum number of instances that should be started to handle requests for
    /// this version.
    pub max_total_instances: i32,

    /// Maximum amount of time that a request should wait in the pending queue
    /// before starting a new instance to handle it.
    pub max_pending_latency: std::option::Option<wkt::Duration>,

    /// Minimum number of idle instances that should be maintained for
    /// this version. Only applicable for the default version of a service.
    pub min_idle_instances: i32,

    /// Minimum number of running instances that should be maintained for this
    /// version.
    pub min_total_instances: i32,

    /// Minimum amount of time a request should wait in the pending queue before
    /// starting a new instance to handle it.
    pub min_pending_latency: std::option::Option<wkt::Duration>,

    /// Target scaling by request utilization.
    pub request_utilization: std::option::Option<crate::model::RequestUtilization>,

    /// Target scaling by disk usage.
    pub disk_utilization: std::option::Option<crate::model::DiskUtilization>,

    /// Target scaling by network usage.
    pub network_utilization: std::option::Option<crate::model::NetworkUtilization>,

    /// Scheduler settings for standard environment.
    pub standard_scheduler_settings: std::option::Option<crate::model::StandardSchedulerSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomaticScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cool_down_period][crate::model::AutomaticScaling::cool_down_period].
    pub fn set_cool_down_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cool_down_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cool_down_period][crate::model::AutomaticScaling::cool_down_period].
    pub fn set_or_clear_cool_down_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cool_down_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_utilization][crate::model::AutomaticScaling::cpu_utilization].
    pub fn set_cpu_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CpuUtilization>,
    {
        self.cpu_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_utilization][crate::model::AutomaticScaling::cpu_utilization].
    pub fn set_or_clear_cpu_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CpuUtilization>,
    {
        self.cpu_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_requests][crate::model::AutomaticScaling::max_concurrent_requests].
    pub fn set_max_concurrent_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_requests = v.into();
        self
    }

    /// Sets the value of [max_idle_instances][crate::model::AutomaticScaling::max_idle_instances].
    pub fn set_max_idle_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_idle_instances = v.into();
        self
    }

    /// Sets the value of [max_total_instances][crate::model::AutomaticScaling::max_total_instances].
    pub fn set_max_total_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_total_instances = v.into();
        self
    }

    /// Sets the value of [max_pending_latency][crate::model::AutomaticScaling::max_pending_latency].
    pub fn set_max_pending_latency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_pending_latency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_pending_latency][crate::model::AutomaticScaling::max_pending_latency].
    pub fn set_or_clear_max_pending_latency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_pending_latency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_idle_instances][crate::model::AutomaticScaling::min_idle_instances].
    pub fn set_min_idle_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_idle_instances = v.into();
        self
    }

    /// Sets the value of [min_total_instances][crate::model::AutomaticScaling::min_total_instances].
    pub fn set_min_total_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_total_instances = v.into();
        self
    }

    /// Sets the value of [min_pending_latency][crate::model::AutomaticScaling::min_pending_latency].
    pub fn set_min_pending_latency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_pending_latency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_pending_latency][crate::model::AutomaticScaling::min_pending_latency].
    pub fn set_or_clear_min_pending_latency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_pending_latency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_utilization][crate::model::AutomaticScaling::request_utilization].
    pub fn set_request_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RequestUtilization>,
    {
        self.request_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_utilization][crate::model::AutomaticScaling::request_utilization].
    pub fn set_or_clear_request_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RequestUtilization>,
    {
        self.request_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_utilization][crate::model::AutomaticScaling::disk_utilization].
    pub fn set_disk_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskUtilization>,
    {
        self.disk_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_utilization][crate::model::AutomaticScaling::disk_utilization].
    pub fn set_or_clear_disk_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskUtilization>,
    {
        self.disk_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_utilization][crate::model::AutomaticScaling::network_utilization].
    pub fn set_network_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkUtilization>,
    {
        self.network_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_utilization][crate::model::AutomaticScaling::network_utilization].
    pub fn set_or_clear_network_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkUtilization>,
    {
        self.network_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [standard_scheduler_settings][crate::model::AutomaticScaling::standard_scheduler_settings].
    pub fn set_standard_scheduler_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StandardSchedulerSettings>,
    {
        self.standard_scheduler_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [standard_scheduler_settings][crate::model::AutomaticScaling::standard_scheduler_settings].
    pub fn set_or_clear_standard_scheduler_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StandardSchedulerSettings>,
    {
        self.standard_scheduler_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutomaticScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AutomaticScaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomaticScaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cool_down_period,
            __cpu_utilization,
            __max_concurrent_requests,
            __max_idle_instances,
            __max_total_instances,
            __max_pending_latency,
            __min_idle_instances,
            __min_total_instances,
            __min_pending_latency,
            __request_utilization,
            __disk_utilization,
            __network_utilization,
            __standard_scheduler_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomaticScaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "coolDownPeriod" => Ok(__FieldTag::__cool_down_period),
                            "cool_down_period" => Ok(__FieldTag::__cool_down_period),
                            "cpuUtilization" => Ok(__FieldTag::__cpu_utilization),
                            "cpu_utilization" => Ok(__FieldTag::__cpu_utilization),
                            "maxConcurrentRequests" => Ok(__FieldTag::__max_concurrent_requests),
                            "max_concurrent_requests" => Ok(__FieldTag::__max_concurrent_requests),
                            "maxIdleInstances" => Ok(__FieldTag::__max_idle_instances),
                            "max_idle_instances" => Ok(__FieldTag::__max_idle_instances),
                            "maxTotalInstances" => Ok(__FieldTag::__max_total_instances),
                            "max_total_instances" => Ok(__FieldTag::__max_total_instances),
                            "maxPendingLatency" => Ok(__FieldTag::__max_pending_latency),
                            "max_pending_latency" => Ok(__FieldTag::__max_pending_latency),
                            "minIdleInstances" => Ok(__FieldTag::__min_idle_instances),
                            "min_idle_instances" => Ok(__FieldTag::__min_idle_instances),
                            "minTotalInstances" => Ok(__FieldTag::__min_total_instances),
                            "min_total_instances" => Ok(__FieldTag::__min_total_instances),
                            "minPendingLatency" => Ok(__FieldTag::__min_pending_latency),
                            "min_pending_latency" => Ok(__FieldTag::__min_pending_latency),
                            "requestUtilization" => Ok(__FieldTag::__request_utilization),
                            "request_utilization" => Ok(__FieldTag::__request_utilization),
                            "diskUtilization" => Ok(__FieldTag::__disk_utilization),
                            "disk_utilization" => Ok(__FieldTag::__disk_utilization),
                            "networkUtilization" => Ok(__FieldTag::__network_utilization),
                            "network_utilization" => Ok(__FieldTag::__network_utilization),
                            "standardSchedulerSettings" => {
                                Ok(__FieldTag::__standard_scheduler_settings)
                            }
                            "standard_scheduler_settings" => {
                                Ok(__FieldTag::__standard_scheduler_settings)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomaticScaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomaticScaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cool_down_period => {
                            if !fields.insert(__FieldTag::__cool_down_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cool_down_period",
                                ));
                            }
                            result.cool_down_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cpu_utilization => {
                            if !fields.insert(__FieldTag::__cpu_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_utilization",
                                ));
                            }
                            result.cpu_utilization = map
                                .next_value::<std::option::Option<crate::model::CpuUtilization>>(
                                )?;
                        }
                        __FieldTag::__max_concurrent_requests => {
                            if !fields.insert(__FieldTag::__max_concurrent_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_requests",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_requests =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_idle_instances => {
                            if !fields.insert(__FieldTag::__max_idle_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_idle_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_idle_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_total_instances => {
                            if !fields.insert(__FieldTag::__max_total_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_total_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_total_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_pending_latency => {
                            if !fields.insert(__FieldTag::__max_pending_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pending_latency",
                                ));
                            }
                            result.max_pending_latency =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__min_idle_instances => {
                            if !fields.insert(__FieldTag::__min_idle_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_idle_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_idle_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_total_instances => {
                            if !fields.insert(__FieldTag::__min_total_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_total_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_total_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_pending_latency => {
                            if !fields.insert(__FieldTag::__min_pending_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_pending_latency",
                                ));
                            }
                            result.min_pending_latency =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__request_utilization => {
                            if !fields.insert(__FieldTag::__request_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_utilization",
                                ));
                            }
                            result.request_utilization = map.next_value::<std::option::Option<crate::model::RequestUtilization>>()?
                                ;
                        }
                        __FieldTag::__disk_utilization => {
                            if !fields.insert(__FieldTag::__disk_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_utilization",
                                ));
                            }
                            result.disk_utilization = map
                                .next_value::<std::option::Option<crate::model::DiskUtilization>>(
                                )?;
                        }
                        __FieldTag::__network_utilization => {
                            if !fields.insert(__FieldTag::__network_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_utilization",
                                ));
                            }
                            result.network_utilization = map.next_value::<std::option::Option<crate::model::NetworkUtilization>>()?
                                ;
                        }
                        __FieldTag::__standard_scheduler_settings => {
                            if !fields.insert(__FieldTag::__standard_scheduler_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_scheduler_settings",
                                ));
                            }
                            result.standard_scheduler_settings = map.next_value::<std::option::Option<crate::model::StandardSchedulerSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomaticScaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cool_down_period.is_some() {
            state.serialize_entry("coolDownPeriod", &self.cool_down_period)?;
        }
        if self.cpu_utilization.is_some() {
            state.serialize_entry("cpuUtilization", &self.cpu_utilization)?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_requests) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentRequests",
                &__With(&self.max_concurrent_requests),
            )?;
        }
        if !wkt::internal::is_default(&self.max_idle_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxIdleInstances", &__With(&self.max_idle_instances))?;
        }
        if !wkt::internal::is_default(&self.max_total_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxTotalInstances", &__With(&self.max_total_instances))?;
        }
        if self.max_pending_latency.is_some() {
            state.serialize_entry("maxPendingLatency", &self.max_pending_latency)?;
        }
        if !wkt::internal::is_default(&self.min_idle_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minIdleInstances", &__With(&self.min_idle_instances))?;
        }
        if !wkt::internal::is_default(&self.min_total_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minTotalInstances", &__With(&self.min_total_instances))?;
        }
        if self.min_pending_latency.is_some() {
            state.serialize_entry("minPendingLatency", &self.min_pending_latency)?;
        }
        if self.request_utilization.is_some() {
            state.serialize_entry("requestUtilization", &self.request_utilization)?;
        }
        if self.disk_utilization.is_some() {
            state.serialize_entry("diskUtilization", &self.disk_utilization)?;
        }
        if self.network_utilization.is_some() {
            state.serialize_entry("networkUtilization", &self.network_utilization)?;
        }
        if self.standard_scheduler_settings.is_some() {
            state.serialize_entry(
                "standardSchedulerSettings",
                &self.standard_scheduler_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomaticScaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomaticScaling");
        debug_struct.field("cool_down_period", &self.cool_down_period);
        debug_struct.field("cpu_utilization", &self.cpu_utilization);
        debug_struct.field("max_concurrent_requests", &self.max_concurrent_requests);
        debug_struct.field("max_idle_instances", &self.max_idle_instances);
        debug_struct.field("max_total_instances", &self.max_total_instances);
        debug_struct.field("max_pending_latency", &self.max_pending_latency);
        debug_struct.field("min_idle_instances", &self.min_idle_instances);
        debug_struct.field("min_total_instances", &self.min_total_instances);
        debug_struct.field("min_pending_latency", &self.min_pending_latency);
        debug_struct.field("request_utilization", &self.request_utilization);
        debug_struct.field("disk_utilization", &self.disk_utilization);
        debug_struct.field("network_utilization", &self.network_utilization);
        debug_struct.field(
            "standard_scheduler_settings",
            &self.standard_scheduler_settings,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A service with basic scaling will create an instance when the application
/// receives a request. The instance will be turned down when the app becomes
/// idle. Basic scaling is ideal for work that is intermittent or driven by
/// user activity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BasicScaling {
    /// Duration of time after the last request that an instance must wait before
    /// the instance is shut down.
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Maximum number of instances to create for this version.
    pub max_instances: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_timeout][crate::model::BasicScaling::idle_timeout].
    pub fn set_idle_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_timeout][crate::model::BasicScaling::idle_timeout].
    pub fn set_or_clear_idle_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_instances][crate::model::BasicScaling::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }
}

impl wkt::message::Message for BasicScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BasicScaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BasicScaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __idle_timeout,
            __max_instances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BasicScaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "idleTimeout" => Ok(__FieldTag::__idle_timeout),
                            "idle_timeout" => Ok(__FieldTag::__idle_timeout),
                            "maxInstances" => Ok(__FieldTag::__max_instances),
                            "max_instances" => Ok(__FieldTag::__max_instances),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BasicScaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BasicScaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__idle_timeout => {
                            if !fields.insert(__FieldTag::__idle_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_timeout",
                                ));
                            }
                            result.idle_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_instances => {
                            if !fields.insert(__FieldTag::__max_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BasicScaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.idle_timeout.is_some() {
            state.serialize_entry("idleTimeout", &self.idle_timeout)?;
        }
        if !wkt::internal::is_default(&self.max_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxInstances", &__With(&self.max_instances))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BasicScaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BasicScaling");
        debug_struct.field("idle_timeout", &self.idle_timeout);
        debug_struct.field("max_instances", &self.max_instances);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A service with manual scaling runs continuously, allowing you to perform
/// complex initialization and rely on the state of its memory over time.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManualScaling {
    /// Number of instances to assign to the service at the start. This number
    /// can later be altered by using the
    /// [Modules API](https://cloud.google.com/appengine/docs/python/modules/functions)
    /// `set_num_instances()` function.
    pub instances: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManualScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ManualScaling::instances].
    pub fn set_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.instances = v.into();
        self
    }
}

impl wkt::message::Message for ManualScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ManualScaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManualScaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManualScaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManualScaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManualScaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.instances = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManualScaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("instances", &__With(&self.instances))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ManualScaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManualScaling");
        debug_struct.field("instances", &self.instances);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Target scaling by CPU usage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CpuUtilization {
    /// Period of time over which CPU utilization is calculated.
    pub aggregation_window_length: std::option::Option<wkt::Duration>,

    /// Target CPU utilization ratio to maintain when scaling. Must be between 0
    /// and 1.
    pub target_utilization: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CpuUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aggregation_window_length][crate::model::CpuUtilization::aggregation_window_length].
    pub fn set_aggregation_window_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.aggregation_window_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregation_window_length][crate::model::CpuUtilization::aggregation_window_length].
    pub fn set_or_clear_aggregation_window_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.aggregation_window_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_utilization][crate::model::CpuUtilization::target_utilization].
    pub fn set_target_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_utilization = v.into();
        self
    }
}

impl wkt::message::Message for CpuUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CpuUtilization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CpuUtilization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregation_window_length,
            __target_utilization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CpuUtilization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregationWindowLength" => {
                                Ok(__FieldTag::__aggregation_window_length)
                            }
                            "aggregation_window_length" => {
                                Ok(__FieldTag::__aggregation_window_length)
                            }
                            "targetUtilization" => Ok(__FieldTag::__target_utilization),
                            "target_utilization" => Ok(__FieldTag::__target_utilization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CpuUtilization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CpuUtilization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregation_window_length => {
                            if !fields.insert(__FieldTag::__aggregation_window_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_window_length",
                                ));
                            }
                            result.aggregation_window_length =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__target_utilization => {
                            if !fields.insert(__FieldTag::__target_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CpuUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aggregation_window_length.is_some() {
            state.serialize_entry("aggregationWindowLength", &self.aggregation_window_length)?;
        }
        if !wkt::internal::is_default(&self.target_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("targetUtilization", &__With(&self.target_utilization))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CpuUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CpuUtilization");
        debug_struct.field("aggregation_window_length", &self.aggregation_window_length);
        debug_struct.field("target_utilization", &self.target_utilization);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Target scaling by request utilization.
/// Only applicable in the App Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RequestUtilization {
    /// Target requests per second.
    pub target_request_count_per_second: i32,

    /// Target number of concurrent requests.
    pub target_concurrent_requests: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_request_count_per_second][crate::model::RequestUtilization::target_request_count_per_second].
    pub fn set_target_request_count_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_request_count_per_second = v.into();
        self
    }

    /// Sets the value of [target_concurrent_requests][crate::model::RequestUtilization::target_concurrent_requests].
    pub fn set_target_concurrent_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_concurrent_requests = v.into();
        self
    }
}

impl wkt::message::Message for RequestUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.RequestUtilization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RequestUtilization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_request_count_per_second,
            __target_concurrent_requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RequestUtilization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetRequestCountPerSecond" => {
                                Ok(__FieldTag::__target_request_count_per_second)
                            }
                            "target_request_count_per_second" => {
                                Ok(__FieldTag::__target_request_count_per_second)
                            }
                            "targetConcurrentRequests" => {
                                Ok(__FieldTag::__target_concurrent_requests)
                            }
                            "target_concurrent_requests" => {
                                Ok(__FieldTag::__target_concurrent_requests)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RequestUtilization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RequestUtilization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_request_count_per_second => {
                            if !fields.insert(__FieldTag::__target_request_count_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_request_count_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_request_count_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_concurrent_requests => {
                            if !fields.insert(__FieldTag::__target_concurrent_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_concurrent_requests",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_concurrent_requests =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RequestUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_request_count_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetRequestCountPerSecond",
                &__With(&self.target_request_count_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_concurrent_requests) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetConcurrentRequests",
                &__With(&self.target_concurrent_requests),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RequestUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RequestUtilization");
        debug_struct.field(
            "target_request_count_per_second",
            &self.target_request_count_per_second,
        );
        debug_struct.field(
            "target_concurrent_requests",
            &self.target_concurrent_requests,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Target scaling by disk usage.
/// Only applicable in the App Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskUtilization {
    /// Target bytes written per second.
    pub target_write_bytes_per_second: i32,

    /// Target ops written per second.
    pub target_write_ops_per_second: i32,

    /// Target bytes read per second.
    pub target_read_bytes_per_second: i32,

    /// Target ops read per seconds.
    pub target_read_ops_per_second: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_write_bytes_per_second][crate::model::DiskUtilization::target_write_bytes_per_second].
    pub fn set_target_write_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_write_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_write_ops_per_second][crate::model::DiskUtilization::target_write_ops_per_second].
    pub fn set_target_write_ops_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_write_ops_per_second = v.into();
        self
    }

    /// Sets the value of [target_read_bytes_per_second][crate::model::DiskUtilization::target_read_bytes_per_second].
    pub fn set_target_read_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_read_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_read_ops_per_second][crate::model::DiskUtilization::target_read_ops_per_second].
    pub fn set_target_read_ops_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_read_ops_per_second = v.into();
        self
    }
}

impl wkt::message::Message for DiskUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DiskUtilization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskUtilization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_write_bytes_per_second,
            __target_write_ops_per_second,
            __target_read_bytes_per_second,
            __target_read_ops_per_second,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskUtilization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetWriteBytesPerSecond" => {
                                Ok(__FieldTag::__target_write_bytes_per_second)
                            }
                            "target_write_bytes_per_second" => {
                                Ok(__FieldTag::__target_write_bytes_per_second)
                            }
                            "targetWriteOpsPerSecond" => {
                                Ok(__FieldTag::__target_write_ops_per_second)
                            }
                            "target_write_ops_per_second" => {
                                Ok(__FieldTag::__target_write_ops_per_second)
                            }
                            "targetReadBytesPerSecond" => {
                                Ok(__FieldTag::__target_read_bytes_per_second)
                            }
                            "target_read_bytes_per_second" => {
                                Ok(__FieldTag::__target_read_bytes_per_second)
                            }
                            "targetReadOpsPerSecond" => {
                                Ok(__FieldTag::__target_read_ops_per_second)
                            }
                            "target_read_ops_per_second" => {
                                Ok(__FieldTag::__target_read_ops_per_second)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskUtilization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskUtilization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_write_bytes_per_second => {
                            if !fields.insert(__FieldTag::__target_write_bytes_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_write_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_write_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_write_ops_per_second => {
                            if !fields.insert(__FieldTag::__target_write_ops_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_write_ops_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_write_ops_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_read_bytes_per_second => {
                            if !fields.insert(__FieldTag::__target_read_bytes_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_read_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_read_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_read_ops_per_second => {
                            if !fields.insert(__FieldTag::__target_read_ops_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_read_ops_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_read_ops_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_write_bytes_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetWriteBytesPerSecond",
                &__With(&self.target_write_bytes_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_write_ops_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetWriteOpsPerSecond",
                &__With(&self.target_write_ops_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_read_bytes_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetReadBytesPerSecond",
                &__With(&self.target_read_bytes_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_read_ops_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetReadOpsPerSecond",
                &__With(&self.target_read_ops_per_second),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskUtilization");
        debug_struct.field(
            "target_write_bytes_per_second",
            &self.target_write_bytes_per_second,
        );
        debug_struct.field(
            "target_write_ops_per_second",
            &self.target_write_ops_per_second,
        );
        debug_struct.field(
            "target_read_bytes_per_second",
            &self.target_read_bytes_per_second,
        );
        debug_struct.field(
            "target_read_ops_per_second",
            &self.target_read_ops_per_second,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Target scaling by network usage.
/// Only applicable in the App Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkUtilization {
    /// Target bytes sent per second.
    pub target_sent_bytes_per_second: i32,

    /// Target packets sent per second.
    pub target_sent_packets_per_second: i32,

    /// Target bytes received per second.
    pub target_received_bytes_per_second: i32,

    /// Target packets received per second.
    pub target_received_packets_per_second: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_sent_bytes_per_second][crate::model::NetworkUtilization::target_sent_bytes_per_second].
    pub fn set_target_sent_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_sent_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_sent_packets_per_second][crate::model::NetworkUtilization::target_sent_packets_per_second].
    pub fn set_target_sent_packets_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_sent_packets_per_second = v.into();
        self
    }

    /// Sets the value of [target_received_bytes_per_second][crate::model::NetworkUtilization::target_received_bytes_per_second].
    pub fn set_target_received_bytes_per_second<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_received_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_received_packets_per_second][crate::model::NetworkUtilization::target_received_packets_per_second].
    pub fn set_target_received_packets_per_second<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_received_packets_per_second = v.into();
        self
    }
}

impl wkt::message::Message for NetworkUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.NetworkUtilization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkUtilization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_sent_bytes_per_second,
            __target_sent_packets_per_second,
            __target_received_bytes_per_second,
            __target_received_packets_per_second,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkUtilization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetSentBytesPerSecond" => {
                                Ok(__FieldTag::__target_sent_bytes_per_second)
                            }
                            "target_sent_bytes_per_second" => {
                                Ok(__FieldTag::__target_sent_bytes_per_second)
                            }
                            "targetSentPacketsPerSecond" => {
                                Ok(__FieldTag::__target_sent_packets_per_second)
                            }
                            "target_sent_packets_per_second" => {
                                Ok(__FieldTag::__target_sent_packets_per_second)
                            }
                            "targetReceivedBytesPerSecond" => {
                                Ok(__FieldTag::__target_received_bytes_per_second)
                            }
                            "target_received_bytes_per_second" => {
                                Ok(__FieldTag::__target_received_bytes_per_second)
                            }
                            "targetReceivedPacketsPerSecond" => {
                                Ok(__FieldTag::__target_received_packets_per_second)
                            }
                            "target_received_packets_per_second" => {
                                Ok(__FieldTag::__target_received_packets_per_second)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkUtilization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkUtilization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_sent_bytes_per_second => {
                            if !fields.insert(__FieldTag::__target_sent_bytes_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_sent_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_sent_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_sent_packets_per_second => {
                            if !fields.insert(__FieldTag::__target_sent_packets_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_sent_packets_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_sent_packets_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_received_bytes_per_second => {
                            if !fields.insert(__FieldTag::__target_received_bytes_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_received_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_received_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_received_packets_per_second => {
                            if !fields.insert(__FieldTag::__target_received_packets_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_received_packets_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_received_packets_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_sent_bytes_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetSentBytesPerSecond",
                &__With(&self.target_sent_bytes_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_sent_packets_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetSentPacketsPerSecond",
                &__With(&self.target_sent_packets_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_received_bytes_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetReceivedBytesPerSecond",
                &__With(&self.target_received_bytes_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.target_received_packets_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetReceivedPacketsPerSecond",
                &__With(&self.target_received_packets_per_second),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkUtilization");
        debug_struct.field(
            "target_sent_bytes_per_second",
            &self.target_sent_bytes_per_second,
        );
        debug_struct.field(
            "target_sent_packets_per_second",
            &self.target_sent_packets_per_second,
        );
        debug_struct.field(
            "target_received_bytes_per_second",
            &self.target_received_bytes_per_second,
        );
        debug_struct.field(
            "target_received_packets_per_second",
            &self.target_received_packets_per_second,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Scheduler settings for standard environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardSchedulerSettings {
    /// Target CPU utilization ratio to maintain when scaling.
    pub target_cpu_utilization: f64,

    /// Target throughput utilization ratio to maintain when scaling
    pub target_throughput_utilization: f64,

    /// Minimum number of instances to run for this version. Set to zero to disable
    /// `min_instances` configuration.
    pub min_instances: i32,

    /// Maximum number of instances to run for this version. Set to zero to disable
    /// `max_instances` configuration.
    pub max_instances: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSchedulerSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_cpu_utilization][crate::model::StandardSchedulerSettings::target_cpu_utilization].
    pub fn set_target_cpu_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_cpu_utilization = v.into();
        self
    }

    /// Sets the value of [target_throughput_utilization][crate::model::StandardSchedulerSettings::target_throughput_utilization].
    pub fn set_target_throughput_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_throughput_utilization = v.into();
        self
    }

    /// Sets the value of [min_instances][crate::model::StandardSchedulerSettings::min_instances].
    pub fn set_min_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instances = v.into();
        self
    }

    /// Sets the value of [max_instances][crate::model::StandardSchedulerSettings::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }
}

impl wkt::message::Message for StandardSchedulerSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.StandardSchedulerSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardSchedulerSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_cpu_utilization,
            __target_throughput_utilization,
            __min_instances,
            __max_instances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSchedulerSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetCpuUtilization" => Ok(__FieldTag::__target_cpu_utilization),
                            "target_cpu_utilization" => Ok(__FieldTag::__target_cpu_utilization),
                            "targetThroughputUtilization" => {
                                Ok(__FieldTag::__target_throughput_utilization)
                            }
                            "target_throughput_utilization" => {
                                Ok(__FieldTag::__target_throughput_utilization)
                            }
                            "minInstances" => Ok(__FieldTag::__min_instances),
                            "min_instances" => Ok(__FieldTag::__min_instances),
                            "maxInstances" => Ok(__FieldTag::__max_instances),
                            "max_instances" => Ok(__FieldTag::__max_instances),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardSchedulerSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSchedulerSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_cpu_utilization => {
                            if !fields.insert(__FieldTag::__target_cpu_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_cpu_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_cpu_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_throughput_utilization => {
                            if !fields.insert(__FieldTag::__target_throughput_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_throughput_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_throughput_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_instances => {
                            if !fields.insert(__FieldTag::__min_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_instances => {
                            if !fields.insert(__FieldTag::__max_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardSchedulerSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_cpu_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetCpuUtilization",
                &__With(&self.target_cpu_utilization),
            )?;
        }
        if !wkt::internal::is_default(&self.target_throughput_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetThroughputUtilization",
                &__With(&self.target_throughput_utilization),
            )?;
        }
        if !wkt::internal::is_default(&self.min_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minInstances", &__With(&self.min_instances))?;
        }
        if !wkt::internal::is_default(&self.max_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxInstances", &__With(&self.max_instances))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StandardSchedulerSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardSchedulerSettings");
        debug_struct.field("target_cpu_utilization", &self.target_cpu_utilization);
        debug_struct.field(
            "target_throughput_utilization",
            &self.target_throughput_utilization,
        );
        debug_struct.field("min_instances", &self.min_instances);
        debug_struct.field("max_instances", &self.max_instances);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Extra network settings.
/// Only applicable in the App Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Network {
    /// List of ports, or port pairs, to forward from the virtual machine to the
    /// application container.
    /// Only applicable in the App Engine flexible environment.
    pub forwarded_ports: std::vec::Vec<std::string::String>,

    /// Tag to apply to the instance during creation.
    /// Only applicable in the App Engine flexible environment.
    pub instance_tag: std::string::String,

    /// Google Compute Engine network where the virtual machines are created.
    /// Specify the short name, not the resource path.
    ///
    /// Defaults to `default`.
    pub name: std::string::String,

    /// Google Cloud Platform sub-network where the virtual machines are created.
    /// Specify the short name, not the resource path.
    ///
    /// If a subnetwork name is specified, a network name will also be required
    /// unless it is for the default network.
    ///
    /// * If the network that the instance is being created in is a Legacy network,
    ///   then the IP address is allocated from the IPv4Range.
    /// * If the network that the instance is being created in is an auto Subnet
    ///   Mode Network, then only network name should be specified (not the
    ///   subnetwork_name) and the IP address is created from the IPCidrRange of the
    ///   subnetwork that exists in that zone for that network.
    /// * If the network that the instance is being created in is a custom Subnet
    ///   Mode Network, then the subnetwork_name must be specified and the
    ///   IP address is created from the IPCidrRange of the subnetwork.
    ///
    /// If specified, the subnetwork must exist in the same region as the
    /// App Engine flexible environment application.
    pub subnetwork_name: std::string::String,

    /// Enable session affinity.
    /// Only applicable in the App Engine flexible environment.
    pub session_affinity: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [forwarded_ports][crate::model::Network::forwarded_ports].
    pub fn set_forwarded_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.forwarded_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_tag][crate::model::Network::instance_tag].
    pub fn set_instance_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_tag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subnetwork_name][crate::model::Network::subnetwork_name].
    pub fn set_subnetwork_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_name = v.into();
        self
    }

    /// Sets the value of [session_affinity][crate::model::Network::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Network"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Network {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __forwarded_ports,
            __instance_tag,
            __name,
            __subnetwork_name,
            __session_affinity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Network")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "forwardedPorts" => Ok(__FieldTag::__forwarded_ports),
                            "forwarded_ports" => Ok(__FieldTag::__forwarded_ports),
                            "instanceTag" => Ok(__FieldTag::__instance_tag),
                            "instance_tag" => Ok(__FieldTag::__instance_tag),
                            "name" => Ok(__FieldTag::__name),
                            "subnetworkName" => Ok(__FieldTag::__subnetwork_name),
                            "subnetwork_name" => Ok(__FieldTag::__subnetwork_name),
                            "sessionAffinity" => Ok(__FieldTag::__session_affinity),
                            "session_affinity" => Ok(__FieldTag::__session_affinity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Network;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Network")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__forwarded_ports => {
                            if !fields.insert(__FieldTag::__forwarded_ports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarded_ports",
                                ));
                            }
                            result.forwarded_ports = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_tag => {
                            if !fields.insert(__FieldTag::__instance_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_tag",
                                ));
                            }
                            result.instance_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork_name => {
                            if !fields.insert(__FieldTag::__subnetwork_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_name",
                                ));
                            }
                            result.subnetwork_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_affinity => {
                            if !fields.insert(__FieldTag::__session_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_affinity",
                                ));
                            }
                            result.session_affinity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Network {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.forwarded_ports.is_empty() {
            state.serialize_entry("forwardedPorts", &self.forwarded_ports)?;
        }
        if !self.instance_tag.is_empty() {
            state.serialize_entry("instanceTag", &self.instance_tag)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.subnetwork_name.is_empty() {
            state.serialize_entry("subnetworkName", &self.subnetwork_name)?;
        }
        if !wkt::internal::is_default(&self.session_affinity) {
            state.serialize_entry("sessionAffinity", &self.session_affinity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Network");
        debug_struct.field("forwarded_ports", &self.forwarded_ports);
        debug_struct.field("instance_tag", &self.instance_tag);
        debug_struct.field("name", &self.name);
        debug_struct.field("subnetwork_name", &self.subnetwork_name);
        debug_struct.field("session_affinity", &self.session_affinity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Volumes mounted within the app container.
/// Only applicable in the App Engine flexible environment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Volume {
    /// Unique name for the volume.
    pub name: std::string::String,

    /// Underlying volume type, e.g. 'tmpfs'.
    pub volume_type: std::string::String,

    /// Volume size in gigabytes.
    pub size_gb: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type].
    pub fn set_volume_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_type = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Volume::size_gb].
    pub fn set_size_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Volume"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Volume {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __volume_type,
            __size_gb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Volume")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "volumeType" => Ok(__FieldTag::__volume_type),
                            "volume_type" => Ok(__FieldTag::__volume_type),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Volume;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Volume")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_type => {
                            if !fields.insert(__FieldTag::__volume_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_type",
                                ));
                            }
                            result.volume_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Volume {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.volume_type.is_empty() {
            state.serialize_entry("volumeType", &self.volume_type)?;
        }
        if !wkt::internal::is_default(&self.size_gb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Volume");
        debug_struct.field("name", &self.name);
        debug_struct.field("volume_type", &self.volume_type);
        debug_struct.field("size_gb", &self.size_gb);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Machine resources for a version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Resources {
    /// Number of CPU cores needed.
    pub cpu: f64,

    /// Disk size (GB) needed.
    pub disk_gb: f64,

    /// Memory (GB) needed.
    pub memory_gb: f64,

    /// User specified volumes.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// The name of the encryption key that is stored in Google Cloud KMS.
    /// Only should be used by Cloud Composer to encrypt the vm disk
    pub kms_key_reference: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Resources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu][crate::model::Resources::cpu].
    pub fn set_cpu<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu = v.into();
        self
    }

    /// Sets the value of [disk_gb][crate::model::Resources::disk_gb].
    pub fn set_disk_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.disk_gb = v.into();
        self
    }

    /// Sets the value of [memory_gb][crate::model::Resources::memory_gb].
    pub fn set_memory_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.memory_gb = v.into();
        self
    }

    /// Sets the value of [volumes][crate::model::Resources::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kms_key_reference][crate::model::Resources::kms_key_reference].
    pub fn set_kms_key_reference<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_reference = v.into();
        self
    }
}

impl wkt::message::Message for Resources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Resources"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Resources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu,
            __disk_gb,
            __memory_gb,
            __volumes,
            __kms_key_reference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Resources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpu" => Ok(__FieldTag::__cpu),
                            "diskGb" => Ok(__FieldTag::__disk_gb),
                            "disk_gb" => Ok(__FieldTag::__disk_gb),
                            "memoryGb" => Ok(__FieldTag::__memory_gb),
                            "memory_gb" => Ok(__FieldTag::__memory_gb),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "kmsKeyReference" => Ok(__FieldTag::__kms_key_reference),
                            "kms_key_reference" => Ok(__FieldTag::__kms_key_reference),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Resources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Resources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu => {
                            if !fields.insert(__FieldTag::__cpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_gb => {
                            if !fields.insert(__FieldTag::__disk_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_gb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_gb => {
                            if !fields.insert(__FieldTag::__memory_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_gb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kms_key_reference => {
                            if !fields.insert(__FieldTag::__kms_key_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_reference",
                                ));
                            }
                            result.kms_key_reference = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Resources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cpu) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpu", &__With(&self.cpu))?;
        }
        if !wkt::internal::is_default(&self.disk_gb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskGb", &__With(&self.disk_gb))?;
        }
        if !wkt::internal::is_default(&self.memory_gb) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryGb", &__With(&self.memory_gb))?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !self.kms_key_reference.is_empty() {
            state.serialize_entry("kmsKeyReference", &self.kms_key_reference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Resources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Resources");
        debug_struct.field("cpu", &self.cpu);
        debug_struct.field("disk_gb", &self.disk_gb);
        debug_struct.field("memory_gb", &self.memory_gb);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("kms_key_reference", &self.kms_key_reference);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VPC access connector specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcAccessConnector {
    /// Full Serverless VPC Access Connector name e.g.
    /// /projects/my-project/locations/us-central1/connectors/c1.
    pub name: std::string::String,

    /// The egress setting for the connector, controlling what traffic is diverted
    /// through it.
    pub egress_setting: crate::model::vpc_access_connector::EgressSetting,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcAccessConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpcAccessConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [egress_setting][crate::model::VpcAccessConnector::egress_setting].
    pub fn set_egress_setting<
        T: std::convert::Into<crate::model::vpc_access_connector::EgressSetting>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.egress_setting = v.into();
        self
    }
}

impl wkt::message::Message for VpcAccessConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.VpcAccessConnector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcAccessConnector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __egress_setting,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcAccessConnector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "egressSetting" => Ok(__FieldTag::__egress_setting),
                            "egress_setting" => Ok(__FieldTag::__egress_setting),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcAccessConnector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcAccessConnector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__egress_setting => {
                            if !fields.insert(__FieldTag::__egress_setting) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for egress_setting",
                                ));
                            }
                            result.egress_setting = map
                                .next_value::<std::option::Option<
                                    crate::model::vpc_access_connector::EgressSetting,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcAccessConnector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.egress_setting) {
            state.serialize_entry("egressSetting", &self.egress_setting)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpcAccessConnector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcAccessConnector");
        debug_struct.field("name", &self.name);
        debug_struct.field("egress_setting", &self.egress_setting);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VpcAccessConnector].
pub mod vpc_access_connector {
    #[allow(unused_imports)]
    use super::*;

    /// Available egress settings.
    ///
    /// This controls what traffic is diverted through the VPC Access Connector
    /// resource. By default PRIVATE_IP_RANGES will be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EgressSetting {
        Unspecified,
        /// Force the use of VPC Access for all egress traffic from the function.
        AllTraffic,
        /// Use the VPC Access Connector for private IP space from RFC1918.
        PrivateIpRanges,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EgressSetting::value] or
        /// [EgressSetting::name].
        UnknownValue(egress_setting::UnknownValue),
    }

    #[doc(hidden)]
    pub mod egress_setting {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EgressSetting {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllTraffic => std::option::Option::Some(1),
                Self::PrivateIpRanges => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EGRESS_SETTING_UNSPECIFIED"),
                Self::AllTraffic => std::option::Option::Some("ALL_TRAFFIC"),
                Self::PrivateIpRanges => std::option::Option::Some("PRIVATE_IP_RANGES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EgressSetting {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EgressSetting {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EgressSetting {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllTraffic,
                2 => Self::PrivateIpRanges,
                _ => Self::UnknownValue(egress_setting::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EgressSetting {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EGRESS_SETTING_UNSPECIFIED" => Self::Unspecified,
                "ALL_TRAFFIC" => Self::AllTraffic,
                "PRIVATE_IP_RANGES" => Self::PrivateIpRanges,
                _ => Self::UnknownValue(egress_setting::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EgressSetting {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllTraffic => serializer.serialize_i32(1),
                Self::PrivateIpRanges => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EgressSetting {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EgressSetting>::new(
                ".google.appengine.v1.VpcAccessConnector.EgressSetting",
            ))
        }
    }
}

/// The entrypoint for the application.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entrypoint {
    /// The command to run.
    pub command: std::option::Option<crate::model::entrypoint::Command>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entrypoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [command][crate::model::Entrypoint::command].
    ///
    /// Note that all the setters affecting `command` are mutually
    /// exclusive.
    pub fn set_command<
        T: std::convert::Into<std::option::Option<crate::model::entrypoint::Command>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.command = v.into();
        self
    }

    /// The value of [command][crate::model::Entrypoint::command]
    /// if it holds a `Shell`, `None` if the field is not set or
    /// holds a different branch.
    pub fn shell(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.command.as_ref().and_then(|v| match v {
            crate::model::entrypoint::Command::Shell(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [command][crate::model::Entrypoint::command]
    /// to hold a `Shell`.
    ///
    /// Note that all the setters affecting `command` are
    /// mutually exclusive.
    pub fn set_shell<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command =
            std::option::Option::Some(crate::model::entrypoint::Command::Shell(v.into()));
        self
    }
}

impl wkt::message::Message for Entrypoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Entrypoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entrypoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shell,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entrypoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shell" => Ok(__FieldTag::__shell),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entrypoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entrypoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shell => {
                            if !fields.insert(__FieldTag::__shell) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shell",
                                ));
                            }
                            if result.command.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `command`, a oneof with full ID .google.appengine.v1.Entrypoint.shell, latest field was shell",
                                ));
                            }
                            result.command = std::option::Option::Some(
                                crate::model::entrypoint::Command::Shell(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entrypoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.shell() {
            state.serialize_entry("shell", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Entrypoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entrypoint");
        debug_struct.field("command", &self.command);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Entrypoint].
pub mod entrypoint {
    #[allow(unused_imports)]
    use super::*;

    /// The command to run.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Command {
        /// The format should be a shell command that can be fed to `bash -c`.
        Shell(std::string::String),
    }
}

/// Actions to take when the user is not logged in.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthFailAction {
    /// Not specified. `AUTH_FAIL_ACTION_REDIRECT` is assumed.
    Unspecified,
    /// Redirects user to "accounts.google.com". The user is redirected back to the
    /// application URL after signing in or creating an account.
    Redirect,
    /// Rejects request with a `401` HTTP status code and an error
    /// message.
    Unauthorized,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthFailAction::value] or
    /// [AuthFailAction::name].
    UnknownValue(auth_fail_action::UnknownValue),
}

#[doc(hidden)]
pub mod auth_fail_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthFailAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Redirect => std::option::Option::Some(1),
            Self::Unauthorized => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTH_FAIL_ACTION_UNSPECIFIED"),
            Self::Redirect => std::option::Option::Some("AUTH_FAIL_ACTION_REDIRECT"),
            Self::Unauthorized => std::option::Option::Some("AUTH_FAIL_ACTION_UNAUTHORIZED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthFailAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthFailAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthFailAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Redirect,
            2 => Self::Unauthorized,
            _ => Self::UnknownValue(auth_fail_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthFailAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTH_FAIL_ACTION_UNSPECIFIED" => Self::Unspecified,
            "AUTH_FAIL_ACTION_REDIRECT" => Self::Redirect,
            "AUTH_FAIL_ACTION_UNAUTHORIZED" => Self::Unauthorized,
            _ => Self::UnknownValue(auth_fail_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthFailAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Redirect => serializer.serialize_i32(1),
            Self::Unauthorized => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthFailAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthFailAction>::new(
            ".google.appengine.v1.AuthFailAction",
        ))
    }
}

/// Methods to restrict access to a URL based on login status.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LoginRequirement {
    /// Not specified. `LOGIN_OPTIONAL` is assumed.
    LoginUnspecified,
    /// Does not require that the user is signed in.
    LoginOptional,
    /// If the user is not signed in, the `auth_fail_action` is taken.
    /// In addition, if the user is not an administrator for the
    /// application, they are given an error message regardless of
    /// `auth_fail_action`. If the user is an administrator, the handler
    /// proceeds.
    LoginAdmin,
    /// If the user has signed in, the handler proceeds normally. Otherwise, the
    /// auth_fail_action is taken.
    LoginRequired,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LoginRequirement::value] or
    /// [LoginRequirement::name].
    UnknownValue(login_requirement::UnknownValue),
}

#[doc(hidden)]
pub mod login_requirement {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LoginRequirement {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::LoginUnspecified => std::option::Option::Some(0),
            Self::LoginOptional => std::option::Option::Some(1),
            Self::LoginAdmin => std::option::Option::Some(2),
            Self::LoginRequired => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::LoginUnspecified => std::option::Option::Some("LOGIN_UNSPECIFIED"),
            Self::LoginOptional => std::option::Option::Some("LOGIN_OPTIONAL"),
            Self::LoginAdmin => std::option::Option::Some("LOGIN_ADMIN"),
            Self::LoginRequired => std::option::Option::Some("LOGIN_REQUIRED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LoginRequirement {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LoginRequirement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LoginRequirement {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::LoginUnspecified,
            1 => Self::LoginOptional,
            2 => Self::LoginAdmin,
            3 => Self::LoginRequired,
            _ => Self::UnknownValue(login_requirement::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LoginRequirement {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LOGIN_UNSPECIFIED" => Self::LoginUnspecified,
            "LOGIN_OPTIONAL" => Self::LoginOptional,
            "LOGIN_ADMIN" => Self::LoginAdmin,
            "LOGIN_REQUIRED" => Self::LoginRequired,
            _ => Self::UnknownValue(login_requirement::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LoginRequirement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::LoginUnspecified => serializer.serialize_i32(0),
            Self::LoginOptional => serializer.serialize_i32(1),
            Self::LoginAdmin => serializer.serialize_i32(2),
            Self::LoginRequired => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LoginRequirement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoginRequirement>::new(
            ".google.appengine.v1.LoginRequirement",
        ))
    }
}

/// Methods to enforce security (HTTPS) on a URL.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecurityLevel {
    /// Not specified.
    SecureUnspecified,
    /// Both HTTP and HTTPS requests with URLs that match the handler succeed
    /// without redirects. The application can examine the request to determine
    /// which protocol was used, and respond accordingly.
    SecureDefault,
    /// Requests for a URL that match this handler that use HTTPS are automatically
    /// redirected to the HTTP equivalent URL.
    SecureNever,
    /// Both HTTP and HTTPS requests with URLs that match the handler succeed
    /// without redirects. The application can examine the request to determine
    /// which protocol was used and respond accordingly.
    SecureOptional,
    /// Requests for a URL that match this handler that do not use HTTPS are
    /// automatically redirected to the HTTPS URL with the same path. Query
    /// parameters are reserved for the redirect.
    SecureAlways,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecurityLevel::value] or
    /// [SecurityLevel::name].
    UnknownValue(security_level::UnknownValue),
}

#[doc(hidden)]
pub mod security_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecurityLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::SecureUnspecified => std::option::Option::Some(0),
            Self::SecureDefault => std::option::Option::Some(0),
            Self::SecureNever => std::option::Option::Some(1),
            Self::SecureOptional => std::option::Option::Some(2),
            Self::SecureAlways => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::SecureUnspecified => std::option::Option::Some("SECURE_UNSPECIFIED"),
            Self::SecureDefault => std::option::Option::Some("SECURE_DEFAULT"),
            Self::SecureNever => std::option::Option::Some("SECURE_NEVER"),
            Self::SecureOptional => std::option::Option::Some("SECURE_OPTIONAL"),
            Self::SecureAlways => std::option::Option::Some("SECURE_ALWAYS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecurityLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecurityLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecurityLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::SecureDefault,
            1 => Self::SecureNever,
            2 => Self::SecureOptional,
            3 => Self::SecureAlways,
            _ => Self::UnknownValue(security_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SecurityLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECURE_UNSPECIFIED" => Self::SecureUnspecified,
            "SECURE_DEFAULT" => Self::SecureDefault,
            "SECURE_NEVER" => Self::SecureNever,
            "SECURE_OPTIONAL" => Self::SecureOptional,
            "SECURE_ALWAYS" => Self::SecureAlways,
            _ => Self::UnknownValue(security_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SecurityLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::SecureUnspecified => serializer.serialize_i32(0),
            Self::SecureDefault => serializer.serialize_i32(0),
            Self::SecureNever => serializer.serialize_i32(1),
            Self::SecureOptional => serializer.serialize_i32(2),
            Self::SecureAlways => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecurityLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecurityLevel>::new(
            ".google.appengine.v1.SecurityLevel",
        ))
    }
}

/// Fields that should be returned when [Version][google.appengine.v1.Version] resources
/// are retrieved.
///
/// [google.appengine.v1.Version]: crate::model::Version
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum VersionView {
    /// Basic version information including scaling and inbound services,
    /// but not detailed deployment information.
    Basic,
    /// The information from `BASIC`, plus detailed information about the
    /// deployment. This format is required when creating resources, but
    /// is not returned in `Get` or `List` by default.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [VersionView::value] or
    /// [VersionView::name].
    UnknownValue(version_view::UnknownValue),
}

#[doc(hidden)]
pub mod version_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl VersionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Basic => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for VersionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for VersionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for VersionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Basic,
            1 => Self::Full,
            _ => Self::UnknownValue(version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for VersionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for VersionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Basic => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for VersionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionView>::new(
            ".google.appengine.v1.VersionView",
        ))
    }
}

/// Fields that should be returned when an AuthorizedCertificate resource is
/// retrieved.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthorizedCertificateView {
    /// Basic certificate information, including applicable domains and expiration
    /// date.
    BasicCertificate,
    /// The information from `BASIC_CERTIFICATE`, plus detailed information on the
    /// domain mappings that have this certificate mapped.
    FullCertificate,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthorizedCertificateView::value] or
    /// [AuthorizedCertificateView::name].
    UnknownValue(authorized_certificate_view::UnknownValue),
}

#[doc(hidden)]
pub mod authorized_certificate_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthorizedCertificateView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::BasicCertificate => std::option::Option::Some(0),
            Self::FullCertificate => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::BasicCertificate => std::option::Option::Some("BASIC_CERTIFICATE"),
            Self::FullCertificate => std::option::Option::Some("FULL_CERTIFICATE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthorizedCertificateView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthorizedCertificateView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthorizedCertificateView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::BasicCertificate,
            1 => Self::FullCertificate,
            _ => Self::UnknownValue(authorized_certificate_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthorizedCertificateView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BASIC_CERTIFICATE" => Self::BasicCertificate,
            "FULL_CERTIFICATE" => Self::FullCertificate,
            _ => Self::UnknownValue(authorized_certificate_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthorizedCertificateView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BasicCertificate => serializer.serialize_i32(0),
            Self::FullCertificate => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthorizedCertificateView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<AuthorizedCertificateView>::new(
                ".google.appengine.v1.AuthorizedCertificateView",
            ),
        )
    }
}

/// Override strategy for mutating an existing mapping.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DomainOverrideStrategy {
    /// Strategy unspecified. Defaults to `STRICT`.
    UnspecifiedDomainOverrideStrategy,
    /// Overrides not allowed. If a mapping already exists for the
    /// specified domain, the request will return an ALREADY_EXISTS (409).
    Strict,
    /// Overrides allowed. If a mapping already exists for the specified domain,
    /// the request will overwrite it. Note that this might stop another
    /// Google product from serving. For example, if the domain is
    /// mapped to another App Engine application, that app will no
    /// longer serve from that domain.
    Override,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DomainOverrideStrategy::value] or
    /// [DomainOverrideStrategy::name].
    UnknownValue(domain_override_strategy::UnknownValue),
}

#[doc(hidden)]
pub mod domain_override_strategy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DomainOverrideStrategy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::UnspecifiedDomainOverrideStrategy => std::option::Option::Some(0),
            Self::Strict => std::option::Option::Some(1),
            Self::Override => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::UnspecifiedDomainOverrideStrategy => {
                std::option::Option::Some("UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY")
            }
            Self::Strict => std::option::Option::Some("STRICT"),
            Self::Override => std::option::Option::Some("OVERRIDE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DomainOverrideStrategy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DomainOverrideStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DomainOverrideStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::UnspecifiedDomainOverrideStrategy,
            1 => Self::Strict,
            2 => Self::Override,
            _ => Self::UnknownValue(domain_override_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DomainOverrideStrategy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY" => Self::UnspecifiedDomainOverrideStrategy,
            "STRICT" => Self::Strict,
            "OVERRIDE" => Self::Override,
            _ => Self::UnknownValue(domain_override_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DomainOverrideStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::UnspecifiedDomainOverrideStrategy => serializer.serialize_i32(0),
            Self::Strict => serializer.serialize_i32(1),
            Self::Override => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DomainOverrideStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DomainOverrideStrategy>::new(
            ".google.appengine.v1.DomainOverrideStrategy",
        ))
    }
}

/// State of certificate management. Refers to the most recent certificate
/// acquisition or renewal attempt.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ManagementStatus {
    Unspecified,
    /// Certificate was successfully obtained and inserted into the serving
    /// system.
    Ok,
    /// Certificate is under active attempts to acquire or renew.
    Pending,
    /// Most recent renewal failed due to an invalid DNS setup and will be
    /// retried. Renewal attempts will continue to fail until the certificate
    /// domain's DNS configuration is fixed. The last successfully provisioned
    /// certificate may still be serving.
    FailedRetryingNotVisible,
    /// All renewal attempts have been exhausted, likely due to an invalid DNS
    /// setup.
    FailedPermanent,
    /// Most recent renewal failed due to an explicit CAA record that does not
    /// include one of the in-use CAs (Google CA and Let's Encrypt). Renewals will
    /// continue to fail until the CAA is reconfigured. The last successfully
    /// provisioned certificate may still be serving.
    FailedRetryingCaaForbidden,
    /// Most recent renewal failed due to a CAA retrieval failure. This means that
    /// the domain's DNS provider does not properly handle CAA records, failing
    /// requests for CAA records when no CAA records are defined. Renewals will
    /// continue to fail until the DNS provider is changed or a CAA record is
    /// added for the given domain. The last successfully provisioned certificate
    /// may still be serving.
    FailedRetryingCaaChecking,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ManagementStatus::value] or
    /// [ManagementStatus::name].
    UnknownValue(management_status::UnknownValue),
}

#[doc(hidden)]
pub mod management_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ManagementStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ok => std::option::Option::Some(1),
            Self::Pending => std::option::Option::Some(2),
            Self::FailedRetryingNotVisible => std::option::Option::Some(4),
            Self::FailedPermanent => std::option::Option::Some(6),
            Self::FailedRetryingCaaForbidden => std::option::Option::Some(7),
            Self::FailedRetryingCaaChecking => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MANAGEMENT_STATUS_UNSPECIFIED"),
            Self::Ok => std::option::Option::Some("OK"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::FailedRetryingNotVisible => {
                std::option::Option::Some("FAILED_RETRYING_NOT_VISIBLE")
            }
            Self::FailedPermanent => std::option::Option::Some("FAILED_PERMANENT"),
            Self::FailedRetryingCaaForbidden => {
                std::option::Option::Some("FAILED_RETRYING_CAA_FORBIDDEN")
            }
            Self::FailedRetryingCaaChecking => {
                std::option::Option::Some("FAILED_RETRYING_CAA_CHECKING")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ManagementStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ManagementStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ManagementStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ok,
            2 => Self::Pending,
            4 => Self::FailedRetryingNotVisible,
            6 => Self::FailedPermanent,
            7 => Self::FailedRetryingCaaForbidden,
            8 => Self::FailedRetryingCaaChecking,
            _ => Self::UnknownValue(management_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ManagementStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MANAGEMENT_STATUS_UNSPECIFIED" => Self::Unspecified,
            "OK" => Self::Ok,
            "PENDING" => Self::Pending,
            "FAILED_RETRYING_NOT_VISIBLE" => Self::FailedRetryingNotVisible,
            "FAILED_PERMANENT" => Self::FailedPermanent,
            "FAILED_RETRYING_CAA_FORBIDDEN" => Self::FailedRetryingCaaForbidden,
            "FAILED_RETRYING_CAA_CHECKING" => Self::FailedRetryingCaaChecking,
            _ => Self::UnknownValue(management_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ManagementStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ok => serializer.serialize_i32(1),
            Self::Pending => serializer.serialize_i32(2),
            Self::FailedRetryingNotVisible => serializer.serialize_i32(4),
            Self::FailedPermanent => serializer.serialize_i32(6),
            Self::FailedRetryingCaaForbidden => serializer.serialize_i32(7),
            Self::FailedRetryingCaaChecking => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ManagementStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagementStatus>::new(
            ".google.appengine.v1.ManagementStatus",
        ))
    }
}

/// Available inbound services.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InboundServiceType {
    /// Not specified.
    InboundServiceUnspecified,
    /// Allows an application to receive mail.
    InboundServiceMail,
    /// Allows an application to receive email-bound notifications.
    InboundServiceMailBounce,
    /// Allows an application to receive error stanzas.
    InboundServiceXmppError,
    /// Allows an application to receive instant messages.
    InboundServiceXmppMessage,
    /// Allows an application to receive user subscription POSTs.
    InboundServiceXmppSubscribe,
    /// Allows an application to receive a user's chat presence.
    InboundServiceXmppPresence,
    /// Registers an application for notifications when a client connects or
    /// disconnects from a channel.
    InboundServiceChannelPresence,
    /// Enables warmup requests.
    InboundServiceWarmup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InboundServiceType::value] or
    /// [InboundServiceType::name].
    UnknownValue(inbound_service_type::UnknownValue),
}

#[doc(hidden)]
pub mod inbound_service_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InboundServiceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::InboundServiceUnspecified => std::option::Option::Some(0),
            Self::InboundServiceMail => std::option::Option::Some(1),
            Self::InboundServiceMailBounce => std::option::Option::Some(2),
            Self::InboundServiceXmppError => std::option::Option::Some(3),
            Self::InboundServiceXmppMessage => std::option::Option::Some(4),
            Self::InboundServiceXmppSubscribe => std::option::Option::Some(5),
            Self::InboundServiceXmppPresence => std::option::Option::Some(6),
            Self::InboundServiceChannelPresence => std::option::Option::Some(7),
            Self::InboundServiceWarmup => std::option::Option::Some(9),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::InboundServiceUnspecified => {
                std::option::Option::Some("INBOUND_SERVICE_UNSPECIFIED")
            }
            Self::InboundServiceMail => std::option::Option::Some("INBOUND_SERVICE_MAIL"),
            Self::InboundServiceMailBounce => {
                std::option::Option::Some("INBOUND_SERVICE_MAIL_BOUNCE")
            }
            Self::InboundServiceXmppError => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_ERROR")
            }
            Self::InboundServiceXmppMessage => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_MESSAGE")
            }
            Self::InboundServiceXmppSubscribe => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_SUBSCRIBE")
            }
            Self::InboundServiceXmppPresence => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_PRESENCE")
            }
            Self::InboundServiceChannelPresence => {
                std::option::Option::Some("INBOUND_SERVICE_CHANNEL_PRESENCE")
            }
            Self::InboundServiceWarmup => std::option::Option::Some("INBOUND_SERVICE_WARMUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InboundServiceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InboundServiceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InboundServiceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::InboundServiceUnspecified,
            1 => Self::InboundServiceMail,
            2 => Self::InboundServiceMailBounce,
            3 => Self::InboundServiceXmppError,
            4 => Self::InboundServiceXmppMessage,
            5 => Self::InboundServiceXmppSubscribe,
            6 => Self::InboundServiceXmppPresence,
            7 => Self::InboundServiceChannelPresence,
            9 => Self::InboundServiceWarmup,
            _ => Self::UnknownValue(inbound_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InboundServiceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INBOUND_SERVICE_UNSPECIFIED" => Self::InboundServiceUnspecified,
            "INBOUND_SERVICE_MAIL" => Self::InboundServiceMail,
            "INBOUND_SERVICE_MAIL_BOUNCE" => Self::InboundServiceMailBounce,
            "INBOUND_SERVICE_XMPP_ERROR" => Self::InboundServiceXmppError,
            "INBOUND_SERVICE_XMPP_MESSAGE" => Self::InboundServiceXmppMessage,
            "INBOUND_SERVICE_XMPP_SUBSCRIBE" => Self::InboundServiceXmppSubscribe,
            "INBOUND_SERVICE_XMPP_PRESENCE" => Self::InboundServiceXmppPresence,
            "INBOUND_SERVICE_CHANNEL_PRESENCE" => Self::InboundServiceChannelPresence,
            "INBOUND_SERVICE_WARMUP" => Self::InboundServiceWarmup,
            _ => Self::UnknownValue(inbound_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InboundServiceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::InboundServiceUnspecified => serializer.serialize_i32(0),
            Self::InboundServiceMail => serializer.serialize_i32(1),
            Self::InboundServiceMailBounce => serializer.serialize_i32(2),
            Self::InboundServiceXmppError => serializer.serialize_i32(3),
            Self::InboundServiceXmppMessage => serializer.serialize_i32(4),
            Self::InboundServiceXmppSubscribe => serializer.serialize_i32(5),
            Self::InboundServiceXmppPresence => serializer.serialize_i32(6),
            Self::InboundServiceChannelPresence => serializer.serialize_i32(7),
            Self::InboundServiceWarmup => serializer.serialize_i32(9),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InboundServiceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InboundServiceType>::new(
            ".google.appengine.v1.InboundServiceType",
        ))
    }
}

/// Run states of a version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ServingStatus {
    /// Not specified.
    Unspecified,
    /// Currently serving. Instances are created according to the
    /// scaling settings of the version.
    Serving,
    /// Disabled. No instances will be created and the scaling
    /// settings are ignored until the state of the version changes
    /// to `SERVING`.
    Stopped,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ServingStatus::value] or
    /// [ServingStatus::name].
    UnknownValue(serving_status::UnknownValue),
}

#[doc(hidden)]
pub mod serving_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ServingStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Serving => std::option::Option::Some(1),
            Self::Stopped => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SERVING_STATUS_UNSPECIFIED"),
            Self::Serving => std::option::Option::Some("SERVING"),
            Self::Stopped => std::option::Option::Some("STOPPED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ServingStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ServingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ServingStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Serving,
            2 => Self::Stopped,
            _ => Self::UnknownValue(serving_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ServingStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SERVING_STATUS_UNSPECIFIED" => Self::Unspecified,
            "SERVING" => Self::Serving,
            "STOPPED" => Self::Stopped,
            _ => Self::UnknownValue(serving_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ServingStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Serving => serializer.serialize_i32(1),
            Self::Stopped => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ServingStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServingStatus>::new(
            ".google.appengine.v1.ServingStatus",
        ))
    }
}
