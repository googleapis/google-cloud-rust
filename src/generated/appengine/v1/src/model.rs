// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/)
/// configuration for API handlers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiConfigHandler {
    /// Action to take when users access resources that require
    /// authentication. Defaults to `redirect`.
    pub auth_fail_action: crate::model::AuthFailAction,

    /// Level of login required to access this resource. Defaults to
    /// `optional`.
    pub login: crate::model::LoginRequirement,

    /// Path to the script from the application root directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,

    /// Security (HTTPS) enforcement for this URL.
    pub security_level: crate::model::SecurityLevel,

    /// URL to serve the endpoint at.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiConfigHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_fail_action][crate::model::ApiConfigHandler::auth_fail_action].
    pub fn set_auth_fail_action<T: std::convert::Into<crate::model::AuthFailAction>>(
        mut self,
        v: T,
    ) -> Self {
        self.auth_fail_action = v.into();
        self
    }

    /// Sets the value of [login][crate::model::ApiConfigHandler::login].
    pub fn set_login<T: std::convert::Into<crate::model::LoginRequirement>>(
        mut self,
        v: T,
    ) -> Self {
        self.login = v.into();
        self
    }

    /// Sets the value of [script][crate::model::ApiConfigHandler::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::ApiConfigHandler::security_level].
    pub fn set_security_level<T: std::convert::Into<crate::model::SecurityLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [url][crate::model::ApiConfigHandler::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for ApiConfigHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ApiConfigHandler"
    }
}

/// Custom static error page to be served when an error occurs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorHandler {
    /// Error condition this handler applies to.
    pub error_code: crate::model::error_handler::ErrorCode,

    /// Static file content to be served for this error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub static_file: std::string::String,

    /// MIME type of file. Defaults to `text/html`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::ErrorHandler::error_code].
    pub fn set_error_code<T: std::convert::Into<crate::model::error_handler::ErrorCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [static_file][crate::model::ErrorHandler::static_file].
    pub fn set_static_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.static_file = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::ErrorHandler::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for ErrorHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ErrorHandler"
    }
}

/// Defines additional types related to [ErrorHandler].
pub mod error_handler {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ErrorCode(i32);

    impl ErrorCode {
        /// Not specified. ERROR_CODE_DEFAULT is assumed.
        pub const ERROR_CODE_UNSPECIFIED: ErrorCode = ErrorCode::new(0);

        /// All other error types.
        pub const ERROR_CODE_DEFAULT: ErrorCode = ErrorCode::new(0);

        /// Application has exceeded a resource quota.
        pub const ERROR_CODE_OVER_QUOTA: ErrorCode = ErrorCode::new(1);

        /// Client blocked by the application's Denial of Service protection
        /// configuration.
        pub const ERROR_CODE_DOS_API_DENIAL: ErrorCode = ErrorCode::new(2);

        /// Deadline reached before the application responds.
        pub const ERROR_CODE_TIMEOUT: ErrorCode = ErrorCode::new(3);

        /// Creates a new ErrorCode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ERROR_CODE_DEFAULT"),
                1 => std::borrow::Cow::Borrowed("ERROR_CODE_OVER_QUOTA"),
                2 => std::borrow::Cow::Borrowed("ERROR_CODE_DOS_API_DENIAL"),
                3 => std::borrow::Cow::Borrowed("ERROR_CODE_TIMEOUT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ERROR_CODE_UNSPECIFIED" => std::option::Option::Some(Self::ERROR_CODE_UNSPECIFIED),
                "ERROR_CODE_DEFAULT" => std::option::Option::Some(Self::ERROR_CODE_DEFAULT),
                "ERROR_CODE_OVER_QUOTA" => std::option::Option::Some(Self::ERROR_CODE_OVER_QUOTA),
                "ERROR_CODE_DOS_API_DENIAL" => {
                    std::option::Option::Some(Self::ERROR_CODE_DOS_API_DENIAL)
                }
                "ERROR_CODE_TIMEOUT" => std::option::Option::Some(Self::ERROR_CODE_TIMEOUT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// URL pattern and description of how the URL should be handled. App Engine can
/// handle URLs by executing application code or by serving static files
/// uploaded with the version, such as images, CSS, or JavaScript.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UrlMap {
    /// URL prefix. Uses regular expression syntax, which means regexp
    /// special characters must be escaped, but should not contain groupings.
    /// All URLs that begin with this prefix are handled by this handler, using the
    /// portion of the URL after the prefix as part of the file path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url_regex: std::string::String,

    /// Security (HTTPS) enforcement for this URL.
    pub security_level: crate::model::SecurityLevel,

    /// Level of login required to access this resource. Not supported for Node.js
    /// in the App Engine standard environment.
    pub login: crate::model::LoginRequirement,

    /// Action to take when users access resources that require
    /// authentication. Defaults to `redirect`.
    pub auth_fail_action: crate::model::AuthFailAction,

    /// `30x` code to use when performing redirects for the `secure` field.
    /// Defaults to `302`.
    pub redirect_http_response_code: crate::model::url_map::RedirectHttpResponseCode,

    /// Type of handler for this URL pattern.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub handler_type: std::option::Option<crate::model::url_map::HandlerType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UrlMap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url_regex][crate::model::UrlMap::url_regex].
    pub fn set_url_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url_regex = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::UrlMap::security_level].
    pub fn set_security_level<T: std::convert::Into<crate::model::SecurityLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [login][crate::model::UrlMap::login].
    pub fn set_login<T: std::convert::Into<crate::model::LoginRequirement>>(
        mut self,
        v: T,
    ) -> Self {
        self.login = v.into();
        self
    }

    /// Sets the value of [auth_fail_action][crate::model::UrlMap::auth_fail_action].
    pub fn set_auth_fail_action<T: std::convert::Into<crate::model::AuthFailAction>>(
        mut self,
        v: T,
    ) -> Self {
        self.auth_fail_action = v.into();
        self
    }

    /// Sets the value of [redirect_http_response_code][crate::model::UrlMap::redirect_http_response_code].
    pub fn set_redirect_http_response_code<
        T: std::convert::Into<crate::model::url_map::RedirectHttpResponseCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redirect_http_response_code = v.into();
        self
    }

    /// Sets the value of `handler_type`.
    pub fn set_handler_type<
        T: std::convert::Into<std::option::Option<crate::model::url_map::HandlerType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type = v.into();
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `StaticFiles`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_static_files(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticFilesHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::StaticFiles(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `Script`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_script(&self) -> std::option::Option<&std::boxed::Box<crate::model::ScriptHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::Script(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `ApiEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_api_endpoint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ApiEndpointHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::ApiEndpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `StaticFiles`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_static_files<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticFilesHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::StaticFiles(v.into()));
        self
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `Script`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_script<T: std::convert::Into<std::boxed::Box<crate::model::ScriptHandler>>>(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::Script(v.into()));
        self
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `ApiEndpoint`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_api_endpoint<
        T: std::convert::Into<std::boxed::Box<crate::model::ApiEndpointHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::ApiEndpoint(v.into()));
        self
    }
}

impl wkt::message::Message for UrlMap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UrlMap"
    }
}

/// Defines additional types related to [UrlMap].
pub mod url_map {
    #[allow(unused_imports)]
    use super::*;

    /// Redirect codes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RedirectHttpResponseCode(i32);

    impl RedirectHttpResponseCode {
        /// Not specified. `302` is assumed.
        pub const REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED: RedirectHttpResponseCode =
            RedirectHttpResponseCode::new(0);

        /// `301 Moved Permanently` code.
        pub const REDIRECT_HTTP_RESPONSE_CODE_301: RedirectHttpResponseCode =
            RedirectHttpResponseCode::new(1);

        /// `302 Moved Temporarily` code.
        pub const REDIRECT_HTTP_RESPONSE_CODE_302: RedirectHttpResponseCode =
            RedirectHttpResponseCode::new(2);

        /// `303 See Other` code.
        pub const REDIRECT_HTTP_RESPONSE_CODE_303: RedirectHttpResponseCode =
            RedirectHttpResponseCode::new(3);

        /// `307 Temporary Redirect` code.
        pub const REDIRECT_HTTP_RESPONSE_CODE_307: RedirectHttpResponseCode =
            RedirectHttpResponseCode::new(4);

        /// Creates a new RedirectHttpResponseCode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REDIRECT_HTTP_RESPONSE_CODE_301"),
                2 => std::borrow::Cow::Borrowed("REDIRECT_HTTP_RESPONSE_CODE_302"),
                3 => std::borrow::Cow::Borrowed("REDIRECT_HTTP_RESPONSE_CODE_303"),
                4 => std::borrow::Cow::Borrowed("REDIRECT_HTTP_RESPONSE_CODE_307"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED)
                }
                "REDIRECT_HTTP_RESPONSE_CODE_301" => {
                    std::option::Option::Some(Self::REDIRECT_HTTP_RESPONSE_CODE_301)
                }
                "REDIRECT_HTTP_RESPONSE_CODE_302" => {
                    std::option::Option::Some(Self::REDIRECT_HTTP_RESPONSE_CODE_302)
                }
                "REDIRECT_HTTP_RESPONSE_CODE_303" => {
                    std::option::Option::Some(Self::REDIRECT_HTTP_RESPONSE_CODE_303)
                }
                "REDIRECT_HTTP_RESPONSE_CODE_307" => {
                    std::option::Option::Some(Self::REDIRECT_HTTP_RESPONSE_CODE_307)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RedirectHttpResponseCode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RedirectHttpResponseCode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of handler for this URL pattern.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum HandlerType {
        /// Returns the contents of a file, such as an image, as the response.
        StaticFiles(std::boxed::Box<crate::model::StaticFilesHandler>),
        /// Executes a script to handle the requests that match this URL
        /// pattern. Only the `auto` value is supported for Node.js in the
        /// App Engine standard environment, for example `"script": "auto"`.
        Script(std::boxed::Box<crate::model::ScriptHandler>),
        /// Uses API Endpoints to handle requests.
        ApiEndpoint(std::boxed::Box<crate::model::ApiEndpointHandler>),
    }
}

/// Files served directly to the user for a given URL, such as images, CSS
/// stylesheets, or JavaScript source files. Static file handlers describe which
/// files in the application directory are static files, and which URLs serve
/// them.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticFilesHandler {
    /// Path to the static files matched by the URL pattern, from the
    /// application root directory. The path can refer to text matched in groupings
    /// in the URL pattern.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Regular expression that matches the file paths for all files that should be
    /// referenced by this handler.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upload_path_regex: std::string::String,

    /// HTTP headers to use for all responses from these URLs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub http_headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// MIME type used to serve all files served by this handler.
    ///
    /// Defaults to file-specific MIME types, which are derived from each file's
    /// filename extension.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Time a static file served by this handler should be cached
    /// by web proxies and browsers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<wkt::Duration>,

    /// Whether this handler should match the request if the file
    /// referenced by the handler does not exist.
    pub require_matching_file: bool,

    /// Whether files should also be uploaded as code data. By default, files
    /// declared in static file handlers are uploaded as static
    /// data and are only served to end users; they cannot be read by the
    /// application. If enabled, uploads are charged against both your code and
    /// static data storage resource quotas.
    pub application_readable: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticFilesHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::StaticFilesHandler::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [upload_path_regex][crate::model::StaticFilesHandler::upload_path_regex].
    pub fn set_upload_path_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.upload_path_regex = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::StaticFilesHandler::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [expiration][crate::model::StaticFilesHandler::expiration].
    pub fn set_expiration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// Sets the value of [require_matching_file][crate::model::StaticFilesHandler::require_matching_file].
    pub fn set_require_matching_file<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_matching_file = v.into();
        self
    }

    /// Sets the value of [application_readable][crate::model::StaticFilesHandler::application_readable].
    pub fn set_application_readable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.application_readable = v.into();
        self
    }

    /// Sets the value of [http_headers][crate::model::StaticFilesHandler::http_headers].
    pub fn set_http_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.http_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for StaticFilesHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.StaticFilesHandler"
    }
}

/// Executes a script to handle the request that matches the URL pattern.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScriptHandler {
    /// Path to the script from the application root directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScriptHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_path][crate::model::ScriptHandler::script_path].
    pub fn set_script_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_path = v.into();
        self
    }
}

impl wkt::message::Message for ScriptHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ScriptHandler"
    }
}

/// Uses Google Cloud Endpoints to handle requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiEndpointHandler {
    /// Path to the script from the application root directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiEndpointHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_path][crate::model::ApiEndpointHandler::script_path].
    pub fn set_script_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_path = v.into();
        self
    }
}

impl wkt::message::Message for ApiEndpointHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ApiEndpointHandler"
    }
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances. Only applicable for
/// instances in App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HealthCheck {
    /// Whether to explicitly disable health checks for this instance.
    pub disable_health_check: bool,

    /// Host header to send when performing an HTTP health check.
    /// Example: "myapp.appspot.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Number of consecutive successful health checks required before receiving
    /// traffic.
    pub healthy_threshold: u32,

    /// Number of consecutive failed health checks required before removing
    /// traffic.
    pub unhealthy_threshold: u32,

    /// Number of consecutive failed health checks required before an instance is
    /// restarted.
    pub restart_threshold: u32,

    /// Interval between health checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the health check is considered failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HealthCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_health_check][crate::model::HealthCheck::disable_health_check].
    pub fn set_disable_health_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_health_check = v.into();
        self
    }

    /// Sets the value of [host][crate::model::HealthCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [healthy_threshold][crate::model::HealthCheck::healthy_threshold].
    pub fn set_healthy_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.healthy_threshold = v.into();
        self
    }

    /// Sets the value of [unhealthy_threshold][crate::model::HealthCheck::unhealthy_threshold].
    pub fn set_unhealthy_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.unhealthy_threshold = v.into();
        self
    }

    /// Sets the value of [restart_threshold][crate::model::HealthCheck::restart_threshold].
    pub fn set_restart_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.restart_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::HealthCheck::check_interval].
    pub fn set_check_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.check_interval = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::HealthCheck::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }
}

impl wkt::message::Message for HealthCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.HealthCheck"
    }
}

/// Readiness checking configuration for VM instances. Unhealthy instances
/// are removed from traffic rotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadinessCheck {
    /// The request path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Host header to send when performing a HTTP Readiness check.
    /// Example: "myapp.appspot.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Number of consecutive failed checks required before removing
    /// traffic.
    pub failure_threshold: u32,

    /// Number of consecutive successful checks required before receiving
    /// traffic.
    pub success_threshold: u32,

    /// Interval between health checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the check is considered failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// A maximum time limit on application initialization, measured from moment
    /// the application successfully replies to a healthcheck until it is ready to
    /// serve traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_start_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadinessCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::ReadinessCheck::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [host][crate::model::ReadinessCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::ReadinessCheck::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::ReadinessCheck::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::ReadinessCheck::check_interval].
    pub fn set_check_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.check_interval = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::ReadinessCheck::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [app_start_timeout][crate::model::ReadinessCheck::app_start_timeout].
    pub fn set_app_start_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.app_start_timeout = v.into();
        self
    }
}

impl wkt::message::Message for ReadinessCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ReadinessCheck"
    }
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LivenessCheck {
    /// The request path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Host header to send when performing a HTTP Liveness check.
    /// Example: "myapp.appspot.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Number of consecutive failed checks required before considering the
    /// VM unhealthy.
    pub failure_threshold: u32,

    /// Number of consecutive successful checks required before considering
    /// the VM healthy.
    pub success_threshold: u32,

    /// Interval between health checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the check is considered failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// The initial delay before starting to execute the checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initial_delay: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LivenessCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::LivenessCheck::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [host][crate::model::LivenessCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::LivenessCheck::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::LivenessCheck::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::LivenessCheck::check_interval].
    pub fn set_check_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.check_interval = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::LivenessCheck::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [initial_delay][crate::model::LivenessCheck::initial_delay].
    pub fn set_initial_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.initial_delay = v.into();
        self
    }
}

impl wkt::message::Message for LivenessCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.LivenessCheck"
    }
}

/// Third-party Python runtime library that is required by the application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Library {
    /// Name of the library. Example: "django".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Version of the library to select, or "latest".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Library {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Library::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Library::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Library {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Library"
    }
}

/// Request message for `Applications.GetApplication`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetApplicationRequest {
    /// Name of the Application resource to get. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetApplicationRequest"
    }
}

/// Request message for `Applications.CreateApplication`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateApplicationRequest {
    /// Application configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub application: std::option::Option<crate::model::Application>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application][crate::model::CreateApplicationRequest::application].
    pub fn set_application<
        T: std::convert::Into<std::option::Option<crate::model::Application>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.application = v.into();
        self
    }
}

impl wkt::message::Message for CreateApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateApplicationRequest"
    }
}

/// Request message for `Applications.UpdateApplication`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateApplicationRequest {
    /// Name of the Application resource to update. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An Application containing the updated resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub application: std::option::Option<crate::model::Application>,

    /// Required. Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [application][crate::model::UpdateApplicationRequest::application].
    pub fn set_application<
        T: std::convert::Into<std::option::Option<crate::model::Application>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.application = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateApplicationRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateApplicationRequest"
    }
}

/// Request message for 'Applications.RepairApplication'.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairApplicationRequest {
    /// Name of the application to repair. Example: `apps/myapp`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RepairApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RepairApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.RepairApplicationRequest"
    }
}

/// Request message for `Services.ListServices`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListServicesRequest"
    }
}

/// Response message for `Services.ListServices`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The services belonging to the requested application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<crate::model::Service>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Services.GetService`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Name of the resource requested. Example: `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetServiceRequest"
    }
}

/// Request message for `Services.UpdateService`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Name of the resource to update. Example: `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A Service resource containing the updated service. Only fields set in the
    /// field mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    /// Required. Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Set to `true` to gradually shift traffic to one or more versions that you
    /// specify. By default, traffic is shifted immediately.
    /// For gradual traffic migration, the target versions
    /// must be located within instances that are configured for both
    /// [warmup requests](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#InboundServiceType)
    /// and
    /// [automatic scaling](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#AutomaticScaling).
    /// You must specify the
    /// [`shardBy`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services#ShardBy)
    /// field in the Service resource. Gradual traffic migration is not
    /// supported in the App Engine flexible environment. For examples, see
    /// [Migrating and Splitting Traffic](https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic).
    pub migrate_traffic: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [migrate_traffic][crate::model::UpdateServiceRequest::migrate_traffic].
    pub fn set_migrate_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.migrate_traffic = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateServiceRequest"
    }
}

/// Request message for `Services.DeleteService`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Name of the resource requested. Example: `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteServiceRequest"
    }
}

/// Request message for `Versions.ListVersions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Name of the parent Service resource. Example:
    /// `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Controls the set of fields returned in the `List` response.
    pub view: crate::model::VersionView,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListVersionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListVersionsRequest"
    }
}

/// Response message for `Versions.ListVersions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The versions belonging to the requested service.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Versions.GetVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Controls the set of fields returned in the `Get` response.
    pub view: crate::model::VersionView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetVersionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetVersionRequest"
    }
}

/// Request message for `Versions.CreateVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Name of the parent resource to create this version under. Example:
    /// `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Application deployment configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::option::Option<crate::model::Version>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionRequest"
    }
}

/// Request message for `Versions.UpdateVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/services/default/versions/1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A Version containing the updated resource. Only fields set in the field
    /// mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    /// Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::option::Option<crate::model::Version>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateVersionRequest"
    }
}

/// Request message for `Versions.DeleteVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteVersionRequest"
    }
}

/// Request message for `Instances.ListInstances`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Name of the parent Version resource. Example:
    /// `apps/myapp/services/default/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListInstancesRequest"
    }
}

/// Response message for `Instances.ListInstances`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The instances belonging to the requested version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Instances.GetInstance`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetInstanceRequest"
    }
}

/// Request message for `Instances.DeleteInstance`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteInstanceRequest"
    }
}

/// Request message for `Instances.DebugInstance`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DebugInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Public SSH key to add to the instance. Examples:
    ///
    /// * `[USERNAME]:ssh-rsa [KEY_VALUE] [USERNAME]`
    /// * `[USERNAME]:ssh-rsa [KEY_VALUE] google-ssh {"userName":"[USERNAME]","expireOn":"[EXPIRE_TIME]"}`
    ///
    /// For more information, see
    /// [Adding and Removing SSH Keys](https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssh_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DebugInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DebugInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssh_key][crate::model::DebugInstanceRequest::ssh_key].
    pub fn set_ssh_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssh_key = v.into();
        self
    }
}

impl wkt::message::Message for DebugInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DebugInstanceRequest"
    }
}

/// Request message for `Firewall.ListIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIngressRulesRequest {
    /// Name of the Firewall collection to retrieve.
    /// Example: `apps/myapp/firewall/ingressRules`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A valid IP Address. If set, only rules matching this address will be
    /// returned. The first returned rule will be the rule that fires on requests
    /// from this IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub matching_address: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIngressRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIngressRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIngressRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIngressRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [matching_address][crate::model::ListIngressRulesRequest::matching_address].
    pub fn set_matching_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matching_address = v.into();
        self
    }
}

impl wkt::message::Message for ListIngressRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListIngressRulesRequest"
    }
}

/// Response message for `Firewall.ListIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIngressRulesResponse {
    /// The ingress FirewallRules for this application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIngressRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIngressRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [ingress_rules][crate::model::ListIngressRulesResponse::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIngressRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListIngressRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIngressRulesResponse {
    type PageItem = crate::model::FirewallRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ingress_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Firewall.BatchUpdateIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchUpdateIngressRulesRequest {
    /// Name of the Firewall collection to set.
    /// Example: `apps/myapp/firewall/ingressRules`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A list of FirewallRules to replace the existing set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateIngressRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchUpdateIngressRulesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ingress_rules][crate::model::BatchUpdateIngressRulesRequest::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateIngressRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BatchUpdateIngressRulesRequest"
    }
}

/// Response message for `Firewall.UpdateAllIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchUpdateIngressRulesResponse {
    /// The full list of ingress FirewallRules for this application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateIngressRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_rules][crate::model::BatchUpdateIngressRulesResponse::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateIngressRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BatchUpdateIngressRulesResponse"
    }
}

/// Request message for `Firewall.CreateIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIngressRuleRequest {
    /// Name of the parent Firewall collection in which to create a new rule.
    /// Example: `apps/myapp/firewall/ingressRules`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A FirewallRule containing the new resource.
    ///
    /// The user may optionally provide a position at which the new rule will be
    /// placed. The positions define a sequential list starting at 1. If a rule
    /// already exists at the given position, rules greater than the provided
    /// position will be moved forward by one.
    ///
    /// If no position is provided, the server will place the rule as the second to
    /// last rule in the sequence before the required default allow-all or deny-all
    /// rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::FirewallRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIngressRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::CreateIngressRuleRequest::rule].
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::FirewallRule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }
}

impl wkt::message::Message for CreateIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateIngressRuleRequest"
    }
}

/// Request message for `Firewall.GetIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIngressRuleRequest {
    /// Name of the Firewall resource to retrieve.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetIngressRuleRequest"
    }
}

/// Request message for `Firewall.UpdateIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIngressRuleRequest {
    /// Name of the Firewall resource to update.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A FirewallRule containing the updated resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::FirewallRule>,

    /// Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::UpdateIngressRuleRequest::rule].
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::FirewallRule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIngressRuleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateIngressRuleRequest"
    }
}

/// Request message for `Firewall.DeleteIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIngressRuleRequest {
    /// Name of the Firewall resource to delete.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteIngressRuleRequest"
    }
}

/// Request message for `AuthorizedDomains.ListAuthorizedDomains`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedDomainsRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedDomainsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedDomainsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedDomainsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedDomainsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedDomainsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedDomainsRequest"
    }
}

/// Response message for `AuthorizedDomains.ListAuthorizedDomains`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedDomainsResponse {
    /// The authorized domains belonging to the user.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domains: std::vec::Vec<crate::model::AuthorizedDomain>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedDomainsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedDomainsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [domains][crate::model::ListAuthorizedDomainsResponse::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedDomain>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAuthorizedDomainsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedDomainsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedDomainsResponse {
    type PageItem = crate::model::AuthorizedDomain;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domains
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AuthorizedCertificates.ListAuthorizedCertificates`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedCertificatesRequest {
    /// Name of the parent `Application` resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Controls the set of fields returned in the `LIST` response.
    pub view: crate::model::AuthorizedCertificateView,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedCertificatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedCertificatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAuthorizedCertificatesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AuthorizedCertificateView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedCertificatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedCertificatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedCertificatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedCertificatesRequest"
    }
}

/// Response message for `AuthorizedCertificates.ListAuthorizedCertificates`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedCertificatesResponse {
    /// The SSL certificates the user is authorized to administer.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificates: std::vec::Vec<crate::model::AuthorizedCertificate>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedCertificatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedCertificatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [certificates][crate::model::ListAuthorizedCertificatesResponse::certificates].
    pub fn set_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        use std::iter::Iterator;
        self.certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAuthorizedCertificatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedCertificatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedCertificatesResponse {
    type PageItem = crate::model::AuthorizedCertificate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AuthorizedCertificates.GetAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAuthorizedCertificateRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Controls the set of fields returned in the `GET` response.
    pub view: crate::model::AuthorizedCertificateView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAuthorizedCertificateRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AuthorizedCertificateView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetAuthorizedCertificateRequest"
    }
}

/// Request message for `AuthorizedCertificates.CreateAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAuthorizedCertificateRequest {
    /// Name of the parent `Application` resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// SSL certificate data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate: std::option::Option<crate::model::AuthorizedCertificate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAuthorizedCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::CreateAuthorizedCertificateRequest::certificate].
    pub fn set_certificate<
        T: std::convert::Into<std::option::Option<crate::model::AuthorizedCertificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate = v.into();
        self
    }
}

impl wkt::message::Message for CreateAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateAuthorizedCertificateRequest"
    }
}

/// Request message for `AuthorizedCertificates.UpdateAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAuthorizedCertificateRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An `AuthorizedCertificate` containing the updated resource. Only fields set
    /// in the field mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate: std::option::Option<crate::model::AuthorizedCertificate>,

    /// Standard field mask for the set of fields to be updated. Updates are only
    /// supported on the `certificate_raw_data` and `display_name` fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::UpdateAuthorizedCertificateRequest::certificate].
    pub fn set_certificate<
        T: std::convert::Into<std::option::Option<crate::model::AuthorizedCertificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAuthorizedCertificateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateAuthorizedCertificateRequest"
    }
}

/// Request message for `AuthorizedCertificates.DeleteAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAuthorizedCertificateRequest {
    /// Name of the resource to delete. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteAuthorizedCertificateRequest"
    }
}

/// Request message for `DomainMappings.ListDomainMappings`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainMappingsRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainMappingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDomainMappingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDomainMappingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDomainMappingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainMappingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListDomainMappingsRequest"
    }
}

/// Response message for `DomainMappings.ListDomainMappings`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainMappingsResponse {
    /// The domain mappings for the application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domain_mappings: std::vec::Vec<crate::model::DomainMapping>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainMappingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDomainMappingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [domain_mappings][crate::model::ListDomainMappingsResponse::domain_mappings].
    pub fn set_domain_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DomainMapping>,
    {
        use std::iter::Iterator;
        self.domain_mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDomainMappingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListDomainMappingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDomainMappingsResponse {
    type PageItem = crate::model::DomainMapping;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domain_mappings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `DomainMappings.GetDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDomainMappingRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/domainMappings/example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetDomainMappingRequest"
    }
}

/// Request message for `DomainMappings.CreateDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDomainMappingRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Domain mapping configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain_mapping: std::option::Option<crate::model::DomainMapping>,

    /// Whether the domain creation should override any existing mappings for this
    /// domain. By default, overrides are rejected.
    pub override_strategy: crate::model::DomainOverrideStrategy,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDomainMappingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [domain_mapping][crate::model::CreateDomainMappingRequest::domain_mapping].
    pub fn set_domain_mapping<
        T: std::convert::Into<std::option::Option<crate::model::DomainMapping>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.domain_mapping = v.into();
        self
    }

    /// Sets the value of [override_strategy][crate::model::CreateDomainMappingRequest::override_strategy].
    pub fn set_override_strategy<T: std::convert::Into<crate::model::DomainOverrideStrategy>>(
        mut self,
        v: T,
    ) -> Self {
        self.override_strategy = v.into();
        self
    }
}

impl wkt::message::Message for CreateDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateDomainMappingRequest"
    }
}

/// Request message for `DomainMappings.UpdateDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDomainMappingRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/domainMappings/example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A domain mapping containing the updated resource. Only fields set
    /// in the field mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain_mapping: std::option::Option<crate::model::DomainMapping>,

    /// Required. Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [domain_mapping][crate::model::UpdateDomainMappingRequest::domain_mapping].
    pub fn set_domain_mapping<
        T: std::convert::Into<std::option::Option<crate::model::DomainMapping>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.domain_mapping = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDomainMappingRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateDomainMappingRequest"
    }
}

/// Request message for `DomainMappings.DeleteDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDomainMappingRequest {
    /// Name of the resource to delete. Example:
    /// `apps/myapp/domainMappings/example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteDomainMappingRequest"
    }
}

/// An Application resource contains the top-level configuration of an App
/// Engine application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Application {
    /// Full path to the Application resource in the API.
    /// Example: `apps/myapp`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Identifier of the Application resource. This identifier is equivalent
    /// to the project ID of the Google Cloud Platform project where you want to
    /// deploy your application.
    /// Example: `myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// HTTP path dispatch rules for requests to the application that do not
    /// explicitly target a service or version. Rules are order-dependent.
    /// Up to 20 dispatch rules can be supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dispatch_rules: std::vec::Vec<crate::model::UrlDispatchRule>,

    /// Google Apps authentication domain that controls which users can access
    /// this application.
    ///
    /// Defaults to open access for any Google Account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub auth_domain: std::string::String,

    /// Location from which this application runs. Application instances
    /// run out of the data centers in the specified location, which is also where
    /// all of the application's end user content is stored.
    ///
    /// Defaults to `us-central`.
    ///
    /// View the list of
    /// [supported locations](https://cloud.google.com/appengine/docs/locations).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// Google Cloud Storage bucket that can be used for storing files
    /// associated with this application. This bucket is associated with the
    /// application and can be used by the gcloud deployment commands.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code_bucket: std::string::String,

    /// Cookie expiration policy for this application.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_cookie_expiration: std::option::Option<wkt::Duration>,

    /// Serving status of this application.
    pub serving_status: crate::model::application::ServingStatus,

    /// Hostname used to reach this application, as resolved by App Engine.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_hostname: std::string::String,

    /// Google Cloud Storage bucket that can be used by this application to store
    /// content.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_bucket: std::string::String,

    /// The service account associated with the application.
    /// This is the app-level default identity. If no identity provided during
    /// create version, Admin API will fallback to this one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub iap: std::option::Option<crate::model::application::IdentityAwareProxy>,

    /// The Google Container Registry domain used for storing managed build docker
    /// images for this application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcr_domain: std::string::String,

    /// The type of the Cloud Firestore or Cloud Datastore database associated with
    /// this application.
    pub database_type: crate::model::application::DatabaseType,

    /// The feature specific settings to be used in the application.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_settings: std::option::Option<crate::model::application::FeatureSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Application {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Application::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Application::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [auth_domain][crate::model::Application::auth_domain].
    pub fn set_auth_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.auth_domain = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::Application::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [code_bucket][crate::model::Application::code_bucket].
    pub fn set_code_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code_bucket = v.into();
        self
    }

    /// Sets the value of [default_cookie_expiration][crate::model::Application::default_cookie_expiration].
    pub fn set_default_cookie_expiration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_cookie_expiration = v.into();
        self
    }

    /// Sets the value of [serving_status][crate::model::Application::serving_status].
    pub fn set_serving_status<T: std::convert::Into<crate::model::application::ServingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_status = v.into();
        self
    }

    /// Sets the value of [default_hostname][crate::model::Application::default_hostname].
    pub fn set_default_hostname<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_hostname = v.into();
        self
    }

    /// Sets the value of [default_bucket][crate::model::Application::default_bucket].
    pub fn set_default_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_bucket = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Application::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [iap][crate::model::Application::iap].
    pub fn set_iap<
        T: std::convert::Into<std::option::Option<crate::model::application::IdentityAwareProxy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.iap = v.into();
        self
    }

    /// Sets the value of [gcr_domain][crate::model::Application::gcr_domain].
    pub fn set_gcr_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcr_domain = v.into();
        self
    }

    /// Sets the value of [database_type][crate::model::Application::database_type].
    pub fn set_database_type<T: std::convert::Into<crate::model::application::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_type = v.into();
        self
    }

    /// Sets the value of [feature_settings][crate::model::Application::feature_settings].
    pub fn set_feature_settings<
        T: std::convert::Into<std::option::Option<crate::model::application::FeatureSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_settings = v.into();
        self
    }

    /// Sets the value of [dispatch_rules][crate::model::Application::dispatch_rules].
    pub fn set_dispatch_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UrlDispatchRule>,
    {
        use std::iter::Iterator;
        self.dispatch_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Application {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Application"
    }
}

/// Defines additional types related to [Application].
pub mod application {
    #[allow(unused_imports)]
    use super::*;

    /// Identity-Aware Proxy
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IdentityAwareProxy {
        /// Whether the serving infrastructure will authenticate and
        /// authorize all incoming requests.
        ///
        /// If true, the `oauth2_client_id` and `oauth2_client_secret`
        /// fields must be non-empty.
        pub enabled: bool,

        /// OAuth2 client ID to use for the authentication flow.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub oauth2_client_id: std::string::String,

        /// OAuth2 client secret to use for the authentication flow.
        ///
        /// For security reasons, this value cannot be retrieved via the API.
        /// Instead, the SHA-256 hash of the value is returned in the
        /// `oauth2_client_secret_sha256` field.
        ///
        /// @InputOnly
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub oauth2_client_secret: std::string::String,

        /// Hex-encoded SHA-256 hash of the client secret.
        ///
        /// @OutputOnly
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub oauth2_client_secret_sha256: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IdentityAwareProxy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::application::IdentityAwareProxy::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [oauth2_client_id][crate::model::application::IdentityAwareProxy::oauth2_client_id].
        pub fn set_oauth2_client_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_id = v.into();
            self
        }

        /// Sets the value of [oauth2_client_secret][crate::model::application::IdentityAwareProxy::oauth2_client_secret].
        pub fn set_oauth2_client_secret<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_secret = v.into();
            self
        }

        /// Sets the value of [oauth2_client_secret_sha256][crate::model::application::IdentityAwareProxy::oauth2_client_secret_sha256].
        pub fn set_oauth2_client_secret_sha256<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_secret_sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for IdentityAwareProxy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Application.IdentityAwareProxy"
        }
    }

    /// The feature specific settings to be used in the application. These define
    /// behaviors that are user configurable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureSettings {
        /// Boolean value indicating if split health checks should be used instead
        /// of the legacy health checks. At an app.yaml level, this means defaulting
        /// to 'readiness_check' and 'liveness_check' values instead of
        /// 'health_check' ones. Once the legacy 'health_check' behavior is
        /// deprecated, and this value is always true, this setting can
        /// be removed.
        pub split_health_checks: bool,

        /// If true, use [Container-Optimized OS](https://cloud.google.com/container-optimized-os/)
        /// base image for VMs, rather than a base Debian image.
        pub use_container_optimized_os: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FeatureSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [split_health_checks][crate::model::application::FeatureSettings::split_health_checks].
        pub fn set_split_health_checks<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.split_health_checks = v.into();
            self
        }

        /// Sets the value of [use_container_optimized_os][crate::model::application::FeatureSettings::use_container_optimized_os].
        pub fn set_use_container_optimized_os<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_container_optimized_os = v.into();
            self
        }
    }

    impl wkt::message::Message for FeatureSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Application.FeatureSettings"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ServingStatus(i32);

    impl ServingStatus {
        /// Serving status is unspecified.
        pub const UNSPECIFIED: ServingStatus = ServingStatus::new(0);

        /// Application is serving.
        pub const SERVING: ServingStatus = ServingStatus::new(1);

        /// Application has been disabled by the user.
        pub const USER_DISABLED: ServingStatus = ServingStatus::new(2);

        /// Application has been disabled by the system.
        pub const SYSTEM_DISABLED: ServingStatus = ServingStatus::new(3);

        /// Creates a new ServingStatus instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SERVING"),
                2 => std::borrow::Cow::Borrowed("USER_DISABLED"),
                3 => std::borrow::Cow::Borrowed("SYSTEM_DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                "SERVING" => std::option::Option::Some(Self::SERVING),
                "USER_DISABLED" => std::option::Option::Some(Self::USER_DISABLED),
                "SYSTEM_DISABLED" => std::option::Option::Some(Self::SYSTEM_DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ServingStatus {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ServingStatus {
        fn default() -> Self {
            Self::new(0)
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatabaseType(i32);

    impl DatabaseType {
        /// Database type is unspecified.
        pub const DATABASE_TYPE_UNSPECIFIED: DatabaseType = DatabaseType::new(0);

        /// Cloud Datastore
        pub const CLOUD_DATASTORE: DatabaseType = DatabaseType::new(1);

        /// Cloud Firestore Native
        pub const CLOUD_FIRESTORE: DatabaseType = DatabaseType::new(2);

        /// Cloud Firestore in Datastore Mode
        pub const CLOUD_DATASTORE_COMPATIBILITY: DatabaseType = DatabaseType::new(3);

        /// Creates a new DatabaseType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATABASE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLOUD_DATASTORE"),
                2 => std::borrow::Cow::Borrowed("CLOUD_FIRESTORE"),
                3 => std::borrow::Cow::Borrowed("CLOUD_DATASTORE_COMPATIBILITY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATABASE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATABASE_TYPE_UNSPECIFIED)
                }
                "CLOUD_DATASTORE" => std::option::Option::Some(Self::CLOUD_DATASTORE),
                "CLOUD_FIRESTORE" => std::option::Option::Some(Self::CLOUD_FIRESTORE),
                "CLOUD_DATASTORE_COMPATIBILITY" => {
                    std::option::Option::Some(Self::CLOUD_DATASTORE_COMPATIBILITY)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Rules to match an HTTP request and dispatch that request to a service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UrlDispatchRule {
    /// Domain name to match against. The wildcard "`*`" is supported if
    /// specified before a period: "`*.`".
    ///
    /// Defaults to matching all domains: "`*`".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// Pathname within the host. Must start with a "`/`". A
    /// single "`*`" can be included at the end of the path.
    ///
    /// The sum of the lengths of the domain and path may not
    /// exceed 100 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Resource ID of a service in this application that should
    /// serve the matched request. The service must already
    /// exist. Example: `default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UrlDispatchRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::UrlDispatchRule::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [path][crate::model::UrlDispatchRule::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UrlDispatchRule::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for UrlDispatchRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UrlDispatchRule"
    }
}

/// App Engine admin service audit log.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuditData {
    /// Detailed information about methods that require it. Does not include
    /// simple Get, List or Delete methods because all significant information
    /// (resource name, number of returned elements for List operations) is already
    /// included in parent audit log message.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::audit_data::Method>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuditData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `method`.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::audit_data::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::AuditData::method]
    /// if it holds a `UpdateService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_update_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateServiceMethod>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::audit_data::Method::UpdateService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::AuditData::method]
    /// if it holds a `CreateVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_create_version(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateVersionMethod>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::audit_data::Method::CreateVersion(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::AuditData::method]
    /// to hold a `UpdateService`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_update_service<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateServiceMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::audit_data::Method::UpdateService(v.into()));
        self
    }

    /// Sets the value of [method][crate::model::AuditData::method]
    /// to hold a `CreateVersion`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_create_version<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateVersionMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::audit_data::Method::CreateVersion(v.into()));
        self
    }
}

impl wkt::message::Message for AuditData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuditData"
    }
}

/// Defines additional types related to [AuditData].
pub mod audit_data {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed information about methods that require it. Does not include
    /// simple Get, List or Delete methods because all significant information
    /// (resource name, number of returned elements for List operations) is already
    /// included in parent audit log message.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// Detailed information about UpdateService call.
        UpdateService(std::boxed::Box<crate::model::UpdateServiceMethod>),
        /// Detailed information about CreateVersion call.
        CreateVersion(std::boxed::Box<crate::model::CreateVersionMethod>),
    }
}

/// Detailed information about UpdateService call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceMethod {
    /// Update service request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::UpdateServiceRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceMethod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::UpdateServiceMethod::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::UpdateServiceRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceMethod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateServiceMethod"
    }
}

/// Detailed information about CreateVersion call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVersionMethod {
    /// Create version request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::CreateVersionRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionMethod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::CreateVersionMethod::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::CreateVersionRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionMethod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionMethod"
    }
}

/// An SSL certificate that a user has been authorized to administer. A user
/// is authorized to administer any certificate that applies to one of their
/// authorized domains.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthorizedCertificate {
    /// Full path to the `AuthorizedCertificate` resource in the API. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the certificate. This is a unique value autogenerated
    /// on `AuthorizedCertificate` resource creation. Example: `12345`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The user-specified display name of the certificate. This is not
    /// guaranteed to be unique. Example: `My Certificate`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Topmost applicable domains of this certificate. This certificate
    /// applies to these domains and their subdomains. Example: `example.com`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domain_names: std::vec::Vec<std::string::String>,

    /// The time when this certificate expires. To update the renewal time on this
    /// certificate, upload an SSL certificate with a different expiration time
    /// using [`AuthorizedCertificates.UpdateAuthorizedCertificate`]().
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The SSL certificate serving the `AuthorizedCertificate` resource. This
    /// must be obtained independently from a certificate authority.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_raw_data: std::option::Option<crate::model::CertificateRawData>,

    /// Only applicable if this certificate is managed by App Engine. Managed
    /// certificates are tied to the lifecycle of a `DomainMapping` and cannot be
    /// updated or deleted via the `AuthorizedCertificates` API. If this
    /// certificate is manually administered by the user, this field will be empty.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub managed_certificate: std::option::Option<crate::model::ManagedCertificate>,

    /// The full paths to user visible Domain Mapping resources that have this
    /// certificate mapped. Example: `apps/myapp/domainMappings/example.com`.
    ///
    /// This may not represent the full list of mapped domain mappings if the user
    /// does not have `VIEWER` permissions on all of the applications that have
    /// this certificate mapped. See `domain_mappings_count` for a complete count.
    ///
    /// Only returned by `GET` or `LIST` requests when specifically requested by
    /// the `view=FULL_CERTIFICATE` option.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub visible_domain_mappings: std::vec::Vec<std::string::String>,

    /// Aggregate count of the domain mappings with this certificate mapped. This
    /// count includes domain mappings on applications for which the user does not
    /// have `VIEWER` permissions.
    ///
    /// Only returned by `GET` or `LIST` requests when specifically requested by
    /// the `view=FULL_CERTIFICATE` option.
    ///
    /// @OutputOnly
    pub domain_mappings_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedCertificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedCertificate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AuthorizedCertificate::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AuthorizedCertificate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::AuthorizedCertificate::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [certificate_raw_data][crate::model::AuthorizedCertificate::certificate_raw_data].
    pub fn set_certificate_raw_data<
        T: std::convert::Into<std::option::Option<crate::model::CertificateRawData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_raw_data = v.into();
        self
    }

    /// Sets the value of [managed_certificate][crate::model::AuthorizedCertificate::managed_certificate].
    pub fn set_managed_certificate<
        T: std::convert::Into<std::option::Option<crate::model::ManagedCertificate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.managed_certificate = v.into();
        self
    }

    /// Sets the value of [domain_mappings_count][crate::model::AuthorizedCertificate::domain_mappings_count].
    pub fn set_domain_mappings_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.domain_mappings_count = v.into();
        self
    }

    /// Sets the value of [domain_names][crate::model::AuthorizedCertificate::domain_names].
    pub fn set_domain_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.domain_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [visible_domain_mappings][crate::model::AuthorizedCertificate::visible_domain_mappings].
    pub fn set_visible_domain_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.visible_domain_mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AuthorizedCertificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuthorizedCertificate"
    }
}

/// An SSL certificate obtained from a certificate authority.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateRawData {
    /// PEM encoded x.509 public key certificate. This field is set once on
    /// certificate creation. Must include the header and footer. Example:
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_certificate: std::string::String,

    /// Unencrypted PEM encoded RSA private key. This field is set once on
    /// certificate creation and then encrypted. The key size must be 2048
    /// bits or fewer. Must include the header and footer. Example:
    ///
    /// @InputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateRawData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_certificate][crate::model::CertificateRawData::public_certificate].
    pub fn set_public_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_certificate = v.into();
        self
    }

    /// Sets the value of [private_key][crate::model::CertificateRawData::private_key].
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }
}

impl wkt::message::Message for CertificateRawData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CertificateRawData"
    }
}

/// A certificate managed by App Engine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedCertificate {
    /// Time at which the certificate was last renewed. The renewal process is
    /// fully managed. Certificate renewal will automatically occur before the
    /// certificate expires. Renewal errors can be tracked via `ManagementStatus`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_renewal_time: std::option::Option<wkt::Timestamp>,

    /// Status of certificate management. Refers to the most recent certificate
    /// acquisition or renewal attempt.
    ///
    /// @OutputOnly
    pub status: crate::model::ManagementStatus,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedCertificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_renewal_time][crate::model::ManagedCertificate::last_renewal_time].
    pub fn set_last_renewal_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_renewal_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ManagedCertificate::status].
    pub fn set_status<T: std::convert::Into<crate::model::ManagementStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ManagedCertificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ManagedCertificate"
    }
}

/// Code and application artifacts used to deploy a version to App Engine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Deployment {
    /// Manifest of the files stored in Google Cloud Storage that are included
    /// as part of this version. All files must be readable using the
    /// credentials supplied with this call.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub files: std::collections::HashMap<std::string::String, crate::model::FileInfo>,

    /// The Docker image for the container that runs the version.
    /// Only applicable for instances running in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container: std::option::Option<crate::model::ContainerInfo>,

    /// The zip file for this deployment, if this is a zip deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zip: std::option::Option<crate::model::ZipInfo>,

    /// Options for any Google Cloud Build builds created as a part of this
    /// deployment.
    ///
    /// These options will only be used if a new build is created, such as when
    /// deploying to the App Engine flexible environment using files or zip.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_build_options: std::option::Option<crate::model::CloudBuildOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container][crate::model::Deployment::container].
    pub fn set_container<
        T: std::convert::Into<std::option::Option<crate::model::ContainerInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container = v.into();
        self
    }

    /// Sets the value of [zip][crate::model::Deployment::zip].
    pub fn set_zip<T: std::convert::Into<std::option::Option<crate::model::ZipInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.zip = v.into();
        self
    }

    /// Sets the value of [cloud_build_options][crate::model::Deployment::cloud_build_options].
    pub fn set_cloud_build_options<
        T: std::convert::Into<std::option::Option<crate::model::CloudBuildOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_build_options = v.into();
        self
    }

    /// Sets the value of [files][crate::model::Deployment::files].
    pub fn set_files<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileInfo>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Deployment"
    }
}

/// Single source file that is part of the version to be deployed. Each source
/// file that is deployed must be specified separately.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileInfo {
    /// URL source to use to fetch this file. Must be a URL to a resource in
    /// Google Cloud Storage in the form
    /// 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_url: std::string::String,

    /// The SHA1 hash of the file, in hex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_sum: std::string::String,

    /// The MIME type of the file.
    ///
    /// Defaults to the value from Google Cloud Storage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_url][crate::model::FileInfo::source_url].
    pub fn set_source_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_url = v.into();
        self
    }

    /// Sets the value of [sha1_sum][crate::model::FileInfo::sha1_sum].
    pub fn set_sha1_sum<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_sum = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::FileInfo::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for FileInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.FileInfo"
    }
}

/// Docker image that is used to create a container and start a VM instance for
/// the version that you deploy. Only applicable for instances running in the App
/// Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerInfo {
    /// URI to the hosted container image in Google Container Registry. The URI
    /// must be fully qualified and include a tag or digest.
    /// Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::ContainerInfo::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }
}

impl wkt::message::Message for ContainerInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ContainerInfo"
    }
}

/// Options for the build operations performed as a part of the version
/// deployment. Only applicable for App Engine flexible environment when creating
/// a version using source code directly.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudBuildOptions {
    /// Path to the yaml file used in deployment, used to determine runtime
    /// configuration details.
    ///
    /// Required for flexible environment builds.
    ///
    /// See <https://cloud.google.com/appengine/docs/standard/python/config/appref>
    /// for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_yaml_path: std::string::String,

    /// The Cloud Build timeout used as part of any dependent builds performed by
    /// version creation. Defaults to 10 minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_build_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBuildOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [app_yaml_path][crate::model::CloudBuildOptions::app_yaml_path].
    pub fn set_app_yaml_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_yaml_path = v.into();
        self
    }

    /// Sets the value of [cloud_build_timeout][crate::model::CloudBuildOptions::cloud_build_timeout].
    pub fn set_cloud_build_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_build_timeout = v.into();
        self
    }
}

impl wkt::message::Message for CloudBuildOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CloudBuildOptions"
    }
}

/// The zip file information for a zip deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZipInfo {
    /// URL of the zip file to deploy from. Must be a URL to a resource in
    /// Google Cloud Storage in the form
    /// 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_url: std::string::String,

    /// An estimate of the number of files in a zip for a zip deployment.
    /// If set, must be greater than or equal to the actual number of files.
    /// Used for optimizing performance; if not provided, deployment may be slow.
    pub files_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZipInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_url][crate::model::ZipInfo::source_url].
    pub fn set_source_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_url = v.into();
        self
    }

    /// Sets the value of [files_count][crate::model::ZipInfo::files_count].
    pub fn set_files_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.files_count = v.into();
        self
    }
}

impl wkt::message::Message for ZipInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ZipInfo"
    }
}

/// A domain that a user has been authorized to administer. To authorize use
/// of a domain, verify ownership via
/// [Search Console](https://search.google.com/search-console/welcome).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthorizedDomain {
    /// Full path to the `AuthorizedDomain` resource in the API. Example:
    /// `apps/myapp/authorizedDomains/example.com`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Fully qualified domain name of the domain authorized for use. Example:
    /// `example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedDomain {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedDomain::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AuthorizedDomain::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizedDomain {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuthorizedDomain"
    }
}

/// A domain serving an App Engine application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DomainMapping {
    /// Full path to the `DomainMapping` resource in the API. Example:
    /// `apps/myapp/domainMapping/example.com`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the domain serving the application. Example:
    /// `example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// SSL configuration for this domain. If unconfigured, this domain will not
    /// serve with SSL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_settings: std::option::Option<crate::model::SslSettings>,

    /// The resource records required to configure this domain mapping. These
    /// records must be added to the domain's DNS configuration in order to
    /// serve the application via this domain mapping.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_records: std::vec::Vec<crate::model::ResourceRecord>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DomainMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DomainMapping::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::DomainMapping::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [ssl_settings][crate::model::DomainMapping::ssl_settings].
    pub fn set_ssl_settings<
        T: std::convert::Into<std::option::Option<crate::model::SslSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_settings = v.into();
        self
    }

    /// Sets the value of [resource_records][crate::model::DomainMapping::resource_records].
    pub fn set_resource_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceRecord>,
    {
        use std::iter::Iterator;
        self.resource_records = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DomainMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DomainMapping"
    }
}

/// SSL configuration for a `DomainMapping` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslSettings {
    /// ID of the `AuthorizedCertificate` resource configuring SSL for the
    /// application. Clearing this field will remove SSL support.
    ///
    /// By default, a managed certificate is automatically created for every
    /// domain mapping. To omit SSL support or to configure SSL manually, specify
    /// `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must
    /// be authorized to administer the `AuthorizedCertificate` resource to
    /// manually map it to a `DomainMapping` resource.
    /// Example: `12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub certificate_id: std::string::String,

    /// SSL management type for this domain. If `AUTOMATIC`, a managed certificate
    /// is automatically provisioned. If `MANUAL`, `certificate_id` must be
    /// manually specified in order to configure SSL for this domain.
    pub ssl_management_type: crate::model::ssl_settings::SslManagementType,

    /// ID of the managed `AuthorizedCertificate` resource currently being
    /// provisioned, if applicable. Until the new managed certificate has been
    /// successfully provisioned, the previous SSL state will be preserved. Once
    /// the provisioning process completes, the `certificate_id` field will reflect
    /// the new managed certificate and this field will be left empty. To remove
    /// SSL support while there is still a pending managed certificate, clear the
    /// `certificate_id` field with an `UpdateDomainMappingRequest`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pending_managed_certificate_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_id][crate::model::SslSettings::certificate_id].
    pub fn set_certificate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.certificate_id = v.into();
        self
    }

    /// Sets the value of [ssl_management_type][crate::model::SslSettings::ssl_management_type].
    pub fn set_ssl_management_type<
        T: std::convert::Into<crate::model::ssl_settings::SslManagementType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_management_type = v.into();
        self
    }

    /// Sets the value of [pending_managed_certificate_id][crate::model::SslSettings::pending_managed_certificate_id].
    pub fn set_pending_managed_certificate_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pending_managed_certificate_id = v.into();
        self
    }
}

impl wkt::message::Message for SslSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.SslSettings"
    }
}

/// Defines additional types related to [SslSettings].
pub mod ssl_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The SSL management type for this domain.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SslManagementType(i32);

    impl SslManagementType {
        /// Defaults to `AUTOMATIC`.
        pub const SSL_MANAGEMENT_TYPE_UNSPECIFIED: SslManagementType = SslManagementType::new(0);

        /// SSL support for this domain is configured automatically. The mapped SSL
        /// certificate will be automatically renewed.
        pub const AUTOMATIC: SslManagementType = SslManagementType::new(1);

        /// SSL support for this domain is configured manually by the user. Either
        /// the domain has no SSL support or a user-obtained SSL certificate has been
        /// explictly mapped to this domain.
        pub const MANUAL: SslManagementType = SslManagementType::new(2);

        /// Creates a new SslManagementType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SSL_MANAGEMENT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AUTOMATIC"),
                2 => std::borrow::Cow::Borrowed("MANUAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SSL_MANAGEMENT_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SSL_MANAGEMENT_TYPE_UNSPECIFIED)
                }
                "AUTOMATIC" => std::option::Option::Some(Self::AUTOMATIC),
                "MANUAL" => std::option::Option::Some(Self::MANUAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SslManagementType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SslManagementType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A DNS resource record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRecord {
    /// Relative name of the object affected by this record. Only applicable for
    /// `CNAME` records. Example: 'www'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Data for this record. Values vary by record type, as defined in RFC 1035
    /// (section 5) and RFC 1034 (section 3.6.1).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rrdata: std::string::String,

    /// Resource record type. Example: `AAAA`.
    #[serde(rename = "type")]
    pub r#type: crate::model::resource_record::RecordType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceRecord::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rrdata][crate::model::ResourceRecord::rrdata].
    pub fn set_rrdata<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rrdata = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ResourceRecord::type].
    pub fn set_type<T: std::convert::Into<crate::model::resource_record::RecordType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for ResourceRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ResourceRecord"
    }
}

/// Defines additional types related to [ResourceRecord].
pub mod resource_record {
    #[allow(unused_imports)]
    use super::*;

    /// A resource record type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RecordType(i32);

    impl RecordType {
        /// An unknown resource record.
        pub const RECORD_TYPE_UNSPECIFIED: RecordType = RecordType::new(0);

        /// An A resource record. Data is an IPv4 address.
        pub const A: RecordType = RecordType::new(1);

        /// An AAAA resource record. Data is an IPv6 address.
        pub const AAAA: RecordType = RecordType::new(2);

        /// A CNAME resource record. Data is a domain name to be aliased.
        pub const CNAME: RecordType = RecordType::new(3);

        /// Creates a new RecordType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RECORD_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("A"),
                2 => std::borrow::Cow::Borrowed("AAAA"),
                3 => std::borrow::Cow::Borrowed("CNAME"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RECORD_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RECORD_TYPE_UNSPECIFIED)
                }
                "A" => std::option::Option::Some(Self::A),
                "AAAA" => std::option::Option::Some(Self::AAAA),
                "CNAME" => std::option::Option::Some(Self::CNAME),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RecordType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RecordType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A single firewall rule that is evaluated against incoming traffic
/// and provides an action to take on matched requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirewallRule {
    /// A positive integer between [1, Int32.MaxValue-1] that defines the order of
    /// rule evaluation. Rules with the lowest priority are evaluated first.
    ///
    /// A default rule at priority Int32.MaxValue matches all IPv4 and IPv6 traffic
    /// when no previous rule matches. Only the action of this rule can be modified
    /// by the user.
    pub priority: i32,

    /// The action to take on matched requests.
    pub action: crate::model::firewall_rule::Action,

    /// IP address or range, defined using CIDR notation, of requests that this
    /// rule applies to. You can use the wildcard character "*" to match all IPs
    /// equivalent to "0/0" and "::/0" together.
    /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
    /// or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_range: std::string::String,

    /// An optional string description of this rule.
    /// This field has a maximum length of 100 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [priority][crate::model::FirewallRule::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [action][crate::model::FirewallRule::action].
    pub fn set_action<T: std::convert::Into<crate::model::firewall_rule::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [source_range][crate::model::FirewallRule::source_range].
    pub fn set_source_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_range = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FirewallRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for FirewallRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.FirewallRule"
    }
}

/// Defines additional types related to [FirewallRule].
pub mod firewall_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Available actions to take on matching requests.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Action(i32);

    impl Action {
        pub const UNSPECIFIED_ACTION: Action = Action::new(0);

        /// Matching requests are allowed.
        pub const ALLOW: Action = Action::new(1);

        /// Matching requests are denied.
        pub const DENY: Action = Action::new(2);

        /// Creates a new Action instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED_ACTION"),
                1 => std::borrow::Cow::Borrowed("ALLOW"),
                2 => std::borrow::Cow::Borrowed("DENY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED_ACTION" => std::option::Option::Some(Self::UNSPECIFIED_ACTION),
                "ALLOW" => std::option::Option::Some(Self::ALLOW),
                "DENY" => std::option::Option::Some(Self::DENY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An Instance resource is the computing unit that App Engine uses to
/// automatically scale an application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. Full path to the Instance resource in the API.
    /// Example: `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Relative name of the instance within the version.
    /// Example: `instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. App Engine release this instance is running on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_engine_release: std::string::String,

    /// Output only. Availability of the instance.
    pub availability: crate::model::instance::Availability,

    /// Output only. Name of the virtual machine where this instance lives. Only applicable
    /// for instances in App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// Output only. Zone where the virtual machine is located. Only applicable for instances
    /// in App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone_name: std::string::String,

    /// Output only. Virtual machine ID of this instance. Only applicable for instances in
    /// App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_id: std::string::String,

    /// Output only. Time that this instance was started.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of requests since this instance was started.
    pub requests: i32,

    /// Output only. Number of errors since this instance was started.
    pub errors: i32,

    /// Output only. Average queries per second (QPS) over the last minute.
    pub qps: f32,

    /// Output only. Average latency (ms) over the last minute.
    pub average_latency: i32,

    /// Output only. Total memory in use (bytes).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub memory_usage: i64,

    /// Output only. Status of the virtual machine where this instance lives. Only applicable
    /// for instances in App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_status: std::string::String,

    /// Output only. Whether this instance is in debug mode. Only applicable for instances in
    /// App Engine flexible environment.
    pub vm_debug_enabled: bool,

    /// Output only. The IP address of this instance. Only applicable for instances in App
    /// Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_ip: std::string::String,

    /// Output only. The liveness health check of this instance. Only applicable for instances
    /// in App Engine flexible environment.
    pub vm_liveness: crate::model::instance::liveness::LivenessState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [app_engine_release][crate::model::Instance::app_engine_release].
    pub fn set_app_engine_release<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_release = v.into();
        self
    }

    /// Sets the value of [availability][crate::model::Instance::availability].
    pub fn set_availability<T: std::convert::Into<crate::model::instance::Availability>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::Instance::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_zone_name][crate::model::Instance::vm_zone_name].
    pub fn set_vm_zone_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone_name = v.into();
        self
    }

    /// Sets the value of [vm_id][crate::model::Instance::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Instance::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::Instance::requests].
    pub fn set_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.requests = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Instance::errors].
    pub fn set_errors<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.errors = v.into();
        self
    }

    /// Sets the value of [qps][crate::model::Instance::qps].
    pub fn set_qps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.qps = v.into();
        self
    }

    /// Sets the value of [average_latency][crate::model::Instance::average_latency].
    pub fn set_average_latency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.average_latency = v.into();
        self
    }

    /// Sets the value of [memory_usage][crate::model::Instance::memory_usage].
    pub fn set_memory_usage<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.memory_usage = v.into();
        self
    }

    /// Sets the value of [vm_status][crate::model::Instance::vm_status].
    pub fn set_vm_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_status = v.into();
        self
    }

    /// Sets the value of [vm_debug_enabled][crate::model::Instance::vm_debug_enabled].
    pub fn set_vm_debug_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vm_debug_enabled = v.into();
        self
    }

    /// Sets the value of [vm_ip][crate::model::Instance::vm_ip].
    pub fn set_vm_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_ip = v.into();
        self
    }

    /// Sets the value of [vm_liveness][crate::model::Instance::vm_liveness].
    pub fn set_vm_liveness<
        T: std::convert::Into<crate::model::instance::liveness::LivenessState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_liveness = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Wrapper for LivenessState enum.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Liveness {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Liveness {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Liveness {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Instance.Liveness"
        }
    }

    /// Defines additional types related to [Liveness].
    pub mod liveness {
        #[allow(unused_imports)]
        use super::*;

        /// Liveness health check status for Flex instances.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct LivenessState(i32);

        impl LivenessState {
            /// There is no liveness health check for the instance. Only applicable for
            /// instances in App Engine standard environment.
            pub const LIVENESS_STATE_UNSPECIFIED: LivenessState = LivenessState::new(0);

            /// The health checking system is aware of the instance but its health is
            /// not known at the moment.
            pub const UNKNOWN: LivenessState = LivenessState::new(1);

            /// The instance is reachable i.e. a connection to the application health
            /// checking endpoint can be established, and conforms to the requirements
            /// defined by the health check.
            pub const HEALTHY: LivenessState = LivenessState::new(2);

            /// The instance is reachable, but does not conform to the requirements
            /// defined by the health check.
            pub const UNHEALTHY: LivenessState = LivenessState::new(3);

            /// The instance is being drained. The existing connections to the instance
            /// have time to complete, but the new ones are being refused.
            pub const DRAINING: LivenessState = LivenessState::new(4);

            /// The instance is unreachable i.e. a connection to the application health
            /// checking endpoint cannot be established, or the server does not respond
            /// within the specified timeout.
            pub const TIMEOUT: LivenessState = LivenessState::new(5);

            /// Creates a new LivenessState instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("LIVENESS_STATE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("UNKNOWN"),
                    2 => std::borrow::Cow::Borrowed("HEALTHY"),
                    3 => std::borrow::Cow::Borrowed("UNHEALTHY"),
                    4 => std::borrow::Cow::Borrowed("DRAINING"),
                    5 => std::borrow::Cow::Borrowed("TIMEOUT"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "LIVENESS_STATE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::LIVENESS_STATE_UNSPECIFIED)
                    }
                    "UNKNOWN" => std::option::Option::Some(Self::UNKNOWN),
                    "HEALTHY" => std::option::Option::Some(Self::HEALTHY),
                    "UNHEALTHY" => std::option::Option::Some(Self::UNHEALTHY),
                    "DRAINING" => std::option::Option::Some(Self::DRAINING),
                    "TIMEOUT" => std::option::Option::Some(Self::TIMEOUT),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for LivenessState {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for LivenessState {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Availability of the instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Availability(i32);

    impl Availability {
        pub const UNSPECIFIED: Availability = Availability::new(0);

        pub const RESIDENT: Availability = Availability::new(1);

        pub const DYNAMIC: Availability = Availability::new(2);

        /// Creates a new Availability instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RESIDENT"),
                2 => std::borrow::Cow::Borrowed("DYNAMIC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                "RESIDENT" => std::option::Option::Some(Self::RESIDENT),
                "DYNAMIC" => std::option::Option::Some(Self::DYNAMIC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Availability {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Availability {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Metadata for the given [google.cloud.location.Location][google.cloud.location.Location].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// App Engine standard environment is available in the given location.
    ///
    /// @OutputOnly
    pub standard_environment_available: bool,

    /// App Engine flexible environment is available in the given location.
    ///
    /// @OutputOnly
    pub flexible_environment_available: bool,

    /// Output only. [Search API](https://cloud.google.com/appengine/docs/standard/python/search)
    /// is available in the given location.
    pub search_api_available: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [standard_environment_available][crate::model::LocationMetadata::standard_environment_available].
    pub fn set_standard_environment_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.standard_environment_available = v.into();
        self
    }

    /// Sets the value of [flexible_environment_available][crate::model::LocationMetadata::flexible_environment_available].
    pub fn set_flexible_environment_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.flexible_environment_available = v.into();
        self
    }

    /// Sets the value of [search_api_available][crate::model::LocationMetadata::search_api_available].
    pub fn set_search_api_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.search_api_available = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.LocationMetadata"
    }
}

/// A NetworkSettings resource is a container for ingress settings for a version
/// or service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkSettings {
    /// The ingress settings for version or service.
    pub ingress_traffic_allowed: crate::model::network_settings::IngressTrafficAllowed,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_traffic_allowed][crate::model::NetworkSettings::ingress_traffic_allowed].
    pub fn set_ingress_traffic_allowed<
        T: std::convert::Into<crate::model::network_settings::IngressTrafficAllowed>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ingress_traffic_allowed = v.into();
        self
    }
}

impl wkt::message::Message for NetworkSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.NetworkSettings"
    }
}

/// Defines additional types related to [NetworkSettings].
pub mod network_settings {
    #[allow(unused_imports)]
    use super::*;

    /// If unspecified, INGRESS_TRAFFIC_ALLOWED_ALL will be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IngressTrafficAllowed(i32);

    impl IngressTrafficAllowed {
        /// Unspecified
        pub const INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED: IngressTrafficAllowed =
            IngressTrafficAllowed::new(0);

        /// Allow HTTP traffic from public and private sources.
        pub const INGRESS_TRAFFIC_ALLOWED_ALL: IngressTrafficAllowed =
            IngressTrafficAllowed::new(1);

        /// Allow HTTP traffic from only private VPC sources.
        pub const INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY: IngressTrafficAllowed =
            IngressTrafficAllowed::new(2);

        /// Allow HTTP traffic from private VPC sources and through load balancers.
        pub const INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB: IngressTrafficAllowed =
            IngressTrafficAllowed::new(3);

        /// Creates a new IngressTrafficAllowed instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INGRESS_TRAFFIC_ALLOWED_ALL"),
                2 => std::borrow::Cow::Borrowed("INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY"),
                3 => std::borrow::Cow::Borrowed("INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED)
                }
                "INGRESS_TRAFFIC_ALLOWED_ALL" => {
                    std::option::Option::Some(Self::INGRESS_TRAFFIC_ALLOWED_ALL)
                }
                "INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY" => {
                    std::option::Option::Some(Self::INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY)
                }
                "INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB" => {
                    std::option::Option::Some(Self::INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for IngressTrafficAllowed {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for IngressTrafficAllowed {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Metadata for the given [google.longrunning.Operation][google.longrunning.Operation].
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadataV1 {
    /// API method that initiated this operation. Example:
    /// `google.appengine.v1.Versions.CreateVersion`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    /// Time that this operation was created.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insert_time: std::option::Option<wkt::Timestamp>,

    /// Time that this operation completed.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// User who requested this operation.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// Name of the resource that this operation is acting on. Example:
    /// `apps/myapp/services/default`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Ephemeral message that may change every time the operation is polled.
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ephemeral_message: std::string::String,

    /// Durable messages that persist on every operation poll.
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warning: std::vec::Vec<std::string::String>,

    /// Metadata specific to the type of operation in progress.
    /// @OutputOnly
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method_metadata: std::option::Option<crate::model::operation_metadata_v_1::MethodMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadataV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::OperationMetadataV1::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [insert_time][crate::model::OperationMetadataV1::insert_time].
    pub fn set_insert_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.insert_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadataV1::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [user][crate::model::OperationMetadataV1::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadataV1::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [ephemeral_message][crate::model::OperationMetadataV1::ephemeral_message].
    pub fn set_ephemeral_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ephemeral_message = v.into();
        self
    }

    /// Sets the value of [warning][crate::model::OperationMetadataV1::warning].
    pub fn set_warning<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warning = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `method_metadata`.
    pub fn set_method_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::operation_metadata_v_1::MethodMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method_metadata = v.into();
        self
    }

    /// The value of [method_metadata][crate::model::OperationMetadataV1::method_metadata]
    /// if it holds a `CreateVersionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_create_version_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateVersionMetadataV1>> {
        #[allow(unreachable_patterns)]
        self.method_metadata.as_ref().and_then(|v| match v {
            crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method_metadata][crate::model::OperationMetadataV1::method_metadata]
    /// to hold a `CreateVersionMetadata`.
    ///
    /// Note that all the setters affecting `method_metadata` are
    /// mutually exclusive.
    pub fn set_create_version_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateVersionMetadataV1>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method_metadata = std::option::Option::Some(
            crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadataV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.OperationMetadataV1"
    }
}

/// Defines additional types related to [OperationMetadataV1].
pub mod operation_metadata_v_1 {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata specific to the type of operation in progress.
    /// @OutputOnly
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MethodMetadata {
        CreateVersionMetadata(std::boxed::Box<crate::model::CreateVersionMetadataV1>),
    }
}

/// Metadata for the given [google.longrunning.Operation][google.longrunning.Operation] during a
/// [google.appengine.v1.CreateVersionRequest][google.appengine.v1.CreateVersionRequest].
///
/// [google.appengine.v1.CreateVersionRequest]: crate::model::CreateVersionRequest
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVersionMetadataV1 {
    /// The Cloud Build ID if one was created as part of the version create.
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_build_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionMetadataV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_build_id][crate::model::CreateVersionMetadataV1::cloud_build_id].
    pub fn set_cloud_build_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_build_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionMetadataV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionMetadataV1"
    }
}

/// A Service resource is a logical component of an application that can share
/// state and communicate in a secure fashion with other services.
/// For example, an application that handles customer requests might
/// include separate services to handle tasks such as backend data
/// analysis or API requests from mobile devices. Each service has a
/// collection of versions that define a specific set of code used to
/// implement the functionality of that service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Service {
    /// Full path to the Service resource in the API.
    /// Example: `apps/myapp/services/default`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the service within the application.
    /// Example: `default`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Mapping that defines fractional HTTP traffic diversion to
    /// different versions within the service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::TrafficSplit>,

    /// A set of labels to apply to this service. Labels are key/value pairs that
    /// describe the service and all resources that belong to it (e.g.,
    /// versions). The labels can be used to search and group resources, and are
    /// propagated to the usage and billing reports, enabling fine-grain analysis
    /// of costs. An example of using labels is to tag resources belonging to
    /// different environments (e.g., "env=prod", "env=qa").
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Ingress settings for this service. Will apply to all versions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_settings: std::option::Option<crate::model::NetworkSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Service::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [split][crate::model::Service::split].
    pub fn set_split<T: std::convert::Into<std::option::Option<crate::model::TrafficSplit>>>(
        mut self,
        v: T,
    ) -> Self {
        self.split = v.into();
        self
    }

    /// Sets the value of [network_settings][crate::model::Service::network_settings].
    pub fn set_network_settings<
        T: std::convert::Into<std::option::Option<crate::model::NetworkSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_settings = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Service::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Service"
    }
}

/// Traffic routing configuration for versions within a single service. Traffic
/// splits define how traffic directed to the service is assigned to versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrafficSplit {
    /// Mechanism used to determine which version a request is sent to.
    /// The traffic selection algorithm will
    /// be stable for either type until allocations are changed.
    pub shard_by: crate::model::traffic_split::ShardBy,

    /// Mapping from version IDs within the service to fractional
    /// (0.000, 1] allocations of traffic for that version. Each version can
    /// be specified only once, but some versions in the service may not
    /// have any traffic allocation. Services that have traffic allocated
    /// cannot be deleted until either the service is deleted or
    /// their traffic allocation is removed. Allocations must sum to 1.
    /// Up to two decimal place precision is supported for IP-based splits and
    /// up to three decimal places is supported for cookie-based splits.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub allocations: std::collections::HashMap<std::string::String, f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shard_by][crate::model::TrafficSplit::shard_by].
    pub fn set_shard_by<T: std::convert::Into<crate::model::traffic_split::ShardBy>>(
        mut self,
        v: T,
    ) -> Self {
        self.shard_by = v.into();
        self
    }

    /// Sets the value of [allocations][crate::model::TrafficSplit::allocations].
    pub fn set_allocations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.allocations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TrafficSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.TrafficSplit"
    }
}

/// Defines additional types related to [TrafficSplit].
pub mod traffic_split {
    #[allow(unused_imports)]
    use super::*;

    /// Available sharding mechanisms.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ShardBy(i32);

    impl ShardBy {
        /// Diversion method unspecified.
        pub const UNSPECIFIED: ShardBy = ShardBy::new(0);

        /// Diversion based on a specially named cookie, "GOOGAPPUID." The cookie
        /// must be set by the application itself or no diversion will occur.
        pub const COOKIE: ShardBy = ShardBy::new(1);

        /// Diversion based on applying the modulus operation to a fingerprint
        /// of the IP address.
        pub const IP: ShardBy = ShardBy::new(2);

        /// Diversion based on weighted random assignment. An incoming request is
        /// randomly routed to a version in the traffic split, with probability
        /// proportional to the version's traffic share.
        pub const RANDOM: ShardBy = ShardBy::new(3);

        /// Creates a new ShardBy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("COOKIE"),
                2 => std::borrow::Cow::Borrowed("IP"),
                3 => std::borrow::Cow::Borrowed("RANDOM"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                "COOKIE" => std::option::Option::Some(Self::COOKIE),
                "IP" => std::option::Option::Some(Self::IP),
                "RANDOM" => std::option::Option::Some(Self::RANDOM),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ShardBy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ShardBy {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A Version resource is a specific set of source code and configuration files
/// that are deployed into a service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Version {
    /// Full path to the Version resource in the API.  Example:
    /// `apps/myapp/services/default/versions/v1`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the version within the service.  Example: `v1`.
    /// Version names can contain only lowercase letters, numbers, or hyphens.
    /// Reserved names: "default", "latest", and any name with the prefix "ah-".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Before an application can receive email or XMPP messages, the application
    /// must be configured to enable the service.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inbound_services: std::vec::Vec<crate::model::InboundServiceType>,

    /// Instance class that is used to run this version. Valid values are:
    ///
    /// * AutomaticScaling: `F1`, `F2`, `F4`, `F4_1G`
    /// * ManualScaling or BasicScaling: `B1`, `B2`, `B4`, `B8`, `B4_1G`
    ///
    /// Defaults to `F1` for AutomaticScaling and `B1` for ManualScaling or
    /// BasicScaling.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_class: std::string::String,

    /// Extra network settings.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::Network>,

    /// The Google Compute Engine zones that are supported by this version in the
    /// App Engine flexible environment. Deprecated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub zones: std::vec::Vec<std::string::String>,

    /// Machine resources for this version.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resources: std::option::Option<crate::model::Resources>,

    /// Desired runtime. Example: `python27`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime: std::string::String,

    /// The channel of the runtime to use. Only available for some
    /// runtimes. Defaults to the `default` channel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_channel: std::string::String,

    /// Whether multiple requests can be dispatched to this version at once.
    pub threadsafe: bool,

    /// Whether to deploy this version in a container on a virtual machine.
    pub vm: bool,

    /// Allows App Engine second generation runtimes to access the legacy bundled
    /// services.
    pub app_engine_apis: bool,

    /// Metadata settings that are supplied to this version to enable
    /// beta runtime features.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub beta_settings: std::collections::HashMap<std::string::String, std::string::String>,

    /// App Engine execution environment for this version.
    ///
    /// Defaults to `standard`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub env: std::string::String,

    /// Current serving status of this version. Only the versions with a
    /// `SERVING` status create instances and can be billed.
    ///
    /// `SERVING_STATUS_UNSPECIFIED` is an invalid value. Defaults to `SERVING`.
    pub serving_status: crate::model::ServingStatus,

    /// Email address of the user who created this version.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub created_by: std::string::String,

    /// Time that this version was created.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Total size in bytes of all the files that are included in this version
    /// and currently hosted on the App Engine disk.
    ///
    /// @OutputOnly
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_usage_bytes: i64,

    /// The version of the API in the given runtime environment. Please see the
    /// app.yaml reference for valid values at
    /// <https://cloud.google.com/appengine/docs/standard/>\<language\>/config/appref
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_api_version: std::string::String,

    /// The path or name of the app's main executable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_main_executable_path: std::string::String,

    /// The identity that the deployed version will run as.
    /// Admin API will use the App Engine Appspot service account as default if
    /// this field is neither provided in app.yaml file nor through CLI flag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// An ordered list of URL-matching patterns that should be applied to incoming
    /// requests. The first matching URL handles the request and other request
    /// handlers are not attempted.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub handlers: std::vec::Vec<crate::model::UrlMap>,

    /// Custom static error pages. Limited to 10KB per page.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_handlers: std::vec::Vec<crate::model::ErrorHandler>,

    /// Configuration for third-party Python runtime libraries that are required
    /// by the application.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub libraries: std::vec::Vec<crate::model::Library>,

    /// Serving configuration for
    /// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/).
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub api_config: std::option::Option<crate::model::ApiConfigHandler>,

    /// Environment variables available to the application.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Environment variables available to the build environment.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub build_env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Duration that static files should be cached by web proxies and browsers.
    /// Only applicable if the corresponding
    /// [StaticFilesHandler](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#StaticFilesHandler)
    /// does not specify its own expiration time.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_expiration: std::option::Option<wkt::Duration>,

    /// Configures health checking for instances. Unhealthy instances are
    /// stopped and replaced with new instances.
    /// Only applicable in the App Engine flexible environment.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub health_check: std::option::Option<crate::model::HealthCheck>,

    /// Configures readiness health checking for instances.
    /// Unhealthy instances are not put into the backend traffic rotation.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub readiness_check: std::option::Option<crate::model::ReadinessCheck>,

    /// Configures liveness health checking for instances.
    /// Unhealthy instances are stopped and replaced with new instances
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub liveness_check: std::option::Option<crate::model::LivenessCheck>,

    /// Files that match this pattern will not be built into this version.
    /// Only applicable for Go runtimes.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nobuild_files_regex: std::string::String,

    /// Code and application artifacts that make up this version.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Serving URL for this version. Example:
    /// `https://myversion-dot-myservice-dot-myapp.appspot.com`
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_url: std::string::String,

    /// Cloud Endpoints configuration.
    ///
    /// If endpoints_api_service is set, the Cloud Endpoints Extensible Service
    /// Proxy will be provided to serve the API implemented by the app.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoints_api_service: std::option::Option<crate::model::EndpointsApiService>,

    /// The entrypoint for the application.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entrypoint: std::option::Option<crate::model::Entrypoint>,

    /// Enables VPC connectivity for standard apps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_access_connector: std::option::Option<crate::model::VpcAccessConnector>,

    /// Controls how instances are created, scaled, and reaped.
    ///
    /// Defaults to `AutomaticScaling`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub scaling: std::option::Option<crate::model::version::Scaling>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Version::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance_class][crate::model::Version::instance_class].
    pub fn set_instance_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_class = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Version::network].
    pub fn set_network<T: std::convert::Into<std::option::Option<crate::model::Network>>>(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [resources][crate::model::Version::resources].
    pub fn set_resources<T: std::convert::Into<std::option::Option<crate::model::Resources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resources = v.into();
        self
    }

    /// Sets the value of [runtime][crate::model::Version::runtime].
    pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime = v.into();
        self
    }

    /// Sets the value of [runtime_channel][crate::model::Version::runtime_channel].
    pub fn set_runtime_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_channel = v.into();
        self
    }

    /// Sets the value of [threadsafe][crate::model::Version::threadsafe].
    pub fn set_threadsafe<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.threadsafe = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::Version::vm].
    pub fn set_vm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [app_engine_apis][crate::model::Version::app_engine_apis].
    pub fn set_app_engine_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.app_engine_apis = v.into();
        self
    }

    /// Sets the value of [env][crate::model::Version::env].
    pub fn set_env<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.env = v.into();
        self
    }

    /// Sets the value of [serving_status][crate::model::Version::serving_status].
    pub fn set_serving_status<T: std::convert::Into<crate::model::ServingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_status = v.into();
        self
    }

    /// Sets the value of [created_by][crate::model::Version::created_by].
    pub fn set_created_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.created_by = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [disk_usage_bytes][crate::model::Version::disk_usage_bytes].
    pub fn set_disk_usage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_usage_bytes = v.into();
        self
    }

    /// Sets the value of [runtime_api_version][crate::model::Version::runtime_api_version].
    pub fn set_runtime_api_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_api_version = v.into();
        self
    }

    /// Sets the value of [runtime_main_executable_path][crate::model::Version::runtime_main_executable_path].
    pub fn set_runtime_main_executable_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_main_executable_path = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Version::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [api_config][crate::model::Version::api_config].
    pub fn set_api_config<
        T: std::convert::Into<std::option::Option<crate::model::ApiConfigHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.api_config = v.into();
        self
    }

    /// Sets the value of [default_expiration][crate::model::Version::default_expiration].
    pub fn set_default_expiration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_expiration = v.into();
        self
    }

    /// Sets the value of [health_check][crate::model::Version::health_check].
    pub fn set_health_check<
        T: std::convert::Into<std::option::Option<crate::model::HealthCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.health_check = v.into();
        self
    }

    /// Sets the value of [readiness_check][crate::model::Version::readiness_check].
    pub fn set_readiness_check<
        T: std::convert::Into<std::option::Option<crate::model::ReadinessCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.readiness_check = v.into();
        self
    }

    /// Sets the value of [liveness_check][crate::model::Version::liveness_check].
    pub fn set_liveness_check<
        T: std::convert::Into<std::option::Option<crate::model::LivenessCheck>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.liveness_check = v.into();
        self
    }

    /// Sets the value of [nobuild_files_regex][crate::model::Version::nobuild_files_regex].
    pub fn set_nobuild_files_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nobuild_files_regex = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::Version::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }

    /// Sets the value of [version_url][crate::model::Version::version_url].
    pub fn set_version_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_url = v.into();
        self
    }

    /// Sets the value of [endpoints_api_service][crate::model::Version::endpoints_api_service].
    pub fn set_endpoints_api_service<
        T: std::convert::Into<std::option::Option<crate::model::EndpointsApiService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoints_api_service = v.into();
        self
    }

    /// Sets the value of [entrypoint][crate::model::Version::entrypoint].
    pub fn set_entrypoint<T: std::convert::Into<std::option::Option<crate::model::Entrypoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entrypoint = v.into();
        self
    }

    /// Sets the value of [vpc_access_connector][crate::model::Version::vpc_access_connector].
    pub fn set_vpc_access_connector<
        T: std::convert::Into<std::option::Option<crate::model::VpcAccessConnector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_access_connector = v.into();
        self
    }

    /// Sets the value of [inbound_services][crate::model::Version::inbound_services].
    pub fn set_inbound_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InboundServiceType>,
    {
        use std::iter::Iterator;
        self.inbound_services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [zones][crate::model::Version::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [handlers][crate::model::Version::handlers].
    pub fn set_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UrlMap>,
    {
        use std::iter::Iterator;
        self.handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_handlers][crate::model::Version::error_handlers].
    pub fn set_error_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorHandler>,
    {
        use std::iter::Iterator;
        self.error_handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [libraries][crate::model::Version::libraries].
    pub fn set_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Library>,
    {
        use std::iter::Iterator;
        self.libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [beta_settings][crate::model::Version::beta_settings].
    pub fn set_beta_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.beta_settings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [env_variables][crate::model::Version::env_variables].
    pub fn set_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [build_env_variables][crate::model::Version::build_env_variables].
    pub fn set_build_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `scaling`.
    pub fn set_scaling<
        T: std::convert::Into<std::option::Option<crate::model::version::Scaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling = v.into();
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `AutomaticScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_automatic_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::AutomaticScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `BasicScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_basic_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::BasicScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `ManualScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_manual_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManualScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::ManualScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `AutomaticScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_automatic_scaling<
        T: std::convert::Into<std::boxed::Box<crate::model::AutomaticScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::AutomaticScaling(v.into()));
        self
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `BasicScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_basic_scaling<T: std::convert::Into<std::boxed::Box<crate::model::BasicScaling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::BasicScaling(v.into()));
        self
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `ManualScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_manual_scaling<
        T: std::convert::Into<std::boxed::Box<crate::model::ManualScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::ManualScaling(v.into()));
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Version"
    }
}

/// Defines additional types related to [Version].
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// Controls how instances are created, scaled, and reaped.
    ///
    /// Defaults to `AutomaticScaling`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Scaling {
        /// Automatic scaling is based on request rate, response latencies, and other
        /// application metrics. Instances are dynamically created and destroyed as
        /// needed in order to handle traffic.
        AutomaticScaling(std::boxed::Box<crate::model::AutomaticScaling>),
        /// A service with basic scaling will create an instance when the application
        /// receives a request. The instance will be turned down when the app becomes
        /// idle. Basic scaling is ideal for work that is intermittent or driven by
        /// user activity.
        BasicScaling(std::boxed::Box<crate::model::BasicScaling>),
        /// A service with manual scaling runs continuously, allowing you to perform
        /// complex initialization and rely on the state of its memory over time.
        /// Manually scaled versions are sometimes referred to as "backends".
        ManualScaling(std::boxed::Box<crate::model::ManualScaling>),
    }
}

/// [Cloud Endpoints](https://cloud.google.com/endpoints) configuration.
/// The Endpoints API Service provides tooling for serving Open API and gRPC
/// endpoints via an NGINX proxy. Only valid for App Engine Flexible environment
/// deployments.
///
/// The fields here refer to the name and configuration ID of a "service"
/// resource in the [Service Management API](https://cloud.google.com/service-management/overview).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EndpointsApiService {
    /// Endpoints service name which is the name of the "service" resource in the
    /// Service Management API. For example "myapi.endpoints.myproject.cloud.goog"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Endpoints service configuration ID as specified by the Service Management
    /// API. For example "2016-09-19r1".
    ///
    /// By default, the rollout strategy for Endpoints is `RolloutStrategy.FIXED`.
    /// This means that Endpoints starts up with a particular configuration ID.
    /// When a new configuration is rolled out, Endpoints must be given the new
    /// configuration ID. The `config_id` field is used to give the configuration
    /// ID and is required in this case.
    ///
    /// Endpoints also has a rollout strategy called `RolloutStrategy.MANAGED`.
    /// When using this, Endpoints fetches the latest configuration and does not
    /// need the configuration ID. In this case, `config_id` must be omitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config_id: std::string::String,

    /// Endpoints rollout strategy. If `FIXED`, `config_id` must be specified. If
    /// `MANAGED`, `config_id` must be omitted.
    pub rollout_strategy: crate::model::endpoints_api_service::RolloutStrategy,

    /// Enable or disable trace sampling. By default, this is set to false for
    /// enabled.
    pub disable_trace_sampling: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointsApiService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EndpointsApiService::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::EndpointsApiService::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }

    /// Sets the value of [rollout_strategy][crate::model::EndpointsApiService::rollout_strategy].
    pub fn set_rollout_strategy<
        T: std::convert::Into<crate::model::endpoints_api_service::RolloutStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_strategy = v.into();
        self
    }

    /// Sets the value of [disable_trace_sampling][crate::model::EndpointsApiService::disable_trace_sampling].
    pub fn set_disable_trace_sampling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_trace_sampling = v.into();
        self
    }
}

impl wkt::message::Message for EndpointsApiService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.EndpointsApiService"
    }
}

/// Defines additional types related to [EndpointsApiService].
pub mod endpoints_api_service {
    #[allow(unused_imports)]
    use super::*;

    /// Available rollout strategies.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RolloutStrategy(i32);

    impl RolloutStrategy {
        /// Not specified. Defaults to `FIXED`.
        pub const UNSPECIFIED_ROLLOUT_STRATEGY: RolloutStrategy = RolloutStrategy::new(0);

        /// Endpoints service configuration ID will be fixed to the configuration ID
        /// specified by `config_id`.
        pub const FIXED: RolloutStrategy = RolloutStrategy::new(1);

        /// Endpoints service configuration ID will be updated with each rollout.
        pub const MANAGED: RolloutStrategy = RolloutStrategy::new(2);

        /// Creates a new RolloutStrategy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED_ROLLOUT_STRATEGY"),
                1 => std::borrow::Cow::Borrowed("FIXED"),
                2 => std::borrow::Cow::Borrowed("MANAGED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED_ROLLOUT_STRATEGY" => {
                    std::option::Option::Some(Self::UNSPECIFIED_ROLLOUT_STRATEGY)
                }
                "FIXED" => std::option::Option::Some(Self::FIXED),
                "MANAGED" => std::option::Option::Some(Self::MANAGED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RolloutStrategy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RolloutStrategy {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Automatic scaling is based on request rate, response latencies, and other
/// application metrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomaticScaling {
    /// The time period that the
    /// [Autoscaler](https://cloud.google.com/compute/docs/autoscaler/)
    /// should wait before it starts collecting information from a new instance.
    /// This prevents the autoscaler from collecting information when the instance
    /// is initializing, during which the collected usage would not be reliable.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cool_down_period: std::option::Option<wkt::Duration>,

    /// Target scaling by CPU usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu_utilization: std::option::Option<crate::model::CpuUtilization>,

    /// Number of concurrent requests an automatic scaling instance can accept
    /// before the scheduler spawns a new instance.
    ///
    /// Defaults to a runtime-specific value.
    pub max_concurrent_requests: i32,

    /// Maximum number of idle instances that should be maintained for this
    /// version.
    pub max_idle_instances: i32,

    /// Maximum number of instances that should be started to handle requests for
    /// this version.
    pub max_total_instances: i32,

    /// Maximum amount of time that a request should wait in the pending queue
    /// before starting a new instance to handle it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_pending_latency: std::option::Option<wkt::Duration>,

    /// Minimum number of idle instances that should be maintained for
    /// this version. Only applicable for the default version of a service.
    pub min_idle_instances: i32,

    /// Minimum number of running instances that should be maintained for this
    /// version.
    pub min_total_instances: i32,

    /// Minimum amount of time a request should wait in the pending queue before
    /// starting a new instance to handle it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_pending_latency: std::option::Option<wkt::Duration>,

    /// Target scaling by request utilization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_utilization: std::option::Option<crate::model::RequestUtilization>,

    /// Target scaling by disk usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_utilization: std::option::Option<crate::model::DiskUtilization>,

    /// Target scaling by network usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_utilization: std::option::Option<crate::model::NetworkUtilization>,

    /// Scheduler settings for standard environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub standard_scheduler_settings: std::option::Option<crate::model::StandardSchedulerSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomaticScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cool_down_period][crate::model::AutomaticScaling::cool_down_period].
    pub fn set_cool_down_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cool_down_period = v.into();
        self
    }

    /// Sets the value of [cpu_utilization][crate::model::AutomaticScaling::cpu_utilization].
    pub fn set_cpu_utilization<
        T: std::convert::Into<std::option::Option<crate::model::CpuUtilization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_utilization = v.into();
        self
    }

    /// Sets the value of [max_concurrent_requests][crate::model::AutomaticScaling::max_concurrent_requests].
    pub fn set_max_concurrent_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_requests = v.into();
        self
    }

    /// Sets the value of [max_idle_instances][crate::model::AutomaticScaling::max_idle_instances].
    pub fn set_max_idle_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_idle_instances = v.into();
        self
    }

    /// Sets the value of [max_total_instances][crate::model::AutomaticScaling::max_total_instances].
    pub fn set_max_total_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_total_instances = v.into();
        self
    }

    /// Sets the value of [max_pending_latency][crate::model::AutomaticScaling::max_pending_latency].
    pub fn set_max_pending_latency<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_pending_latency = v.into();
        self
    }

    /// Sets the value of [min_idle_instances][crate::model::AutomaticScaling::min_idle_instances].
    pub fn set_min_idle_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_idle_instances = v.into();
        self
    }

    /// Sets the value of [min_total_instances][crate::model::AutomaticScaling::min_total_instances].
    pub fn set_min_total_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_total_instances = v.into();
        self
    }

    /// Sets the value of [min_pending_latency][crate::model::AutomaticScaling::min_pending_latency].
    pub fn set_min_pending_latency<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_pending_latency = v.into();
        self
    }

    /// Sets the value of [request_utilization][crate::model::AutomaticScaling::request_utilization].
    pub fn set_request_utilization<
        T: std::convert::Into<std::option::Option<crate::model::RequestUtilization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_utilization = v.into();
        self
    }

    /// Sets the value of [disk_utilization][crate::model::AutomaticScaling::disk_utilization].
    pub fn set_disk_utilization<
        T: std::convert::Into<std::option::Option<crate::model::DiskUtilization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_utilization = v.into();
        self
    }

    /// Sets the value of [network_utilization][crate::model::AutomaticScaling::network_utilization].
    pub fn set_network_utilization<
        T: std::convert::Into<std::option::Option<crate::model::NetworkUtilization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_utilization = v.into();
        self
    }

    /// Sets the value of [standard_scheduler_settings][crate::model::AutomaticScaling::standard_scheduler_settings].
    pub fn set_standard_scheduler_settings<
        T: std::convert::Into<std::option::Option<crate::model::StandardSchedulerSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.standard_scheduler_settings = v.into();
        self
    }
}

impl wkt::message::Message for AutomaticScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AutomaticScaling"
    }
}

/// A service with basic scaling will create an instance when the application
/// receives a request. The instance will be turned down when the app becomes
/// idle. Basic scaling is ideal for work that is intermittent or driven by
/// user activity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BasicScaling {
    /// Duration of time after the last request that an instance must wait before
    /// the instance is shut down.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Maximum number of instances to create for this version.
    pub max_instances: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_timeout][crate::model::BasicScaling::idle_timeout].
    pub fn set_idle_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_timeout = v.into();
        self
    }

    /// Sets the value of [max_instances][crate::model::BasicScaling::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }
}

impl wkt::message::Message for BasicScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BasicScaling"
    }
}

/// A service with manual scaling runs continuously, allowing you to perform
/// complex initialization and rely on the state of its memory over time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManualScaling {
    /// Number of instances to assign to the service at the start. This number
    /// can later be altered by using the
    /// [Modules API](https://cloud.google.com/appengine/docs/python/modules/functions)
    /// `set_num_instances()` function.
    pub instances: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManualScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ManualScaling::instances].
    pub fn set_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.instances = v.into();
        self
    }
}

impl wkt::message::Message for ManualScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ManualScaling"
    }
}

/// Target scaling by CPU usage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CpuUtilization {
    /// Period of time over which CPU utilization is calculated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation_window_length: std::option::Option<wkt::Duration>,

    /// Target CPU utilization ratio to maintain when scaling. Must be between 0
    /// and 1.
    pub target_utilization: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CpuUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aggregation_window_length][crate::model::CpuUtilization::aggregation_window_length].
    pub fn set_aggregation_window_length<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_window_length = v.into();
        self
    }

    /// Sets the value of [target_utilization][crate::model::CpuUtilization::target_utilization].
    pub fn set_target_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_utilization = v.into();
        self
    }
}

impl wkt::message::Message for CpuUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CpuUtilization"
    }
}

/// Target scaling by request utilization.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RequestUtilization {
    /// Target requests per second.
    pub target_request_count_per_second: i32,

    /// Target number of concurrent requests.
    pub target_concurrent_requests: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_request_count_per_second][crate::model::RequestUtilization::target_request_count_per_second].
    pub fn set_target_request_count_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_request_count_per_second = v.into();
        self
    }

    /// Sets the value of [target_concurrent_requests][crate::model::RequestUtilization::target_concurrent_requests].
    pub fn set_target_concurrent_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_concurrent_requests = v.into();
        self
    }
}

impl wkt::message::Message for RequestUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.RequestUtilization"
    }
}

/// Target scaling by disk usage.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskUtilization {
    /// Target bytes written per second.
    pub target_write_bytes_per_second: i32,

    /// Target ops written per second.
    pub target_write_ops_per_second: i32,

    /// Target bytes read per second.
    pub target_read_bytes_per_second: i32,

    /// Target ops read per seconds.
    pub target_read_ops_per_second: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_write_bytes_per_second][crate::model::DiskUtilization::target_write_bytes_per_second].
    pub fn set_target_write_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_write_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_write_ops_per_second][crate::model::DiskUtilization::target_write_ops_per_second].
    pub fn set_target_write_ops_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_write_ops_per_second = v.into();
        self
    }

    /// Sets the value of [target_read_bytes_per_second][crate::model::DiskUtilization::target_read_bytes_per_second].
    pub fn set_target_read_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_read_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_read_ops_per_second][crate::model::DiskUtilization::target_read_ops_per_second].
    pub fn set_target_read_ops_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_read_ops_per_second = v.into();
        self
    }
}

impl wkt::message::Message for DiskUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DiskUtilization"
    }
}

/// Target scaling by network usage.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkUtilization {
    /// Target bytes sent per second.
    pub target_sent_bytes_per_second: i32,

    /// Target packets sent per second.
    pub target_sent_packets_per_second: i32,

    /// Target bytes received per second.
    pub target_received_bytes_per_second: i32,

    /// Target packets received per second.
    pub target_received_packets_per_second: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_sent_bytes_per_second][crate::model::NetworkUtilization::target_sent_bytes_per_second].
    pub fn set_target_sent_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_sent_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_sent_packets_per_second][crate::model::NetworkUtilization::target_sent_packets_per_second].
    pub fn set_target_sent_packets_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_sent_packets_per_second = v.into();
        self
    }

    /// Sets the value of [target_received_bytes_per_second][crate::model::NetworkUtilization::target_received_bytes_per_second].
    pub fn set_target_received_bytes_per_second<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_received_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_received_packets_per_second][crate::model::NetworkUtilization::target_received_packets_per_second].
    pub fn set_target_received_packets_per_second<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_received_packets_per_second = v.into();
        self
    }
}

impl wkt::message::Message for NetworkUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.NetworkUtilization"
    }
}

/// Scheduler settings for standard environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSchedulerSettings {
    /// Target CPU utilization ratio to maintain when scaling.
    pub target_cpu_utilization: f64,

    /// Target throughput utilization ratio to maintain when scaling
    pub target_throughput_utilization: f64,

    /// Minimum number of instances to run for this version. Set to zero to disable
    /// `min_instances` configuration.
    pub min_instances: i32,

    /// Maximum number of instances to run for this version. Set to zero to disable
    /// `max_instances` configuration.
    pub max_instances: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSchedulerSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_cpu_utilization][crate::model::StandardSchedulerSettings::target_cpu_utilization].
    pub fn set_target_cpu_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_cpu_utilization = v.into();
        self
    }

    /// Sets the value of [target_throughput_utilization][crate::model::StandardSchedulerSettings::target_throughput_utilization].
    pub fn set_target_throughput_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_throughput_utilization = v.into();
        self
    }

    /// Sets the value of [min_instances][crate::model::StandardSchedulerSettings::min_instances].
    pub fn set_min_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instances = v.into();
        self
    }

    /// Sets the value of [max_instances][crate::model::StandardSchedulerSettings::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }
}

impl wkt::message::Message for StandardSchedulerSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.StandardSchedulerSettings"
    }
}

/// Extra network settings.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Network {
    /// List of ports, or port pairs, to forward from the virtual machine to the
    /// application container.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub forwarded_ports: std::vec::Vec<std::string::String>,

    /// Tag to apply to the instance during creation.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_tag: std::string::String,

    /// Google Compute Engine network where the virtual machines are created.
    /// Specify the short name, not the resource path.
    ///
    /// Defaults to `default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Google Cloud Platform sub-network where the virtual machines are created.
    /// Specify the short name, not the resource path.
    ///
    /// If a subnetwork name is specified, a network name will also be required
    /// unless it is for the default network.
    ///
    /// * If the network that the instance is being created in is a Legacy network,
    ///   then the IP address is allocated from the IPv4Range.
    /// * If the network that the instance is being created in is an auto Subnet
    ///   Mode Network, then only network name should be specified (not the
    ///   subnetwork_name) and the IP address is created from the IPCidrRange of the
    ///   subnetwork that exists in that zone for that network.
    /// * If the network that the instance is being created in is a custom Subnet
    ///   Mode Network, then the subnetwork_name must be specified and the
    ///   IP address is created from the IPCidrRange of the subnetwork.
    ///
    /// If specified, the subnetwork must exist in the same region as the
    /// App Engine flexible environment application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork_name: std::string::String,

    /// Enable session affinity.
    /// Only applicable in the App Engine flexible environment.
    pub session_affinity: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_tag][crate::model::Network::instance_tag].
    pub fn set_instance_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_tag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subnetwork_name][crate::model::Network::subnetwork_name].
    pub fn set_subnetwork_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_name = v.into();
        self
    }

    /// Sets the value of [session_affinity][crate::model::Network::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }

    /// Sets the value of [forwarded_ports][crate::model::Network::forwarded_ports].
    pub fn set_forwarded_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.forwarded_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Network"
    }
}

/// Volumes mounted within the app container.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Unique name for the volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Underlying volume type, e.g. 'tmpfs'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume_type: std::string::String,

    /// Volume size in gigabytes.
    pub size_gb: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type].
    pub fn set_volume_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_type = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Volume::size_gb].
    pub fn set_size_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Volume"
    }
}

/// Machine resources for a version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Resources {
    /// Number of CPU cores needed.
    pub cpu: f64,

    /// Disk size (GB) needed.
    pub disk_gb: f64,

    /// Memory (GB) needed.
    pub memory_gb: f64,

    /// User specified volumes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// The name of the encryption key that is stored in Google Cloud KMS.
    /// Only should be used by Cloud Composer to encrypt the vm disk
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_reference: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Resources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu][crate::model::Resources::cpu].
    pub fn set_cpu<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu = v.into();
        self
    }

    /// Sets the value of [disk_gb][crate::model::Resources::disk_gb].
    pub fn set_disk_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.disk_gb = v.into();
        self
    }

    /// Sets the value of [memory_gb][crate::model::Resources::memory_gb].
    pub fn set_memory_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.memory_gb = v.into();
        self
    }

    /// Sets the value of [kms_key_reference][crate::model::Resources::kms_key_reference].
    pub fn set_kms_key_reference<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_reference = v.into();
        self
    }

    /// Sets the value of [volumes][crate::model::Resources::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Resources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Resources"
    }
}

/// VPC access connector specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcAccessConnector {
    /// Full Serverless VPC Access Connector name e.g.
    /// /projects/my-project/locations/us-central1/connectors/c1.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The egress setting for the connector, controlling what traffic is diverted
    /// through it.
    pub egress_setting: crate::model::vpc_access_connector::EgressSetting,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcAccessConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpcAccessConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [egress_setting][crate::model::VpcAccessConnector::egress_setting].
    pub fn set_egress_setting<
        T: std::convert::Into<crate::model::vpc_access_connector::EgressSetting>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.egress_setting = v.into();
        self
    }
}

impl wkt::message::Message for VpcAccessConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.VpcAccessConnector"
    }
}

/// Defines additional types related to [VpcAccessConnector].
pub mod vpc_access_connector {
    #[allow(unused_imports)]
    use super::*;

    /// Available egress settings.
    ///
    /// This controls what traffic is diverted through the VPC Access Connector
    /// resource. By default PRIVATE_IP_RANGES will be used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EgressSetting(i32);

    impl EgressSetting {
        pub const EGRESS_SETTING_UNSPECIFIED: EgressSetting = EgressSetting::new(0);

        /// Force the use of VPC Access for all egress traffic from the function.
        pub const ALL_TRAFFIC: EgressSetting = EgressSetting::new(1);

        /// Use the VPC Access Connector for private IP space from RFC1918.
        pub const PRIVATE_IP_RANGES: EgressSetting = EgressSetting::new(2);

        /// Creates a new EgressSetting instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EGRESS_SETTING_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALL_TRAFFIC"),
                2 => std::borrow::Cow::Borrowed("PRIVATE_IP_RANGES"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EGRESS_SETTING_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EGRESS_SETTING_UNSPECIFIED)
                }
                "ALL_TRAFFIC" => std::option::Option::Some(Self::ALL_TRAFFIC),
                "PRIVATE_IP_RANGES" => std::option::Option::Some(Self::PRIVATE_IP_RANGES),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EgressSetting {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EgressSetting {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The entrypoint for the application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entrypoint {
    /// The command to run.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub command: std::option::Option<crate::model::entrypoint::Command>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entrypoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `command`.
    pub fn set_command<
        T: std::convert::Into<std::option::Option<crate::model::entrypoint::Command>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.command = v.into();
        self
    }

    /// The value of [command][crate::model::Entrypoint::command]
    /// if it holds a `Shell`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_shell(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.command.as_ref().and_then(|v| match v {
            crate::model::entrypoint::Command::Shell(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [command][crate::model::Entrypoint::command]
    /// to hold a `Shell`.
    ///
    /// Note that all the setters affecting `command` are
    /// mutually exclusive.
    pub fn set_shell<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command =
            std::option::Option::Some(crate::model::entrypoint::Command::Shell(v.into()));
        self
    }
}

impl wkt::message::Message for Entrypoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Entrypoint"
    }
}

/// Defines additional types related to [Entrypoint].
pub mod entrypoint {
    #[allow(unused_imports)]
    use super::*;

    /// The command to run.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Command {
        /// The format should be a shell command that can be fed to `bash -c`.
        Shell(std::string::String),
    }
}

/// Actions to take when the user is not logged in.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct AuthFailAction(i32);

impl AuthFailAction {
    /// Not specified. `AUTH_FAIL_ACTION_REDIRECT` is assumed.
    pub const AUTH_FAIL_ACTION_UNSPECIFIED: AuthFailAction = AuthFailAction::new(0);

    /// Redirects user to "accounts.google.com". The user is redirected back to the
    /// application URL after signing in or creating an account.
    pub const AUTH_FAIL_ACTION_REDIRECT: AuthFailAction = AuthFailAction::new(1);

    /// Rejects request with a `401` HTTP status code and an error
    /// message.
    pub const AUTH_FAIL_ACTION_UNAUTHORIZED: AuthFailAction = AuthFailAction::new(2);

    /// Creates a new AuthFailAction instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("AUTH_FAIL_ACTION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("AUTH_FAIL_ACTION_REDIRECT"),
            2 => std::borrow::Cow::Borrowed("AUTH_FAIL_ACTION_UNAUTHORIZED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "AUTH_FAIL_ACTION_UNSPECIFIED" => {
                std::option::Option::Some(Self::AUTH_FAIL_ACTION_UNSPECIFIED)
            }
            "AUTH_FAIL_ACTION_REDIRECT" => {
                std::option::Option::Some(Self::AUTH_FAIL_ACTION_REDIRECT)
            }
            "AUTH_FAIL_ACTION_UNAUTHORIZED" => {
                std::option::Option::Some(Self::AUTH_FAIL_ACTION_UNAUTHORIZED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for AuthFailAction {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for AuthFailAction {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Methods to restrict access to a URL based on login status.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct LoginRequirement(i32);

impl LoginRequirement {
    /// Not specified. `LOGIN_OPTIONAL` is assumed.
    pub const LOGIN_UNSPECIFIED: LoginRequirement = LoginRequirement::new(0);

    /// Does not require that the user is signed in.
    pub const LOGIN_OPTIONAL: LoginRequirement = LoginRequirement::new(1);

    /// If the user is not signed in, the `auth_fail_action` is taken.
    /// In addition, if the user is not an administrator for the
    /// application, they are given an error message regardless of
    /// `auth_fail_action`. If the user is an administrator, the handler
    /// proceeds.
    pub const LOGIN_ADMIN: LoginRequirement = LoginRequirement::new(2);

    /// If the user has signed in, the handler proceeds normally. Otherwise, the
    /// auth_fail_action is taken.
    pub const LOGIN_REQUIRED: LoginRequirement = LoginRequirement::new(3);

    /// Creates a new LoginRequirement instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("LOGIN_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("LOGIN_OPTIONAL"),
            2 => std::borrow::Cow::Borrowed("LOGIN_ADMIN"),
            3 => std::borrow::Cow::Borrowed("LOGIN_REQUIRED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "LOGIN_UNSPECIFIED" => std::option::Option::Some(Self::LOGIN_UNSPECIFIED),
            "LOGIN_OPTIONAL" => std::option::Option::Some(Self::LOGIN_OPTIONAL),
            "LOGIN_ADMIN" => std::option::Option::Some(Self::LOGIN_ADMIN),
            "LOGIN_REQUIRED" => std::option::Option::Some(Self::LOGIN_REQUIRED),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for LoginRequirement {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for LoginRequirement {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Methods to enforce security (HTTPS) on a URL.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SecurityLevel(i32);

impl SecurityLevel {
    /// Not specified.
    pub const SECURE_UNSPECIFIED: SecurityLevel = SecurityLevel::new(0);

    /// Both HTTP and HTTPS requests with URLs that match the handler succeed
    /// without redirects. The application can examine the request to determine
    /// which protocol was used, and respond accordingly.
    pub const SECURE_DEFAULT: SecurityLevel = SecurityLevel::new(0);

    /// Requests for a URL that match this handler that use HTTPS are automatically
    /// redirected to the HTTP equivalent URL.
    pub const SECURE_NEVER: SecurityLevel = SecurityLevel::new(1);

    /// Both HTTP and HTTPS requests with URLs that match the handler succeed
    /// without redirects. The application can examine the request to determine
    /// which protocol was used and respond accordingly.
    pub const SECURE_OPTIONAL: SecurityLevel = SecurityLevel::new(2);

    /// Requests for a URL that match this handler that do not use HTTPS are
    /// automatically redirected to the HTTPS URL with the same path. Query
    /// parameters are reserved for the redirect.
    pub const SECURE_ALWAYS: SecurityLevel = SecurityLevel::new(3);

    /// Creates a new SecurityLevel instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SECURE_DEFAULT"),
            1 => std::borrow::Cow::Borrowed("SECURE_NEVER"),
            2 => std::borrow::Cow::Borrowed("SECURE_OPTIONAL"),
            3 => std::borrow::Cow::Borrowed("SECURE_ALWAYS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SECURE_UNSPECIFIED" => std::option::Option::Some(Self::SECURE_UNSPECIFIED),
            "SECURE_DEFAULT" => std::option::Option::Some(Self::SECURE_DEFAULT),
            "SECURE_NEVER" => std::option::Option::Some(Self::SECURE_NEVER),
            "SECURE_OPTIONAL" => std::option::Option::Some(Self::SECURE_OPTIONAL),
            "SECURE_ALWAYS" => std::option::Option::Some(Self::SECURE_ALWAYS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for SecurityLevel {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for SecurityLevel {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Fields that should be returned when [Version][google.appengine.v1.Version] resources
/// are retrieved.
///
/// [google.appengine.v1.Version]: crate::model::Version
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct VersionView(i32);

impl VersionView {
    /// Basic version information including scaling and inbound services,
    /// but not detailed deployment information.
    pub const BASIC: VersionView = VersionView::new(0);

    /// The information from `BASIC`, plus detailed information about the
    /// deployment. This format is required when creating resources, but
    /// is not returned in `Get` or `List` by default.
    pub const FULL: VersionView = VersionView::new(1);

    /// Creates a new VersionView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("BASIC"),
            1 => std::borrow::Cow::Borrowed("FULL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "BASIC" => std::option::Option::Some(Self::BASIC),
            "FULL" => std::option::Option::Some(Self::FULL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for VersionView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for VersionView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Fields that should be returned when an AuthorizedCertificate resource is
/// retrieved.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct AuthorizedCertificateView(i32);

impl AuthorizedCertificateView {
    /// Basic certificate information, including applicable domains and expiration
    /// date.
    pub const BASIC_CERTIFICATE: AuthorizedCertificateView = AuthorizedCertificateView::new(0);

    /// The information from `BASIC_CERTIFICATE`, plus detailed information on the
    /// domain mappings that have this certificate mapped.
    pub const FULL_CERTIFICATE: AuthorizedCertificateView = AuthorizedCertificateView::new(1);

    /// Creates a new AuthorizedCertificateView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("BASIC_CERTIFICATE"),
            1 => std::borrow::Cow::Borrowed("FULL_CERTIFICATE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "BASIC_CERTIFICATE" => std::option::Option::Some(Self::BASIC_CERTIFICATE),
            "FULL_CERTIFICATE" => std::option::Option::Some(Self::FULL_CERTIFICATE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for AuthorizedCertificateView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for AuthorizedCertificateView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Override strategy for mutating an existing mapping.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DomainOverrideStrategy(i32);

impl DomainOverrideStrategy {
    /// Strategy unspecified. Defaults to `STRICT`.
    pub const UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY: DomainOverrideStrategy =
        DomainOverrideStrategy::new(0);

    /// Overrides not allowed. If a mapping already exists for the
    /// specified domain, the request will return an ALREADY_EXISTS (409).
    pub const STRICT: DomainOverrideStrategy = DomainOverrideStrategy::new(1);

    /// Overrides allowed. If a mapping already exists for the specified domain,
    /// the request will overwrite it. Note that this might stop another
    /// Google product from serving. For example, if the domain is
    /// mapped to another App Engine application, that app will no
    /// longer serve from that domain.
    pub const OVERRIDE: DomainOverrideStrategy = DomainOverrideStrategy::new(2);

    /// Creates a new DomainOverrideStrategy instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY"),
            1 => std::borrow::Cow::Borrowed("STRICT"),
            2 => std::borrow::Cow::Borrowed("OVERRIDE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY" => {
                std::option::Option::Some(Self::UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY)
            }
            "STRICT" => std::option::Option::Some(Self::STRICT),
            "OVERRIDE" => std::option::Option::Some(Self::OVERRIDE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DomainOverrideStrategy {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DomainOverrideStrategy {
    fn default() -> Self {
        Self::new(0)
    }
}

/// State of certificate management. Refers to the most recent certificate
/// acquisition or renewal attempt.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ManagementStatus(i32);

impl ManagementStatus {
    pub const MANAGEMENT_STATUS_UNSPECIFIED: ManagementStatus = ManagementStatus::new(0);

    /// Certificate was successfully obtained and inserted into the serving
    /// system.
    pub const OK: ManagementStatus = ManagementStatus::new(1);

    /// Certificate is under active attempts to acquire or renew.
    pub const PENDING: ManagementStatus = ManagementStatus::new(2);

    /// Most recent renewal failed due to an invalid DNS setup and will be
    /// retried. Renewal attempts will continue to fail until the certificate
    /// domain's DNS configuration is fixed. The last successfully provisioned
    /// certificate may still be serving.
    pub const FAILED_RETRYING_NOT_VISIBLE: ManagementStatus = ManagementStatus::new(4);

    /// All renewal attempts have been exhausted, likely due to an invalid DNS
    /// setup.
    pub const FAILED_PERMANENT: ManagementStatus = ManagementStatus::new(6);

    /// Most recent renewal failed due to an explicit CAA record that does not
    /// include one of the in-use CAs (Google CA and Let's Encrypt). Renewals will
    /// continue to fail until the CAA is reconfigured. The last successfully
    /// provisioned certificate may still be serving.
    pub const FAILED_RETRYING_CAA_FORBIDDEN: ManagementStatus = ManagementStatus::new(7);

    /// Most recent renewal failed due to a CAA retrieval failure. This means that
    /// the domain's DNS provider does not properly handle CAA records, failing
    /// requests for CAA records when no CAA records are defined. Renewals will
    /// continue to fail until the DNS provider is changed or a CAA record is
    /// added for the given domain. The last successfully provisioned certificate
    /// may still be serving.
    pub const FAILED_RETRYING_CAA_CHECKING: ManagementStatus = ManagementStatus::new(8);

    /// Creates a new ManagementStatus instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MANAGEMENT_STATUS_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("OK"),
            2 => std::borrow::Cow::Borrowed("PENDING"),
            4 => std::borrow::Cow::Borrowed("FAILED_RETRYING_NOT_VISIBLE"),
            6 => std::borrow::Cow::Borrowed("FAILED_PERMANENT"),
            7 => std::borrow::Cow::Borrowed("FAILED_RETRYING_CAA_FORBIDDEN"),
            8 => std::borrow::Cow::Borrowed("FAILED_RETRYING_CAA_CHECKING"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MANAGEMENT_STATUS_UNSPECIFIED" => {
                std::option::Option::Some(Self::MANAGEMENT_STATUS_UNSPECIFIED)
            }
            "OK" => std::option::Option::Some(Self::OK),
            "PENDING" => std::option::Option::Some(Self::PENDING),
            "FAILED_RETRYING_NOT_VISIBLE" => {
                std::option::Option::Some(Self::FAILED_RETRYING_NOT_VISIBLE)
            }
            "FAILED_PERMANENT" => std::option::Option::Some(Self::FAILED_PERMANENT),
            "FAILED_RETRYING_CAA_FORBIDDEN" => {
                std::option::Option::Some(Self::FAILED_RETRYING_CAA_FORBIDDEN)
            }
            "FAILED_RETRYING_CAA_CHECKING" => {
                std::option::Option::Some(Self::FAILED_RETRYING_CAA_CHECKING)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ManagementStatus {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ManagementStatus {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Available inbound services.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct InboundServiceType(i32);

impl InboundServiceType {
    /// Not specified.
    pub const INBOUND_SERVICE_UNSPECIFIED: InboundServiceType = InboundServiceType::new(0);

    /// Allows an application to receive mail.
    pub const INBOUND_SERVICE_MAIL: InboundServiceType = InboundServiceType::new(1);

    /// Allows an application to receive email-bound notifications.
    pub const INBOUND_SERVICE_MAIL_BOUNCE: InboundServiceType = InboundServiceType::new(2);

    /// Allows an application to receive error stanzas.
    pub const INBOUND_SERVICE_XMPP_ERROR: InboundServiceType = InboundServiceType::new(3);

    /// Allows an application to receive instant messages.
    pub const INBOUND_SERVICE_XMPP_MESSAGE: InboundServiceType = InboundServiceType::new(4);

    /// Allows an application to receive user subscription POSTs.
    pub const INBOUND_SERVICE_XMPP_SUBSCRIBE: InboundServiceType = InboundServiceType::new(5);

    /// Allows an application to receive a user's chat presence.
    pub const INBOUND_SERVICE_XMPP_PRESENCE: InboundServiceType = InboundServiceType::new(6);

    /// Registers an application for notifications when a client connects or
    /// disconnects from a channel.
    pub const INBOUND_SERVICE_CHANNEL_PRESENCE: InboundServiceType = InboundServiceType::new(7);

    /// Enables warmup requests.
    pub const INBOUND_SERVICE_WARMUP: InboundServiceType = InboundServiceType::new(9);

    /// Creates a new InboundServiceType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_MAIL"),
            2 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_MAIL_BOUNCE"),
            3 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_XMPP_ERROR"),
            4 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_XMPP_MESSAGE"),
            5 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_XMPP_SUBSCRIBE"),
            6 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_XMPP_PRESENCE"),
            7 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_CHANNEL_PRESENCE"),
            9 => std::borrow::Cow::Borrowed("INBOUND_SERVICE_WARMUP"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "INBOUND_SERVICE_UNSPECIFIED" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_UNSPECIFIED)
            }
            "INBOUND_SERVICE_MAIL" => std::option::Option::Some(Self::INBOUND_SERVICE_MAIL),
            "INBOUND_SERVICE_MAIL_BOUNCE" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_MAIL_BOUNCE)
            }
            "INBOUND_SERVICE_XMPP_ERROR" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_XMPP_ERROR)
            }
            "INBOUND_SERVICE_XMPP_MESSAGE" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_XMPP_MESSAGE)
            }
            "INBOUND_SERVICE_XMPP_SUBSCRIBE" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_XMPP_SUBSCRIBE)
            }
            "INBOUND_SERVICE_XMPP_PRESENCE" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_XMPP_PRESENCE)
            }
            "INBOUND_SERVICE_CHANNEL_PRESENCE" => {
                std::option::Option::Some(Self::INBOUND_SERVICE_CHANNEL_PRESENCE)
            }
            "INBOUND_SERVICE_WARMUP" => std::option::Option::Some(Self::INBOUND_SERVICE_WARMUP),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for InboundServiceType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for InboundServiceType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Run states of a version.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ServingStatus(i32);

impl ServingStatus {
    /// Not specified.
    pub const SERVING_STATUS_UNSPECIFIED: ServingStatus = ServingStatus::new(0);

    /// Currently serving. Instances are created according to the
    /// scaling settings of the version.
    pub const SERVING: ServingStatus = ServingStatus::new(1);

    /// Disabled. No instances will be created and the scaling
    /// settings are ignored until the state of the version changes
    /// to `SERVING`.
    pub const STOPPED: ServingStatus = ServingStatus::new(2);

    /// Creates a new ServingStatus instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SERVING_STATUS_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("SERVING"),
            2 => std::borrow::Cow::Borrowed("STOPPED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SERVING_STATUS_UNSPECIFIED" => {
                std::option::Option::Some(Self::SERVING_STATUS_UNSPECIFIED)
            }
            "SERVING" => std::option::Option::Some(Self::SERVING),
            "STOPPED" => std::option::Option::Some(Self::STOPPED),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ServingStatus {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ServingStatus {
    fn default() -> Self {
        Self::new(0)
    }
}
