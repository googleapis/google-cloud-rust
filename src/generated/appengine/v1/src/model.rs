// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/)
/// configuration for API handlers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiConfigHandler {
    /// Action to take when users access resources that require
    /// authentication. Defaults to `redirect`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auth_fail_action: crate::model::AuthFailAction,

    /// Level of login required to access this resource. Defaults to
    /// `optional`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub login: crate::model::LoginRequirement,

    /// Path to the script from the application root directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,

    /// Security (HTTPS) enforcement for this URL.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub security_level: crate::model::SecurityLevel,

    /// URL to serve the endpoint at.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiConfigHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_fail_action][crate::model::ApiConfigHandler::auth_fail_action].
    pub fn set_auth_fail_action<T: std::convert::Into<crate::model::AuthFailAction>>(
        mut self,
        v: T,
    ) -> Self {
        self.auth_fail_action = v.into();
        self
    }

    /// Sets the value of [login][crate::model::ApiConfigHandler::login].
    pub fn set_login<T: std::convert::Into<crate::model::LoginRequirement>>(
        mut self,
        v: T,
    ) -> Self {
        self.login = v.into();
        self
    }

    /// Sets the value of [script][crate::model::ApiConfigHandler::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::ApiConfigHandler::security_level].
    pub fn set_security_level<T: std::convert::Into<crate::model::SecurityLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [url][crate::model::ApiConfigHandler::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for ApiConfigHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ApiConfigHandler"
    }
}

/// Custom static error page to be served when an error occurs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorHandler {
    /// Error condition this handler applies to.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub error_code: crate::model::error_handler::ErrorCode,

    /// Static file content to be served for this error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub static_file: std::string::String,

    /// MIME type of file. Defaults to `text/html`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::ErrorHandler::error_code].
    pub fn set_error_code<T: std::convert::Into<crate::model::error_handler::ErrorCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [static_file][crate::model::ErrorHandler::static_file].
    pub fn set_static_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.static_file = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::ErrorHandler::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for ErrorHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ErrorHandler"
    }
}

/// Defines additional types related to [ErrorHandler].
pub mod error_handler {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// Not specified. ERROR_CODE_DEFAULT is assumed.
        Unspecified,
        /// All other error types.
        Default,
        /// Application has exceeded a resource quota.
        OverQuota,
        /// Client blocked by the application's Denial of Service protection
        /// configuration.
        DosApiDenial,
        /// Deadline reached before the application responds.
        Timeout,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(0),
                Self::OverQuota => std::option::Option::Some(1),
                Self::DosApiDenial => std::option::Option::Some(2),
                Self::Timeout => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("ERROR_CODE_DEFAULT"),
                Self::OverQuota => std::option::Option::Some("ERROR_CODE_OVER_QUOTA"),
                Self::DosApiDenial => std::option::Option::Some("ERROR_CODE_DOS_API_DENIAL"),
                Self::Timeout => std::option::Option::Some("ERROR_CODE_TIMEOUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Default,
                1 => Self::OverQuota,
                2 => Self::DosApiDenial,
                3 => Self::Timeout,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "ERROR_CODE_DEFAULT" => Self::Default,
                "ERROR_CODE_OVER_QUOTA" => Self::OverQuota,
                "ERROR_CODE_DOS_API_DENIAL" => Self::DosApiDenial,
                "ERROR_CODE_TIMEOUT" => Self::Timeout,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(0),
                Self::OverQuota => serializer.serialize_i32(1),
                Self::DosApiDenial => serializer.serialize_i32(2),
                Self::Timeout => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.appengine.v1.ErrorHandler.ErrorCode",
            ))
        }
    }
}

/// URL pattern and description of how the URL should be handled. App Engine can
/// handle URLs by executing application code or by serving static files
/// uploaded with the version, such as images, CSS, or JavaScript.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UrlMap {
    /// URL prefix. Uses regular expression syntax, which means regexp
    /// special characters must be escaped, but should not contain groupings.
    /// All URLs that begin with this prefix are handled by this handler, using the
    /// portion of the URL after the prefix as part of the file path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url_regex: std::string::String,

    /// Security (HTTPS) enforcement for this URL.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub security_level: crate::model::SecurityLevel,

    /// Level of login required to access this resource. Not supported for Node.js
    /// in the App Engine standard environment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub login: crate::model::LoginRequirement,

    /// Action to take when users access resources that require
    /// authentication. Defaults to `redirect`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auth_fail_action: crate::model::AuthFailAction,

    /// `30x` code to use when performing redirects for the `secure` field.
    /// Defaults to `302`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub redirect_http_response_code: crate::model::url_map::RedirectHttpResponseCode,

    /// Type of handler for this URL pattern.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub handler_type: std::option::Option<crate::model::url_map::HandlerType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UrlMap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url_regex][crate::model::UrlMap::url_regex].
    pub fn set_url_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url_regex = v.into();
        self
    }

    /// Sets the value of [security_level][crate::model::UrlMap::security_level].
    pub fn set_security_level<T: std::convert::Into<crate::model::SecurityLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_level = v.into();
        self
    }

    /// Sets the value of [login][crate::model::UrlMap::login].
    pub fn set_login<T: std::convert::Into<crate::model::LoginRequirement>>(
        mut self,
        v: T,
    ) -> Self {
        self.login = v.into();
        self
    }

    /// Sets the value of [auth_fail_action][crate::model::UrlMap::auth_fail_action].
    pub fn set_auth_fail_action<T: std::convert::Into<crate::model::AuthFailAction>>(
        mut self,
        v: T,
    ) -> Self {
        self.auth_fail_action = v.into();
        self
    }

    /// Sets the value of [redirect_http_response_code][crate::model::UrlMap::redirect_http_response_code].
    pub fn set_redirect_http_response_code<
        T: std::convert::Into<crate::model::url_map::RedirectHttpResponseCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redirect_http_response_code = v.into();
        self
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type].
    ///
    /// Note that all the setters affecting `handler_type` are mutually
    /// exclusive.
    pub fn set_handler_type<
        T: std::convert::Into<std::option::Option<crate::model::url_map::HandlerType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type = v.into();
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `StaticFiles`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_files(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticFilesHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::StaticFiles(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `StaticFiles`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_static_files<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticFilesHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::StaticFiles(v.into()));
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `Script`, `None` if the field is not set or
    /// holds a different branch.
    pub fn script(&self) -> std::option::Option<&std::boxed::Box<crate::model::ScriptHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::Script(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `Script`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_script<T: std::convert::Into<std::boxed::Box<crate::model::ScriptHandler>>>(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::Script(v.into()));
        self
    }

    /// The value of [handler_type][crate::model::UrlMap::handler_type]
    /// if it holds a `ApiEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn api_endpoint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ApiEndpointHandler>> {
        #[allow(unreachable_patterns)]
        self.handler_type.as_ref().and_then(|v| match v {
            crate::model::url_map::HandlerType::ApiEndpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [handler_type][crate::model::UrlMap::handler_type]
    /// to hold a `ApiEndpoint`.
    ///
    /// Note that all the setters affecting `handler_type` are
    /// mutually exclusive.
    pub fn set_api_endpoint<
        T: std::convert::Into<std::boxed::Box<crate::model::ApiEndpointHandler>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.handler_type =
            std::option::Option::Some(crate::model::url_map::HandlerType::ApiEndpoint(v.into()));
        self
    }
}

impl wkt::message::Message for UrlMap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UrlMap"
    }
}

/// Defines additional types related to [UrlMap].
pub mod url_map {
    #[allow(unused_imports)]
    use super::*;

    /// Redirect codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RedirectHttpResponseCode {
        /// Not specified. `302` is assumed.
        Unspecified,
        /// `301 Moved Permanently` code.
        RedirectHttpResponseCode301,
        /// `302 Moved Temporarily` code.
        RedirectHttpResponseCode302,
        /// `303 See Other` code.
        RedirectHttpResponseCode303,
        /// `307 Temporary Redirect` code.
        RedirectHttpResponseCode307,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RedirectHttpResponseCode::value] or
        /// [RedirectHttpResponseCode::name].
        UnknownValue(redirect_http_response_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod redirect_http_response_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RedirectHttpResponseCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RedirectHttpResponseCode301 => std::option::Option::Some(1),
                Self::RedirectHttpResponseCode302 => std::option::Option::Some(2),
                Self::RedirectHttpResponseCode303 => std::option::Option::Some(3),
                Self::RedirectHttpResponseCode307 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED")
                }
                Self::RedirectHttpResponseCode301 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_301")
                }
                Self::RedirectHttpResponseCode302 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_302")
                }
                Self::RedirectHttpResponseCode303 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_303")
                }
                Self::RedirectHttpResponseCode307 => {
                    std::option::Option::Some("REDIRECT_HTTP_RESPONSE_CODE_307")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RedirectHttpResponseCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RedirectHttpResponseCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RedirectHttpResponseCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RedirectHttpResponseCode301,
                2 => Self::RedirectHttpResponseCode302,
                3 => Self::RedirectHttpResponseCode303,
                4 => Self::RedirectHttpResponseCode307,
                _ => Self::UnknownValue(redirect_http_response_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RedirectHttpResponseCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED" => Self::Unspecified,
                "REDIRECT_HTTP_RESPONSE_CODE_301" => Self::RedirectHttpResponseCode301,
                "REDIRECT_HTTP_RESPONSE_CODE_302" => Self::RedirectHttpResponseCode302,
                "REDIRECT_HTTP_RESPONSE_CODE_303" => Self::RedirectHttpResponseCode303,
                "REDIRECT_HTTP_RESPONSE_CODE_307" => Self::RedirectHttpResponseCode307,
                _ => Self::UnknownValue(redirect_http_response_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RedirectHttpResponseCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RedirectHttpResponseCode301 => serializer.serialize_i32(1),
                Self::RedirectHttpResponseCode302 => serializer.serialize_i32(2),
                Self::RedirectHttpResponseCode303 => serializer.serialize_i32(3),
                Self::RedirectHttpResponseCode307 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RedirectHttpResponseCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<RedirectHttpResponseCode>::new(
                    ".google.appengine.v1.UrlMap.RedirectHttpResponseCode",
                ),
            )
        }
    }

    /// Type of handler for this URL pattern.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum HandlerType {
        /// Returns the contents of a file, such as an image, as the response.
        StaticFiles(std::boxed::Box<crate::model::StaticFilesHandler>),
        /// Executes a script to handle the requests that match this URL
        /// pattern. Only the `auto` value is supported for Node.js in the
        /// App Engine standard environment, for example `"script": "auto"`.
        Script(std::boxed::Box<crate::model::ScriptHandler>),
        /// Uses API Endpoints to handle requests.
        ApiEndpoint(std::boxed::Box<crate::model::ApiEndpointHandler>),
    }
}

/// Files served directly to the user for a given URL, such as images, CSS
/// stylesheets, or JavaScript source files. Static file handlers describe which
/// files in the application directory are static files, and which URLs serve
/// them.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticFilesHandler {
    /// Path to the static files matched by the URL pattern, from the
    /// application root directory. The path can refer to text matched in groupings
    /// in the URL pattern.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Regular expression that matches the file paths for all files that should be
    /// referenced by this handler.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upload_path_regex: std::string::String,

    /// HTTP headers to use for all responses from these URLs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub http_headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// MIME type used to serve all files served by this handler.
    ///
    /// Defaults to file-specific MIME types, which are derived from each file's
    /// filename extension.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Time a static file served by this handler should be cached
    /// by web proxies and browsers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<wkt::Duration>,

    /// Whether this handler should match the request if the file
    /// referenced by the handler does not exist.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub require_matching_file: bool,

    /// Whether files should also be uploaded as code data. By default, files
    /// declared in static file handlers are uploaded as static
    /// data and are only served to end users; they cannot be read by the
    /// application. If enabled, uploads are charged against both your code and
    /// static data storage resource quotas.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub application_readable: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticFilesHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::StaticFilesHandler::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [upload_path_regex][crate::model::StaticFilesHandler::upload_path_regex].
    pub fn set_upload_path_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.upload_path_regex = v.into();
        self
    }

    /// Sets the value of [http_headers][crate::model::StaticFilesHandler::http_headers].
    pub fn set_http_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.http_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [mime_type][crate::model::StaticFilesHandler::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [expiration][crate::model::StaticFilesHandler::expiration].
    pub fn set_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration][crate::model::StaticFilesHandler::expiration].
    pub fn set_or_clear_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [require_matching_file][crate::model::StaticFilesHandler::require_matching_file].
    pub fn set_require_matching_file<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_matching_file = v.into();
        self
    }

    /// Sets the value of [application_readable][crate::model::StaticFilesHandler::application_readable].
    pub fn set_application_readable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.application_readable = v.into();
        self
    }
}

impl wkt::message::Message for StaticFilesHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.StaticFilesHandler"
    }
}

/// Executes a script to handle the request that matches the URL pattern.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScriptHandler {
    /// Path to the script from the application root directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScriptHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_path][crate::model::ScriptHandler::script_path].
    pub fn set_script_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_path = v.into();
        self
    }
}

impl wkt::message::Message for ScriptHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ScriptHandler"
    }
}

/// Uses Google Cloud Endpoints to handle requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiEndpointHandler {
    /// Path to the script from the application root directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiEndpointHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_path][crate::model::ApiEndpointHandler::script_path].
    pub fn set_script_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_path = v.into();
        self
    }
}

impl wkt::message::Message for ApiEndpointHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ApiEndpointHandler"
    }
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances. Only applicable for
/// instances in App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HealthCheck {
    /// Whether to explicitly disable health checks for this instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_health_check: bool,

    /// Host header to send when performing an HTTP health check.
    /// Example: "myapp.appspot.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Number of consecutive successful health checks required before receiving
    /// traffic.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub healthy_threshold: u32,

    /// Number of consecutive failed health checks required before removing
    /// traffic.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub unhealthy_threshold: u32,

    /// Number of consecutive failed health checks required before an instance is
    /// restarted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub restart_threshold: u32,

    /// Interval between health checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the health check is considered failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HealthCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_health_check][crate::model::HealthCheck::disable_health_check].
    pub fn set_disable_health_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_health_check = v.into();
        self
    }

    /// Sets the value of [host][crate::model::HealthCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [healthy_threshold][crate::model::HealthCheck::healthy_threshold].
    pub fn set_healthy_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.healthy_threshold = v.into();
        self
    }

    /// Sets the value of [unhealthy_threshold][crate::model::HealthCheck::unhealthy_threshold].
    pub fn set_unhealthy_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.unhealthy_threshold = v.into();
        self
    }

    /// Sets the value of [restart_threshold][crate::model::HealthCheck::restart_threshold].
    pub fn set_restart_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.restart_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::HealthCheck::check_interval].
    pub fn set_check_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_interval][crate::model::HealthCheck::check_interval].
    pub fn set_or_clear_check_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::HealthCheck::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::HealthCheck::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HealthCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.HealthCheck"
    }
}

/// Readiness checking configuration for VM instances. Unhealthy instances
/// are removed from traffic rotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadinessCheck {
    /// The request path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Host header to send when performing a HTTP Readiness check.
    /// Example: "myapp.appspot.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Number of consecutive failed checks required before removing
    /// traffic.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub failure_threshold: u32,

    /// Number of consecutive successful checks required before receiving
    /// traffic.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub success_threshold: u32,

    /// Interval between health checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the check is considered failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// A maximum time limit on application initialization, measured from moment
    /// the application successfully replies to a healthcheck until it is ready to
    /// serve traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_start_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadinessCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::ReadinessCheck::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [host][crate::model::ReadinessCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::ReadinessCheck::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::ReadinessCheck::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::ReadinessCheck::check_interval].
    pub fn set_check_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_interval][crate::model::ReadinessCheck::check_interval].
    pub fn set_or_clear_check_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::ReadinessCheck::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::ReadinessCheck::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [app_start_timeout][crate::model::ReadinessCheck::app_start_timeout].
    pub fn set_app_start_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.app_start_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_start_timeout][crate::model::ReadinessCheck::app_start_timeout].
    pub fn set_or_clear_app_start_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.app_start_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReadinessCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ReadinessCheck"
    }
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LivenessCheck {
    /// The request path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Host header to send when performing a HTTP Liveness check.
    /// Example: "myapp.appspot.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Number of consecutive failed checks required before considering the
    /// VM unhealthy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub failure_threshold: u32,

    /// Number of consecutive successful checks required before considering
    /// the VM healthy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::U32")]
    pub success_threshold: u32,

    /// Interval between health checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_interval: std::option::Option<wkt::Duration>,

    /// Time before the check is considered failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// The initial delay before starting to execute the checks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initial_delay: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LivenessCheck {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::LivenessCheck::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [host][crate::model::LivenessCheck::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::LivenessCheck::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::LivenessCheck::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [check_interval][crate::model::LivenessCheck::check_interval].
    pub fn set_check_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_interval][crate::model::LivenessCheck::check_interval].
    pub fn set_or_clear_check_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.check_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::LivenessCheck::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::LivenessCheck::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initial_delay][crate::model::LivenessCheck::initial_delay].
    pub fn set_initial_delay<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_delay = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_delay][crate::model::LivenessCheck::initial_delay].
    pub fn set_or_clear_initial_delay<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_delay = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LivenessCheck {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.LivenessCheck"
    }
}

/// Third-party Python runtime library that is required by the application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Library {
    /// Name of the library. Example: "django".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Version of the library to select, or "latest".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Library {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Library::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Library::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Library {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Library"
    }
}

/// Request message for `Applications.GetApplication`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetApplicationRequest {
    /// Name of the Application resource to get. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetApplicationRequest"
    }
}

/// Request message for `Applications.CreateApplication`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateApplicationRequest {
    /// Application configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub application: std::option::Option<crate::model::Application>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application][crate::model::CreateApplicationRequest::application].
    pub fn set_application<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application][crate::model::CreateApplicationRequest::application].
    pub fn set_or_clear_application<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateApplicationRequest"
    }
}

/// Request message for `Applications.UpdateApplication`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateApplicationRequest {
    /// Name of the Application resource to update. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An Application containing the updated resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub application: std::option::Option<crate::model::Application>,

    /// Required. Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [application][crate::model::UpdateApplicationRequest::application].
    pub fn set_application<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application][crate::model::UpdateApplicationRequest::application].
    pub fn set_or_clear_application<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateApplicationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateApplicationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateApplicationRequest"
    }
}

/// Request message for 'Applications.RepairApplication'.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairApplicationRequest {
    /// Name of the application to repair. Example: `apps/myapp`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairApplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RepairApplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RepairApplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.RepairApplicationRequest"
    }
}

/// Request message for `Services.ListServices`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListServicesRequest"
    }
}

/// Response message for `Services.ListServices`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The services belonging to the requested application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<crate::model::Service>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Services.GetService`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Name of the resource requested. Example: `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetServiceRequest"
    }
}

/// Request message for `Services.UpdateService`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Name of the resource to update. Example: `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A Service resource containing the updated service. Only fields set in the
    /// field mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    /// Required. Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Set to `true` to gradually shift traffic to one or more versions that you
    /// specify. By default, traffic is shifted immediately.
    /// For gradual traffic migration, the target versions
    /// must be located within instances that are configured for both
    /// [warmup requests](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#InboundServiceType)
    /// and
    /// [automatic scaling](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#AutomaticScaling).
    /// You must specify the
    /// [`shardBy`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services#ShardBy)
    /// field in the Service resource. Gradual traffic migration is not
    /// supported in the App Engine flexible environment. For examples, see
    /// [Migrating and Splitting Traffic](https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub migrate_traffic: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migrate_traffic][crate::model::UpdateServiceRequest::migrate_traffic].
    pub fn set_migrate_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.migrate_traffic = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateServiceRequest"
    }
}

/// Request message for `Services.DeleteService`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Name of the resource requested. Example: `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteServiceRequest"
    }
}

/// Request message for `Versions.ListVersions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Name of the parent Service resource. Example:
    /// `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Controls the set of fields returned in the `List` response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::VersionView,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListVersionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListVersionsRequest"
    }
}

/// Response message for `Versions.ListVersions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The versions belonging to the requested service.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Versions.GetVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Controls the set of fields returned in the `Get` response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::VersionView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetVersionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetVersionRequest"
    }
}

/// Request message for `Versions.CreateVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Name of the parent resource to create this version under. Example:
    /// `apps/myapp/services/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Application deployment configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionRequest"
    }
}

/// Request message for `Versions.UpdateVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/services/default/versions/1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A Version containing the updated resource. Only fields set in the field
    /// mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    /// Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateVersionRequest"
    }
}

/// Request message for `Versions.DeleteVersion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteVersionRequest"
    }
}

/// Request message for `Instances.ListInstances`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Name of the parent Version resource. Example:
    /// `apps/myapp/services/default/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListInstancesRequest"
    }
}

/// Response message for `Instances.ListInstances`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The instances belonging to the requested version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Instances.GetInstance`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetInstanceRequest"
    }
}

/// Request message for `Instances.DeleteInstance`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteInstanceRequest"
    }
}

/// Request message for `Instances.DebugInstance`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DebugInstanceRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Public SSH key to add to the instance. Examples:
    ///
    /// * `[USERNAME]:ssh-rsa [KEY_VALUE] [USERNAME]`
    /// * `[USERNAME]:ssh-rsa [KEY_VALUE] google-ssh {"userName":"[USERNAME]","expireOn":"[EXPIRE_TIME]"}`
    ///
    /// For more information, see
    /// [Adding and Removing SSH Keys](https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssh_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DebugInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DebugInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssh_key][crate::model::DebugInstanceRequest::ssh_key].
    pub fn set_ssh_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssh_key = v.into();
        self
    }
}

impl wkt::message::Message for DebugInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DebugInstanceRequest"
    }
}

/// Request message for `Firewall.ListIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIngressRulesRequest {
    /// Name of the Firewall collection to retrieve.
    /// Example: `apps/myapp/firewall/ingressRules`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A valid IP Address. If set, only rules matching this address will be
    /// returned. The first returned rule will be the rule that fires on requests
    /// from this IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub matching_address: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIngressRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIngressRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIngressRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIngressRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [matching_address][crate::model::ListIngressRulesRequest::matching_address].
    pub fn set_matching_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matching_address = v.into();
        self
    }
}

impl wkt::message::Message for ListIngressRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListIngressRulesRequest"
    }
}

/// Response message for `Firewall.ListIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIngressRulesResponse {
    /// The ingress FirewallRules for this application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIngressRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_rules][crate::model::ListIngressRulesResponse::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIngressRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIngressRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListIngressRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIngressRulesResponse {
    type PageItem = crate::model::FirewallRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ingress_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `Firewall.BatchUpdateIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchUpdateIngressRulesRequest {
    /// Name of the Firewall collection to set.
    /// Example: `apps/myapp/firewall/ingressRules`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A list of FirewallRules to replace the existing set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateIngressRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchUpdateIngressRulesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ingress_rules][crate::model::BatchUpdateIngressRulesRequest::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateIngressRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BatchUpdateIngressRulesRequest"
    }
}

/// Response message for `Firewall.UpdateAllIngressRules`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchUpdateIngressRulesResponse {
    /// The full list of ingress FirewallRules for this application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ingress_rules: std::vec::Vec<crate::model::FirewallRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateIngressRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_rules][crate::model::BatchUpdateIngressRulesResponse::ingress_rules].
    pub fn set_ingress_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallRule>,
    {
        use std::iter::Iterator;
        self.ingress_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateIngressRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BatchUpdateIngressRulesResponse"
    }
}

/// Request message for `Firewall.CreateIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIngressRuleRequest {
    /// Name of the parent Firewall collection in which to create a new rule.
    /// Example: `apps/myapp/firewall/ingressRules`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A FirewallRule containing the new resource.
    ///
    /// The user may optionally provide a position at which the new rule will be
    /// placed. The positions define a sequential list starting at 1. If a rule
    /// already exists at the given position, rules greater than the provided
    /// position will be moved forward by one.
    ///
    /// If no position is provided, the server will place the rule as the second to
    /// last rule in the sequence before the required default allow-all or deny-all
    /// rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::FirewallRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIngressRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::CreateIngressRuleRequest::rule].
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::CreateIngressRuleRequest::rule].
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateIngressRuleRequest"
    }
}

/// Request message for `Firewall.GetIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIngressRuleRequest {
    /// Name of the Firewall resource to retrieve.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetIngressRuleRequest"
    }
}

/// Request message for `Firewall.UpdateIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIngressRuleRequest {
    /// Name of the Firewall resource to update.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A FirewallRule containing the updated resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::FirewallRule>,

    /// Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::UpdateIngressRuleRequest::rule].
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::UpdateIngressRuleRequest::rule].
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallRule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIngressRuleRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIngressRuleRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateIngressRuleRequest"
    }
}

/// Request message for `Firewall.DeleteIngressRule`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIngressRuleRequest {
    /// Name of the Firewall resource to delete.
    /// Example: `apps/myapp/firewall/ingressRules/100`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIngressRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIngressRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIngressRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteIngressRuleRequest"
    }
}

/// Request message for `AuthorizedDomains.ListAuthorizedDomains`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedDomainsRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedDomainsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedDomainsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedDomainsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedDomainsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedDomainsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedDomainsRequest"
    }
}

/// Response message for `AuthorizedDomains.ListAuthorizedDomains`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedDomainsResponse {
    /// The authorized domains belonging to the user.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domains: std::vec::Vec<crate::model::AuthorizedDomain>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedDomainsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domains][crate::model::ListAuthorizedDomainsResponse::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedDomain>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedDomainsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedDomainsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedDomainsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedDomainsResponse {
    type PageItem = crate::model::AuthorizedDomain;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domains
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AuthorizedCertificates.ListAuthorizedCertificates`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedCertificatesRequest {
    /// Name of the parent `Application` resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Controls the set of fields returned in the `LIST` response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::AuthorizedCertificateView,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedCertificatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedCertificatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAuthorizedCertificatesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AuthorizedCertificateView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedCertificatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedCertificatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedCertificatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedCertificatesRequest"
    }
}

/// Response message for `AuthorizedCertificates.ListAuthorizedCertificates`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedCertificatesResponse {
    /// The SSL certificates the user is authorized to administer.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certificates: std::vec::Vec<crate::model::AuthorizedCertificate>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedCertificatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificates][crate::model::ListAuthorizedCertificatesResponse::certificates].
    pub fn set_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        use std::iter::Iterator;
        self.certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedCertificatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedCertificatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListAuthorizedCertificatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedCertificatesResponse {
    type PageItem = crate::model::AuthorizedCertificate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AuthorizedCertificates.GetAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAuthorizedCertificateRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Controls the set of fields returned in the `GET` response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::AuthorizedCertificateView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAuthorizedCertificateRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::AuthorizedCertificateView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetAuthorizedCertificateRequest"
    }
}

/// Request message for `AuthorizedCertificates.CreateAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAuthorizedCertificateRequest {
    /// Name of the parent `Application` resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// SSL certificate data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate: std::option::Option<crate::model::AuthorizedCertificate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAuthorizedCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::CreateAuthorizedCertificateRequest::certificate].
    pub fn set_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate][crate::model::CreateAuthorizedCertificateRequest::certificate].
    pub fn set_or_clear_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateAuthorizedCertificateRequest"
    }
}

/// Request message for `AuthorizedCertificates.UpdateAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAuthorizedCertificateRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An `AuthorizedCertificate` containing the updated resource. Only fields set
    /// in the field mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate: std::option::Option<crate::model::AuthorizedCertificate>,

    /// Standard field mask for the set of fields to be updated. Updates are only
    /// supported on the `certificate_raw_data` and `display_name` fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::UpdateAuthorizedCertificateRequest::certificate].
    pub fn set_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate][crate::model::UpdateAuthorizedCertificateRequest::certificate].
    pub fn set_or_clear_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedCertificate>,
    {
        self.certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAuthorizedCertificateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAuthorizedCertificateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateAuthorizedCertificateRequest"
    }
}

/// Request message for `AuthorizedCertificates.DeleteAuthorizedCertificate`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAuthorizedCertificateRequest {
    /// Name of the resource to delete. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAuthorizedCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAuthorizedCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAuthorizedCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteAuthorizedCertificateRequest"
    }
}

/// Request message for `DomainMappings.ListDomainMappings`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainMappingsRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum results to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainMappingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDomainMappingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDomainMappingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDomainMappingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainMappingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListDomainMappingsRequest"
    }
}

/// Response message for `DomainMappings.ListDomainMappings`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainMappingsResponse {
    /// The domain mappings for the application.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domain_mappings: std::vec::Vec<crate::model::DomainMapping>,

    /// Continuation token for fetching the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainMappingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain_mappings][crate::model::ListDomainMappingsResponse::domain_mappings].
    pub fn set_domain_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DomainMapping>,
    {
        use std::iter::Iterator;
        self.domain_mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDomainMappingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainMappingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ListDomainMappingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDomainMappingsResponse {
    type PageItem = crate::model::DomainMapping;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domain_mappings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `DomainMappings.GetDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDomainMappingRequest {
    /// Name of the resource requested. Example:
    /// `apps/myapp/domainMappings/example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.GetDomainMappingRequest"
    }
}

/// Request message for `DomainMappings.CreateDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDomainMappingRequest {
    /// Name of the parent Application resource. Example: `apps/myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Domain mapping configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain_mapping: std::option::Option<crate::model::DomainMapping>,

    /// Whether the domain creation should override any existing mappings for this
    /// domain. By default, overrides are rejected.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub override_strategy: crate::model::DomainOverrideStrategy,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDomainMappingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [domain_mapping][crate::model::CreateDomainMappingRequest::domain_mapping].
    pub fn set_domain_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain_mapping][crate::model::CreateDomainMappingRequest::domain_mapping].
    pub fn set_or_clear_domain_mapping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = v.map(|x| x.into());
        self
    }

    /// Sets the value of [override_strategy][crate::model::CreateDomainMappingRequest::override_strategy].
    pub fn set_override_strategy<T: std::convert::Into<crate::model::DomainOverrideStrategy>>(
        mut self,
        v: T,
    ) -> Self {
        self.override_strategy = v.into();
        self
    }
}

impl wkt::message::Message for CreateDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateDomainMappingRequest"
    }
}

/// Request message for `DomainMappings.UpdateDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDomainMappingRequest {
    /// Name of the resource to update. Example:
    /// `apps/myapp/domainMappings/example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A domain mapping containing the updated resource. Only fields set
    /// in the field mask will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain_mapping: std::option::Option<crate::model::DomainMapping>,

    /// Required. Standard field mask for the set of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [domain_mapping][crate::model::UpdateDomainMappingRequest::domain_mapping].
    pub fn set_domain_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain_mapping][crate::model::UpdateDomainMappingRequest::domain_mapping].
    pub fn set_or_clear_domain_mapping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DomainMapping>,
    {
        self.domain_mapping = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDomainMappingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDomainMappingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateDomainMappingRequest"
    }
}

/// Request message for `DomainMappings.DeleteDomainMapping`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDomainMappingRequest {
    /// Name of the resource to delete. Example:
    /// `apps/myapp/domainMappings/example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDomainMappingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDomainMappingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDomainMappingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DeleteDomainMappingRequest"
    }
}

/// An Application resource contains the top-level configuration of an App
/// Engine application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Application {
    /// Full path to the Application resource in the API.
    /// Example: `apps/myapp`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Identifier of the Application resource. This identifier is equivalent
    /// to the project ID of the Google Cloud Platform project where you want to
    /// deploy your application.
    /// Example: `myapp`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// HTTP path dispatch rules for requests to the application that do not
    /// explicitly target a service or version. Rules are order-dependent.
    /// Up to 20 dispatch rules can be supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dispatch_rules: std::vec::Vec<crate::model::UrlDispatchRule>,

    /// Google Apps authentication domain that controls which users can access
    /// this application.
    ///
    /// Defaults to open access for any Google Account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub auth_domain: std::string::String,

    /// Location from which this application runs. Application instances
    /// run out of the data centers in the specified location, which is also where
    /// all of the application's end user content is stored.
    ///
    /// Defaults to `us-central`.
    ///
    /// View the list of
    /// [supported locations](https://cloud.google.com/appengine/docs/locations).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// Google Cloud Storage bucket that can be used for storing files
    /// associated with this application. This bucket is associated with the
    /// application and can be used by the gcloud deployment commands.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code_bucket: std::string::String,

    /// Cookie expiration policy for this application.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_cookie_expiration: std::option::Option<wkt::Duration>,

    /// Serving status of this application.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub serving_status: crate::model::application::ServingStatus,

    /// Hostname used to reach this application, as resolved by App Engine.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_hostname: std::string::String,

    /// Google Cloud Storage bucket that can be used by this application to store
    /// content.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_bucket: std::string::String,

    /// The service account associated with the application.
    /// This is the app-level default identity. If no identity provided during
    /// create version, Admin API will fallback to this one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub iap: std::option::Option<crate::model::application::IdentityAwareProxy>,

    /// The Google Container Registry domain used for storing managed build docker
    /// images for this application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcr_domain: std::string::String,

    /// The type of the Cloud Firestore or Cloud Datastore database associated with
    /// this application.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub database_type: crate::model::application::DatabaseType,

    /// The feature specific settings to be used in the application.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_settings: std::option::Option<crate::model::application::FeatureSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Application {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Application::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Application::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [dispatch_rules][crate::model::Application::dispatch_rules].
    pub fn set_dispatch_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UrlDispatchRule>,
    {
        use std::iter::Iterator;
        self.dispatch_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auth_domain][crate::model::Application::auth_domain].
    pub fn set_auth_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.auth_domain = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::Application::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [code_bucket][crate::model::Application::code_bucket].
    pub fn set_code_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code_bucket = v.into();
        self
    }

    /// Sets the value of [default_cookie_expiration][crate::model::Application::default_cookie_expiration].
    pub fn set_default_cookie_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_cookie_expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_cookie_expiration][crate::model::Application::default_cookie_expiration].
    pub fn set_or_clear_default_cookie_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_cookie_expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serving_status][crate::model::Application::serving_status].
    pub fn set_serving_status<T: std::convert::Into<crate::model::application::ServingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_status = v.into();
        self
    }

    /// Sets the value of [default_hostname][crate::model::Application::default_hostname].
    pub fn set_default_hostname<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_hostname = v.into();
        self
    }

    /// Sets the value of [default_bucket][crate::model::Application::default_bucket].
    pub fn set_default_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_bucket = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Application::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [iap][crate::model::Application::iap].
    pub fn set_iap<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::application::IdentityAwareProxy>,
    {
        self.iap = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [iap][crate::model::Application::iap].
    pub fn set_or_clear_iap<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::application::IdentityAwareProxy>,
    {
        self.iap = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcr_domain][crate::model::Application::gcr_domain].
    pub fn set_gcr_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcr_domain = v.into();
        self
    }

    /// Sets the value of [database_type][crate::model::Application::database_type].
    pub fn set_database_type<T: std::convert::Into<crate::model::application::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_type = v.into();
        self
    }

    /// Sets the value of [feature_settings][crate::model::Application::feature_settings].
    pub fn set_feature_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::application::FeatureSettings>,
    {
        self.feature_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feature_settings][crate::model::Application::feature_settings].
    pub fn set_or_clear_feature_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::application::FeatureSettings>,
    {
        self.feature_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Application {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Application"
    }
}

/// Defines additional types related to [Application].
pub mod application {
    #[allow(unused_imports)]
    use super::*;

    /// Identity-Aware Proxy
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IdentityAwareProxy {
        /// Whether the serving infrastructure will authenticate and
        /// authorize all incoming requests.
        ///
        /// If true, the `oauth2_client_id` and `oauth2_client_secret`
        /// fields must be non-empty.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        /// OAuth2 client ID to use for the authentication flow.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub oauth2_client_id: std::string::String,

        /// OAuth2 client secret to use for the authentication flow.
        ///
        /// For security reasons, this value cannot be retrieved via the API.
        /// Instead, the SHA-256 hash of the value is returned in the
        /// `oauth2_client_secret_sha256` field.
        ///
        /// @InputOnly
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub oauth2_client_secret: std::string::String,

        /// Hex-encoded SHA-256 hash of the client secret.
        ///
        /// @OutputOnly
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub oauth2_client_secret_sha256: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IdentityAwareProxy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::application::IdentityAwareProxy::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [oauth2_client_id][crate::model::application::IdentityAwareProxy::oauth2_client_id].
        pub fn set_oauth2_client_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_id = v.into();
            self
        }

        /// Sets the value of [oauth2_client_secret][crate::model::application::IdentityAwareProxy::oauth2_client_secret].
        pub fn set_oauth2_client_secret<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_secret = v.into();
            self
        }

        /// Sets the value of [oauth2_client_secret_sha256][crate::model::application::IdentityAwareProxy::oauth2_client_secret_sha256].
        pub fn set_oauth2_client_secret_sha256<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.oauth2_client_secret_sha256 = v.into();
            self
        }
    }

    impl wkt::message::Message for IdentityAwareProxy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Application.IdentityAwareProxy"
        }
    }

    /// The feature specific settings to be used in the application. These define
    /// behaviors that are user configurable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureSettings {
        /// Boolean value indicating if split health checks should be used instead
        /// of the legacy health checks. At an app.yaml level, this means defaulting
        /// to 'readiness_check' and 'liveness_check' values instead of
        /// 'health_check' ones. Once the legacy 'health_check' behavior is
        /// deprecated, and this value is always true, this setting can
        /// be removed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub split_health_checks: bool,

        /// If true, use [Container-Optimized OS](https://cloud.google.com/container-optimized-os/)
        /// base image for VMs, rather than a base Debian image.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub use_container_optimized_os: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FeatureSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [split_health_checks][crate::model::application::FeatureSettings::split_health_checks].
        pub fn set_split_health_checks<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.split_health_checks = v.into();
            self
        }

        /// Sets the value of [use_container_optimized_os][crate::model::application::FeatureSettings::use_container_optimized_os].
        pub fn set_use_container_optimized_os<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_container_optimized_os = v.into();
            self
        }
    }

    impl wkt::message::Message for FeatureSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Application.FeatureSettings"
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServingStatus {
        /// Serving status is unspecified.
        Unspecified,
        /// Application is serving.
        Serving,
        /// Application has been disabled by the user.
        UserDisabled,
        /// Application has been disabled by the system.
        SystemDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ServingStatus::value] or
        /// [ServingStatus::name].
        UnknownValue(serving_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod serving_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ServingStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Serving => std::option::Option::Some(1),
                Self::UserDisabled => std::option::Option::Some(2),
                Self::SystemDisabled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Serving => std::option::Option::Some("SERVING"),
                Self::UserDisabled => std::option::Option::Some("USER_DISABLED"),
                Self::SystemDisabled => std::option::Option::Some("SYSTEM_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ServingStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ServingStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ServingStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Serving,
                2 => Self::UserDisabled,
                3 => Self::SystemDisabled,
                _ => Self::UnknownValue(serving_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ServingStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "SERVING" => Self::Serving,
                "USER_DISABLED" => Self::UserDisabled,
                "SYSTEM_DISABLED" => Self::SystemDisabled,
                _ => Self::UnknownValue(serving_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ServingStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Serving => serializer.serialize_i32(1),
                Self::UserDisabled => serializer.serialize_i32(2),
                Self::SystemDisabled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ServingStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServingStatus>::new(
                ".google.appengine.v1.Application.ServingStatus",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Database type is unspecified.
        Unspecified,
        /// Cloud Datastore
        CloudDatastore,
        /// Cloud Firestore Native
        CloudFirestore,
        /// Cloud Firestore in Datastore Mode
        CloudDatastoreCompatibility,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudDatastore => std::option::Option::Some(1),
                Self::CloudFirestore => std::option::Option::Some(2),
                Self::CloudDatastoreCompatibility => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::CloudDatastore => std::option::Option::Some("CLOUD_DATASTORE"),
                Self::CloudFirestore => std::option::Option::Some("CLOUD_FIRESTORE"),
                Self::CloudDatastoreCompatibility => {
                    std::option::Option::Some("CLOUD_DATASTORE_COMPATIBILITY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudDatastore,
                2 => Self::CloudFirestore,
                3 => Self::CloudDatastoreCompatibility,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_DATASTORE" => Self::CloudDatastore,
                "CLOUD_FIRESTORE" => Self::CloudFirestore,
                "CLOUD_DATASTORE_COMPATIBILITY" => Self::CloudDatastoreCompatibility,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudDatastore => serializer.serialize_i32(1),
                Self::CloudFirestore => serializer.serialize_i32(2),
                Self::CloudDatastoreCompatibility => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.appengine.v1.Application.DatabaseType",
            ))
        }
    }
}

/// Rules to match an HTTP request and dispatch that request to a service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UrlDispatchRule {
    /// Domain name to match against. The wildcard "`*`" is supported if
    /// specified before a period: "`*.`".
    ///
    /// Defaults to matching all domains: "`*`".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// Pathname within the host. Must start with a "`/`". A
    /// single "`*`" can be included at the end of the path.
    ///
    /// The sum of the lengths of the domain and path may not
    /// exceed 100 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Resource ID of a service in this application that should
    /// serve the matched request. The service must already
    /// exist. Example: `default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UrlDispatchRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::UrlDispatchRule::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [path][crate::model::UrlDispatchRule::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UrlDispatchRule::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for UrlDispatchRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UrlDispatchRule"
    }
}

/// App Engine admin service audit log.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuditData {
    /// Detailed information about methods that require it. Does not include
    /// simple Get, List or Delete methods because all significant information
    /// (resource name, number of returned elements for List operations) is already
    /// included in parent audit log message.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::audit_data::Method>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuditData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::AuditData::method].
    ///
    /// Note that all the setters affecting `method` are mutually
    /// exclusive.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::audit_data::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::AuditData::method]
    /// if it holds a `UpdateService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateServiceMethod>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::audit_data::Method::UpdateService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::AuditData::method]
    /// to hold a `UpdateService`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_update_service<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateServiceMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::audit_data::Method::UpdateService(v.into()));
        self
    }

    /// The value of [method][crate::model::AuditData::method]
    /// if it holds a `CreateVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_version(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateVersionMethod>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::audit_data::Method::CreateVersion(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::AuditData::method]
    /// to hold a `CreateVersion`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_create_version<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateVersionMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method =
            std::option::Option::Some(crate::model::audit_data::Method::CreateVersion(v.into()));
        self
    }
}

impl wkt::message::Message for AuditData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuditData"
    }
}

/// Defines additional types related to [AuditData].
pub mod audit_data {
    #[allow(unused_imports)]
    use super::*;

    /// Detailed information about methods that require it. Does not include
    /// simple Get, List or Delete methods because all significant information
    /// (resource name, number of returned elements for List operations) is already
    /// included in parent audit log message.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// Detailed information about UpdateService call.
        UpdateService(std::boxed::Box<crate::model::UpdateServiceMethod>),
        /// Detailed information about CreateVersion call.
        CreateVersion(std::boxed::Box<crate::model::CreateVersionMethod>),
    }
}

/// Detailed information about UpdateService call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceMethod {
    /// Update service request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::UpdateServiceRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceMethod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::UpdateServiceMethod::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpdateServiceRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::UpdateServiceMethod::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpdateServiceRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServiceMethod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.UpdateServiceMethod"
    }
}

/// Detailed information about CreateVersion call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVersionMethod {
    /// Create version request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::CreateVersionRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionMethod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::CreateVersionMethod::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateVersionRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::CreateVersionMethod::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateVersionRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionMethod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionMethod"
    }
}

/// An SSL certificate that a user has been authorized to administer. A user
/// is authorized to administer any certificate that applies to one of their
/// authorized domains.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthorizedCertificate {
    /// Full path to the `AuthorizedCertificate` resource in the API. Example:
    /// `apps/myapp/authorizedCertificates/12345`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the certificate. This is a unique value autogenerated
    /// on `AuthorizedCertificate` resource creation. Example: `12345`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The user-specified display name of the certificate. This is not
    /// guaranteed to be unique. Example: `My Certificate`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Topmost applicable domains of this certificate. This certificate
    /// applies to these domains and their subdomains. Example: `example.com`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domain_names: std::vec::Vec<std::string::String>,

    /// The time when this certificate expires. To update the renewal time on this
    /// certificate, upload an SSL certificate with a different expiration time
    /// using [`AuthorizedCertificates.UpdateAuthorizedCertificate`]().
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The SSL certificate serving the `AuthorizedCertificate` resource. This
    /// must be obtained independently from a certificate authority.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub certificate_raw_data: std::option::Option<crate::model::CertificateRawData>,

    /// Only applicable if this certificate is managed by App Engine. Managed
    /// certificates are tied to the lifecycle of a `DomainMapping` and cannot be
    /// updated or deleted via the `AuthorizedCertificates` API. If this
    /// certificate is manually administered by the user, this field will be empty.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub managed_certificate: std::option::Option<crate::model::ManagedCertificate>,

    /// The full paths to user visible Domain Mapping resources that have this
    /// certificate mapped. Example: `apps/myapp/domainMappings/example.com`.
    ///
    /// This may not represent the full list of mapped domain mappings if the user
    /// does not have `VIEWER` permissions on all of the applications that have
    /// this certificate mapped. See `domain_mappings_count` for a complete count.
    ///
    /// Only returned by `GET` or `LIST` requests when specifically requested by
    /// the `view=FULL_CERTIFICATE` option.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub visible_domain_mappings: std::vec::Vec<std::string::String>,

    /// Aggregate count of the domain mappings with this certificate mapped. This
    /// count includes domain mappings on applications for which the user does not
    /// have `VIEWER` permissions.
    ///
    /// Only returned by `GET` or `LIST` requests when specifically requested by
    /// the `view=FULL_CERTIFICATE` option.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub domain_mappings_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedCertificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedCertificate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AuthorizedCertificate::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AuthorizedCertificate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [domain_names][crate::model::AuthorizedCertificate::domain_names].
    pub fn set_domain_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.domain_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expire_time][crate::model::AuthorizedCertificate::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::AuthorizedCertificate::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [certificate_raw_data][crate::model::AuthorizedCertificate::certificate_raw_data].
    pub fn set_certificate_raw_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateRawData>,
    {
        self.certificate_raw_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_raw_data][crate::model::AuthorizedCertificate::certificate_raw_data].
    pub fn set_or_clear_certificate_raw_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateRawData>,
    {
        self.certificate_raw_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [managed_certificate][crate::model::AuthorizedCertificate::managed_certificate].
    pub fn set_managed_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedCertificate>,
    {
        self.managed_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [managed_certificate][crate::model::AuthorizedCertificate::managed_certificate].
    pub fn set_or_clear_managed_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedCertificate>,
    {
        self.managed_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [visible_domain_mappings][crate::model::AuthorizedCertificate::visible_domain_mappings].
    pub fn set_visible_domain_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.visible_domain_mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [domain_mappings_count][crate::model::AuthorizedCertificate::domain_mappings_count].
    pub fn set_domain_mappings_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.domain_mappings_count = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizedCertificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuthorizedCertificate"
    }
}

/// An SSL certificate obtained from a certificate authority.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateRawData {
    /// PEM encoded x.509 public key certificate. This field is set once on
    /// certificate creation. Must include the header and footer. Example:
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_certificate: std::string::String,

    /// Unencrypted PEM encoded RSA private key. This field is set once on
    /// certificate creation and then encrypted. The key size must be 2048
    /// bits or fewer. Must include the header and footer. Example:
    ///
    /// @InputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateRawData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_certificate][crate::model::CertificateRawData::public_certificate].
    pub fn set_public_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_certificate = v.into();
        self
    }

    /// Sets the value of [private_key][crate::model::CertificateRawData::private_key].
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }
}

impl wkt::message::Message for CertificateRawData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CertificateRawData"
    }
}

/// A certificate managed by App Engine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedCertificate {
    /// Time at which the certificate was last renewed. The renewal process is
    /// fully managed. Certificate renewal will automatically occur before the
    /// certificate expires. Renewal errors can be tracked via `ManagementStatus`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_renewal_time: std::option::Option<wkt::Timestamp>,

    /// Status of certificate management. Refers to the most recent certificate
    /// acquisition or renewal attempt.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub status: crate::model::ManagementStatus,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedCertificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_renewal_time][crate::model::ManagedCertificate::last_renewal_time].
    pub fn set_last_renewal_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_renewal_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_renewal_time][crate::model::ManagedCertificate::last_renewal_time].
    pub fn set_or_clear_last_renewal_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_renewal_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::ManagedCertificate::status].
    pub fn set_status<T: std::convert::Into<crate::model::ManagementStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ManagedCertificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ManagedCertificate"
    }
}

/// Code and application artifacts used to deploy a version to App Engine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Deployment {
    /// Manifest of the files stored in Google Cloud Storage that are included
    /// as part of this version. All files must be readable using the
    /// credentials supplied with this call.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub files: std::collections::HashMap<std::string::String, crate::model::FileInfo>,

    /// The Docker image for the container that runs the version.
    /// Only applicable for instances running in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container: std::option::Option<crate::model::ContainerInfo>,

    /// The zip file for this deployment, if this is a zip deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zip: std::option::Option<crate::model::ZipInfo>,

    /// Options for any Google Cloud Build builds created as a part of this
    /// deployment.
    ///
    /// These options will only be used if a new build is created, such as when
    /// deploying to the App Engine flexible environment using files or zip.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_build_options: std::option::Option<crate::model::CloudBuildOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [files][crate::model::Deployment::files].
    pub fn set_files<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileInfo>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [container][crate::model::Deployment::container].
    pub fn set_container<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContainerInfo>,
    {
        self.container = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container][crate::model::Deployment::container].
    pub fn set_or_clear_container<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContainerInfo>,
    {
        self.container = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zip][crate::model::Deployment::zip].
    pub fn set_zip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ZipInfo>,
    {
        self.zip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zip][crate::model::Deployment::zip].
    pub fn set_or_clear_zip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ZipInfo>,
    {
        self.zip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_build_options][crate::model::Deployment::cloud_build_options].
    pub fn set_cloud_build_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudBuildOptions>,
    {
        self.cloud_build_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_build_options][crate::model::Deployment::cloud_build_options].
    pub fn set_or_clear_cloud_build_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudBuildOptions>,
    {
        self.cloud_build_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Deployment"
    }
}

/// Single source file that is part of the version to be deployed. Each source
/// file that is deployed must be specified separately.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileInfo {
    /// URL source to use to fetch this file. Must be a URL to a resource in
    /// Google Cloud Storage in the form
    /// 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_url: std::string::String,

    /// The SHA1 hash of the file, in hex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_sum: std::string::String,

    /// The MIME type of the file.
    ///
    /// Defaults to the value from Google Cloud Storage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_url][crate::model::FileInfo::source_url].
    pub fn set_source_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_url = v.into();
        self
    }

    /// Sets the value of [sha1_sum][crate::model::FileInfo::sha1_sum].
    pub fn set_sha1_sum<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_sum = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::FileInfo::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for FileInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.FileInfo"
    }
}

/// Docker image that is used to create a container and start a VM instance for
/// the version that you deploy. Only applicable for instances running in the App
/// Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerInfo {
    /// URI to the hosted container image in Google Container Registry. The URI
    /// must be fully qualified and include a tag or digest.
    /// Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::ContainerInfo::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }
}

impl wkt::message::Message for ContainerInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ContainerInfo"
    }
}

/// Options for the build operations performed as a part of the version
/// deployment. Only applicable for App Engine flexible environment when creating
/// a version using source code directly.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudBuildOptions {
    /// Path to the yaml file used in deployment, used to determine runtime
    /// configuration details.
    ///
    /// Required for flexible environment builds.
    ///
    /// See <https://cloud.google.com/appengine/docs/standard/python/config/appref>
    /// for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_yaml_path: std::string::String,

    /// The Cloud Build timeout used as part of any dependent builds performed by
    /// version creation. Defaults to 10 minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_build_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudBuildOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [app_yaml_path][crate::model::CloudBuildOptions::app_yaml_path].
    pub fn set_app_yaml_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_yaml_path = v.into();
        self
    }

    /// Sets the value of [cloud_build_timeout][crate::model::CloudBuildOptions::cloud_build_timeout].
    pub fn set_cloud_build_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cloud_build_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_build_timeout][crate::model::CloudBuildOptions::cloud_build_timeout].
    pub fn set_or_clear_cloud_build_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cloud_build_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudBuildOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CloudBuildOptions"
    }
}

/// The zip file information for a zip deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZipInfo {
    /// URL of the zip file to deploy from. Must be a URL to a resource in
    /// Google Cloud Storage in the form
    /// 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_url: std::string::String,

    /// An estimate of the number of files in a zip for a zip deployment.
    /// If set, must be greater than or equal to the actual number of files.
    /// Used for optimizing performance; if not provided, deployment may be slow.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub files_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZipInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_url][crate::model::ZipInfo::source_url].
    pub fn set_source_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_url = v.into();
        self
    }

    /// Sets the value of [files_count][crate::model::ZipInfo::files_count].
    pub fn set_files_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.files_count = v.into();
        self
    }
}

impl wkt::message::Message for ZipInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ZipInfo"
    }
}

/// A domain that a user has been authorized to administer. To authorize use
/// of a domain, verify ownership via
/// [Search Console](https://search.google.com/search-console/welcome).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthorizedDomain {
    /// Full path to the `AuthorizedDomain` resource in the API. Example:
    /// `apps/myapp/authorizedDomains/example.com`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Fully qualified domain name of the domain authorized for use. Example:
    /// `example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedDomain {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedDomain::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AuthorizedDomain::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizedDomain {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AuthorizedDomain"
    }
}

/// A domain serving an App Engine application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DomainMapping {
    /// Full path to the `DomainMapping` resource in the API. Example:
    /// `apps/myapp/domainMapping/example.com`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the domain serving the application. Example:
    /// `example.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// SSL configuration for this domain. If unconfigured, this domain will not
    /// serve with SSL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_settings: std::option::Option<crate::model::SslSettings>,

    /// The resource records required to configure this domain mapping. These
    /// records must be added to the domain's DNS configuration in order to
    /// serve the application via this domain mapping.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_records: std::vec::Vec<crate::model::ResourceRecord>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DomainMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DomainMapping::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::DomainMapping::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [ssl_settings][crate::model::DomainMapping::ssl_settings].
    pub fn set_ssl_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslSettings>,
    {
        self.ssl_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_settings][crate::model::DomainMapping::ssl_settings].
    pub fn set_or_clear_ssl_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslSettings>,
    {
        self.ssl_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_records][crate::model::DomainMapping::resource_records].
    pub fn set_resource_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceRecord>,
    {
        use std::iter::Iterator;
        self.resource_records = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DomainMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DomainMapping"
    }
}

/// SSL configuration for a `DomainMapping` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslSettings {
    /// ID of the `AuthorizedCertificate` resource configuring SSL for the
    /// application. Clearing this field will remove SSL support.
    ///
    /// By default, a managed certificate is automatically created for every
    /// domain mapping. To omit SSL support or to configure SSL manually, specify
    /// `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must
    /// be authorized to administer the `AuthorizedCertificate` resource to
    /// manually map it to a `DomainMapping` resource.
    /// Example: `12345`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub certificate_id: std::string::String,

    /// SSL management type for this domain. If `AUTOMATIC`, a managed certificate
    /// is automatically provisioned. If `MANUAL`, `certificate_id` must be
    /// manually specified in order to configure SSL for this domain.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ssl_management_type: crate::model::ssl_settings::SslManagementType,

    /// ID of the managed `AuthorizedCertificate` resource currently being
    /// provisioned, if applicable. Until the new managed certificate has been
    /// successfully provisioned, the previous SSL state will be preserved. Once
    /// the provisioning process completes, the `certificate_id` field will reflect
    /// the new managed certificate and this field will be left empty. To remove
    /// SSL support while there is still a pending managed certificate, clear the
    /// `certificate_id` field with an `UpdateDomainMappingRequest`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pending_managed_certificate_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_id][crate::model::SslSettings::certificate_id].
    pub fn set_certificate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.certificate_id = v.into();
        self
    }

    /// Sets the value of [ssl_management_type][crate::model::SslSettings::ssl_management_type].
    pub fn set_ssl_management_type<
        T: std::convert::Into<crate::model::ssl_settings::SslManagementType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_management_type = v.into();
        self
    }

    /// Sets the value of [pending_managed_certificate_id][crate::model::SslSettings::pending_managed_certificate_id].
    pub fn set_pending_managed_certificate_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pending_managed_certificate_id = v.into();
        self
    }
}

impl wkt::message::Message for SslSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.SslSettings"
    }
}

/// Defines additional types related to [SslSettings].
pub mod ssl_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The SSL management type for this domain.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslManagementType {
        /// Defaults to `AUTOMATIC`.
        Unspecified,
        /// SSL support for this domain is configured automatically. The mapped SSL
        /// certificate will be automatically renewed.
        Automatic,
        /// SSL support for this domain is configured manually by the user. Either
        /// the domain has no SSL support or a user-obtained SSL certificate has been
        /// explictly mapped to this domain.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslManagementType::value] or
        /// [SslManagementType::name].
        UnknownValue(ssl_management_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_management_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslManagementType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_MANAGEMENT_TYPE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslManagementType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslManagementType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslManagementType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(ssl_management_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslManagementType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_MANAGEMENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(ssl_management_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslManagementType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslManagementType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslManagementType>::new(
                ".google.appengine.v1.SslSettings.SslManagementType",
            ))
        }
    }
}

/// A DNS resource record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRecord {
    /// Relative name of the object affected by this record. Only applicable for
    /// `CNAME` records. Example: 'www'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Data for this record. Values vary by record type, as defined in RFC 1035
    /// (section 5) and RFC 1034 (section 3.6.1).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rrdata: std::string::String,

    /// Resource record type. Example: `AAAA`.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::resource_record::RecordType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceRecord::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rrdata][crate::model::ResourceRecord::rrdata].
    pub fn set_rrdata<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rrdata = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ResourceRecord::type].
    pub fn set_type<T: std::convert::Into<crate::model::resource_record::RecordType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for ResourceRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ResourceRecord"
    }
}

/// Defines additional types related to [ResourceRecord].
pub mod resource_record {
    #[allow(unused_imports)]
    use super::*;

    /// A resource record type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RecordType {
        /// An unknown resource record.
        Unspecified,
        /// An A resource record. Data is an IPv4 address.
        A,
        /// An AAAA resource record. Data is an IPv6 address.
        Aaaa,
        /// A CNAME resource record. Data is a domain name to be aliased.
        Cname,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RecordType::value] or
        /// [RecordType::name].
        UnknownValue(record_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod record_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RecordType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::A => std::option::Option::Some(1),
                Self::Aaaa => std::option::Option::Some(2),
                Self::Cname => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECORD_TYPE_UNSPECIFIED"),
                Self::A => std::option::Option::Some("A"),
                Self::Aaaa => std::option::Option::Some("AAAA"),
                Self::Cname => std::option::Option::Some("CNAME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RecordType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RecordType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RecordType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::A,
                2 => Self::Aaaa,
                3 => Self::Cname,
                _ => Self::UnknownValue(record_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RecordType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECORD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "A" => Self::A,
                "AAAA" => Self::Aaaa,
                "CNAME" => Self::Cname,
                _ => Self::UnknownValue(record_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RecordType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::A => serializer.serialize_i32(1),
                Self::Aaaa => serializer.serialize_i32(2),
                Self::Cname => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RecordType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RecordType>::new(
                ".google.appengine.v1.ResourceRecord.RecordType",
            ))
        }
    }
}

/// A single firewall rule that is evaluated against incoming traffic
/// and provides an action to take on matched requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirewallRule {
    /// A positive integer between [1, Int32.MaxValue-1] that defines the order of
    /// rule evaluation. Rules with the lowest priority are evaluated first.
    ///
    /// A default rule at priority Int32.MaxValue matches all IPv4 and IPv6 traffic
    /// when no previous rule matches. Only the action of this rule can be modified
    /// by the user.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub priority: i32,

    /// The action to take on matched requests.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub action: crate::model::firewall_rule::Action,

    /// IP address or range, defined using CIDR notation, of requests that this
    /// rule applies to. You can use the wildcard character "*" to match all IPs
    /// equivalent to "0/0" and "::/0" together.
    /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
    /// or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_range: std::string::String,

    /// An optional string description of this rule.
    /// This field has a maximum length of 100 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [priority][crate::model::FirewallRule::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [action][crate::model::FirewallRule::action].
    pub fn set_action<T: std::convert::Into<crate::model::firewall_rule::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [source_range][crate::model::FirewallRule::source_range].
    pub fn set_source_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_range = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FirewallRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for FirewallRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.FirewallRule"
    }
}

/// Defines additional types related to [FirewallRule].
pub mod firewall_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Available actions to take on matching requests.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        UnspecifiedAction,
        /// Matching requests are allowed.
        Allow,
        /// Matching requests are denied.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::UnspecifiedAction => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::UnspecifiedAction => std::option::Option::Some("UNSPECIFIED_ACTION"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::UnspecifiedAction,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED_ACTION" => Self::UnspecifiedAction,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::UnspecifiedAction => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.appengine.v1.FirewallRule.Action",
            ))
        }
    }
}

/// An Instance resource is the computing unit that App Engine uses to
/// automatically scale an application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. Full path to the Instance resource in the API.
    /// Example: `apps/myapp/services/default/versions/v1/instances/instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Relative name of the instance within the version.
    /// Example: `instance-1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. App Engine release this instance is running on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_engine_release: std::string::String,

    /// Output only. Availability of the instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub availability: crate::model::instance::Availability,

    /// Output only. Name of the virtual machine where this instance lives. Only applicable
    /// for instances in App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// Output only. Zone where the virtual machine is located. Only applicable for instances
    /// in App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone_name: std::string::String,

    /// Output only. Virtual machine ID of this instance. Only applicable for instances in
    /// App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_id: std::string::String,

    /// Output only. Time that this instance was started.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of requests since this instance was started.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub requests: i32,

    /// Output only. Number of errors since this instance was started.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub errors: i32,

    /// Output only. Average queries per second (QPS) over the last minute.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub qps: f32,

    /// Output only. Average latency (ms) over the last minute.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub average_latency: i32,

    /// Output only. Total memory in use (bytes).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub memory_usage: i64,

    /// Output only. Status of the virtual machine where this instance lives. Only applicable
    /// for instances in App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_status: std::string::String,

    /// Output only. Whether this instance is in debug mode. Only applicable for instances in
    /// App Engine flexible environment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub vm_debug_enabled: bool,

    /// Output only. The IP address of this instance. Only applicable for instances in App
    /// Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_ip: std::string::String,

    /// Output only. The liveness health check of this instance. Only applicable for instances
    /// in App Engine flexible environment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub vm_liveness: crate::model::instance::liveness::LivenessState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [app_engine_release][crate::model::Instance::app_engine_release].
    pub fn set_app_engine_release<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_release = v.into();
        self
    }

    /// Sets the value of [availability][crate::model::Instance::availability].
    pub fn set_availability<T: std::convert::Into<crate::model::instance::Availability>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::Instance::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_zone_name][crate::model::Instance::vm_zone_name].
    pub fn set_vm_zone_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone_name = v.into();
        self
    }

    /// Sets the value of [vm_id][crate::model::Instance::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Instance::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Instance::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requests][crate::model::Instance::requests].
    pub fn set_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.requests = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::Instance::errors].
    pub fn set_errors<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.errors = v.into();
        self
    }

    /// Sets the value of [qps][crate::model::Instance::qps].
    pub fn set_qps<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.qps = v.into();
        self
    }

    /// Sets the value of [average_latency][crate::model::Instance::average_latency].
    pub fn set_average_latency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.average_latency = v.into();
        self
    }

    /// Sets the value of [memory_usage][crate::model::Instance::memory_usage].
    pub fn set_memory_usage<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.memory_usage = v.into();
        self
    }

    /// Sets the value of [vm_status][crate::model::Instance::vm_status].
    pub fn set_vm_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_status = v.into();
        self
    }

    /// Sets the value of [vm_debug_enabled][crate::model::Instance::vm_debug_enabled].
    pub fn set_vm_debug_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vm_debug_enabled = v.into();
        self
    }

    /// Sets the value of [vm_ip][crate::model::Instance::vm_ip].
    pub fn set_vm_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_ip = v.into();
        self
    }

    /// Sets the value of [vm_liveness][crate::model::Instance::vm_liveness].
    pub fn set_vm_liveness<
        T: std::convert::Into<crate::model::instance::liveness::LivenessState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_liveness = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Wrapper for LivenessState enum.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Liveness {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Liveness {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Liveness {
        fn typename() -> &'static str {
            "type.googleapis.com/google.appengine.v1.Instance.Liveness"
        }
    }

    /// Defines additional types related to [Liveness].
    pub mod liveness {
        #[allow(unused_imports)]
        use super::*;

        /// Liveness health check status for Flex instances.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LivenessState {
            /// There is no liveness health check for the instance. Only applicable for
            /// instances in App Engine standard environment.
            Unspecified,
            /// The health checking system is aware of the instance but its health is
            /// not known at the moment.
            Unknown,
            /// The instance is reachable i.e. a connection to the application health
            /// checking endpoint can be established, and conforms to the requirements
            /// defined by the health check.
            Healthy,
            /// The instance is reachable, but does not conform to the requirements
            /// defined by the health check.
            Unhealthy,
            /// The instance is being drained. The existing connections to the instance
            /// have time to complete, but the new ones are being refused.
            Draining,
            /// The instance is unreachable i.e. a connection to the application health
            /// checking endpoint cannot be established, or the server does not respond
            /// within the specified timeout.
            Timeout,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LivenessState::value] or
            /// [LivenessState::name].
            UnknownValue(liveness_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod liveness_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LivenessState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Unknown => std::option::Option::Some(1),
                    Self::Healthy => std::option::Option::Some(2),
                    Self::Unhealthy => std::option::Option::Some(3),
                    Self::Draining => std::option::Option::Some(4),
                    Self::Timeout => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LIVENESS_STATE_UNSPECIFIED"),
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::Healthy => std::option::Option::Some("HEALTHY"),
                    Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
                    Self::Draining => std::option::Option::Some("DRAINING"),
                    Self::Timeout => std::option::Option::Some("TIMEOUT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LivenessState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LivenessState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LivenessState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Unknown,
                    2 => Self::Healthy,
                    3 => Self::Unhealthy,
                    4 => Self::Draining,
                    5 => Self::Timeout,
                    _ => Self::UnknownValue(liveness_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LivenessState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LIVENESS_STATE_UNSPECIFIED" => Self::Unspecified,
                    "UNKNOWN" => Self::Unknown,
                    "HEALTHY" => Self::Healthy,
                    "UNHEALTHY" => Self::Unhealthy,
                    "DRAINING" => Self::Draining,
                    "TIMEOUT" => Self::Timeout,
                    _ => Self::UnknownValue(liveness_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LivenessState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Unknown => serializer.serialize_i32(1),
                    Self::Healthy => serializer.serialize_i32(2),
                    Self::Unhealthy => serializer.serialize_i32(3),
                    Self::Draining => serializer.serialize_i32(4),
                    Self::Timeout => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LivenessState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LivenessState>::new(
                    ".google.appengine.v1.Instance.Liveness.LivenessState",
                ))
            }
        }
    }

    /// Availability of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Availability {
        Unspecified,
        Resident,
        Dynamic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Availability::value] or
        /// [Availability::name].
        UnknownValue(availability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod availability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Availability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Resident => std::option::Option::Some(1),
                Self::Dynamic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Resident => std::option::Option::Some("RESIDENT"),
                Self::Dynamic => std::option::Option::Some("DYNAMIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Availability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Availability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Availability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Resident,
                2 => Self::Dynamic,
                _ => Self::UnknownValue(availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Availability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "RESIDENT" => Self::Resident,
                "DYNAMIC" => Self::Dynamic,
                _ => Self::UnknownValue(availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Availability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Resident => serializer.serialize_i32(1),
                Self::Dynamic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Availability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Availability>::new(
                ".google.appengine.v1.Instance.Availability",
            ))
        }
    }
}

/// Metadata for the given [google.cloud.location.Location][google.cloud.location.Location].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// App Engine standard environment is available in the given location.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub standard_environment_available: bool,

    /// App Engine flexible environment is available in the given location.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub flexible_environment_available: bool,

    /// Output only. [Search API](https://cloud.google.com/appengine/docs/standard/python/search)
    /// is available in the given location.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub search_api_available: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [standard_environment_available][crate::model::LocationMetadata::standard_environment_available].
    pub fn set_standard_environment_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.standard_environment_available = v.into();
        self
    }

    /// Sets the value of [flexible_environment_available][crate::model::LocationMetadata::flexible_environment_available].
    pub fn set_flexible_environment_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.flexible_environment_available = v.into();
        self
    }

    /// Sets the value of [search_api_available][crate::model::LocationMetadata::search_api_available].
    pub fn set_search_api_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.search_api_available = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.LocationMetadata"
    }
}

/// A NetworkSettings resource is a container for ingress settings for a version
/// or service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkSettings {
    /// The ingress settings for version or service.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ingress_traffic_allowed: crate::model::network_settings::IngressTrafficAllowed,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingress_traffic_allowed][crate::model::NetworkSettings::ingress_traffic_allowed].
    pub fn set_ingress_traffic_allowed<
        T: std::convert::Into<crate::model::network_settings::IngressTrafficAllowed>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ingress_traffic_allowed = v.into();
        self
    }
}

impl wkt::message::Message for NetworkSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.NetworkSettings"
    }
}

/// Defines additional types related to [NetworkSettings].
pub mod network_settings {
    #[allow(unused_imports)]
    use super::*;

    /// If unspecified, INGRESS_TRAFFIC_ALLOWED_ALL will be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IngressTrafficAllowed {
        /// Unspecified
        Unspecified,
        /// Allow HTTP traffic from public and private sources.
        All,
        /// Allow HTTP traffic from only private VPC sources.
        InternalOnly,
        /// Allow HTTP traffic from private VPC sources and through load balancers.
        InternalAndLb,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IngressTrafficAllowed::value] or
        /// [IngressTrafficAllowed::name].
        UnknownValue(ingress_traffic_allowed::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ingress_traffic_allowed {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IngressTrafficAllowed {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::InternalOnly => std::option::Option::Some(2),
                Self::InternalAndLb => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED")
                }
                Self::All => std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_ALL"),
                Self::InternalOnly => {
                    std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY")
                }
                Self::InternalAndLb => {
                    std::option::Option::Some("INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IngressTrafficAllowed {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IngressTrafficAllowed {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IngressTrafficAllowed {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::InternalOnly,
                3 => Self::InternalAndLb,
                _ => Self::UnknownValue(ingress_traffic_allowed::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IngressTrafficAllowed {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED" => Self::Unspecified,
                "INGRESS_TRAFFIC_ALLOWED_ALL" => Self::All,
                "INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY" => Self::InternalOnly,
                "INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB" => Self::InternalAndLb,
                _ => Self::UnknownValue(ingress_traffic_allowed::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IngressTrafficAllowed {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::InternalOnly => serializer.serialize_i32(2),
                Self::InternalAndLb => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IngressTrafficAllowed {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IngressTrafficAllowed>::new(
                ".google.appengine.v1.NetworkSettings.IngressTrafficAllowed",
            ))
        }
    }
}

/// Metadata for the given [google.longrunning.Operation][google.longrunning.Operation].
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadataV1 {
    /// API method that initiated this operation. Example:
    /// `google.appengine.v1.Versions.CreateVersion`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    /// Time that this operation was created.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insert_time: std::option::Option<wkt::Timestamp>,

    /// Time that this operation completed.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// User who requested this operation.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// Name of the resource that this operation is acting on. Example:
    /// `apps/myapp/services/default`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Ephemeral message that may change every time the operation is polled.
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ephemeral_message: std::string::String,

    /// Durable messages that persist on every operation poll.
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warning: std::vec::Vec<std::string::String>,

    /// Metadata specific to the type of operation in progress.
    /// @OutputOnly
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method_metadata: std::option::Option<crate::model::operation_metadata_v_1::MethodMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadataV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::OperationMetadataV1::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [insert_time][crate::model::OperationMetadataV1::insert_time].
    pub fn set_insert_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.insert_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insert_time][crate::model::OperationMetadataV1::insert_time].
    pub fn set_or_clear_insert_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.insert_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadataV1::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadataV1::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::OperationMetadataV1::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadataV1::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [ephemeral_message][crate::model::OperationMetadataV1::ephemeral_message].
    pub fn set_ephemeral_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ephemeral_message = v.into();
        self
    }

    /// Sets the value of [warning][crate::model::OperationMetadataV1::warning].
    pub fn set_warning<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warning = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [method_metadata][crate::model::OperationMetadataV1::method_metadata].
    ///
    /// Note that all the setters affecting `method_metadata` are mutually
    /// exclusive.
    pub fn set_method_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::operation_metadata_v_1::MethodMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method_metadata = v.into();
        self
    }

    /// The value of [method_metadata][crate::model::OperationMetadataV1::method_metadata]
    /// if it holds a `CreateVersionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_version_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateVersionMetadataV1>> {
        #[allow(unreachable_patterns)]
        self.method_metadata.as_ref().and_then(|v| match v {
            crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method_metadata][crate::model::OperationMetadataV1::method_metadata]
    /// to hold a `CreateVersionMetadata`.
    ///
    /// Note that all the setters affecting `method_metadata` are
    /// mutually exclusive.
    pub fn set_create_version_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateVersionMetadataV1>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method_metadata = std::option::Option::Some(
            crate::model::operation_metadata_v_1::MethodMetadata::CreateVersionMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadataV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.OperationMetadataV1"
    }
}

/// Defines additional types related to [OperationMetadataV1].
pub mod operation_metadata_v_1 {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata specific to the type of operation in progress.
    /// @OutputOnly
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MethodMetadata {
        CreateVersionMetadata(std::boxed::Box<crate::model::CreateVersionMetadataV1>),
    }
}

/// Metadata for the given [google.longrunning.Operation][google.longrunning.Operation] during a
/// [google.appengine.v1.CreateVersionRequest][google.appengine.v1.CreateVersionRequest].
///
/// [google.appengine.v1.CreateVersionRequest]: crate::model::CreateVersionRequest
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVersionMetadataV1 {
    /// The Cloud Build ID if one was created as part of the version create.
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_build_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionMetadataV1 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_build_id][crate::model::CreateVersionMetadataV1::cloud_build_id].
    pub fn set_cloud_build_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_build_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionMetadataV1 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CreateVersionMetadataV1"
    }
}

/// A Service resource is a logical component of an application that can share
/// state and communicate in a secure fashion with other services.
/// For example, an application that handles customer requests might
/// include separate services to handle tasks such as backend data
/// analysis or API requests from mobile devices. Each service has a
/// collection of versions that define a specific set of code used to
/// implement the functionality of that service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Service {
    /// Full path to the Service resource in the API.
    /// Example: `apps/myapp/services/default`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the service within the application.
    /// Example: `default`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Mapping that defines fractional HTTP traffic diversion to
    /// different versions within the service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::TrafficSplit>,

    /// A set of labels to apply to this service. Labels are key/value pairs that
    /// describe the service and all resources that belong to it (e.g.,
    /// versions). The labels can be used to search and group resources, and are
    /// propagated to the usage and billing reports, enabling fine-grain analysis
    /// of costs. An example of using labels is to tag resources belonging to
    /// different environments (e.g., "env=prod", "env=qa").
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Ingress settings for this service. Will apply to all versions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_settings: std::option::Option<crate::model::NetworkSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Service::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [split][crate::model::Service::split].
    pub fn set_split<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TrafficSplit>,
    {
        self.split = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [split][crate::model::Service::split].
    pub fn set_or_clear_split<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TrafficSplit>,
    {
        self.split = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Service::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network_settings][crate::model::Service::network_settings].
    pub fn set_network_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkSettings>,
    {
        self.network_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_settings][crate::model::Service::network_settings].
    pub fn set_or_clear_network_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkSettings>,
    {
        self.network_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Service"
    }
}

/// Traffic routing configuration for versions within a single service. Traffic
/// splits define how traffic directed to the service is assigned to versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrafficSplit {
    /// Mechanism used to determine which version a request is sent to.
    /// The traffic selection algorithm will
    /// be stable for either type until allocations are changed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub shard_by: crate::model::traffic_split::ShardBy,

    /// Mapping from version IDs within the service to fractional
    /// (0.000, 1] allocations of traffic for that version. Each version can
    /// be specified only once, but some versions in the service may not
    /// have any traffic allocation. Services that have traffic allocated
    /// cannot be deleted until either the service is deleted or
    /// their traffic allocation is removed. Allocations must sum to 1.
    /// Up to two decimal place precision is supported for IP-based splits and
    /// up to three decimal places is supported for cookie-based splits.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, wkt::internal::F64>")]
    pub allocations: std::collections::HashMap<std::string::String, f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [shard_by][crate::model::TrafficSplit::shard_by].
    pub fn set_shard_by<T: std::convert::Into<crate::model::traffic_split::ShardBy>>(
        mut self,
        v: T,
    ) -> Self {
        self.shard_by = v.into();
        self
    }

    /// Sets the value of [allocations][crate::model::TrafficSplit::allocations].
    pub fn set_allocations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.allocations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TrafficSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.TrafficSplit"
    }
}

/// Defines additional types related to [TrafficSplit].
pub mod traffic_split {
    #[allow(unused_imports)]
    use super::*;

    /// Available sharding mechanisms.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ShardBy {
        /// Diversion method unspecified.
        Unspecified,
        /// Diversion based on a specially named cookie, "GOOGAPPUID." The cookie
        /// must be set by the application itself or no diversion will occur.
        Cookie,
        /// Diversion based on applying the modulus operation to a fingerprint
        /// of the IP address.
        Ip,
        /// Diversion based on weighted random assignment. An incoming request is
        /// randomly routed to a version in the traffic split, with probability
        /// proportional to the version's traffic share.
        Random,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ShardBy::value] or
        /// [ShardBy::name].
        UnknownValue(shard_by::UnknownValue),
    }

    #[doc(hidden)]
    pub mod shard_by {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ShardBy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cookie => std::option::Option::Some(1),
                Self::Ip => std::option::Option::Some(2),
                Self::Random => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Cookie => std::option::Option::Some("COOKIE"),
                Self::Ip => std::option::Option::Some("IP"),
                Self::Random => std::option::Option::Some("RANDOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ShardBy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ShardBy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ShardBy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cookie,
                2 => Self::Ip,
                3 => Self::Random,
                _ => Self::UnknownValue(shard_by::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ShardBy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "COOKIE" => Self::Cookie,
                "IP" => Self::Ip,
                "RANDOM" => Self::Random,
                _ => Self::UnknownValue(shard_by::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ShardBy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cookie => serializer.serialize_i32(1),
                Self::Ip => serializer.serialize_i32(2),
                Self::Random => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ShardBy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ShardBy>::new(
                ".google.appengine.v1.TrafficSplit.ShardBy",
            ))
        }
    }
}

/// A Version resource is a specific set of source code and configuration files
/// that are deployed into a service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Version {
    /// Full path to the Version resource in the API.  Example:
    /// `apps/myapp/services/default/versions/v1`.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Relative name of the version within the service.  Example: `v1`.
    /// Version names can contain only lowercase letters, numbers, or hyphens.
    /// Reserved names: "default", "latest", and any name with the prefix "ah-".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Before an application can receive email or XMPP messages, the application
    /// must be configured to enable the service.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inbound_services: std::vec::Vec<crate::model::InboundServiceType>,

    /// Instance class that is used to run this version. Valid values are:
    ///
    /// * AutomaticScaling: `F1`, `F2`, `F4`, `F4_1G`
    /// * ManualScaling or BasicScaling: `B1`, `B2`, `B4`, `B8`, `B4_1G`
    ///
    /// Defaults to `F1` for AutomaticScaling and `B1` for ManualScaling or
    /// BasicScaling.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_class: std::string::String,

    /// Extra network settings.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::Network>,

    /// The Google Compute Engine zones that are supported by this version in the
    /// App Engine flexible environment. Deprecated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub zones: std::vec::Vec<std::string::String>,

    /// Machine resources for this version.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resources: std::option::Option<crate::model::Resources>,

    /// Desired runtime. Example: `python27`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime: std::string::String,

    /// The channel of the runtime to use. Only available for some
    /// runtimes. Defaults to the `default` channel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_channel: std::string::String,

    /// Whether multiple requests can be dispatched to this version at once.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub threadsafe: bool,

    /// Whether to deploy this version in a container on a virtual machine.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub vm: bool,

    /// Allows App Engine second generation runtimes to access the legacy bundled
    /// services.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub app_engine_apis: bool,

    /// Metadata settings that are supplied to this version to enable
    /// beta runtime features.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub beta_settings: std::collections::HashMap<std::string::String, std::string::String>,

    /// App Engine execution environment for this version.
    ///
    /// Defaults to `standard`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub env: std::string::String,

    /// Current serving status of this version. Only the versions with a
    /// `SERVING` status create instances and can be billed.
    ///
    /// `SERVING_STATUS_UNSPECIFIED` is an invalid value. Defaults to `SERVING`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub serving_status: crate::model::ServingStatus,

    /// Email address of the user who created this version.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub created_by: std::string::String,

    /// Time that this version was created.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Total size in bytes of all the files that are included in this version
    /// and currently hosted on the App Engine disk.
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_usage_bytes: i64,

    /// The version of the API in the given runtime environment. Please see the
    /// app.yaml reference for valid values at
    /// <https://cloud.google.com/appengine/docs/standard/>\<language\>/config/appref
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_api_version: std::string::String,

    /// The path or name of the app's main executable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_main_executable_path: std::string::String,

    /// The identity that the deployed version will run as.
    /// Admin API will use the App Engine Appspot service account as default if
    /// this field is neither provided in app.yaml file nor through CLI flag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// An ordered list of URL-matching patterns that should be applied to incoming
    /// requests. The first matching URL handles the request and other request
    /// handlers are not attempted.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub handlers: std::vec::Vec<crate::model::UrlMap>,

    /// Custom static error pages. Limited to 10KB per page.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_handlers: std::vec::Vec<crate::model::ErrorHandler>,

    /// Configuration for third-party Python runtime libraries that are required
    /// by the application.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub libraries: std::vec::Vec<crate::model::Library>,

    /// Serving configuration for
    /// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/).
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub api_config: std::option::Option<crate::model::ApiConfigHandler>,

    /// Environment variables available to the application.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Environment variables available to the build environment.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub build_env_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Duration that static files should be cached by web proxies and browsers.
    /// Only applicable if the corresponding
    /// [StaticFilesHandler](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#StaticFilesHandler)
    /// does not specify its own expiration time.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_expiration: std::option::Option<wkt::Duration>,

    /// Configures health checking for instances. Unhealthy instances are
    /// stopped and replaced with new instances.
    /// Only applicable in the App Engine flexible environment.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub health_check: std::option::Option<crate::model::HealthCheck>,

    /// Configures readiness health checking for instances.
    /// Unhealthy instances are not put into the backend traffic rotation.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub readiness_check: std::option::Option<crate::model::ReadinessCheck>,

    /// Configures liveness health checking for instances.
    /// Unhealthy instances are stopped and replaced with new instances
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub liveness_check: std::option::Option<crate::model::LivenessCheck>,

    /// Files that match this pattern will not be built into this version.
    /// Only applicable for Go runtimes.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nobuild_files_regex: std::string::String,

    /// Code and application artifacts that make up this version.
    ///
    /// Only returned in `GET` requests if `view=FULL` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Serving URL for this version. Example:
    /// `https://myversion-dot-myservice-dot-myapp.appspot.com`
    ///
    /// @OutputOnly
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_url: std::string::String,

    /// Cloud Endpoints configuration.
    ///
    /// If endpoints_api_service is set, the Cloud Endpoints Extensible Service
    /// Proxy will be provided to serve the API implemented by the app.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoints_api_service: std::option::Option<crate::model::EndpointsApiService>,

    /// The entrypoint for the application.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entrypoint: std::option::Option<crate::model::Entrypoint>,

    /// Enables VPC connectivity for standard apps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_access_connector: std::option::Option<crate::model::VpcAccessConnector>,

    /// Controls how instances are created, scaled, and reaped.
    ///
    /// Defaults to `AutomaticScaling`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub scaling: std::option::Option<crate::model::version::Scaling>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Version::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [inbound_services][crate::model::Version::inbound_services].
    pub fn set_inbound_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InboundServiceType>,
    {
        use std::iter::Iterator;
        self.inbound_services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_class][crate::model::Version::instance_class].
    pub fn set_instance_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_class = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Version::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::Version::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zones][crate::model::Version::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resources][crate::model::Version::resources].
    pub fn set_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Resources>,
    {
        self.resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resources][crate::model::Version::resources].
    pub fn set_or_clear_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Resources>,
    {
        self.resources = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime][crate::model::Version::runtime].
    pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime = v.into();
        self
    }

    /// Sets the value of [runtime_channel][crate::model::Version::runtime_channel].
    pub fn set_runtime_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_channel = v.into();
        self
    }

    /// Sets the value of [threadsafe][crate::model::Version::threadsafe].
    pub fn set_threadsafe<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.threadsafe = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::Version::vm].
    pub fn set_vm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [app_engine_apis][crate::model::Version::app_engine_apis].
    pub fn set_app_engine_apis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.app_engine_apis = v.into();
        self
    }

    /// Sets the value of [beta_settings][crate::model::Version::beta_settings].
    pub fn set_beta_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.beta_settings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [env][crate::model::Version::env].
    pub fn set_env<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.env = v.into();
        self
    }

    /// Sets the value of [serving_status][crate::model::Version::serving_status].
    pub fn set_serving_status<T: std::convert::Into<crate::model::ServingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_status = v.into();
        self
    }

    /// Sets the value of [created_by][crate::model::Version::created_by].
    pub fn set_created_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.created_by = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Version::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_usage_bytes][crate::model::Version::disk_usage_bytes].
    pub fn set_disk_usage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_usage_bytes = v.into();
        self
    }

    /// Sets the value of [runtime_api_version][crate::model::Version::runtime_api_version].
    pub fn set_runtime_api_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_api_version = v.into();
        self
    }

    /// Sets the value of [runtime_main_executable_path][crate::model::Version::runtime_main_executable_path].
    pub fn set_runtime_main_executable_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_main_executable_path = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Version::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [handlers][crate::model::Version::handlers].
    pub fn set_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UrlMap>,
    {
        use std::iter::Iterator;
        self.handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_handlers][crate::model::Version::error_handlers].
    pub fn set_error_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorHandler>,
    {
        use std::iter::Iterator;
        self.error_handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [libraries][crate::model::Version::libraries].
    pub fn set_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Library>,
    {
        use std::iter::Iterator;
        self.libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [api_config][crate::model::Version::api_config].
    pub fn set_api_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiConfigHandler>,
    {
        self.api_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_config][crate::model::Version::api_config].
    pub fn set_or_clear_api_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiConfigHandler>,
    {
        self.api_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [env_variables][crate::model::Version::env_variables].
    pub fn set_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [build_env_variables][crate::model::Version::build_env_variables].
    pub fn set_build_env_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_env_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [default_expiration][crate::model::Version::default_expiration].
    pub fn set_default_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_expiration][crate::model::Version::default_expiration].
    pub fn set_or_clear_default_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.default_expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [health_check][crate::model::Version::health_check].
    pub fn set_health_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HealthCheck>,
    {
        self.health_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [health_check][crate::model::Version::health_check].
    pub fn set_or_clear_health_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HealthCheck>,
    {
        self.health_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [readiness_check][crate::model::Version::readiness_check].
    pub fn set_readiness_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReadinessCheck>,
    {
        self.readiness_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [readiness_check][crate::model::Version::readiness_check].
    pub fn set_or_clear_readiness_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReadinessCheck>,
    {
        self.readiness_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [liveness_check][crate::model::Version::liveness_check].
    pub fn set_liveness_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LivenessCheck>,
    {
        self.liveness_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [liveness_check][crate::model::Version::liveness_check].
    pub fn set_or_clear_liveness_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LivenessCheck>,
    {
        self.liveness_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nobuild_files_regex][crate::model::Version::nobuild_files_regex].
    pub fn set_nobuild_files_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nobuild_files_regex = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::Version::deployment].
    pub fn set_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deployment][crate::model::Version::deployment].
    pub fn set_or_clear_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Deployment>,
    {
        self.deployment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version_url][crate::model::Version::version_url].
    pub fn set_version_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_url = v.into();
        self
    }

    /// Sets the value of [endpoints_api_service][crate::model::Version::endpoints_api_service].
    pub fn set_endpoints_api_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EndpointsApiService>,
    {
        self.endpoints_api_service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoints_api_service][crate::model::Version::endpoints_api_service].
    pub fn set_or_clear_endpoints_api_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EndpointsApiService>,
    {
        self.endpoints_api_service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entrypoint][crate::model::Version::entrypoint].
    pub fn set_entrypoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entrypoint>,
    {
        self.entrypoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entrypoint][crate::model::Version::entrypoint].
    pub fn set_or_clear_entrypoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entrypoint>,
    {
        self.entrypoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_access_connector][crate::model::Version::vpc_access_connector].
    pub fn set_vpc_access_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccessConnector>,
    {
        self.vpc_access_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_access_connector][crate::model::Version::vpc_access_connector].
    pub fn set_or_clear_vpc_access_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccessConnector>,
    {
        self.vpc_access_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scaling][crate::model::Version::scaling].
    ///
    /// Note that all the setters affecting `scaling` are mutually
    /// exclusive.
    pub fn set_scaling<
        T: std::convert::Into<std::option::Option<crate::model::version::Scaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling = v.into();
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `AutomaticScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automatic_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::AutomaticScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `AutomaticScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_automatic_scaling<
        T: std::convert::Into<std::boxed::Box<crate::model::AutomaticScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::AutomaticScaling(v.into()));
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `BasicScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::BasicScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `BasicScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_basic_scaling<T: std::convert::Into<std::boxed::Box<crate::model::BasicScaling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::BasicScaling(v.into()));
        self
    }

    /// The value of [scaling][crate::model::Version::scaling]
    /// if it holds a `ManualScaling`, `None` if the field is not set or
    /// holds a different branch.
    pub fn manual_scaling(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManualScaling>> {
        #[allow(unreachable_patterns)]
        self.scaling.as_ref().and_then(|v| match v {
            crate::model::version::Scaling::ManualScaling(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scaling][crate::model::Version::scaling]
    /// to hold a `ManualScaling`.
    ///
    /// Note that all the setters affecting `scaling` are
    /// mutually exclusive.
    pub fn set_manual_scaling<
        T: std::convert::Into<std::boxed::Box<crate::model::ManualScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling =
            std::option::Option::Some(crate::model::version::Scaling::ManualScaling(v.into()));
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Version"
    }
}

/// Defines additional types related to [Version].
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// Controls how instances are created, scaled, and reaped.
    ///
    /// Defaults to `AutomaticScaling`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Scaling {
        /// Automatic scaling is based on request rate, response latencies, and other
        /// application metrics. Instances are dynamically created and destroyed as
        /// needed in order to handle traffic.
        AutomaticScaling(std::boxed::Box<crate::model::AutomaticScaling>),
        /// A service with basic scaling will create an instance when the application
        /// receives a request. The instance will be turned down when the app becomes
        /// idle. Basic scaling is ideal for work that is intermittent or driven by
        /// user activity.
        BasicScaling(std::boxed::Box<crate::model::BasicScaling>),
        /// A service with manual scaling runs continuously, allowing you to perform
        /// complex initialization and rely on the state of its memory over time.
        /// Manually scaled versions are sometimes referred to as "backends".
        ManualScaling(std::boxed::Box<crate::model::ManualScaling>),
    }
}

/// [Cloud Endpoints](https://cloud.google.com/endpoints) configuration.
/// The Endpoints API Service provides tooling for serving Open API and gRPC
/// endpoints via an NGINX proxy. Only valid for App Engine Flexible environment
/// deployments.
///
/// The fields here refer to the name and configuration ID of a "service"
/// resource in the [Service Management API](https://cloud.google.com/service-management/overview).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EndpointsApiService {
    /// Endpoints service name which is the name of the "service" resource in the
    /// Service Management API. For example "myapi.endpoints.myproject.cloud.goog"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Endpoints service configuration ID as specified by the Service Management
    /// API. For example "2016-09-19r1".
    ///
    /// By default, the rollout strategy for Endpoints is `RolloutStrategy.FIXED`.
    /// This means that Endpoints starts up with a particular configuration ID.
    /// When a new configuration is rolled out, Endpoints must be given the new
    /// configuration ID. The `config_id` field is used to give the configuration
    /// ID and is required in this case.
    ///
    /// Endpoints also has a rollout strategy called `RolloutStrategy.MANAGED`.
    /// When using this, Endpoints fetches the latest configuration and does not
    /// need the configuration ID. In this case, `config_id` must be omitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config_id: std::string::String,

    /// Endpoints rollout strategy. If `FIXED`, `config_id` must be specified. If
    /// `MANAGED`, `config_id` must be omitted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rollout_strategy: crate::model::endpoints_api_service::RolloutStrategy,

    /// Enable or disable trace sampling. By default, this is set to false for
    /// enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_trace_sampling: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointsApiService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EndpointsApiService::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::EndpointsApiService::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }

    /// Sets the value of [rollout_strategy][crate::model::EndpointsApiService::rollout_strategy].
    pub fn set_rollout_strategy<
        T: std::convert::Into<crate::model::endpoints_api_service::RolloutStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_strategy = v.into();
        self
    }

    /// Sets the value of [disable_trace_sampling][crate::model::EndpointsApiService::disable_trace_sampling].
    pub fn set_disable_trace_sampling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_trace_sampling = v.into();
        self
    }
}

impl wkt::message::Message for EndpointsApiService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.EndpointsApiService"
    }
}

/// Defines additional types related to [EndpointsApiService].
pub mod endpoints_api_service {
    #[allow(unused_imports)]
    use super::*;

    /// Available rollout strategies.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutStrategy {
        /// Not specified. Defaults to `FIXED`.
        UnspecifiedRolloutStrategy,
        /// Endpoints service configuration ID will be fixed to the configuration ID
        /// specified by `config_id`.
        Fixed,
        /// Endpoints service configuration ID will be updated with each rollout.
        Managed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutStrategy::value] or
        /// [RolloutStrategy::name].
        UnknownValue(rollout_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::UnspecifiedRolloutStrategy => std::option::Option::Some(0),
                Self::Fixed => std::option::Option::Some(1),
                Self::Managed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::UnspecifiedRolloutStrategy => {
                    std::option::Option::Some("UNSPECIFIED_ROLLOUT_STRATEGY")
                }
                Self::Fixed => std::option::Option::Some("FIXED"),
                Self::Managed => std::option::Option::Some("MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::UnspecifiedRolloutStrategy,
                1 => Self::Fixed,
                2 => Self::Managed,
                _ => Self::UnknownValue(rollout_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED_ROLLOUT_STRATEGY" => Self::UnspecifiedRolloutStrategy,
                "FIXED" => Self::Fixed,
                "MANAGED" => Self::Managed,
                _ => Self::UnknownValue(rollout_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::UnspecifiedRolloutStrategy => serializer.serialize_i32(0),
                Self::Fixed => serializer.serialize_i32(1),
                Self::Managed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutStrategy>::new(
                ".google.appengine.v1.EndpointsApiService.RolloutStrategy",
            ))
        }
    }
}

/// Automatic scaling is based on request rate, response latencies, and other
/// application metrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomaticScaling {
    /// The time period that the
    /// [Autoscaler](https://cloud.google.com/compute/docs/autoscaler/)
    /// should wait before it starts collecting information from a new instance.
    /// This prevents the autoscaler from collecting information when the instance
    /// is initializing, during which the collected usage would not be reliable.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cool_down_period: std::option::Option<wkt::Duration>,

    /// Target scaling by CPU usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu_utilization: std::option::Option<crate::model::CpuUtilization>,

    /// Number of concurrent requests an automatic scaling instance can accept
    /// before the scheduler spawns a new instance.
    ///
    /// Defaults to a runtime-specific value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_concurrent_requests: i32,

    /// Maximum number of idle instances that should be maintained for this
    /// version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_idle_instances: i32,

    /// Maximum number of instances that should be started to handle requests for
    /// this version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_total_instances: i32,

    /// Maximum amount of time that a request should wait in the pending queue
    /// before starting a new instance to handle it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_pending_latency: std::option::Option<wkt::Duration>,

    /// Minimum number of idle instances that should be maintained for
    /// this version. Only applicable for the default version of a service.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub min_idle_instances: i32,

    /// Minimum number of running instances that should be maintained for this
    /// version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub min_total_instances: i32,

    /// Minimum amount of time a request should wait in the pending queue before
    /// starting a new instance to handle it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_pending_latency: std::option::Option<wkt::Duration>,

    /// Target scaling by request utilization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_utilization: std::option::Option<crate::model::RequestUtilization>,

    /// Target scaling by disk usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_utilization: std::option::Option<crate::model::DiskUtilization>,

    /// Target scaling by network usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_utilization: std::option::Option<crate::model::NetworkUtilization>,

    /// Scheduler settings for standard environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub standard_scheduler_settings: std::option::Option<crate::model::StandardSchedulerSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomaticScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cool_down_period][crate::model::AutomaticScaling::cool_down_period].
    pub fn set_cool_down_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cool_down_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cool_down_period][crate::model::AutomaticScaling::cool_down_period].
    pub fn set_or_clear_cool_down_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cool_down_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_utilization][crate::model::AutomaticScaling::cpu_utilization].
    pub fn set_cpu_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CpuUtilization>,
    {
        self.cpu_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_utilization][crate::model::AutomaticScaling::cpu_utilization].
    pub fn set_or_clear_cpu_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CpuUtilization>,
    {
        self.cpu_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_concurrent_requests][crate::model::AutomaticScaling::max_concurrent_requests].
    pub fn set_max_concurrent_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_requests = v.into();
        self
    }

    /// Sets the value of [max_idle_instances][crate::model::AutomaticScaling::max_idle_instances].
    pub fn set_max_idle_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_idle_instances = v.into();
        self
    }

    /// Sets the value of [max_total_instances][crate::model::AutomaticScaling::max_total_instances].
    pub fn set_max_total_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_total_instances = v.into();
        self
    }

    /// Sets the value of [max_pending_latency][crate::model::AutomaticScaling::max_pending_latency].
    pub fn set_max_pending_latency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_pending_latency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_pending_latency][crate::model::AutomaticScaling::max_pending_latency].
    pub fn set_or_clear_max_pending_latency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_pending_latency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_idle_instances][crate::model::AutomaticScaling::min_idle_instances].
    pub fn set_min_idle_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_idle_instances = v.into();
        self
    }

    /// Sets the value of [min_total_instances][crate::model::AutomaticScaling::min_total_instances].
    pub fn set_min_total_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_total_instances = v.into();
        self
    }

    /// Sets the value of [min_pending_latency][crate::model::AutomaticScaling::min_pending_latency].
    pub fn set_min_pending_latency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_pending_latency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_pending_latency][crate::model::AutomaticScaling::min_pending_latency].
    pub fn set_or_clear_min_pending_latency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_pending_latency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_utilization][crate::model::AutomaticScaling::request_utilization].
    pub fn set_request_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RequestUtilization>,
    {
        self.request_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_utilization][crate::model::AutomaticScaling::request_utilization].
    pub fn set_or_clear_request_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RequestUtilization>,
    {
        self.request_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_utilization][crate::model::AutomaticScaling::disk_utilization].
    pub fn set_disk_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskUtilization>,
    {
        self.disk_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_utilization][crate::model::AutomaticScaling::disk_utilization].
    pub fn set_or_clear_disk_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskUtilization>,
    {
        self.disk_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_utilization][crate::model::AutomaticScaling::network_utilization].
    pub fn set_network_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkUtilization>,
    {
        self.network_utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_utilization][crate::model::AutomaticScaling::network_utilization].
    pub fn set_or_clear_network_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkUtilization>,
    {
        self.network_utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [standard_scheduler_settings][crate::model::AutomaticScaling::standard_scheduler_settings].
    pub fn set_standard_scheduler_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StandardSchedulerSettings>,
    {
        self.standard_scheduler_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [standard_scheduler_settings][crate::model::AutomaticScaling::standard_scheduler_settings].
    pub fn set_or_clear_standard_scheduler_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StandardSchedulerSettings>,
    {
        self.standard_scheduler_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutomaticScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.AutomaticScaling"
    }
}

/// A service with basic scaling will create an instance when the application
/// receives a request. The instance will be turned down when the app becomes
/// idle. Basic scaling is ideal for work that is intermittent or driven by
/// user activity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BasicScaling {
    /// Duration of time after the last request that an instance must wait before
    /// the instance is shut down.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Maximum number of instances to create for this version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_instances: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_timeout][crate::model::BasicScaling::idle_timeout].
    pub fn set_idle_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_timeout][crate::model::BasicScaling::idle_timeout].
    pub fn set_or_clear_idle_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_instances][crate::model::BasicScaling::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }
}

impl wkt::message::Message for BasicScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.BasicScaling"
    }
}

/// A service with manual scaling runs continuously, allowing you to perform
/// complex initialization and rely on the state of its memory over time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManualScaling {
    /// Number of instances to assign to the service at the start. This number
    /// can later be altered by using the
    /// [Modules API](https://cloud.google.com/appengine/docs/python/modules/functions)
    /// `set_num_instances()` function.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub instances: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManualScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ManualScaling::instances].
    pub fn set_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.instances = v.into();
        self
    }
}

impl wkt::message::Message for ManualScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.ManualScaling"
    }
}

/// Target scaling by CPU usage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CpuUtilization {
    /// Period of time over which CPU utilization is calculated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation_window_length: std::option::Option<wkt::Duration>,

    /// Target CPU utilization ratio to maintain when scaling. Must be between 0
    /// and 1.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub target_utilization: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CpuUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aggregation_window_length][crate::model::CpuUtilization::aggregation_window_length].
    pub fn set_aggregation_window_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.aggregation_window_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregation_window_length][crate::model::CpuUtilization::aggregation_window_length].
    pub fn set_or_clear_aggregation_window_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.aggregation_window_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_utilization][crate::model::CpuUtilization::target_utilization].
    pub fn set_target_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_utilization = v.into();
        self
    }
}

impl wkt::message::Message for CpuUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.CpuUtilization"
    }
}

/// Target scaling by request utilization.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RequestUtilization {
    /// Target requests per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_request_count_per_second: i32,

    /// Target number of concurrent requests.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_concurrent_requests: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_request_count_per_second][crate::model::RequestUtilization::target_request_count_per_second].
    pub fn set_target_request_count_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_request_count_per_second = v.into();
        self
    }

    /// Sets the value of [target_concurrent_requests][crate::model::RequestUtilization::target_concurrent_requests].
    pub fn set_target_concurrent_requests<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_concurrent_requests = v.into();
        self
    }
}

impl wkt::message::Message for RequestUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.RequestUtilization"
    }
}

/// Target scaling by disk usage.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskUtilization {
    /// Target bytes written per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_write_bytes_per_second: i32,

    /// Target ops written per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_write_ops_per_second: i32,

    /// Target bytes read per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_read_bytes_per_second: i32,

    /// Target ops read per seconds.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_read_ops_per_second: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_write_bytes_per_second][crate::model::DiskUtilization::target_write_bytes_per_second].
    pub fn set_target_write_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_write_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_write_ops_per_second][crate::model::DiskUtilization::target_write_ops_per_second].
    pub fn set_target_write_ops_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_write_ops_per_second = v.into();
        self
    }

    /// Sets the value of [target_read_bytes_per_second][crate::model::DiskUtilization::target_read_bytes_per_second].
    pub fn set_target_read_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_read_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_read_ops_per_second][crate::model::DiskUtilization::target_read_ops_per_second].
    pub fn set_target_read_ops_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_read_ops_per_second = v.into();
        self
    }
}

impl wkt::message::Message for DiskUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.DiskUtilization"
    }
}

/// Target scaling by network usage.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkUtilization {
    /// Target bytes sent per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_sent_bytes_per_second: i32,

    /// Target packets sent per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_sent_packets_per_second: i32,

    /// Target bytes received per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_received_bytes_per_second: i32,

    /// Target packets received per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub target_received_packets_per_second: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkUtilization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_sent_bytes_per_second][crate::model::NetworkUtilization::target_sent_bytes_per_second].
    pub fn set_target_sent_bytes_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_sent_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_sent_packets_per_second][crate::model::NetworkUtilization::target_sent_packets_per_second].
    pub fn set_target_sent_packets_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_sent_packets_per_second = v.into();
        self
    }

    /// Sets the value of [target_received_bytes_per_second][crate::model::NetworkUtilization::target_received_bytes_per_second].
    pub fn set_target_received_bytes_per_second<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_received_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [target_received_packets_per_second][crate::model::NetworkUtilization::target_received_packets_per_second].
    pub fn set_target_received_packets_per_second<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_received_packets_per_second = v.into();
        self
    }
}

impl wkt::message::Message for NetworkUtilization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.NetworkUtilization"
    }
}

/// Scheduler settings for standard environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSchedulerSettings {
    /// Target CPU utilization ratio to maintain when scaling.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub target_cpu_utilization: f64,

    /// Target throughput utilization ratio to maintain when scaling
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub target_throughput_utilization: f64,

    /// Minimum number of instances to run for this version. Set to zero to disable
    /// `min_instances` configuration.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub min_instances: i32,

    /// Maximum number of instances to run for this version. Set to zero to disable
    /// `max_instances` configuration.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub max_instances: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSchedulerSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_cpu_utilization][crate::model::StandardSchedulerSettings::target_cpu_utilization].
    pub fn set_target_cpu_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_cpu_utilization = v.into();
        self
    }

    /// Sets the value of [target_throughput_utilization][crate::model::StandardSchedulerSettings::target_throughput_utilization].
    pub fn set_target_throughput_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.target_throughput_utilization = v.into();
        self
    }

    /// Sets the value of [min_instances][crate::model::StandardSchedulerSettings::min_instances].
    pub fn set_min_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instances = v.into();
        self
    }

    /// Sets the value of [max_instances][crate::model::StandardSchedulerSettings::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }
}

impl wkt::message::Message for StandardSchedulerSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.StandardSchedulerSettings"
    }
}

/// Extra network settings.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Network {
    /// List of ports, or port pairs, to forward from the virtual machine to the
    /// application container.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub forwarded_ports: std::vec::Vec<std::string::String>,

    /// Tag to apply to the instance during creation.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_tag: std::string::String,

    /// Google Compute Engine network where the virtual machines are created.
    /// Specify the short name, not the resource path.
    ///
    /// Defaults to `default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Google Cloud Platform sub-network where the virtual machines are created.
    /// Specify the short name, not the resource path.
    ///
    /// If a subnetwork name is specified, a network name will also be required
    /// unless it is for the default network.
    ///
    /// * If the network that the instance is being created in is a Legacy network,
    ///   then the IP address is allocated from the IPv4Range.
    /// * If the network that the instance is being created in is an auto Subnet
    ///   Mode Network, then only network name should be specified (not the
    ///   subnetwork_name) and the IP address is created from the IPCidrRange of the
    ///   subnetwork that exists in that zone for that network.
    /// * If the network that the instance is being created in is a custom Subnet
    ///   Mode Network, then the subnetwork_name must be specified and the
    ///   IP address is created from the IPCidrRange of the subnetwork.
    ///
    /// If specified, the subnetwork must exist in the same region as the
    /// App Engine flexible environment application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork_name: std::string::String,

    /// Enable session affinity.
    /// Only applicable in the App Engine flexible environment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub session_affinity: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [forwarded_ports][crate::model::Network::forwarded_ports].
    pub fn set_forwarded_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.forwarded_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_tag][crate::model::Network::instance_tag].
    pub fn set_instance_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_tag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subnetwork_name][crate::model::Network::subnetwork_name].
    pub fn set_subnetwork_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_name = v.into();
        self
    }

    /// Sets the value of [session_affinity][crate::model::Network::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Network"
    }
}

/// Volumes mounted within the app container.
/// Only applicable in the App Engine flexible environment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Unique name for the volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Underlying volume type, e.g. 'tmpfs'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume_type: std::string::String,

    /// Volume size in gigabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub size_gb: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type].
    pub fn set_volume_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_type = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Volume::size_gb].
    pub fn set_size_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Volume"
    }
}

/// Machine resources for a version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Resources {
    /// Number of CPU cores needed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub cpu: f64,

    /// Disk size (GB) needed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub disk_gb: f64,

    /// Memory (GB) needed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub memory_gb: f64,

    /// User specified volumes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// The name of the encryption key that is stored in Google Cloud KMS.
    /// Only should be used by Cloud Composer to encrypt the vm disk
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_reference: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Resources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu][crate::model::Resources::cpu].
    pub fn set_cpu<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.cpu = v.into();
        self
    }

    /// Sets the value of [disk_gb][crate::model::Resources::disk_gb].
    pub fn set_disk_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.disk_gb = v.into();
        self
    }

    /// Sets the value of [memory_gb][crate::model::Resources::memory_gb].
    pub fn set_memory_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.memory_gb = v.into();
        self
    }

    /// Sets the value of [volumes][crate::model::Resources::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kms_key_reference][crate::model::Resources::kms_key_reference].
    pub fn set_kms_key_reference<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_reference = v.into();
        self
    }
}

impl wkt::message::Message for Resources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Resources"
    }
}

/// VPC access connector specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcAccessConnector {
    /// Full Serverless VPC Access Connector name e.g.
    /// /projects/my-project/locations/us-central1/connectors/c1.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The egress setting for the connector, controlling what traffic is diverted
    /// through it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub egress_setting: crate::model::vpc_access_connector::EgressSetting,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcAccessConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpcAccessConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [egress_setting][crate::model::VpcAccessConnector::egress_setting].
    pub fn set_egress_setting<
        T: std::convert::Into<crate::model::vpc_access_connector::EgressSetting>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.egress_setting = v.into();
        self
    }
}

impl wkt::message::Message for VpcAccessConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.VpcAccessConnector"
    }
}

/// Defines additional types related to [VpcAccessConnector].
pub mod vpc_access_connector {
    #[allow(unused_imports)]
    use super::*;

    /// Available egress settings.
    ///
    /// This controls what traffic is diverted through the VPC Access Connector
    /// resource. By default PRIVATE_IP_RANGES will be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EgressSetting {
        Unspecified,
        /// Force the use of VPC Access for all egress traffic from the function.
        AllTraffic,
        /// Use the VPC Access Connector for private IP space from RFC1918.
        PrivateIpRanges,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EgressSetting::value] or
        /// [EgressSetting::name].
        UnknownValue(egress_setting::UnknownValue),
    }

    #[doc(hidden)]
    pub mod egress_setting {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EgressSetting {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllTraffic => std::option::Option::Some(1),
                Self::PrivateIpRanges => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EGRESS_SETTING_UNSPECIFIED"),
                Self::AllTraffic => std::option::Option::Some("ALL_TRAFFIC"),
                Self::PrivateIpRanges => std::option::Option::Some("PRIVATE_IP_RANGES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EgressSetting {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EgressSetting {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EgressSetting {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllTraffic,
                2 => Self::PrivateIpRanges,
                _ => Self::UnknownValue(egress_setting::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EgressSetting {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EGRESS_SETTING_UNSPECIFIED" => Self::Unspecified,
                "ALL_TRAFFIC" => Self::AllTraffic,
                "PRIVATE_IP_RANGES" => Self::PrivateIpRanges,
                _ => Self::UnknownValue(egress_setting::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EgressSetting {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllTraffic => serializer.serialize_i32(1),
                Self::PrivateIpRanges => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EgressSetting {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EgressSetting>::new(
                ".google.appengine.v1.VpcAccessConnector.EgressSetting",
            ))
        }
    }
}

/// The entrypoint for the application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entrypoint {
    /// The command to run.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub command: std::option::Option<crate::model::entrypoint::Command>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entrypoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [command][crate::model::Entrypoint::command].
    ///
    /// Note that all the setters affecting `command` are mutually
    /// exclusive.
    pub fn set_command<
        T: std::convert::Into<std::option::Option<crate::model::entrypoint::Command>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.command = v.into();
        self
    }

    /// The value of [command][crate::model::Entrypoint::command]
    /// if it holds a `Shell`, `None` if the field is not set or
    /// holds a different branch.
    pub fn shell(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.command.as_ref().and_then(|v| match v {
            crate::model::entrypoint::Command::Shell(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [command][crate::model::Entrypoint::command]
    /// to hold a `Shell`.
    ///
    /// Note that all the setters affecting `command` are
    /// mutually exclusive.
    pub fn set_shell<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command =
            std::option::Option::Some(crate::model::entrypoint::Command::Shell(v.into()));
        self
    }
}

impl wkt::message::Message for Entrypoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.appengine.v1.Entrypoint"
    }
}

/// Defines additional types related to [Entrypoint].
pub mod entrypoint {
    #[allow(unused_imports)]
    use super::*;

    /// The command to run.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Command {
        /// The format should be a shell command that can be fed to `bash -c`.
        Shell(std::string::String),
    }
}

/// Actions to take when the user is not logged in.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthFailAction {
    /// Not specified. `AUTH_FAIL_ACTION_REDIRECT` is assumed.
    Unspecified,
    /// Redirects user to "accounts.google.com". The user is redirected back to the
    /// application URL after signing in or creating an account.
    Redirect,
    /// Rejects request with a `401` HTTP status code and an error
    /// message.
    Unauthorized,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthFailAction::value] or
    /// [AuthFailAction::name].
    UnknownValue(auth_fail_action::UnknownValue),
}

#[doc(hidden)]
pub mod auth_fail_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthFailAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Redirect => std::option::Option::Some(1),
            Self::Unauthorized => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTH_FAIL_ACTION_UNSPECIFIED"),
            Self::Redirect => std::option::Option::Some("AUTH_FAIL_ACTION_REDIRECT"),
            Self::Unauthorized => std::option::Option::Some("AUTH_FAIL_ACTION_UNAUTHORIZED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthFailAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthFailAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthFailAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Redirect,
            2 => Self::Unauthorized,
            _ => Self::UnknownValue(auth_fail_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthFailAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTH_FAIL_ACTION_UNSPECIFIED" => Self::Unspecified,
            "AUTH_FAIL_ACTION_REDIRECT" => Self::Redirect,
            "AUTH_FAIL_ACTION_UNAUTHORIZED" => Self::Unauthorized,
            _ => Self::UnknownValue(auth_fail_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthFailAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Redirect => serializer.serialize_i32(1),
            Self::Unauthorized => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthFailAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthFailAction>::new(
            ".google.appengine.v1.AuthFailAction",
        ))
    }
}

/// Methods to restrict access to a URL based on login status.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LoginRequirement {
    /// Not specified. `LOGIN_OPTIONAL` is assumed.
    LoginUnspecified,
    /// Does not require that the user is signed in.
    LoginOptional,
    /// If the user is not signed in, the `auth_fail_action` is taken.
    /// In addition, if the user is not an administrator for the
    /// application, they are given an error message regardless of
    /// `auth_fail_action`. If the user is an administrator, the handler
    /// proceeds.
    LoginAdmin,
    /// If the user has signed in, the handler proceeds normally. Otherwise, the
    /// auth_fail_action is taken.
    LoginRequired,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LoginRequirement::value] or
    /// [LoginRequirement::name].
    UnknownValue(login_requirement::UnknownValue),
}

#[doc(hidden)]
pub mod login_requirement {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LoginRequirement {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::LoginUnspecified => std::option::Option::Some(0),
            Self::LoginOptional => std::option::Option::Some(1),
            Self::LoginAdmin => std::option::Option::Some(2),
            Self::LoginRequired => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::LoginUnspecified => std::option::Option::Some("LOGIN_UNSPECIFIED"),
            Self::LoginOptional => std::option::Option::Some("LOGIN_OPTIONAL"),
            Self::LoginAdmin => std::option::Option::Some("LOGIN_ADMIN"),
            Self::LoginRequired => std::option::Option::Some("LOGIN_REQUIRED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LoginRequirement {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LoginRequirement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LoginRequirement {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::LoginUnspecified,
            1 => Self::LoginOptional,
            2 => Self::LoginAdmin,
            3 => Self::LoginRequired,
            _ => Self::UnknownValue(login_requirement::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LoginRequirement {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LOGIN_UNSPECIFIED" => Self::LoginUnspecified,
            "LOGIN_OPTIONAL" => Self::LoginOptional,
            "LOGIN_ADMIN" => Self::LoginAdmin,
            "LOGIN_REQUIRED" => Self::LoginRequired,
            _ => Self::UnknownValue(login_requirement::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LoginRequirement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::LoginUnspecified => serializer.serialize_i32(0),
            Self::LoginOptional => serializer.serialize_i32(1),
            Self::LoginAdmin => serializer.serialize_i32(2),
            Self::LoginRequired => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LoginRequirement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoginRequirement>::new(
            ".google.appengine.v1.LoginRequirement",
        ))
    }
}

/// Methods to enforce security (HTTPS) on a URL.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecurityLevel {
    /// Not specified.
    SecureUnspecified,
    /// Both HTTP and HTTPS requests with URLs that match the handler succeed
    /// without redirects. The application can examine the request to determine
    /// which protocol was used, and respond accordingly.
    SecureDefault,
    /// Requests for a URL that match this handler that use HTTPS are automatically
    /// redirected to the HTTP equivalent URL.
    SecureNever,
    /// Both HTTP and HTTPS requests with URLs that match the handler succeed
    /// without redirects. The application can examine the request to determine
    /// which protocol was used and respond accordingly.
    SecureOptional,
    /// Requests for a URL that match this handler that do not use HTTPS are
    /// automatically redirected to the HTTPS URL with the same path. Query
    /// parameters are reserved for the redirect.
    SecureAlways,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecurityLevel::value] or
    /// [SecurityLevel::name].
    UnknownValue(security_level::UnknownValue),
}

#[doc(hidden)]
pub mod security_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecurityLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::SecureUnspecified => std::option::Option::Some(0),
            Self::SecureDefault => std::option::Option::Some(0),
            Self::SecureNever => std::option::Option::Some(1),
            Self::SecureOptional => std::option::Option::Some(2),
            Self::SecureAlways => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::SecureUnspecified => std::option::Option::Some("SECURE_UNSPECIFIED"),
            Self::SecureDefault => std::option::Option::Some("SECURE_DEFAULT"),
            Self::SecureNever => std::option::Option::Some("SECURE_NEVER"),
            Self::SecureOptional => std::option::Option::Some("SECURE_OPTIONAL"),
            Self::SecureAlways => std::option::Option::Some("SECURE_ALWAYS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecurityLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecurityLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecurityLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::SecureDefault,
            1 => Self::SecureNever,
            2 => Self::SecureOptional,
            3 => Self::SecureAlways,
            _ => Self::UnknownValue(security_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SecurityLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECURE_UNSPECIFIED" => Self::SecureUnspecified,
            "SECURE_DEFAULT" => Self::SecureDefault,
            "SECURE_NEVER" => Self::SecureNever,
            "SECURE_OPTIONAL" => Self::SecureOptional,
            "SECURE_ALWAYS" => Self::SecureAlways,
            _ => Self::UnknownValue(security_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SecurityLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::SecureUnspecified => serializer.serialize_i32(0),
            Self::SecureDefault => serializer.serialize_i32(0),
            Self::SecureNever => serializer.serialize_i32(1),
            Self::SecureOptional => serializer.serialize_i32(2),
            Self::SecureAlways => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecurityLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecurityLevel>::new(
            ".google.appengine.v1.SecurityLevel",
        ))
    }
}

/// Fields that should be returned when [Version][google.appengine.v1.Version] resources
/// are retrieved.
///
/// [google.appengine.v1.Version]: crate::model::Version
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum VersionView {
    /// Basic version information including scaling and inbound services,
    /// but not detailed deployment information.
    Basic,
    /// The information from `BASIC`, plus detailed information about the
    /// deployment. This format is required when creating resources, but
    /// is not returned in `Get` or `List` by default.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [VersionView::value] or
    /// [VersionView::name].
    UnknownValue(version_view::UnknownValue),
}

#[doc(hidden)]
pub mod version_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl VersionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Basic => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for VersionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for VersionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for VersionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Basic,
            1 => Self::Full,
            _ => Self::UnknownValue(version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for VersionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for VersionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Basic => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for VersionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionView>::new(
            ".google.appengine.v1.VersionView",
        ))
    }
}

/// Fields that should be returned when an AuthorizedCertificate resource is
/// retrieved.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthorizedCertificateView {
    /// Basic certificate information, including applicable domains and expiration
    /// date.
    BasicCertificate,
    /// The information from `BASIC_CERTIFICATE`, plus detailed information on the
    /// domain mappings that have this certificate mapped.
    FullCertificate,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthorizedCertificateView::value] or
    /// [AuthorizedCertificateView::name].
    UnknownValue(authorized_certificate_view::UnknownValue),
}

#[doc(hidden)]
pub mod authorized_certificate_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthorizedCertificateView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::BasicCertificate => std::option::Option::Some(0),
            Self::FullCertificate => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::BasicCertificate => std::option::Option::Some("BASIC_CERTIFICATE"),
            Self::FullCertificate => std::option::Option::Some("FULL_CERTIFICATE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthorizedCertificateView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthorizedCertificateView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthorizedCertificateView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::BasicCertificate,
            1 => Self::FullCertificate,
            _ => Self::UnknownValue(authorized_certificate_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthorizedCertificateView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BASIC_CERTIFICATE" => Self::BasicCertificate,
            "FULL_CERTIFICATE" => Self::FullCertificate,
            _ => Self::UnknownValue(authorized_certificate_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthorizedCertificateView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BasicCertificate => serializer.serialize_i32(0),
            Self::FullCertificate => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthorizedCertificateView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<AuthorizedCertificateView>::new(
                ".google.appengine.v1.AuthorizedCertificateView",
            ),
        )
    }
}

/// Override strategy for mutating an existing mapping.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DomainOverrideStrategy {
    /// Strategy unspecified. Defaults to `STRICT`.
    UnspecifiedDomainOverrideStrategy,
    /// Overrides not allowed. If a mapping already exists for the
    /// specified domain, the request will return an ALREADY_EXISTS (409).
    Strict,
    /// Overrides allowed. If a mapping already exists for the specified domain,
    /// the request will overwrite it. Note that this might stop another
    /// Google product from serving. For example, if the domain is
    /// mapped to another App Engine application, that app will no
    /// longer serve from that domain.
    Override,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DomainOverrideStrategy::value] or
    /// [DomainOverrideStrategy::name].
    UnknownValue(domain_override_strategy::UnknownValue),
}

#[doc(hidden)]
pub mod domain_override_strategy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DomainOverrideStrategy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::UnspecifiedDomainOverrideStrategy => std::option::Option::Some(0),
            Self::Strict => std::option::Option::Some(1),
            Self::Override => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::UnspecifiedDomainOverrideStrategy => {
                std::option::Option::Some("UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY")
            }
            Self::Strict => std::option::Option::Some("STRICT"),
            Self::Override => std::option::Option::Some("OVERRIDE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DomainOverrideStrategy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DomainOverrideStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DomainOverrideStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::UnspecifiedDomainOverrideStrategy,
            1 => Self::Strict,
            2 => Self::Override,
            _ => Self::UnknownValue(domain_override_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DomainOverrideStrategy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY" => Self::UnspecifiedDomainOverrideStrategy,
            "STRICT" => Self::Strict,
            "OVERRIDE" => Self::Override,
            _ => Self::UnknownValue(domain_override_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DomainOverrideStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::UnspecifiedDomainOverrideStrategy => serializer.serialize_i32(0),
            Self::Strict => serializer.serialize_i32(1),
            Self::Override => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DomainOverrideStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DomainOverrideStrategy>::new(
            ".google.appengine.v1.DomainOverrideStrategy",
        ))
    }
}

/// State of certificate management. Refers to the most recent certificate
/// acquisition or renewal attempt.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ManagementStatus {
    Unspecified,
    /// Certificate was successfully obtained and inserted into the serving
    /// system.
    Ok,
    /// Certificate is under active attempts to acquire or renew.
    Pending,
    /// Most recent renewal failed due to an invalid DNS setup and will be
    /// retried. Renewal attempts will continue to fail until the certificate
    /// domain's DNS configuration is fixed. The last successfully provisioned
    /// certificate may still be serving.
    FailedRetryingNotVisible,
    /// All renewal attempts have been exhausted, likely due to an invalid DNS
    /// setup.
    FailedPermanent,
    /// Most recent renewal failed due to an explicit CAA record that does not
    /// include one of the in-use CAs (Google CA and Let's Encrypt). Renewals will
    /// continue to fail until the CAA is reconfigured. The last successfully
    /// provisioned certificate may still be serving.
    FailedRetryingCaaForbidden,
    /// Most recent renewal failed due to a CAA retrieval failure. This means that
    /// the domain's DNS provider does not properly handle CAA records, failing
    /// requests for CAA records when no CAA records are defined. Renewals will
    /// continue to fail until the DNS provider is changed or a CAA record is
    /// added for the given domain. The last successfully provisioned certificate
    /// may still be serving.
    FailedRetryingCaaChecking,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ManagementStatus::value] or
    /// [ManagementStatus::name].
    UnknownValue(management_status::UnknownValue),
}

#[doc(hidden)]
pub mod management_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ManagementStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ok => std::option::Option::Some(1),
            Self::Pending => std::option::Option::Some(2),
            Self::FailedRetryingNotVisible => std::option::Option::Some(4),
            Self::FailedPermanent => std::option::Option::Some(6),
            Self::FailedRetryingCaaForbidden => std::option::Option::Some(7),
            Self::FailedRetryingCaaChecking => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MANAGEMENT_STATUS_UNSPECIFIED"),
            Self::Ok => std::option::Option::Some("OK"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::FailedRetryingNotVisible => {
                std::option::Option::Some("FAILED_RETRYING_NOT_VISIBLE")
            }
            Self::FailedPermanent => std::option::Option::Some("FAILED_PERMANENT"),
            Self::FailedRetryingCaaForbidden => {
                std::option::Option::Some("FAILED_RETRYING_CAA_FORBIDDEN")
            }
            Self::FailedRetryingCaaChecking => {
                std::option::Option::Some("FAILED_RETRYING_CAA_CHECKING")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ManagementStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ManagementStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ManagementStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ok,
            2 => Self::Pending,
            4 => Self::FailedRetryingNotVisible,
            6 => Self::FailedPermanent,
            7 => Self::FailedRetryingCaaForbidden,
            8 => Self::FailedRetryingCaaChecking,
            _ => Self::UnknownValue(management_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ManagementStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MANAGEMENT_STATUS_UNSPECIFIED" => Self::Unspecified,
            "OK" => Self::Ok,
            "PENDING" => Self::Pending,
            "FAILED_RETRYING_NOT_VISIBLE" => Self::FailedRetryingNotVisible,
            "FAILED_PERMANENT" => Self::FailedPermanent,
            "FAILED_RETRYING_CAA_FORBIDDEN" => Self::FailedRetryingCaaForbidden,
            "FAILED_RETRYING_CAA_CHECKING" => Self::FailedRetryingCaaChecking,
            _ => Self::UnknownValue(management_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ManagementStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ok => serializer.serialize_i32(1),
            Self::Pending => serializer.serialize_i32(2),
            Self::FailedRetryingNotVisible => serializer.serialize_i32(4),
            Self::FailedPermanent => serializer.serialize_i32(6),
            Self::FailedRetryingCaaForbidden => serializer.serialize_i32(7),
            Self::FailedRetryingCaaChecking => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ManagementStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagementStatus>::new(
            ".google.appengine.v1.ManagementStatus",
        ))
    }
}

/// Available inbound services.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InboundServiceType {
    /// Not specified.
    InboundServiceUnspecified,
    /// Allows an application to receive mail.
    InboundServiceMail,
    /// Allows an application to receive email-bound notifications.
    InboundServiceMailBounce,
    /// Allows an application to receive error stanzas.
    InboundServiceXmppError,
    /// Allows an application to receive instant messages.
    InboundServiceXmppMessage,
    /// Allows an application to receive user subscription POSTs.
    InboundServiceXmppSubscribe,
    /// Allows an application to receive a user's chat presence.
    InboundServiceXmppPresence,
    /// Registers an application for notifications when a client connects or
    /// disconnects from a channel.
    InboundServiceChannelPresence,
    /// Enables warmup requests.
    InboundServiceWarmup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InboundServiceType::value] or
    /// [InboundServiceType::name].
    UnknownValue(inbound_service_type::UnknownValue),
}

#[doc(hidden)]
pub mod inbound_service_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InboundServiceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::InboundServiceUnspecified => std::option::Option::Some(0),
            Self::InboundServiceMail => std::option::Option::Some(1),
            Self::InboundServiceMailBounce => std::option::Option::Some(2),
            Self::InboundServiceXmppError => std::option::Option::Some(3),
            Self::InboundServiceXmppMessage => std::option::Option::Some(4),
            Self::InboundServiceXmppSubscribe => std::option::Option::Some(5),
            Self::InboundServiceXmppPresence => std::option::Option::Some(6),
            Self::InboundServiceChannelPresence => std::option::Option::Some(7),
            Self::InboundServiceWarmup => std::option::Option::Some(9),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::InboundServiceUnspecified => {
                std::option::Option::Some("INBOUND_SERVICE_UNSPECIFIED")
            }
            Self::InboundServiceMail => std::option::Option::Some("INBOUND_SERVICE_MAIL"),
            Self::InboundServiceMailBounce => {
                std::option::Option::Some("INBOUND_SERVICE_MAIL_BOUNCE")
            }
            Self::InboundServiceXmppError => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_ERROR")
            }
            Self::InboundServiceXmppMessage => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_MESSAGE")
            }
            Self::InboundServiceXmppSubscribe => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_SUBSCRIBE")
            }
            Self::InboundServiceXmppPresence => {
                std::option::Option::Some("INBOUND_SERVICE_XMPP_PRESENCE")
            }
            Self::InboundServiceChannelPresence => {
                std::option::Option::Some("INBOUND_SERVICE_CHANNEL_PRESENCE")
            }
            Self::InboundServiceWarmup => std::option::Option::Some("INBOUND_SERVICE_WARMUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InboundServiceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InboundServiceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InboundServiceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::InboundServiceUnspecified,
            1 => Self::InboundServiceMail,
            2 => Self::InboundServiceMailBounce,
            3 => Self::InboundServiceXmppError,
            4 => Self::InboundServiceXmppMessage,
            5 => Self::InboundServiceXmppSubscribe,
            6 => Self::InboundServiceXmppPresence,
            7 => Self::InboundServiceChannelPresence,
            9 => Self::InboundServiceWarmup,
            _ => Self::UnknownValue(inbound_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InboundServiceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INBOUND_SERVICE_UNSPECIFIED" => Self::InboundServiceUnspecified,
            "INBOUND_SERVICE_MAIL" => Self::InboundServiceMail,
            "INBOUND_SERVICE_MAIL_BOUNCE" => Self::InboundServiceMailBounce,
            "INBOUND_SERVICE_XMPP_ERROR" => Self::InboundServiceXmppError,
            "INBOUND_SERVICE_XMPP_MESSAGE" => Self::InboundServiceXmppMessage,
            "INBOUND_SERVICE_XMPP_SUBSCRIBE" => Self::InboundServiceXmppSubscribe,
            "INBOUND_SERVICE_XMPP_PRESENCE" => Self::InboundServiceXmppPresence,
            "INBOUND_SERVICE_CHANNEL_PRESENCE" => Self::InboundServiceChannelPresence,
            "INBOUND_SERVICE_WARMUP" => Self::InboundServiceWarmup,
            _ => Self::UnknownValue(inbound_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InboundServiceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::InboundServiceUnspecified => serializer.serialize_i32(0),
            Self::InboundServiceMail => serializer.serialize_i32(1),
            Self::InboundServiceMailBounce => serializer.serialize_i32(2),
            Self::InboundServiceXmppError => serializer.serialize_i32(3),
            Self::InboundServiceXmppMessage => serializer.serialize_i32(4),
            Self::InboundServiceXmppSubscribe => serializer.serialize_i32(5),
            Self::InboundServiceXmppPresence => serializer.serialize_i32(6),
            Self::InboundServiceChannelPresence => serializer.serialize_i32(7),
            Self::InboundServiceWarmup => serializer.serialize_i32(9),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InboundServiceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InboundServiceType>::new(
            ".google.appengine.v1.InboundServiceType",
        ))
    }
}

/// Run states of a version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ServingStatus {
    /// Not specified.
    Unspecified,
    /// Currently serving. Instances are created according to the
    /// scaling settings of the version.
    Serving,
    /// Disabled. No instances will be created and the scaling
    /// settings are ignored until the state of the version changes
    /// to `SERVING`.
    Stopped,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ServingStatus::value] or
    /// [ServingStatus::name].
    UnknownValue(serving_status::UnknownValue),
}

#[doc(hidden)]
pub mod serving_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ServingStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Serving => std::option::Option::Some(1),
            Self::Stopped => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SERVING_STATUS_UNSPECIFIED"),
            Self::Serving => std::option::Option::Some("SERVING"),
            Self::Stopped => std::option::Option::Some("STOPPED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ServingStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ServingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ServingStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Serving,
            2 => Self::Stopped,
            _ => Self::UnknownValue(serving_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ServingStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SERVING_STATUS_UNSPECIFIED" => Self::Unspecified,
            "SERVING" => Self::Serving,
            "STOPPED" => Self::Stopped,
            _ => Self::UnknownValue(serving_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ServingStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Serving => serializer.serialize_i32(1),
            Self::Stopped => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ServingStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServingStatus>::new(
            ".google.appengine.v1.ServingStatus",
        ))
    }
}
