// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate bytes;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate wkt;

/// The encryption state of the device.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DeviceEncryptionStatus {
    /// The encryption status of the device is not specified or not known.
    EncryptionUnspecified,
    /// The device does not support encryption.
    EncryptionUnsupported,
    /// The device supports encryption, but is currently unencrypted.
    Unencrypted,
    /// The device is encrypted.
    Encrypted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DeviceEncryptionStatus::value] or
    /// [DeviceEncryptionStatus::name].
    UnknownValue(device_encryption_status::UnknownValue),
}

#[doc(hidden)]
pub mod device_encryption_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DeviceEncryptionStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::EncryptionUnspecified => std::option::Option::Some(0),
            Self::EncryptionUnsupported => std::option::Option::Some(1),
            Self::Unencrypted => std::option::Option::Some(2),
            Self::Encrypted => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::EncryptionUnspecified => std::option::Option::Some("ENCRYPTION_UNSPECIFIED"),
            Self::EncryptionUnsupported => std::option::Option::Some("ENCRYPTION_UNSUPPORTED"),
            Self::Unencrypted => std::option::Option::Some("UNENCRYPTED"),
            Self::Encrypted => std::option::Option::Some("ENCRYPTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DeviceEncryptionStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DeviceEncryptionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DeviceEncryptionStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::EncryptionUnspecified,
            1 => Self::EncryptionUnsupported,
            2 => Self::Unencrypted,
            3 => Self::Encrypted,
            _ => Self::UnknownValue(device_encryption_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DeviceEncryptionStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_UNSPECIFIED" => Self::EncryptionUnspecified,
            "ENCRYPTION_UNSUPPORTED" => Self::EncryptionUnsupported,
            "UNENCRYPTED" => Self::Unencrypted,
            "ENCRYPTED" => Self::Encrypted,
            _ => Self::UnknownValue(device_encryption_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DeviceEncryptionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::EncryptionUnspecified => serializer.serialize_i32(0),
            Self::EncryptionUnsupported => serializer.serialize_i32(1),
            Self::Unencrypted => serializer.serialize_i32(2),
            Self::Encrypted => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DeviceEncryptionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeviceEncryptionStatus>::new(
            ".google.identity.accesscontextmanager.type.DeviceEncryptionStatus",
        ))
    }
}

/// The operating system type of the device.
/// Next id: 7
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OsType {
    /// The operating system of the device is not specified or not known.
    OsUnspecified,
    /// A desktop Mac operating system.
    DesktopMac,
    /// A desktop Windows operating system.
    DesktopWindows,
    /// A desktop Linux operating system.
    DesktopLinux,
    /// A desktop ChromeOS operating system.
    DesktopChromeOs,
    /// An Android operating system.
    Android,
    /// An iOS operating system.
    Ios,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OsType::value] or
    /// [OsType::name].
    UnknownValue(os_type::UnknownValue),
}

#[doc(hidden)]
pub mod os_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OsType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::OsUnspecified => std::option::Option::Some(0),
            Self::DesktopMac => std::option::Option::Some(1),
            Self::DesktopWindows => std::option::Option::Some(2),
            Self::DesktopLinux => std::option::Option::Some(3),
            Self::DesktopChromeOs => std::option::Option::Some(6),
            Self::Android => std::option::Option::Some(4),
            Self::Ios => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::OsUnspecified => std::option::Option::Some("OS_UNSPECIFIED"),
            Self::DesktopMac => std::option::Option::Some("DESKTOP_MAC"),
            Self::DesktopWindows => std::option::Option::Some("DESKTOP_WINDOWS"),
            Self::DesktopLinux => std::option::Option::Some("DESKTOP_LINUX"),
            Self::DesktopChromeOs => std::option::Option::Some("DESKTOP_CHROME_OS"),
            Self::Android => std::option::Option::Some("ANDROID"),
            Self::Ios => std::option::Option::Some("IOS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OsType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OsType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::OsUnspecified,
            1 => Self::DesktopMac,
            2 => Self::DesktopWindows,
            3 => Self::DesktopLinux,
            4 => Self::Android,
            5 => Self::Ios,
            6 => Self::DesktopChromeOs,
            _ => Self::UnknownValue(os_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OsType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OS_UNSPECIFIED" => Self::OsUnspecified,
            "DESKTOP_MAC" => Self::DesktopMac,
            "DESKTOP_WINDOWS" => Self::DesktopWindows,
            "DESKTOP_LINUX" => Self::DesktopLinux,
            "DESKTOP_CHROME_OS" => Self::DesktopChromeOs,
            "ANDROID" => Self::Android,
            "IOS" => Self::Ios,
            _ => Self::UnknownValue(os_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OsType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::OsUnspecified => serializer.serialize_i32(0),
            Self::DesktopMac => serializer.serialize_i32(1),
            Self::DesktopWindows => serializer.serialize_i32(2),
            Self::DesktopLinux => serializer.serialize_i32(3),
            Self::DesktopChromeOs => serializer.serialize_i32(6),
            Self::Android => serializer.serialize_i32(4),
            Self::Ios => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OsType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OsType>::new(
            ".google.identity.accesscontextmanager.type.OsType",
        ))
    }
}

/// The degree to which the device is managed by the Cloud organization.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DeviceManagementLevel {
    /// The device's management level is not specified or not known.
    ManagementUnspecified,
    /// The device is not managed.
    None,
    /// Basic management is enabled, which is generally limited to monitoring and
    /// wiping the corporate account.
    Basic,
    /// Complete device management. This includes more thorough monitoring and the
    /// ability to directly manage the device (such as remote wiping). This can be
    /// enabled through the Android Enterprise Platform.
    Complete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DeviceManagementLevel::value] or
    /// [DeviceManagementLevel::name].
    UnknownValue(device_management_level::UnknownValue),
}

#[doc(hidden)]
pub mod device_management_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DeviceManagementLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ManagementUnspecified => std::option::Option::Some(0),
            Self::None => std::option::Option::Some(1),
            Self::Basic => std::option::Option::Some(2),
            Self::Complete => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ManagementUnspecified => std::option::Option::Some("MANAGEMENT_UNSPECIFIED"),
            Self::None => std::option::Option::Some("NONE"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Complete => std::option::Option::Some("COMPLETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DeviceManagementLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DeviceManagementLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DeviceManagementLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ManagementUnspecified,
            1 => Self::None,
            2 => Self::Basic,
            3 => Self::Complete,
            _ => Self::UnknownValue(device_management_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DeviceManagementLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MANAGEMENT_UNSPECIFIED" => Self::ManagementUnspecified,
            "NONE" => Self::None,
            "BASIC" => Self::Basic,
            "COMPLETE" => Self::Complete,
            _ => Self::UnknownValue(device_management_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DeviceManagementLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ManagementUnspecified => serializer.serialize_i32(0),
            Self::None => serializer.serialize_i32(1),
            Self::Basic => serializer.serialize_i32(2),
            Self::Complete => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DeviceManagementLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeviceManagementLevel>::new(
            ".google.identity.accesscontextmanager.type.DeviceManagementLevel",
        ))
    }
}
