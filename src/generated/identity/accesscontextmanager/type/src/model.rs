// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate bytes;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate wkt;

/// The encryption state of the device.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DeviceEncryptionStatus(i32);

impl DeviceEncryptionStatus {
    /// The encryption status of the device is not specified or not known.
    pub const ENCRYPTION_UNSPECIFIED: DeviceEncryptionStatus = DeviceEncryptionStatus::new(0);

    /// The device does not support encryption.
    pub const ENCRYPTION_UNSUPPORTED: DeviceEncryptionStatus = DeviceEncryptionStatus::new(1);

    /// The device supports encryption, but is currently unencrypted.
    pub const UNENCRYPTED: DeviceEncryptionStatus = DeviceEncryptionStatus::new(2);

    /// The device is encrypted.
    pub const ENCRYPTED: DeviceEncryptionStatus = DeviceEncryptionStatus::new(3);

    /// Creates a new DeviceEncryptionStatus instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("ENCRYPTION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("ENCRYPTION_UNSUPPORTED"),
            2 => std::borrow::Cow::Borrowed("UNENCRYPTED"),
            3 => std::borrow::Cow::Borrowed("ENCRYPTED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "ENCRYPTION_UNSPECIFIED" => std::option::Option::Some(Self::ENCRYPTION_UNSPECIFIED),
            "ENCRYPTION_UNSUPPORTED" => std::option::Option::Some(Self::ENCRYPTION_UNSUPPORTED),
            "UNENCRYPTED" => std::option::Option::Some(Self::UNENCRYPTED),
            "ENCRYPTED" => std::option::Option::Some(Self::ENCRYPTED),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DeviceEncryptionStatus {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DeviceEncryptionStatus {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The operating system type of the device.
/// Next id: 7
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct OsType(i32);

impl OsType {
    /// The operating system of the device is not specified or not known.
    pub const OS_UNSPECIFIED: OsType = OsType::new(0);

    /// A desktop Mac operating system.
    pub const DESKTOP_MAC: OsType = OsType::new(1);

    /// A desktop Windows operating system.
    pub const DESKTOP_WINDOWS: OsType = OsType::new(2);

    /// A desktop Linux operating system.
    pub const DESKTOP_LINUX: OsType = OsType::new(3);

    /// A desktop ChromeOS operating system.
    pub const DESKTOP_CHROME_OS: OsType = OsType::new(6);

    /// An Android operating system.
    pub const ANDROID: OsType = OsType::new(4);

    /// An iOS operating system.
    pub const IOS: OsType = OsType::new(5);

    /// Creates a new OsType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("OS_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("DESKTOP_MAC"),
            2 => std::borrow::Cow::Borrowed("DESKTOP_WINDOWS"),
            3 => std::borrow::Cow::Borrowed("DESKTOP_LINUX"),
            4 => std::borrow::Cow::Borrowed("ANDROID"),
            5 => std::borrow::Cow::Borrowed("IOS"),
            6 => std::borrow::Cow::Borrowed("DESKTOP_CHROME_OS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "OS_UNSPECIFIED" => std::option::Option::Some(Self::OS_UNSPECIFIED),
            "DESKTOP_MAC" => std::option::Option::Some(Self::DESKTOP_MAC),
            "DESKTOP_WINDOWS" => std::option::Option::Some(Self::DESKTOP_WINDOWS),
            "DESKTOP_LINUX" => std::option::Option::Some(Self::DESKTOP_LINUX),
            "DESKTOP_CHROME_OS" => std::option::Option::Some(Self::DESKTOP_CHROME_OS),
            "ANDROID" => std::option::Option::Some(Self::ANDROID),
            "IOS" => std::option::Option::Some(Self::IOS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for OsType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for OsType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The degree to which the device is managed by the Cloud organization.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DeviceManagementLevel(i32);

impl DeviceManagementLevel {
    /// The device's management level is not specified or not known.
    pub const MANAGEMENT_UNSPECIFIED: DeviceManagementLevel = DeviceManagementLevel::new(0);

    /// The device is not managed.
    pub const NONE: DeviceManagementLevel = DeviceManagementLevel::new(1);

    /// Basic management is enabled, which is generally limited to monitoring and
    /// wiping the corporate account.
    pub const BASIC: DeviceManagementLevel = DeviceManagementLevel::new(2);

    /// Complete device management. This includes more thorough monitoring and the
    /// ability to directly manage the device (such as remote wiping). This can be
    /// enabled through the Android Enterprise Platform.
    pub const COMPLETE: DeviceManagementLevel = DeviceManagementLevel::new(3);

    /// Creates a new DeviceManagementLevel instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MANAGEMENT_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("NONE"),
            2 => std::borrow::Cow::Borrowed("BASIC"),
            3 => std::borrow::Cow::Borrowed("COMPLETE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MANAGEMENT_UNSPECIFIED" => std::option::Option::Some(Self::MANAGEMENT_UNSPECIFIED),
            "NONE" => std::option::Option::Some(Self::NONE),
            "BASIC" => std::option::Option::Some(Self::BASIC),
            "COMPLETE" => std::option::Option::Some(Self::COMPLETE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DeviceManagementLevel {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DeviceManagementLevel {
    fn default() -> Self {
        Self::new(0)
    }
}
