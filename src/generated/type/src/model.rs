// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate bytes;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate wkt;

/// Represents a color in the RGBA color space. This representation is designed
/// for simplicity of conversion to/from color representations in various
/// languages over compactness. For example, the fields of this representation
/// can be trivially provided to the constructor of `java.awt.Color` in Java; it
/// can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha`
/// method in iOS; and, with just a little work, it can be easily formatted into
/// a CSS `rgba()` string in JavaScript.
///
/// This reference page doesn't carry information about the absolute color
/// space
/// that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB,
/// DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color
/// space.
///
/// When color equality needs to be decided, implementations, unless
/// documented otherwise, treat two colors as equal if all their red,
/// green, blue, and alpha values each differ by at most 1e-5.
///
/// Example (Java):
///
/// ```norust
///  import com.google.type.Color;
///
///  // ...
///  public static java.awt.Color fromProto(Color protocolor) {
///    float alpha = protocolor.hasAlpha()
///        ? protocolor.getAlpha().getValue()
///        : 1.0;
///
///    return new java.awt.Color(
///        protocolor.getRed(),
///        protocolor.getGreen(),
///        protocolor.getBlue(),
///        alpha);
///  }
///
///  public static Color toProto(java.awt.Color color) {
///    float red = (float) color.getRed();
///    float green = (float) color.getGreen();
///    float blue = (float) color.getBlue();
///    float denominator = 255.0;
///    Color.Builder resultBuilder =
///        Color
///            .newBuilder()
///            .setRed(red / denominator)
///            .setGreen(green / denominator)
///            .setBlue(blue / denominator);
///    int alpha = color.getAlpha();
///    if (alpha != 255) {
///      result.setAlpha(
///          FloatValue
///              .newBuilder()
///              .setValue(((float) alpha) / denominator)
///              .build());
///    }
///    return resultBuilder.build();
///  }
///  // ...
/// ```
///
/// Example (iOS / Obj-C):
///
/// ```norust
///  // ...
///  static UIColor* fromProto(Color* protocolor) {
///     float red = [protocolor red];
///     float green = [protocolor green];
///     float blue = [protocolor blue];
///     FloatValue* alpha_wrapper = [protocolor alpha];
///     float alpha = 1.0;
///     if (alpha_wrapper != nil) {
///       alpha = [alpha_wrapper value];
///     }
///     return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];
///  }
///
///  static Color* toProto(UIColor* color) {
///      CGFloat red, green, blue, alpha;
///      if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {
///        return nil;
///      }
///      Color* result = [[Color alloc] init];
///      [result setRed:red];
///      [result setGreen:green];
///      [result setBlue:blue];
///      if (alpha <= 0.9999) {
///        [result setAlpha:floatWrapperWithValue(alpha)];
///      }
///      [result autorelease];
///      return result;
/// }
/// // ...
/// ```
///
/// Example (JavaScript):
///
/// ```norust
/// // ...
///
/// var protoToCssColor = function(rgb_color) {
///    var redFrac = rgb_color.red || 0.0;
///    var greenFrac = rgb_color.green || 0.0;
///    var blueFrac = rgb_color.blue || 0.0;
///    var red = Math.floor(redFrac * 255);
///    var green = Math.floor(greenFrac * 255);
///    var blue = Math.floor(blueFrac * 255);
///
///    if (!('alpha' in rgb_color)) {
///       return rgbToCssColor(red, green, blue);
///    }
///
///    var alphaFrac = rgb_color.alpha.value || 0.0;
///    var rgbParams = [red, green, blue].join(',');
///    return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');
/// };
///
/// var rgbToCssColor = function(red, green, blue) {
///   var rgbNumber = new Number((red << 16) | (green << 8) | blue);
///   var hexString = rgbNumber.toString(16);
///   var missingZeros = 6 - hexString.length;
///   var resultBuilder = ['#'];
///   for (var i = 0; i < missingZeros; i++) {
///      resultBuilder.push('0');
///   }
///   resultBuilder.push(hexString);
///   return resultBuilder.join('');
/// };
///
/// // ...
/// ```
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Color {
    /// The amount of red in the color as a value in the interval [0, 1].
    pub red: f32,

    /// The amount of green in the color as a value in the interval [0, 1].
    pub green: f32,

    /// The amount of blue in the color as a value in the interval [0, 1].
    pub blue: f32,

    /// The fraction of this color that should be applied to the pixel. That is,
    /// the final pixel color is defined by the equation:
    ///
    /// `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)`
    ///
    /// This means that a value of 1.0 corresponds to a solid color, whereas
    /// a value of 0.0 corresponds to a completely transparent color. This
    /// uses a wrapper message rather than a simple float scalar so that it is
    /// possible to distinguish between a default value and the value being unset.
    /// If omitted, this color object is rendered as a solid color
    /// (as if the alpha value had been explicitly given a value of 1.0).
    pub alpha: std::option::Option<wkt::FloatValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Color {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [red][crate::model::Color::red].
    pub fn set_red<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.red = v.into();
        self
    }

    /// Sets the value of [green][crate::model::Color::green].
    pub fn set_green<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.green = v.into();
        self
    }

    /// Sets the value of [blue][crate::model::Color::blue].
    pub fn set_blue<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.blue = v.into();
        self
    }

    /// Sets the value of [alpha][crate::model::Color::alpha].
    pub fn set_alpha<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FloatValue>,
    {
        self.alpha = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [alpha][crate::model::Color::alpha].
    pub fn set_or_clear_alpha<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FloatValue>,
    {
        self.alpha = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Color {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Color"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Color {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __red,
            __green,
            __blue,
            __alpha,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Color")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "red" => Ok(__FieldTag::__red),
                            "green" => Ok(__FieldTag::__green),
                            "blue" => Ok(__FieldTag::__blue),
                            "alpha" => Ok(__FieldTag::__alpha),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Color;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Color")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__red => {
                            if !fields.insert(__FieldTag::__red) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for red",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.red = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__green => {
                            if !fields.insert(__FieldTag::__green) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for green",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.green = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__blue => {
                            if !fields.insert(__FieldTag::__blue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blue",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.blue = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__alpha => {
                            if !fields.insert(__FieldTag::__alpha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alpha",
                                ));
                            }
                            struct __With(std::option::Option<wkt::FloatValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.alpha = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Color {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.red) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("red", &__With(&self.red))?;
        }
        if !wkt::internal::is_default(&self.green) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("green", &__With(&self.green))?;
        }
        if !wkt::internal::is_default(&self.blue) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("blue", &__With(&self.blue))?;
        }
        if self.alpha.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::FloatValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("alpha", &__With(&self.alpha))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Color {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Color");
        debug_struct.field("red", &self.red);
        debug_struct.field("green", &self.green);
        debug_struct.field("blue", &self.blue);
        debug_struct.field("alpha", &self.alpha);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a whole or partial calendar date, such as a birthday. The time of
/// day and time zone are either specified elsewhere or are insignificant. The
/// date is relative to the Gregorian Calendar. This can represent one of the
/// following:
///
/// * A full date, with non-zero year, month, and day values
/// * A month and day value, with a zero year, such as an anniversary
/// * A year on its own, with zero month and day values
/// * A year and month value, with a zero day, such as a credit card expiration
///   date
///
/// Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and
/// `google.protobuf.Timestamp`.
///
/// [google.type.TimeOfDay]: crate::model::TimeOfDay
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Date {
    /// Year of the date. Must be from 1 to 9999, or 0 to specify a date without
    /// a year.
    pub year: i32,

    /// Month of a year. Must be from 1 to 12, or 0 to specify a year without a
    /// month and day.
    pub month: i32,

    /// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
    /// to specify a year by itself or a year and month where the day isn't
    /// significant.
    pub day: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Date {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [year][crate::model::Date::year].
    pub fn set_year<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.year = v.into();
        self
    }

    /// Sets the value of [month][crate::model::Date::month].
    pub fn set_month<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.month = v.into();
        self
    }

    /// Sets the value of [day][crate::model::Date::day].
    pub fn set_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }
}

impl wkt::message::Message for Date {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Date"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Date {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __year,
            __month,
            __day,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Date")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "year" => Ok(__FieldTag::__year),
                            "month" => Ok(__FieldTag::__month),
                            "day" => Ok(__FieldTag::__day),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Date;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Date")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__year => {
                            if !fields.insert(__FieldTag::__year) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for year",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.year = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__month => {
                            if !fields.insert(__FieldTag::__month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for month",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.month = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__day => {
                            if !fields.insert(__FieldTag::__day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.day = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Date {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.year) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("year", &__With(&self.year))?;
        }
        if !wkt::internal::is_default(&self.month) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("month", &__With(&self.month))?;
        }
        if !wkt::internal::is_default(&self.day) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("day", &__With(&self.day))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Date {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Date");
        debug_struct.field("year", &self.year);
        debug_struct.field("month", &self.month);
        debug_struct.field("day", &self.day);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents civil time (or occasionally physical time).
///
/// This type can represent a civil time in one of a few possible ways:
///
/// * When utc_offset is set and time_zone is unset: a civil time on a calendar
///   day with a particular offset from UTC.
/// * When time_zone is set and utc_offset is unset: a civil time on a calendar
///   day in a particular time zone.
/// * When neither time_zone nor utc_offset is set: a civil time on a calendar
///   day in local time.
///
/// The date is relative to the Proleptic Gregorian Calendar.
///
/// If year is 0, the DateTime is considered not to have a specific year. month
/// and day must have valid, non-zero values.
///
/// This type may also be used to represent a physical time if all the date and
/// time fields are set and either case of the `time_offset` oneof is set.
/// Consider using `Timestamp` message for physical time instead. If your use
/// case also would like to store the user's timezone, that can be done in
/// another field.
///
/// This type is more flexible than some applications may want. Make sure to
/// document and validate your application's limitations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DateTime {
    /// Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a
    /// datetime without a year.
    pub year: i32,

    /// Required. Month of year. Must be from 1 to 12.
    pub month: i32,

    /// Required. Day of month. Must be from 1 to 31 and valid for the year and
    /// month.
    pub day: i32,

    /// Required. Hours of day in 24 hour format. Should be from 0 to 23. An API
    /// may choose to allow the value "24:00:00" for scenarios like business
    /// closing time.
    pub hours: i32,

    /// Required. Minutes of hour of day. Must be from 0 to 59.
    pub minutes: i32,

    /// Required. Seconds of minutes of the time. Must normally be from 0 to 59. An
    /// API may allow the value 60 if it allows leap-seconds.
    pub seconds: i32,

    /// Required. Fractions of seconds in nanoseconds. Must be from 0 to
    /// 999,999,999.
    pub nanos: i32,

    /// Optional. Specifies either the UTC offset or the time zone of the DateTime.
    /// Choose carefully between them, considering that time zone data may change
    /// in the future (for example, a country modifies their DST start/end dates,
    /// and future DateTimes in the affected range had already been stored).
    /// If omitted, the DateTime is considered to be in local time.
    pub time_offset: std::option::Option<crate::model::date_time::TimeOffset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DateTime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [year][crate::model::DateTime::year].
    pub fn set_year<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.year = v.into();
        self
    }

    /// Sets the value of [month][crate::model::DateTime::month].
    pub fn set_month<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.month = v.into();
        self
    }

    /// Sets the value of [day][crate::model::DateTime::day].
    pub fn set_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }

    /// Sets the value of [hours][crate::model::DateTime::hours].
    pub fn set_hours<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.hours = v.into();
        self
    }

    /// Sets the value of [minutes][crate::model::DateTime::minutes].
    pub fn set_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.minutes = v.into();
        self
    }

    /// Sets the value of [seconds][crate::model::DateTime::seconds].
    pub fn set_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.seconds = v.into();
        self
    }

    /// Sets the value of [nanos][crate::model::DateTime::nanos].
    pub fn set_nanos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.nanos = v.into();
        self
    }

    /// Sets the value of [time_offset][crate::model::DateTime::time_offset].
    ///
    /// Note that all the setters affecting `time_offset` are mutually
    /// exclusive.
    pub fn set_time_offset<
        T: std::convert::Into<std::option::Option<crate::model::date_time::TimeOffset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_offset = v.into();
        self
    }

    /// The value of [time_offset][crate::model::DateTime::time_offset]
    /// if it holds a `UtcOffset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn utc_offset(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.time_offset.as_ref().and_then(|v| match v {
            crate::model::date_time::TimeOffset::UtcOffset(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time_offset][crate::model::DateTime::time_offset]
    /// to hold a `UtcOffset`.
    ///
    /// Note that all the setters affecting `time_offset` are
    /// mutually exclusive.
    pub fn set_utc_offset<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_offset =
            std::option::Option::Some(crate::model::date_time::TimeOffset::UtcOffset(v.into()));
        self
    }

    /// The value of [time_offset][crate::model::DateTime::time_offset]
    /// if it holds a `TimeZone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_zone(&self) -> std::option::Option<&std::boxed::Box<crate::model::TimeZone>> {
        #[allow(unreachable_patterns)]
        self.time_offset.as_ref().and_then(|v| match v {
            crate::model::date_time::TimeOffset::TimeZone(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time_offset][crate::model::DateTime::time_offset]
    /// to hold a `TimeZone`.
    ///
    /// Note that all the setters affecting `time_offset` are
    /// mutually exclusive.
    pub fn set_time_zone<T: std::convert::Into<std::boxed::Box<crate::model::TimeZone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_offset =
            std::option::Option::Some(crate::model::date_time::TimeOffset::TimeZone(v.into()));
        self
    }
}

impl wkt::message::Message for DateTime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.DateTime"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DateTime {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __year,
            __month,
            __day,
            __hours,
            __minutes,
            __seconds,
            __nanos,
            __utc_offset,
            __time_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DateTime")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "year" => Ok(__FieldTag::__year),
                            "month" => Ok(__FieldTag::__month),
                            "day" => Ok(__FieldTag::__day),
                            "hours" => Ok(__FieldTag::__hours),
                            "minutes" => Ok(__FieldTag::__minutes),
                            "seconds" => Ok(__FieldTag::__seconds),
                            "nanos" => Ok(__FieldTag::__nanos),
                            "utcOffset" => Ok(__FieldTag::__utc_offset),
                            "utc_offset" => Ok(__FieldTag::__utc_offset),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DateTime;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DateTime")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__year => {
                            if !fields.insert(__FieldTag::__year) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for year",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.year = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__month => {
                            if !fields.insert(__FieldTag::__month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for month",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.month = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__day => {
                            if !fields.insert(__FieldTag::__day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.day = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hours => {
                            if !fields.insert(__FieldTag::__hours) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hours",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hours = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__minutes => {
                            if !fields.insert(__FieldTag::__minutes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minutes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minutes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__seconds => {
                            if !fields.insert(__FieldTag::__seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.seconds = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nanos => {
                            if !fields.insert(__FieldTag::__nanos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nanos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nanos = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__utc_offset => {
                            if !fields.insert(__FieldTag::__utc_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utc_offset",
                                ));
                            }
                            if result.time_offset.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time_offset`, a oneof with full ID .google.type.DateTime.utc_offset, latest field was utcOffset",
                                ));
                            }
                            result.time_offset = std::option::Option::Some(
                                crate::model::date_time::TimeOffset::UtcOffset(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            if result.time_offset.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time_offset`, a oneof with full ID .google.type.DateTime.time_zone, latest field was timeZone",
                                ));
                            }
                            result.time_offset = std::option::Option::Some(
                                crate::model::date_time::TimeOffset::TimeZone(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeZone>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DateTime {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.year) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("year", &__With(&self.year))?;
        }
        if !wkt::internal::is_default(&self.month) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("month", &__With(&self.month))?;
        }
        if !wkt::internal::is_default(&self.day) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("day", &__With(&self.day))?;
        }
        if !wkt::internal::is_default(&self.hours) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hours", &__With(&self.hours))?;
        }
        if !wkt::internal::is_default(&self.minutes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minutes", &__With(&self.minutes))?;
        }
        if !wkt::internal::is_default(&self.seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("seconds", &__With(&self.seconds))?;
        }
        if !wkt::internal::is_default(&self.nanos) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nanos", &__With(&self.nanos))?;
        }
        if let Some(value) = self.utc_offset() {
            state.serialize_entry("utcOffset", value)?;
        }
        if let Some(value) = self.time_zone() {
            state.serialize_entry("timeZone", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DateTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DateTime");
        debug_struct.field("year", &self.year);
        debug_struct.field("month", &self.month);
        debug_struct.field("day", &self.day);
        debug_struct.field("hours", &self.hours);
        debug_struct.field("minutes", &self.minutes);
        debug_struct.field("seconds", &self.seconds);
        debug_struct.field("nanos", &self.nanos);
        debug_struct.field("time_offset", &self.time_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DateTime].
pub mod date_time {
    #[allow(unused_imports)]
    use super::*;

    /// Optional. Specifies either the UTC offset or the time zone of the DateTime.
    /// Choose carefully between them, considering that time zone data may change
    /// in the future (for example, a country modifies their DST start/end dates,
    /// and future DateTimes in the affected range had already been stored).
    /// If omitted, the DateTime is considered to be in local time.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeOffset {
        /// UTC offset. Must be whole seconds, between -18 hours and +18 hours.
        /// For example, a UTC offset of -4:00 would be represented as
        /// { seconds: -14400 }.
        UtcOffset(std::boxed::Box<wkt::Duration>),
        /// Time zone.
        TimeZone(std::boxed::Box<crate::model::TimeZone>),
    }
}

/// Represents a time zone from the
/// [IANA Time Zone Database](https://www.iana.org/time-zones).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeZone {
    /// IANA Time Zone Database time zone, e.g. "America/New_York".
    pub id: std::string::String,

    /// Optional. IANA Time Zone Database version number, e.g. "2019a".
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeZone {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TimeZone::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [version][crate::model::TimeZone::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for TimeZone {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.TimeZone"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeZone {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeZone")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeZone;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeZone")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeZone {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeZone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeZone");
        debug_struct.field("id", &self.id);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A representation of a decimal value, such as 2.5. Clients may convert values
/// into language-native decimal formats, such as Java's [BigDecimal][] or
/// Python's [decimal.Decimal][].
///
/// [BigDecimal]:
///  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
/// [decimal.Decimal]:
///  https://docs.python.org/3/library/decimal.html
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Decimal {
    /// The decimal value, as a string.
    ///
    /// The string representation consists of an optional sign, `+` (`U+002B`)
    /// or `-` (`U+002D`), followed by a sequence of zero or more decimal digits
    /// ("the integer"), optionally followed by a fraction, optionally followed
    /// by an exponent.
    ///
    /// The fraction consists of a decimal point followed by zero or more decimal
    /// digits. The string must contain at least one digit in either the integer
    /// or the fraction. The number formed by the sign, the integer and the
    /// fraction is referred to as the significand.
    ///
    /// The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`)
    /// followed by one or more decimal digits.
    ///
    /// Services **should** normalize decimal values before storing them by:
    ///
    /// - Removing an explicitly-provided `+` sign (`+2.5` -> `2.5`).
    /// - Replacing a zero-length integer value with `0` (`.5` -> `0.5`).
    /// - Coercing the exponent character to lower-case (`2.5E8` -> `2.5e8`).
    /// - Removing an explicitly-provided zero exponent (`2.5e0` -> `2.5`).
    ///
    /// Services **may** perform additional normalization based on its own needs
    /// and the internal decimal implementation selected, such as shifting the
    /// decimal point and exponent value together (example: `2.5e-1` <-> `0.25`).
    /// Additionally, services **may** preserve trailing zeroes in the fraction
    /// to indicate increased precision, but are not required to do so.
    ///
    /// Note that only the `.` character is supported to divide the integer
    /// and the fraction; `,` **should not** be supported regardless of locale.
    /// Additionally, thousand separators **should not** be supported. If a
    /// service does support them, values **must** be normalized.
    ///
    /// The ENBF grammar is:
    ///
    /// ```norust
    /// DecimalString =
    ///   [Sign] Significand [Exponent];
    ///
    /// Sign = '+' | '-';
    ///
    /// Significand =
    ///   Digits ['.'] [Digits] | [Digits] '.' Digits;
    ///
    /// Exponent = ('e' | 'E') [Sign] Digits;
    ///
    /// Digits = { '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' };
    /// ```
    ///
    /// Services **should** clearly document the range of supported values, the
    /// maximum supported precision (total number of digits), and, if applicable,
    /// the scale (number of digits after the decimal point), as well as how it
    /// behaves when receiving out-of-bounds values.
    ///
    /// Services **may** choose to accept values passed as input even when the
    /// value has a higher precision or scale than the service supports, and
    /// **should** round the value to fit the supported scale. Alternatively, the
    /// service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC)
    /// if precision would be lost.
    ///
    /// Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in
    /// gRPC) if the service receives a value outside of the supported range.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Decimal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::Decimal::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Decimal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Decimal"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Decimal {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Decimal")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Decimal;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Decimal")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Decimal {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Decimal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Decimal");
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax. CEL is a C-like expression language. The syntax and semantics of CEL
/// are documented at <https://github.com/google/cel-spec>.
///
/// Example (Comparison):
///
/// ```norust
/// title: "Summary size limit"
/// description: "Determines if a summary is less than 100 chars"
/// expression: "document.summary.size() < 100"
/// ```
///
/// Example (Equality):
///
/// ```norust
/// title: "Requestor is owner"
/// description: "Determines if requestor is the document owner"
/// expression: "document.owner == request.auth.claims.email"
/// ```
///
/// Example (Logic):
///
/// ```norust
/// title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// ```
///
/// Example (Data Manipulation):
///
/// ```norust
/// title: "Notification string"
/// description: "Create a notification string with a timestamp."
/// expression: "'New message received at ' + string(document.create_time)"
/// ```
///
/// The exact variables and functions that may be referenced within an expression
/// are determined by the service that evaluates it. See the service
/// documentation for additional information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Expr {
    /// Textual representation of an expression in Common Expression Language
    /// syntax.
    pub expression: std::string::String,

    /// Optional. Title for the expression, i.e. a short string describing
    /// its purpose. This can be used e.g. in UIs which allow to enter the
    /// expression.
    pub title: std::string::String,

    /// Optional. Description of the expression. This is a longer text which
    /// describes the expression, e.g. when hovered over it in a UI.
    pub description: std::string::String,

    /// Optional. String indicating the location of the expression for error
    /// reporting, e.g. a file name and a position in the file.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Expr {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::Expr::expression].
    pub fn set_expression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expression = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Expr::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Expr::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Expr::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for Expr {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Expr"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Expr {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expression,
            __title,
            __description,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Expr")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expression" => Ok(__FieldTag::__expression),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Expr;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Expr")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Expr {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.expression.is_empty() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Expr");
        debug_struct.field("expression", &self.expression);
        debug_struct.field("title", &self.title);
        debug_struct.field("description", &self.description);
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a fraction in terms of a numerator divided by a denominator.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Fraction {
    /// The numerator in the fraction, e.g. 2 in 2/3.
    pub numerator: i64,

    /// The value by which the numerator is divided, e.g. 3 in 2/3. Must be
    /// positive.
    pub denominator: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fraction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [numerator][crate::model::Fraction::numerator].
    pub fn set_numerator<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.numerator = v.into();
        self
    }

    /// Sets the value of [denominator][crate::model::Fraction::denominator].
    pub fn set_denominator<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.denominator = v.into();
        self
    }
}

impl wkt::message::Message for Fraction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Fraction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fraction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __numerator,
            __denominator,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fraction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "numerator" => Ok(__FieldTag::__numerator),
                            "denominator" => Ok(__FieldTag::__denominator),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fraction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fraction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__numerator => {
                            if !fields.insert(__FieldTag::__numerator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numerator",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.numerator = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__denominator => {
                            if !fields.insert(__FieldTag::__denominator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denominator",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.denominator = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Fraction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.numerator) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numerator", &__With(&self.numerator))?;
        }
        if !wkt::internal::is_default(&self.denominator) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("denominator", &__With(&self.denominator))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Fraction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fraction");
        debug_struct.field("numerator", &self.numerator);
        debug_struct.field("denominator", &self.denominator);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a time interval, encoded as a Timestamp start (inclusive) and a
/// Timestamp end (exclusive).
///
/// The start must be less than or equal to the end.
/// When the start equals the end, the interval is empty (matches no time).
/// When both start and end are unspecified, the interval matches any time.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Interval {
    /// Optional. Inclusive start of the interval.
    ///
    /// If specified, a Timestamp matching this interval will have to be the same
    /// or after the start.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Exclusive end of the interval.
    ///
    /// If specified, a Timestamp matching this interval will have to be before the
    /// end.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Interval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::Interval::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Interval::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Interval::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Interval::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Interval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Interval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Interval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Interval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Interval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Interval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Interval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Interval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Interval");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An object that represents a latitude/longitude pair. This is expressed as a
/// pair of doubles to represent degrees latitude and degrees longitude. Unless
/// specified otherwise, this must conform to the
/// <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
/// standard</a>. Values must be within normalized ranges.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LatLng {
    /// The latitude in degrees. It must be in the range [-90.0, +90.0].
    pub latitude: f64,

    /// The longitude in degrees. It must be in the range [-180.0, +180.0].
    pub longitude: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LatLng {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [latitude][crate::model::LatLng::latitude].
    pub fn set_latitude<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.latitude = v.into();
        self
    }

    /// Sets the value of [longitude][crate::model::LatLng::longitude].
    pub fn set_longitude<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.longitude = v.into();
        self
    }
}

impl wkt::message::Message for LatLng {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.LatLng"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LatLng {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __latitude,
            __longitude,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatLng")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latitude" => Ok(__FieldTag::__latitude),
                            "longitude" => Ok(__FieldTag::__longitude),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LatLng;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatLng")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__latitude => {
                            if !fields.insert(__FieldTag::__latitude) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latitude",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.latitude = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__longitude => {
                            if !fields.insert(__FieldTag::__longitude) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for longitude",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.longitude = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LatLng {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.latitude) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("latitude", &__With(&self.latitude))?;
        }
        if !wkt::internal::is_default(&self.longitude) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("longitude", &__With(&self.longitude))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LatLng {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LatLng");
        debug_struct.field("latitude", &self.latitude);
        debug_struct.field("longitude", &self.longitude);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Localized variant of a text in a particular language.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocalizedText {
    /// Localized string in the language corresponding to `language_code' below.
    pub text: std::string::String,

    /// The text's BCP-47 language code, such as "en-US" or "sr-Latn".
    ///
    /// For more information, see
    /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocalizedText {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::LocalizedText::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::LocalizedText::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for LocalizedText {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.LocalizedText"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocalizedText {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocalizedText")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocalizedText;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocalizedText")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocalizedText {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocalizedText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocalizedText");
        debug_struct.field("text", &self.text);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an amount of money with its currency type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Money {
    /// The three-letter currency code defined in ISO 4217.
    pub currency_code: std::string::String,

    /// The whole units of the amount.
    /// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
    pub units: i64,

    /// Number of nano (10^-9) units of the amount.
    /// The value must be between -999,999,999 and +999,999,999 inclusive.
    /// If `units` is positive, `nanos` must be positive or zero.
    /// If `units` is zero, `nanos` can be positive, zero, or negative.
    /// If `units` is negative, `nanos` must be negative or zero.
    /// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
    pub nanos: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Money {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [currency_code][crate::model::Money::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }

    /// Sets the value of [units][crate::model::Money::units].
    pub fn set_units<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.units = v.into();
        self
    }

    /// Sets the value of [nanos][crate::model::Money::nanos].
    pub fn set_nanos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.nanos = v.into();
        self
    }
}

impl wkt::message::Message for Money {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Money"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Money {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __currency_code,
            __units,
            __nanos,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Money")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "currencyCode" => Ok(__FieldTag::__currency_code),
                            "currency_code" => Ok(__FieldTag::__currency_code),
                            "units" => Ok(__FieldTag::__units),
                            "nanos" => Ok(__FieldTag::__nanos),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Money;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Money")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__currency_code => {
                            if !fields.insert(__FieldTag::__currency_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_code",
                                ));
                            }
                            result.currency_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__units => {
                            if !fields.insert(__FieldTag::__units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for units",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.units = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nanos => {
                            if !fields.insert(__FieldTag::__nanos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nanos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nanos = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Money {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.currency_code.is_empty() {
            state.serialize_entry("currencyCode", &self.currency_code)?;
        }
        if !wkt::internal::is_default(&self.units) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("units", &__With(&self.units))?;
        }
        if !wkt::internal::is_default(&self.nanos) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nanos", &__With(&self.nanos))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Money {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Money");
        debug_struct.field("currency_code", &self.currency_code);
        debug_struct.field("units", &self.units);
        debug_struct.field("nanos", &self.nanos);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An object representing a phone number, suitable as an API wire format.
///
/// This representation:
///
/// - should not be used for locale-specific formatting of a phone number, such
///   as "+1 (650) 253-0000 ext. 123"
///
/// - is not designed for efficient storage
///
/// - may not be suitable for dialing - specialized libraries (see references)
///   should be used to parse the number for that purpose
///
///
/// To do something meaningful with this number, such as format it for various
/// use-cases, convert it to an `i18n.phonenumbers.PhoneNumber` object first.
///
/// For instance, in Java this would be:
///
/// com.google.type.PhoneNumber wireProto =
/// com.google.type.PhoneNumber.newBuilder().build();
/// com.google.i18n.phonenumbers.Phonenumber.PhoneNumber phoneNumber =
/// PhoneNumberUtil.getInstance().parse(wireProto.getE164Number(), "ZZ");
/// if (!wireProto.getExtension().isEmpty()) {
/// phoneNumber.setExtension(wireProto.getExtension());
/// }
///
/// Reference(s):
///
/// - <https://github.com/google/libphonenumber>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhoneNumber {
    /// The phone number's extension. The extension is not standardized in ITU
    /// recommendations, except for being defined as a series of numbers with a
    /// maximum length of 40 digits. Other than digits, some other dialing
    /// characters such as ',' (indicating a wait) or '#' may be stored here.
    ///
    /// Note that no regions currently use extensions with short codes, so this
    /// field is normally only set in conjunction with an E.164 number. It is held
    /// separately from the E.164 number to allow for short code extensions in the
    /// future.
    pub extension: std::string::String,

    /// Required.  Either a regular number, or a short code.  New fields may be
    /// added to the oneof below in the future, so clients should ignore phone
    /// numbers for which none of the fields they coded against are set.
    pub kind: std::option::Option<crate::model::phone_number::Kind>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhoneNumber {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [extension][crate::model::PhoneNumber::extension].
    pub fn set_extension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extension = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::PhoneNumber::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<
        T: std::convert::Into<std::option::Option<crate::model::phone_number::Kind>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::PhoneNumber::kind]
    /// if it holds a `E164Number`, `None` if the field is not set or
    /// holds a different branch.
    pub fn e164_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::phone_number::Kind::E164Number(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::PhoneNumber::kind]
    /// to hold a `E164Number`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_e164_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::phone_number::Kind::E164Number(v.into()));
        self
    }

    /// The value of [kind][crate::model::PhoneNumber::kind]
    /// if it holds a `ShortCode`, `None` if the field is not set or
    /// holds a different branch.
    pub fn short_code(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::phone_number::ShortCode>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::phone_number::Kind::ShortCode(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::PhoneNumber::kind]
    /// to hold a `ShortCode`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_short_code<
        T: std::convert::Into<std::boxed::Box<crate::model::phone_number::ShortCode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::phone_number::Kind::ShortCode(v.into()));
        self
    }
}

impl wkt::message::Message for PhoneNumber {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.PhoneNumber"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhoneNumber {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __e164_number,
            __short_code,
            __extension,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhoneNumber")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "e164Number" => Ok(__FieldTag::__e164_number),
                            "e164_number" => Ok(__FieldTag::__e164_number),
                            "shortCode" => Ok(__FieldTag::__short_code),
                            "short_code" => Ok(__FieldTag::__short_code),
                            "extension" => Ok(__FieldTag::__extension),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhoneNumber;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhoneNumber")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__e164_number => {
                            if !fields.insert(__FieldTag::__e164_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for e164_number",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.type.PhoneNumber.e164_number, latest field was e164Number",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::phone_number::Kind::E164Number(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__short_code => {
                            if !fields.insert(__FieldTag::__short_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_code",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.type.PhoneNumber.short_code, latest field was shortCode",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::phone_number::Kind::ShortCode(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::phone_number::ShortCode>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__extension => {
                            if !fields.insert(__FieldTag::__extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extension",
                                ));
                            }
                            result.extension = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhoneNumber {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.e164_number() {
            state.serialize_entry("e164Number", value)?;
        }
        if let Some(value) = self.short_code() {
            state.serialize_entry("shortCode", value)?;
        }
        if !self.extension.is_empty() {
            state.serialize_entry("extension", &self.extension)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhoneNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhoneNumber");
        debug_struct.field("extension", &self.extension);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PhoneNumber].
pub mod phone_number {
    #[allow(unused_imports)]
    use super::*;

    /// An object representing a short code, which is a phone number that is
    /// typically much shorter than regular phone numbers and can be used to
    /// address messages in MMS and SMS systems, as well as for abbreviated dialing
    /// (e.g. "Text 611 to see how many minutes you have remaining on your plan.").
    ///
    /// Short codes are restricted to a region and are not internationally
    /// dialable, which means the same short code can exist in different regions,
    /// with different usage and pricing, even if those regions share the same
    /// country calling code (e.g. US and CA).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ShortCode {
        /// Required. The BCP-47 region code of the location where calls to this
        /// short code can be made, such as "US" and "BB".
        ///
        /// Reference(s):
        ///
        /// - <http://www.unicode.org/reports/tr35/#unicode_region_subtag>
        pub region_code: std::string::String,

        /// Required. The short code digits, without a leading plus ('+') or country
        /// calling code, e.g. "611".
        pub number: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ShortCode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [region_code][crate::model::phone_number::ShortCode::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [number][crate::model::phone_number::ShortCode::number].
        pub fn set_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.number = v.into();
            self
        }
    }

    impl wkt::message::Message for ShortCode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.type.PhoneNumber.ShortCode"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ShortCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __region_code,
                __number,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ShortCode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "regionCode" => Ok(__FieldTag::__region_code),
                                "region_code" => Ok(__FieldTag::__region_code),
                                "number" => Ok(__FieldTag::__number),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ShortCode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ShortCode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__region_code => {
                                if !fields.insert(__FieldTag::__region_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for region_code",
                                    ));
                                }
                                result.region_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__number => {
                                if !fields.insert(__FieldTag::__number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for number",
                                    ));
                                }
                                result.number = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ShortCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.region_code.is_empty() {
                state.serialize_entry("regionCode", &self.region_code)?;
            }
            if !self.number.is_empty() {
                state.serialize_entry("number", &self.number)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ShortCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ShortCode");
            debug_struct.field("region_code", &self.region_code);
            debug_struct.field("number", &self.number);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Required.  Either a regular number, or a short code.  New fields may be
    /// added to the oneof below in the future, so clients should ignore phone
    /// numbers for which none of the fields they coded against are set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// The phone number, represented as a leading plus sign ('+'), followed by a
        /// phone number that uses a relaxed ITU E.164 format consisting of the
        /// country calling code (1 to 3 digits) and the subscriber number, with no
        /// additional spaces or formatting, e.g.:
        ///
        /// - correct: "+15552220123"
        /// - incorrect: "+1 (555) 222-01234 x123".
        ///
        /// The ITU E.164 format limits the latter to 12 digits, but in practice not
        /// all countries respect that, so we relax that restriction here.
        /// National-only numbers are not allowed.
        ///
        /// References:
        ///
        /// - <https://www.itu.int/rec/T-REC-E.164-201011-I>
        /// - <https://en.wikipedia.org/wiki/E.164>.
        /// - <https://en.wikipedia.org/wiki/List_of_country_calling_codes>
        E164Number(std::string::String),
        /// A short code.
        ///
        /// Reference(s):
        ///
        /// - <https://en.wikipedia.org/wiki/Short_code>
        ShortCode(std::boxed::Box<crate::model::phone_number::ShortCode>),
    }
}

/// Represents a postal address, e.g. for postal delivery or payments addresses.
/// Given a postal address, a postal service can deliver items to a premise, P.O.
/// Box or similar.
/// It is not intended to model geographical locations (roads, towns,
/// mountains).
///
/// In typical usage an address would be created via user input or from importing
/// existing data, depending on the type of process.
///
/// Advice on address input / editing:
///
/// - Use an i18n-ready address widget such as
///   <https://github.com/google/libaddressinput>)
/// - Users should not be presented with UI elements for input or editing of
///   fields outside countries where that field is used.
///
/// For more guidance on how to use this schema, please see:
/// <https://support.google.com/business/answer/6397478>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostalAddress {
    /// The schema revision of the `PostalAddress`. This must be set to 0, which is
    /// the latest revision.
    ///
    /// All new revisions **must** be backward compatible with old revisions.
    pub revision: i32,

    /// Required. CLDR region code of the country/region of the address. This
    /// is never inferred and it is up to the user to ensure the value is
    /// correct. See <http://cldr.unicode.org/> and
    /// <http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html>
    /// for details. Example: "CH" for Switzerland.
    pub region_code: std::string::String,

    /// Optional. BCP-47 language code of the contents of this address (if
    /// known). This is often the UI language of the input form or is expected
    /// to match one of the languages used in the address' country/region, or their
    /// transliterated equivalents.
    /// This can affect formatting in certain countries, but is not critical
    /// to the correctness of the data and will never affect any validation or
    /// other non-formatting related operations.
    ///
    /// If this value is not known, it should be omitted (rather than specifying a
    /// possibly incorrect default).
    ///
    /// Examples: "zh-Hant", "ja", "ja-Latn", "en".
    pub language_code: std::string::String,

    /// Optional. Postal code of the address. Not all countries use or require
    /// postal codes to be present, but where they are used, they may trigger
    /// additional validation with other parts of the address (e.g. state/zip
    /// validation in the U.S.A.).
    pub postal_code: std::string::String,

    /// Optional. Additional, country-specific, sorting code. This is not used
    /// in most regions. Where it is used, the value is either a string like
    /// "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
    /// alone, representing the "sector code" (Jamaica), "delivery area indicator"
    /// (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
    pub sorting_code: std::string::String,

    /// Optional. Highest administrative subdivision which is used for postal
    /// addresses of a country or region.
    /// For example, this can be a state, a province, an oblast, or a prefecture.
    /// Specifically, for Spain this is the province and not the autonomous
    /// community (e.g. "Barcelona" and not "Catalonia").
    /// Many countries don't use an administrative area in postal addresses. E.g.
    /// in Switzerland this should be left unpopulated.
    pub administrative_area: std::string::String,

    /// Optional. Generally refers to the city/town portion of the address.
    /// Examples: US city, IT comune, UK post town.
    /// In regions of the world where localities are not well defined or do not fit
    /// into this structure well, leave locality empty and use address_lines.
    pub locality: std::string::String,

    /// Optional. Sublocality of the address.
    /// For example, this can be neighborhoods, boroughs, districts.
    pub sublocality: std::string::String,

    /// Unstructured address lines describing the lower levels of an address.
    ///
    /// Because values in address_lines do not have type information and may
    /// sometimes contain multiple values in a single field (e.g.
    /// "Austin, TX"), it is important that the line order is clear. The order of
    /// address lines should be "envelope order" for the country/region of the
    /// address. In places where this can vary (e.g. Japan), address_language is
    /// used to make it explicit (e.g. "ja" for large-to-small ordering and
    /// "ja-Latn" or "en" for small-to-large). This way, the most specific line of
    /// an address can be selected based on the language.
    ///
    /// The minimum permitted structural representation of an address consists
    /// of a region_code with all remaining information placed in the
    /// address_lines. It would be possible to format such an address very
    /// approximately without geocoding, but no semantic reasoning could be
    /// made about any of the address components until it was at least
    /// partially resolved.
    ///
    /// Creating an address only containing a region_code and address_lines, and
    /// then geocoding is the recommended way to handle completely unstructured
    /// addresses (as opposed to guessing which parts of the address should be
    /// localities or administrative areas).
    pub address_lines: std::vec::Vec<std::string::String>,

    /// Optional. The recipient at the address.
    /// This field may, under certain circumstances, contain multiline information.
    /// For example, it might contain "care of" information.
    pub recipients: std::vec::Vec<std::string::String>,

    /// Optional. The name of the organization at the address.
    pub organization: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostalAddress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revision][crate::model::PostalAddress::revision].
    pub fn set_revision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [region_code][crate::model::PostalAddress::region_code].
    pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region_code = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::PostalAddress::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [postal_code][crate::model::PostalAddress::postal_code].
    pub fn set_postal_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.postal_code = v.into();
        self
    }

    /// Sets the value of [sorting_code][crate::model::PostalAddress::sorting_code].
    pub fn set_sorting_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sorting_code = v.into();
        self
    }

    /// Sets the value of [administrative_area][crate::model::PostalAddress::administrative_area].
    pub fn set_administrative_area<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.administrative_area = v.into();
        self
    }

    /// Sets the value of [locality][crate::model::PostalAddress::locality].
    pub fn set_locality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.locality = v.into();
        self
    }

    /// Sets the value of [sublocality][crate::model::PostalAddress::sublocality].
    pub fn set_sublocality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sublocality = v.into();
        self
    }

    /// Sets the value of [address_lines][crate::model::PostalAddress::address_lines].
    pub fn set_address_lines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.address_lines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [recipients][crate::model::PostalAddress::recipients].
    pub fn set_recipients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.recipients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [organization][crate::model::PostalAddress::organization].
    pub fn set_organization<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.organization = v.into();
        self
    }
}

impl wkt::message::Message for PostalAddress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.PostalAddress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostalAddress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __revision,
            __region_code,
            __language_code,
            __postal_code,
            __sorting_code,
            __administrative_area,
            __locality,
            __sublocality,
            __address_lines,
            __recipients,
            __organization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostalAddress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "revision" => Ok(__FieldTag::__revision),
                            "regionCode" => Ok(__FieldTag::__region_code),
                            "region_code" => Ok(__FieldTag::__region_code),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "postalCode" => Ok(__FieldTag::__postal_code),
                            "postal_code" => Ok(__FieldTag::__postal_code),
                            "sortingCode" => Ok(__FieldTag::__sorting_code),
                            "sorting_code" => Ok(__FieldTag::__sorting_code),
                            "administrativeArea" => Ok(__FieldTag::__administrative_area),
                            "administrative_area" => Ok(__FieldTag::__administrative_area),
                            "locality" => Ok(__FieldTag::__locality),
                            "sublocality" => Ok(__FieldTag::__sublocality),
                            "addressLines" => Ok(__FieldTag::__address_lines),
                            "address_lines" => Ok(__FieldTag::__address_lines),
                            "recipients" => Ok(__FieldTag::__recipients),
                            "organization" => Ok(__FieldTag::__organization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostalAddress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostalAddress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.revision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__region_code => {
                            if !fields.insert(__FieldTag::__region_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region_code",
                                ));
                            }
                            result.region_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__postal_code => {
                            if !fields.insert(__FieldTag::__postal_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postal_code",
                                ));
                            }
                            result.postal_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sorting_code => {
                            if !fields.insert(__FieldTag::__sorting_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sorting_code",
                                ));
                            }
                            result.sorting_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__administrative_area => {
                            if !fields.insert(__FieldTag::__administrative_area) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for administrative_area",
                                ));
                            }
                            result.administrative_area = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locality => {
                            if !fields.insert(__FieldTag::__locality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locality",
                                ));
                            }
                            result.locality = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sublocality => {
                            if !fields.insert(__FieldTag::__sublocality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sublocality",
                                ));
                            }
                            result.sublocality = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__address_lines => {
                            if !fields.insert(__FieldTag::__address_lines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address_lines",
                                ));
                            }
                            result.address_lines = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__recipients => {
                            if !fields.insert(__FieldTag::__recipients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recipients",
                                ));
                            }
                            result.recipients = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostalAddress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.revision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("revision", &__With(&self.revision))?;
        }
        if !self.region_code.is_empty() {
            state.serialize_entry("regionCode", &self.region_code)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.postal_code.is_empty() {
            state.serialize_entry("postalCode", &self.postal_code)?;
        }
        if !self.sorting_code.is_empty() {
            state.serialize_entry("sortingCode", &self.sorting_code)?;
        }
        if !self.administrative_area.is_empty() {
            state.serialize_entry("administrativeArea", &self.administrative_area)?;
        }
        if !self.locality.is_empty() {
            state.serialize_entry("locality", &self.locality)?;
        }
        if !self.sublocality.is_empty() {
            state.serialize_entry("sublocality", &self.sublocality)?;
        }
        if !self.address_lines.is_empty() {
            state.serialize_entry("addressLines", &self.address_lines)?;
        }
        if !self.recipients.is_empty() {
            state.serialize_entry("recipients", &self.recipients)?;
        }
        if !self.organization.is_empty() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostalAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostalAddress");
        debug_struct.field("revision", &self.revision);
        debug_struct.field("region_code", &self.region_code);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("postal_code", &self.postal_code);
        debug_struct.field("sorting_code", &self.sorting_code);
        debug_struct.field("administrative_area", &self.administrative_area);
        debug_struct.field("locality", &self.locality);
        debug_struct.field("sublocality", &self.sublocality);
        debug_struct.field("address_lines", &self.address_lines);
        debug_struct.field("recipients", &self.recipients);
        debug_struct.field("organization", &self.organization);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A quaternion is defined as the quotient of two directed lines in a
/// three-dimensional space or equivalently as the quotient of two Euclidean
/// vectors (<https://en.wikipedia.org/wiki/Quaternion>).
///
/// Quaternions are often used in calculations involving three-dimensional
/// rotations (<https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation>),
/// as they provide greater mathematical robustness by avoiding the gimbal lock
/// problems that can be encountered when using Euler angles
/// (<https://en.wikipedia.org/wiki/Gimbal_lock>).
///
/// Quaternions are generally represented in this form:
///
/// ```norust
/// w + xi + yj + zk
/// ```
///
/// where x, y, z, and w are real numbers, and i, j, and k are three imaginary
/// numbers.
///
/// Our naming choice `(x, y, z, w)` comes from the desire to avoid confusion for
/// those interested in the geometric properties of the quaternion in the 3D
/// Cartesian space. Other texts often use alternative names or subscripts, such
/// as `(a, b, c, d)`, `(1, i, j, k)`, or `(0, 1, 2, 3)`, which are perhaps
/// better suited for mathematical interpretations.
///
/// To avoid any confusion, as well as to maintain compatibility with a large
/// number of software libraries, the quaternions represented using the protocol
/// buffer below *must* follow the Hamilton convention, which defines `ij = k`
/// (i.e. a right-handed algebra), and therefore:
///
/// ```norust
/// i^2 = j^2 = k^2 = ijk = 1
/// ij = ji = k
/// jk = kj = i
/// ki = ik = j
/// ```
///
/// Please DO NOT use this to represent quaternions that follow the JPL
/// convention, or any of the other quaternion flavors out there.
///
/// Definitions:
///
/// - Quaternion norm (or magnitude): `sqrt(x^2 + y^2 + z^2 + w^2)`.
/// - Unit (or normalized) quaternion: a quaternion whose norm is 1.
/// - Pure quaternion: a quaternion whose scalar component (`w`) is 0.
/// - Rotation quaternion: a unit quaternion used to represent rotation.
/// - Orientation quaternion: a unit quaternion used to represent orientation.
///
/// A quaternion can be normalized by dividing it by its norm. The resulting
/// quaternion maintains the same direction, but has a norm of 1, i.e. it moves
/// on the unit sphere. This is generally necessary for rotation and orientation
/// quaternions, to avoid rounding errors:
/// <https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions>
///
/// Note that `(x, y, z, w)` and `(-x, -y, -z, -w)` represent the same rotation,
/// but normalization would be even more useful, e.g. for comparison purposes, if
/// it would produce a unique representation. It is thus recommended that `w` be
/// kept positive, which can be achieved by changing all the signs when `w` is
/// negative.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Quaternion {
    /// The x component.
    pub x: f64,

    /// The y component.
    pub y: f64,

    /// The z component.
    pub z: f64,

    /// The scalar component.
    pub w: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Quaternion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::Quaternion::x].
    pub fn set_x<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Quaternion::y].
    pub fn set_y<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [z][crate::model::Quaternion::z].
    pub fn set_z<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.z = v.into();
        self
    }

    /// Sets the value of [w][crate::model::Quaternion::w].
    pub fn set_w<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.w = v.into();
        self
    }
}

impl wkt::message::Message for Quaternion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.Quaternion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Quaternion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            __z,
            __w,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Quaternion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            "z" => Ok(__FieldTag::__z),
                            "w" => Ok(__FieldTag::__w),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Quaternion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Quaternion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__z => {
                            if !fields.insert(__FieldTag::__z) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for z",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.z = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__w => {
                            if !fields.insert(__FieldTag::__w) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for w",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.w = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Quaternion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !wkt::internal::is_default(&self.z) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("z", &__With(&self.z))?;
        }
        if !wkt::internal::is_default(&self.w) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("w", &__With(&self.w))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Quaternion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Quaternion");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        debug_struct.field("z", &self.z);
        debug_struct.field("w", &self.w);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a time of day. The date and time zone are either not significant
/// or are specified elsewhere. An API may choose to allow leap seconds. Related
/// types are [google.type.Date][google.type.Date] and
/// `google.protobuf.Timestamp`.
///
/// [google.type.Date]: crate::model::Date
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeOfDay {
    /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
    /// to allow the value "24:00:00" for scenarios like business closing time.
    pub hours: i32,

    /// Minutes of hour of day. Must be from 0 to 59.
    pub minutes: i32,

    /// Seconds of minutes of the time. Must normally be from 0 to 59. An API may
    /// allow the value 60 if it allows leap-seconds.
    pub seconds: i32,

    /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
    pub nanos: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeOfDay {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hours][crate::model::TimeOfDay::hours].
    pub fn set_hours<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.hours = v.into();
        self
    }

    /// Sets the value of [minutes][crate::model::TimeOfDay::minutes].
    pub fn set_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.minutes = v.into();
        self
    }

    /// Sets the value of [seconds][crate::model::TimeOfDay::seconds].
    pub fn set_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.seconds = v.into();
        self
    }

    /// Sets the value of [nanos][crate::model::TimeOfDay::nanos].
    pub fn set_nanos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.nanos = v.into();
        self
    }
}

impl wkt::message::Message for TimeOfDay {
    fn typename() -> &'static str {
        "type.googleapis.com/google.type.TimeOfDay"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeOfDay {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hours,
            __minutes,
            __seconds,
            __nanos,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeOfDay")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hours" => Ok(__FieldTag::__hours),
                            "minutes" => Ok(__FieldTag::__minutes),
                            "seconds" => Ok(__FieldTag::__seconds),
                            "nanos" => Ok(__FieldTag::__nanos),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeOfDay;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeOfDay")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hours => {
                            if !fields.insert(__FieldTag::__hours) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hours",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hours = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__minutes => {
                            if !fields.insert(__FieldTag::__minutes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minutes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minutes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__seconds => {
                            if !fields.insert(__FieldTag::__seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.seconds = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nanos => {
                            if !fields.insert(__FieldTag::__nanos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nanos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nanos = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeOfDay {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.hours) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hours", &__With(&self.hours))?;
        }
        if !wkt::internal::is_default(&self.minutes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minutes", &__With(&self.minutes))?;
        }
        if !wkt::internal::is_default(&self.seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("seconds", &__With(&self.seconds))?;
        }
        if !wkt::internal::is_default(&self.nanos) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nanos", &__With(&self.nanos))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeOfDay {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeOfDay");
        debug_struct.field("hours", &self.hours);
        debug_struct.field("minutes", &self.minutes);
        debug_struct.field("seconds", &self.seconds);
        debug_struct.field("nanos", &self.nanos);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `CalendarPeriod` represents the abstract concept of a time period that has
/// a canonical start. Grammatically, "the start of the current
/// `CalendarPeriod`." All calendar times begin at midnight UTC.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CalendarPeriod {
    /// Undefined period, raises an error.
    Unspecified,
    /// A day.
    Day,
    /// A week. Weeks begin on Monday, following
    /// [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).
    Week,
    /// A fortnight. The first calendar fortnight of the year begins at the start
    /// of week 1 according to
    /// [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).
    Fortnight,
    /// A month.
    Month,
    /// A quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of each
    /// year.
    Quarter,
    /// A half-year. Half-years start on dates 1-Jan and 1-Jul.
    Half,
    /// A year.
    Year,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CalendarPeriod::value] or
    /// [CalendarPeriod::name].
    UnknownValue(calendar_period::UnknownValue),
}

#[doc(hidden)]
pub mod calendar_period {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CalendarPeriod {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Day => std::option::Option::Some(1),
            Self::Week => std::option::Option::Some(2),
            Self::Fortnight => std::option::Option::Some(3),
            Self::Month => std::option::Option::Some(4),
            Self::Quarter => std::option::Option::Some(5),
            Self::Half => std::option::Option::Some(6),
            Self::Year => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CALENDAR_PERIOD_UNSPECIFIED"),
            Self::Day => std::option::Option::Some("DAY"),
            Self::Week => std::option::Option::Some("WEEK"),
            Self::Fortnight => std::option::Option::Some("FORTNIGHT"),
            Self::Month => std::option::Option::Some("MONTH"),
            Self::Quarter => std::option::Option::Some("QUARTER"),
            Self::Half => std::option::Option::Some("HALF"),
            Self::Year => std::option::Option::Some("YEAR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CalendarPeriod {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CalendarPeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CalendarPeriod {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Day,
            2 => Self::Week,
            3 => Self::Fortnight,
            4 => Self::Month,
            5 => Self::Quarter,
            6 => Self::Half,
            7 => Self::Year,
            _ => Self::UnknownValue(calendar_period::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CalendarPeriod {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CALENDAR_PERIOD_UNSPECIFIED" => Self::Unspecified,
            "DAY" => Self::Day,
            "WEEK" => Self::Week,
            "FORTNIGHT" => Self::Fortnight,
            "MONTH" => Self::Month,
            "QUARTER" => Self::Quarter,
            "HALF" => Self::Half,
            "YEAR" => Self::Year,
            _ => Self::UnknownValue(calendar_period::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CalendarPeriod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Day => serializer.serialize_i32(1),
            Self::Week => serializer.serialize_i32(2),
            Self::Fortnight => serializer.serialize_i32(3),
            Self::Month => serializer.serialize_i32(4),
            Self::Quarter => serializer.serialize_i32(5),
            Self::Half => serializer.serialize_i32(6),
            Self::Year => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CalendarPeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CalendarPeriod>::new(
            ".google.type.CalendarPeriod",
        ))
    }
}

/// Represents a day of the week.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DayOfWeek {
    /// The day of the week is unspecified.
    Unspecified,
    /// Monday
    Monday,
    /// Tuesday
    Tuesday,
    /// Wednesday
    Wednesday,
    /// Thursday
    Thursday,
    /// Friday
    Friday,
    /// Saturday
    Saturday,
    /// Sunday
    Sunday,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DayOfWeek::value] or
    /// [DayOfWeek::name].
    UnknownValue(day_of_week::UnknownValue),
}

#[doc(hidden)]
pub mod day_of_week {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DayOfWeek {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Monday => std::option::Option::Some(1),
            Self::Tuesday => std::option::Option::Some(2),
            Self::Wednesday => std::option::Option::Some(3),
            Self::Thursday => std::option::Option::Some(4),
            Self::Friday => std::option::Option::Some(5),
            Self::Saturday => std::option::Option::Some(6),
            Self::Sunday => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DAY_OF_WEEK_UNSPECIFIED"),
            Self::Monday => std::option::Option::Some("MONDAY"),
            Self::Tuesday => std::option::Option::Some("TUESDAY"),
            Self::Wednesday => std::option::Option::Some("WEDNESDAY"),
            Self::Thursday => std::option::Option::Some("THURSDAY"),
            Self::Friday => std::option::Option::Some("FRIDAY"),
            Self::Saturday => std::option::Option::Some("SATURDAY"),
            Self::Sunday => std::option::Option::Some("SUNDAY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DayOfWeek {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DayOfWeek {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DayOfWeek {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Monday,
            2 => Self::Tuesday,
            3 => Self::Wednesday,
            4 => Self::Thursday,
            5 => Self::Friday,
            6 => Self::Saturday,
            7 => Self::Sunday,
            _ => Self::UnknownValue(day_of_week::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DayOfWeek {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DAY_OF_WEEK_UNSPECIFIED" => Self::Unspecified,
            "MONDAY" => Self::Monday,
            "TUESDAY" => Self::Tuesday,
            "WEDNESDAY" => Self::Wednesday,
            "THURSDAY" => Self::Thursday,
            "FRIDAY" => Self::Friday,
            "SATURDAY" => Self::Saturday,
            "SUNDAY" => Self::Sunday,
            _ => Self::UnknownValue(day_of_week::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DayOfWeek {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Monday => serializer.serialize_i32(1),
            Self::Tuesday => serializer.serialize_i32(2),
            Self::Wednesday => serializer.serialize_i32(3),
            Self::Thursday => serializer.serialize_i32(4),
            Self::Friday => serializer.serialize_i32(5),
            Self::Saturday => serializer.serialize_i32(6),
            Self::Sunday => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DayOfWeek {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DayOfWeek>::new(
            ".google.type.DayOfWeek",
        ))
    }
}

/// Represents a month in the Gregorian calendar.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Month {
    /// The unspecified month.
    Unspecified,
    /// The month of January.
    January,
    /// The month of February.
    February,
    /// The month of March.
    March,
    /// The month of April.
    April,
    /// The month of May.
    May,
    /// The month of June.
    June,
    /// The month of July.
    July,
    /// The month of August.
    August,
    /// The month of September.
    September,
    /// The month of October.
    October,
    /// The month of November.
    November,
    /// The month of December.
    December,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Month::value] or
    /// [Month::name].
    UnknownValue(month::UnknownValue),
}

#[doc(hidden)]
pub mod month {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Month {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::January => std::option::Option::Some(1),
            Self::February => std::option::Option::Some(2),
            Self::March => std::option::Option::Some(3),
            Self::April => std::option::Option::Some(4),
            Self::May => std::option::Option::Some(5),
            Self::June => std::option::Option::Some(6),
            Self::July => std::option::Option::Some(7),
            Self::August => std::option::Option::Some(8),
            Self::September => std::option::Option::Some(9),
            Self::October => std::option::Option::Some(10),
            Self::November => std::option::Option::Some(11),
            Self::December => std::option::Option::Some(12),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MONTH_UNSPECIFIED"),
            Self::January => std::option::Option::Some("JANUARY"),
            Self::February => std::option::Option::Some("FEBRUARY"),
            Self::March => std::option::Option::Some("MARCH"),
            Self::April => std::option::Option::Some("APRIL"),
            Self::May => std::option::Option::Some("MAY"),
            Self::June => std::option::Option::Some("JUNE"),
            Self::July => std::option::Option::Some("JULY"),
            Self::August => std::option::Option::Some("AUGUST"),
            Self::September => std::option::Option::Some("SEPTEMBER"),
            Self::October => std::option::Option::Some("OCTOBER"),
            Self::November => std::option::Option::Some("NOVEMBER"),
            Self::December => std::option::Option::Some("DECEMBER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Month {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Month {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Month {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::January,
            2 => Self::February,
            3 => Self::March,
            4 => Self::April,
            5 => Self::May,
            6 => Self::June,
            7 => Self::July,
            8 => Self::August,
            9 => Self::September,
            10 => Self::October,
            11 => Self::November,
            12 => Self::December,
            _ => Self::UnknownValue(month::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Month {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MONTH_UNSPECIFIED" => Self::Unspecified,
            "JANUARY" => Self::January,
            "FEBRUARY" => Self::February,
            "MARCH" => Self::March,
            "APRIL" => Self::April,
            "MAY" => Self::May,
            "JUNE" => Self::June,
            "JULY" => Self::July,
            "AUGUST" => Self::August,
            "SEPTEMBER" => Self::September,
            "OCTOBER" => Self::October,
            "NOVEMBER" => Self::November,
            "DECEMBER" => Self::December,
            _ => Self::UnknownValue(month::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Month {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::January => serializer.serialize_i32(1),
            Self::February => serializer.serialize_i32(2),
            Self::March => serializer.serialize_i32(3),
            Self::April => serializer.serialize_i32(4),
            Self::May => serializer.serialize_i32(5),
            Self::June => serializer.serialize_i32(6),
            Self::July => serializer.serialize_i32(7),
            Self::August => serializer.serialize_i32(8),
            Self::September => serializer.serialize_i32(9),
            Self::October => serializer.serialize_i32(10),
            Self::November => serializer.serialize_i32(11),
            Self::December => serializer.serialize_i32(12),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Month {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Month>::new(
            ".google.type.Month",
        ))
    }
}
