// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate grafeas;
extern crate iam_v1;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request to generate and export SBOM. Target must be specified for the
/// request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportSBOMRequest {
    /// Required. The name of the resource in the form of
    /// `projects/[PROJECT_ID]/resources/[RESOURCE_URL]`.
    pub name: std::string::String,

    /// The location of the SBOM export.
    pub target: std::option::Option<crate::model::export_sbom_request::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportSBOMRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportSBOMRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::ExportSBOMRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::export_sbom_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::ExportSBOMRequest::target]
    /// if it holds a `CloudStorageLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_location(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_sbom_request::CloudStorageLocation>,
    > {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::export_sbom_request::Target::CloudStorageLocation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::ExportSBOMRequest::target]
    /// to hold a `CloudStorageLocation`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_cloud_storage_location<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_sbom_request::CloudStorageLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::export_sbom_request::Target::CloudStorageLocation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportSBOMRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.containeranalysis.v1.ExportSBOMRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportSBOMRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cloud_storage_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportSBOMRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cloudStorageLocation" => Ok(__FieldTag::__cloud_storage_location),
                            "cloud_storage_location" => Ok(__FieldTag::__cloud_storage_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportSBOMRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportSBOMRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_storage_location => {
                            if !fields.insert(__FieldTag::__cloud_storage_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_location",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.devtools.containeranalysis.v1.ExportSBOMRequest.cloud_storage_location, latest field was cloudStorageLocation",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::export_sbom_request::Target::CloudStorageLocation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::export_sbom_request::CloudStorageLocation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportSBOMRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.cloud_storage_location() {
            state.serialize_entry("cloudStorageLocation", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportSBOMRequest].
pub mod export_sbom_request {
    #[allow(unused_imports)]
    use super::*;

    /// Empty placeholder to denote that this is a Google Cloud Storage
    /// export request.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudStorageLocation {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudStorageLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CloudStorageLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.containeranalysis.v1.ExportSBOMRequest.CloudStorageLocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudStorageLocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudStorageLocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudStorageLocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudStorageLocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudStorageLocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The location of the SBOM export.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Optional. Empty placeholder to denote that this is a Google Cloud Storage
        /// export request.
        CloudStorageLocation(
            std::boxed::Box<crate::model::export_sbom_request::CloudStorageLocation>,
        ),
    }
}

/// The response from a call to ExportSBOM.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportSBOMResponse {
    /// The name of the discovery occurrence in the form
    /// "projects/{project_id}/occurrences/{OCCURRENCE_ID}
    /// It can be used to track the progress of the SBOM export.
    pub discovery_occurrence: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportSBOMResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discovery_occurrence][crate::model::ExportSBOMResponse::discovery_occurrence].
    pub fn set_discovery_occurrence<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_occurrence = v.into();
        self
    }
}

impl wkt::message::Message for ExportSBOMResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.containeranalysis.v1.ExportSBOMResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportSBOMResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __discovery_occurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportSBOMResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "discoveryOccurrence" => Ok(__FieldTag::__discovery_occurrence),
                            "discovery_occurrence" => Ok(__FieldTag::__discovery_occurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportSBOMResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportSBOMResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__discovery_occurrence => {
                            if !fields.insert(__FieldTag::__discovery_occurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_occurrence",
                                ));
                            }
                            result.discovery_occurrence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportSBOMResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.discovery_occurrence.is_empty() {
            state.serialize_entry("discoveryOccurrence", &self.discovery_occurrence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get a vulnerability summary for some set of occurrences.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVulnerabilityOccurrencesSummaryRequest {
    /// Required. The name of the project to get a vulnerability summary for in the
    /// form of `projects/[PROJECT_ID]`.
    pub parent: std::string::String,

    /// The filter expression.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVulnerabilityOccurrencesSummaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetVulnerabilityOccurrencesSummaryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::GetVulnerabilityOccurrencesSummaryRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for GetVulnerabilityOccurrencesSummaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.containeranalysis.v1.GetVulnerabilityOccurrencesSummaryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVulnerabilityOccurrencesSummaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GetVulnerabilityOccurrencesSummaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVulnerabilityOccurrencesSummaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVulnerabilityOccurrencesSummaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVulnerabilityOccurrencesSummaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A summary of how many vulnerability occurrences there are per resource and
/// severity type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityOccurrencesSummary {
    /// A listing by resource of the number of fixable and total vulnerabilities.
    pub counts:
        std::vec::Vec<crate::model::vulnerability_occurrences_summary::FixableTotalByDigest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityOccurrencesSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [counts][crate::model::VulnerabilityOccurrencesSummary::counts].
    pub fn set_counts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::vulnerability_occurrences_summary::FixableTotalByDigest,
            >,
    {
        use std::iter::Iterator;
        self.counts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VulnerabilityOccurrencesSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.containeranalysis.v1.VulnerabilityOccurrencesSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerabilityOccurrencesSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __counts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityOccurrencesSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "counts" => Ok(__FieldTag::__counts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerabilityOccurrencesSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityOccurrencesSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__counts => {
                            if !fields.insert(__FieldTag::__counts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for counts",
                                ));
                            }
                            result.counts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_occurrences_summary::FixableTotalByDigest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerabilityOccurrencesSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.counts.is_empty() {
            state.serialize_entry("counts", &self.counts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VulnerabilityOccurrencesSummary].
pub mod vulnerability_occurrences_summary {
    #[allow(unused_imports)]
    use super::*;

    /// Per resource and severity counts of fixable and total vulnerabilities.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FixableTotalByDigest {
        /// The affected resource.
        pub resource_uri: std::string::String,

        /// The severity for this count. SEVERITY_UNSPECIFIED indicates total across
        /// all severities.
        pub severity: grafeas::model::Severity,

        /// The number of fixable vulnerabilities associated with this resource.
        pub fixable_count: i64,

        /// The total number of vulnerabilities associated with this resource.
        pub total_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FixableTotalByDigest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_uri][crate::model::vulnerability_occurrences_summary::FixableTotalByDigest::resource_uri].
        pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_uri = v.into();
            self
        }

        /// Sets the value of [severity][crate::model::vulnerability_occurrences_summary::FixableTotalByDigest::severity].
        pub fn set_severity<T: std::convert::Into<grafeas::model::Severity>>(
            mut self,
            v: T,
        ) -> Self {
            self.severity = v.into();
            self
        }

        /// Sets the value of [fixable_count][crate::model::vulnerability_occurrences_summary::FixableTotalByDigest::fixable_count].
        pub fn set_fixable_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.fixable_count = v.into();
            self
        }

        /// Sets the value of [total_count][crate::model::vulnerability_occurrences_summary::FixableTotalByDigest::total_count].
        pub fn set_total_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_count = v.into();
            self
        }
    }

    impl wkt::message::Message for FixableTotalByDigest {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.containeranalysis.v1.VulnerabilityOccurrencesSummary.FixableTotalByDigest"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FixableTotalByDigest {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resource_uri,
                __severity,
                __fixable_count,
                __total_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FixableTotalByDigest")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resourceUri" => Ok(__FieldTag::__resource_uri),
                                "resource_uri" => Ok(__FieldTag::__resource_uri),
                                "severity" => Ok(__FieldTag::__severity),
                                "fixableCount" => Ok(__FieldTag::__fixable_count),
                                "fixable_count" => Ok(__FieldTag::__fixable_count),
                                "totalCount" => Ok(__FieldTag::__total_count),
                                "total_count" => Ok(__FieldTag::__total_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FixableTotalByDigest;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FixableTotalByDigest")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resource_uri => {
                                if !fields.insert(__FieldTag::__resource_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_uri",
                                    ));
                                }
                                result.resource_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__severity => {
                                if !fields.insert(__FieldTag::__severity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for severity",
                                    ));
                                }
                                result.severity = map
                                    .next_value::<std::option::Option<grafeas::model::Severity>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fixable_count => {
                                if !fields.insert(__FieldTag::__fixable_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fixable_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.fixable_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_count => {
                                if !fields.insert(__FieldTag::__total_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FixableTotalByDigest {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resource_uri.is_empty() {
                state.serialize_entry("resourceUri", &self.resource_uri)?;
            }
            if !wkt::internal::is_default(&self.severity) {
                state.serialize_entry("severity", &self.severity)?;
            }
            if !wkt::internal::is_default(&self.fixable_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("fixableCount", &__With(&self.fixable_count))?;
            }
            if !wkt::internal::is_default(&self.total_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("totalCount", &__With(&self.total_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}
