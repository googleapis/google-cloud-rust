// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A span represents a single operation within a trace. Spans can be
/// nested to form a trace tree. Often, a trace contains a root span
/// that describes the end-to-end latency, and one or more subspans for
/// its sub-operations.
///
/// A trace can also contain multiple root spans, or none at all.
/// Spans do not need to be contiguous. There might be
/// gaps or overlaps between spans in a trace.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Span {
    /// Required. The resource name of the span in the following format:
    ///
    /// * `projects/[PROJECT_ID]/traces/[TRACE_ID]/spans/[SPAN_ID]`
    ///
    /// `[TRACE_ID]` is a unique identifier for a trace within a project;
    /// it is a 32-character hexadecimal encoding of a 16-byte array. It should
    /// not be zero.
    ///
    /// `[SPAN_ID]` is a unique identifier for a span within a trace; it
    /// is a 16-character hexadecimal encoding of an 8-byte array. It should not
    /// be zero.
    /// .
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The `[SPAN_ID]` portion of the span's resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub span_id: std::string::String,

    /// The `[SPAN_ID]` of this span's parent span. If this is a root span,
    /// then this field must be empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_span_id: std::string::String,

    /// Required. A description of the span's operation (up to 128 bytes).
    /// Cloud Trace displays the description in the
    /// Cloud console.
    /// For example, the display name can be a qualified method name or a file name
    /// and a line number where the operation is called. A best practice is to use
    /// the same display name within an application and at the same call point.
    /// This makes it easier to correlate spans in different traces.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_name: std::option::Option<crate::model::TruncatableString>,

    /// Required. The start time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution starts. On the server
    /// side, this is the time when the server's application handler starts
    /// running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. The end time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution ends. On the server
    /// side, this is the time when the server application handler stops running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// A set of attributes on the span. You can have up to 32 attributes per
    /// span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attributes: std::option::Option<crate::model::span::Attributes>,

    /// Stack trace captured at the start of the span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stack_trace: std::option::Option<crate::model::StackTrace>,

    /// A set of time events. You can have up to 32 annotations and 128 message
    /// events per span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_events: std::option::Option<crate::model::span::TimeEvents>,

    /// Links associated with the span. You can have up to 128 links per Span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub links: std::option::Option<crate::model::span::Links>,

    /// Optional. The final status for this span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Optional. Set this parameter to indicate whether this span is in
    /// the same process as its parent. If you do not set this parameter,
    /// Trace is unable to take advantage of this helpful information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub same_process_as_parent_span: std::option::Option<wkt::BoolValue>,

    /// Optional. The number of child spans that were generated while this span
    /// was active. If set, allows implementation to detect missing child spans.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub child_span_count: std::option::Option<wkt::Int32Value>,

    /// Optional. Distinguishes between spans generated in a particular context.
    /// For example, two spans with the same name may be distinguished using
    /// `CLIENT` (caller) and `SERVER` (callee) to identify an RPC call.
    pub span_kind: crate::model::span::SpanKind,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Span {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Span::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [span_id][crate::model::Span::span_id].
    pub fn set_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.span_id = v.into();
        self
    }

    /// Sets the value of [parent_span_id][crate::model::Span::parent_span_id].
    pub fn set_parent_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_span_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Span::display_name].
    pub fn set_display_name<
        T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Span::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Span::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::Span::attributes].
    pub fn set_attributes<
        T: std::convert::Into<std::option::Option<crate::model::span::Attributes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attributes = v.into();
        self
    }

    /// Sets the value of [stack_trace][crate::model::Span::stack_trace].
    pub fn set_stack_trace<T: std::convert::Into<std::option::Option<crate::model::StackTrace>>>(
        mut self,
        v: T,
    ) -> Self {
        self.stack_trace = v.into();
        self
    }

    /// Sets the value of [time_events][crate::model::Span::time_events].
    pub fn set_time_events<
        T: std::convert::Into<std::option::Option<crate::model::span::TimeEvents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_events = v.into();
        self
    }

    /// Sets the value of [links][crate::model::Span::links].
    pub fn set_links<T: std::convert::Into<std::option::Option<crate::model::span::Links>>>(
        mut self,
        v: T,
    ) -> Self {
        self.links = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Span::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [same_process_as_parent_span][crate::model::Span::same_process_as_parent_span].
    pub fn set_same_process_as_parent_span<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.same_process_as_parent_span = v.into();
        self
    }

    /// Sets the value of [child_span_count][crate::model::Span::child_span_count].
    pub fn set_child_span_count<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.child_span_count = v.into();
        self
    }

    /// Sets the value of [span_kind][crate::model::Span::span_kind].
    pub fn set_span_kind<T: std::convert::Into<crate::model::span::SpanKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.span_kind = v.into();
        self
    }
}

impl wkt::message::Message for Span {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.Span"
    }
}

/// Defines additional types related to [Span].
pub mod span {
    #[allow(unused_imports)]
    use super::*;

    /// A set of attributes as key-value pairs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Attributes {
        /// A set of attributes. Each attribute's key can be up to 128 bytes
        /// long. The value can be a string up to 256 bytes, a signed 64-bit integer,
        /// or the boolean values `true` or `false`. For example:
        ///
        /// ```norust
        /// "/instance_id": { "string_value": { "value": "my-instance" } }
        /// "/http/request_bytes": { "int_value": 300 }
        /// "abc.com/myattribute": { "bool_value": false }
        /// ```
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub attribute_map:
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,

        /// The number of attributes that were discarded. Attributes can be discarded
        /// because their keys are too long or because there are too many attributes.
        /// If this value is 0 then all attributes are valid.
        pub dropped_attributes_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Attributes {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dropped_attributes_count][crate::model::span::Attributes::dropped_attributes_count].
        pub fn set_dropped_attributes_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_attributes_count = v.into();
            self
        }

        /// Sets the value of [attribute_map][crate::model::span::Attributes::attribute_map].
        pub fn set_attribute_map<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::AttributeValue>,
        {
            use std::iter::Iterator;
            self.attribute_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Attributes {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.Attributes"
        }
    }

    /// A time-stamped annotation or message event in the Span.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeEvent {
        /// The timestamp indicating the time the event occurred.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time: std::option::Option<wkt::Timestamp>,

        /// A `TimeEvent` can contain either an `Annotation` object or a
        /// `MessageEvent` object, but not both.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::span::time_event::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeEvent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time][crate::model::span::TimeEvent::time].
        pub fn set_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.time = v.into();
            self
        }

        /// Sets the value of [value][crate::model::span::TimeEvent::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::span::time_event::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::span::TimeEvent::value]
        /// if it holds a `Annotation`, `None` if the field is not set or
        /// holds a different branch.
        pub fn annotation(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::span::time_event::Annotation>>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::span::time_event::Value::Annotation(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::span::TimeEvent::value]
        /// if it holds a `MessageEvent`, `None` if the field is not set or
        /// holds a different branch.
        pub fn message_event(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::span::time_event::MessageEvent>>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::span::time_event::Value::MessageEvent(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::span::TimeEvent::value]
        /// to hold a `Annotation`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_annotation<
            T: std::convert::Into<std::boxed::Box<crate::model::span::time_event::Annotation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::span::time_event::Value::Annotation(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::span::TimeEvent::value]
        /// to hold a `MessageEvent`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_message_event<
            T: std::convert::Into<std::boxed::Box<crate::model::span::time_event::MessageEvent>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::span::time_event::Value::MessageEvent(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for TimeEvent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvent"
        }
    }

    /// Defines additional types related to [TimeEvent].
    pub mod time_event {
        #[allow(unused_imports)]
        use super::*;

        /// Text annotation with a set of attributes.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Annotation {
            /// A user-supplied message describing the event. The maximum length for
            /// the description is 256 bytes.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub description: std::option::Option<crate::model::TruncatableString>,

            /// A set of attributes on the annotation. You can have up to 4 attributes
            /// per Annotation.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub attributes: std::option::Option<crate::model::span::Attributes>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Annotation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [description][crate::model::span::time_event::Annotation::description].
            pub fn set_description<
                T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.description = v.into();
                self
            }

            /// Sets the value of [attributes][crate::model::span::time_event::Annotation::attributes].
            pub fn set_attributes<
                T: std::convert::Into<std::option::Option<crate::model::span::Attributes>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.attributes = v.into();
                self
            }
        }

        impl wkt::message::Message for Annotation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvent.Annotation"
            }
        }

        /// An event describing a message sent/received between Spans.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MessageEvent {
            /// Type of MessageEvent. Indicates whether the message was sent or
            /// received.
            #[serde(rename = "type")]
            pub r#type: crate::model::span::time_event::message_event::Type,

            /// An identifier for the MessageEvent's message that can be used to match
            /// `SENT` and `RECEIVED` MessageEvents.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub id: i64,

            /// The number of uncompressed bytes sent or received.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub uncompressed_size_bytes: i64,

            /// The number of compressed bytes sent or received. If missing, the
            /// compressed size is assumed to be the same size as the uncompressed
            /// size.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub compressed_size_bytes: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MessageEvent {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::span::time_event::MessageEvent::type].
            pub fn set_type<
                T: std::convert::Into<crate::model::span::time_event::message_event::Type>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [id][crate::model::span::time_event::MessageEvent::id].
            pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.id = v.into();
                self
            }

            /// Sets the value of [uncompressed_size_bytes][crate::model::span::time_event::MessageEvent::uncompressed_size_bytes].
            pub fn set_uncompressed_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.uncompressed_size_bytes = v.into();
                self
            }

            /// Sets the value of [compressed_size_bytes][crate::model::span::time_event::MessageEvent::compressed_size_bytes].
            pub fn set_compressed_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.compressed_size_bytes = v.into();
                self
            }
        }

        impl wkt::message::Message for MessageEvent {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvent.MessageEvent"
            }
        }

        /// Defines additional types related to [MessageEvent].
        pub mod message_event {
            #[allow(unused_imports)]
            use super::*;

            /// Indicates whether the message was sent or received.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct Type(i32);

            impl Type {
                /// Unknown event type.
                pub const TYPE_UNSPECIFIED: Type = Type::new(0);

                /// Indicates a sent message.
                pub const SENT: Type = Type::new(1);

                /// Indicates a received message.
                pub const RECEIVED: Type = Type::new(2);

                /// Creates a new Type instance.
                pub(crate) const fn new(value: i32) -> Self {
                    Self(value)
                }

                /// Gets the enum value.
                pub fn value(&self) -> i32 {
                    self.0
                }

                /// Gets the enum value as a string.
                pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                    match self.0 {
                        0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                        1 => std::borrow::Cow::Borrowed("SENT"),
                        2 => std::borrow::Cow::Borrowed("RECEIVED"),
                        _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                    }
                }

                /// Creates an enum value from the value name.
                pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                    match name {
                        "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                        "SENT" => std::option::Option::Some(Self::SENT),
                        "RECEIVED" => std::option::Option::Some(Self::RECEIVED),
                        _ => std::option::Option::None,
                    }
                }
            }

            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    Self::new(value)
                }
            }

            impl std::default::Default for Type {
                fn default() -> Self {
                    Self::new(0)
                }
            }
        }

        /// A `TimeEvent` can contain either an `Annotation` object or a
        /// `MessageEvent` object, but not both.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// Text annotation with a set of attributes.
            Annotation(std::boxed::Box<crate::model::span::time_event::Annotation>),
            /// An event describing a message sent/received between Spans.
            MessageEvent(std::boxed::Box<crate::model::span::time_event::MessageEvent>),
        }
    }

    /// A collection of `TimeEvent`s. A `TimeEvent` is a time-stamped annotation
    /// on the span, consisting of either user-supplied key:value pairs, or
    /// details of a message sent/received between Spans.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeEvents {
        /// A collection of `TimeEvent`s.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub time_event: std::vec::Vec<crate::model::span::TimeEvent>,

        /// The number of dropped annotations in all the included time events.
        /// If the value is 0, then no annotations were dropped.
        pub dropped_annotations_count: i32,

        /// The number of dropped message events in all the included time events.
        /// If the value is 0, then no message events were dropped.
        pub dropped_message_events_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeEvents {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dropped_annotations_count][crate::model::span::TimeEvents::dropped_annotations_count].
        pub fn set_dropped_annotations_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_annotations_count = v.into();
            self
        }

        /// Sets the value of [dropped_message_events_count][crate::model::span::TimeEvents::dropped_message_events_count].
        pub fn set_dropped_message_events_count<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.dropped_message_events_count = v.into();
            self
        }

        /// Sets the value of [time_event][crate::model::span::TimeEvents::time_event].
        pub fn set_time_event<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::span::TimeEvent>,
        {
            use std::iter::Iterator;
            self.time_event = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TimeEvents {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvents"
        }
    }

    /// A pointer from the current span to another span in the same trace or in a
    /// different trace. For example, this can be used in batching operations,
    /// where a single batch handler processes multiple requests from different
    /// traces or when the handler receives a request from a different project.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Link {
        /// The `[TRACE_ID]` for a trace within a project.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub trace_id: std::string::String,

        /// The `[SPAN_ID]` for a span within a trace.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub span_id: std::string::String,

        /// The relationship of the current span relative to the linked span.
        #[serde(rename = "type")]
        pub r#type: crate::model::span::link::Type,

        /// A set of attributes on the link. Up to 32 attributes can be
        /// specified per link.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub attributes: std::option::Option<crate::model::span::Attributes>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Link {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trace_id][crate::model::span::Link::trace_id].
        pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trace_id = v.into();
            self
        }

        /// Sets the value of [span_id][crate::model::span::Link::span_id].
        pub fn set_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.span_id = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::span::Link::type].
        pub fn set_type<T: std::convert::Into<crate::model::span::link::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [attributes][crate::model::span::Link::attributes].
        pub fn set_attributes<
            T: std::convert::Into<std::option::Option<crate::model::span::Attributes>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.attributes = v.into();
            self
        }
    }

    impl wkt::message::Message for Link {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.Link"
        }
    }

    /// Defines additional types related to [Link].
    pub mod link {
        #[allow(unused_imports)]
        use super::*;

        /// The relationship of the current span relative to the linked span: child,
        /// parent, or unspecified.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Type(i32);

        impl Type {
            /// The relationship of the two spans is unknown.
            pub const TYPE_UNSPECIFIED: Type = Type::new(0);

            /// The linked span is a child of the current span.
            pub const CHILD_LINKED_SPAN: Type = Type::new(1);

            /// The linked span is a parent of the current span.
            pub const PARENT_LINKED_SPAN: Type = Type::new(2);

            /// Creates a new Type instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("CHILD_LINKED_SPAN"),
                    2 => std::borrow::Cow::Borrowed("PARENT_LINKED_SPAN"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                    "CHILD_LINKED_SPAN" => std::option::Option::Some(Self::CHILD_LINKED_SPAN),
                    "PARENT_LINKED_SPAN" => std::option::Option::Some(Self::PARENT_LINKED_SPAN),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// A collection of links, which are references from this span to a span
    /// in the same or different trace.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Links {
        /// A collection of links.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub link: std::vec::Vec<crate::model::span::Link>,

        /// The number of dropped links after the maximum size was enforced. If
        /// this value is 0, then no links were dropped.
        pub dropped_links_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Links {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dropped_links_count][crate::model::span::Links::dropped_links_count].
        pub fn set_dropped_links_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_links_count = v.into();
            self
        }

        /// Sets the value of [link][crate::model::span::Links::link].
        pub fn set_link<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::span::Link>,
        {
            use std::iter::Iterator;
            self.link = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Links {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.Links"
        }
    }

    /// Type of span. Can be used to specify additional relationships between spans
    /// in addition to a parent/child relationship.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SpanKind(i32);

    impl SpanKind {
        /// Unspecified. Do NOT use as default.
        /// Implementations MAY assume SpanKind.INTERNAL to be default.
        pub const SPAN_KIND_UNSPECIFIED: SpanKind = SpanKind::new(0);

        /// Indicates that the span is used internally. Default value.
        pub const INTERNAL: SpanKind = SpanKind::new(1);

        /// Indicates that the span covers server-side handling of an RPC or other
        /// remote network request.
        pub const SERVER: SpanKind = SpanKind::new(2);

        /// Indicates that the span covers the client-side wrapper around an RPC or
        /// other remote request.
        pub const CLIENT: SpanKind = SpanKind::new(3);

        /// Indicates that the span describes producer sending a message to a broker.
        /// Unlike client and  server, there is no direct critical path latency
        /// relationship between producer and consumer spans (e.g. publishing a
        /// message to a pubsub service).
        pub const PRODUCER: SpanKind = SpanKind::new(4);

        /// Indicates that the span describes consumer receiving a message from a
        /// broker. Unlike client and  server, there is no direct critical path
        /// latency relationship between producer and consumer spans (e.g. receiving
        /// a message from a pubsub service subscription).
        pub const CONSUMER: SpanKind = SpanKind::new(5);

        /// Creates a new SpanKind instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SPAN_KIND_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INTERNAL"),
                2 => std::borrow::Cow::Borrowed("SERVER"),
                3 => std::borrow::Cow::Borrowed("CLIENT"),
                4 => std::borrow::Cow::Borrowed("PRODUCER"),
                5 => std::borrow::Cow::Borrowed("CONSUMER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SPAN_KIND_UNSPECIFIED" => std::option::Option::Some(Self::SPAN_KIND_UNSPECIFIED),
                "INTERNAL" => std::option::Option::Some(Self::INTERNAL),
                "SERVER" => std::option::Option::Some(Self::SERVER),
                "CLIENT" => std::option::Option::Some(Self::CLIENT),
                "PRODUCER" => std::option::Option::Some(Self::PRODUCER),
                "CONSUMER" => std::option::Option::Some(Self::CONSUMER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SpanKind {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SpanKind {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The allowed types for `[VALUE]` in a `[KEY]:[VALUE]` attribute.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttributeValue {
    /// The type of the value.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::attribute_value::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributeValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AttributeValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::attribute_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::AttributeValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TruncatableString>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::AttributeValue::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_value::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::AttributeValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<
        T: std::convert::Into<std::boxed::Box<crate::model::TruncatableString>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_value::Value::StringValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::AttributeValue::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_value::Value::IntValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::AttributeValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_value::Value::BoolValue(v.into()));
        self
    }
}

impl wkt::message::Message for AttributeValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.AttributeValue"
    }
}

/// Defines additional types related to [AttributeValue].
pub mod attribute_value {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the value.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A string up to 256 bytes long.
        StringValue(std::boxed::Box<crate::model::TruncatableString>),
        /// A 64-bit signed integer.
        IntValue(i64),
        /// A Boolean value represented by `true` or `false`.
        BoolValue(bool),
    }
}

/// A call stack appearing in a trace.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StackTrace {
    /// Stack frames in this stack trace. A maximum of 128 frames are allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stack_frames: std::option::Option<crate::model::stack_trace::StackFrames>,

    /// The hash ID is used to conserve network bandwidth for duplicate
    /// stack traces within a single trace.
    ///
    /// Often multiple spans will have identical stack traces.
    /// The first occurrence of a stack trace should contain both the
    /// `stackFrame` content and a value in `stackTraceHashId`.
    ///
    /// Subsequent spans within the same request can refer
    /// to that stack trace by only setting `stackTraceHashId`.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub stack_trace_hash_id: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StackTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stack_frames][crate::model::StackTrace::stack_frames].
    pub fn set_stack_frames<
        T: std::convert::Into<std::option::Option<crate::model::stack_trace::StackFrames>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stack_frames = v.into();
        self
    }

    /// Sets the value of [stack_trace_hash_id][crate::model::StackTrace::stack_trace_hash_id].
    pub fn set_stack_trace_hash_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.stack_trace_hash_id = v.into();
        self
    }
}

impl wkt::message::Message for StackTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.StackTrace"
    }
}

/// Defines additional types related to [StackTrace].
pub mod stack_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a single stack frame in a stack trace.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StackFrame {
        /// The fully-qualified name that uniquely identifies the function or
        /// method that is active in this frame (up to 1024 bytes).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub function_name: std::option::Option<crate::model::TruncatableString>,

        /// An un-mangled function name, if `function_name` is mangled.
        /// To get information about name mangling, run
        /// [this search](https://www.google.com/search?q=cxx+name+mangling).
        /// The name can be fully-qualified (up to 1024 bytes).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub original_function_name: std::option::Option<crate::model::TruncatableString>,

        /// The name of the source file where the function call appears (up to 256
        /// bytes).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub file_name: std::option::Option<crate::model::TruncatableString>,

        /// The line number in `file_name` where the function call appears.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub line_number: i64,

        /// The column number where the function call appears, if available.
        /// This is important in JavaScript because of its anonymous functions.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub column_number: i64,

        /// The binary module from where the code was loaded.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub load_module: std::option::Option<crate::model::Module>,

        /// The version of the deployed source code (up to 128 bytes).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub source_version: std::option::Option<crate::model::TruncatableString>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StackFrame {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [function_name][crate::model::stack_trace::StackFrame::function_name].
        pub fn set_function_name<
            T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.function_name = v.into();
            self
        }

        /// Sets the value of [original_function_name][crate::model::stack_trace::StackFrame::original_function_name].
        pub fn set_original_function_name<
            T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.original_function_name = v.into();
            self
        }

        /// Sets the value of [file_name][crate::model::stack_trace::StackFrame::file_name].
        pub fn set_file_name<
            T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.file_name = v.into();
            self
        }

        /// Sets the value of [line_number][crate::model::stack_trace::StackFrame::line_number].
        pub fn set_line_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.line_number = v.into();
            self
        }

        /// Sets the value of [column_number][crate::model::stack_trace::StackFrame::column_number].
        pub fn set_column_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.column_number = v.into();
            self
        }

        /// Sets the value of [load_module][crate::model::stack_trace::StackFrame::load_module].
        pub fn set_load_module<T: std::convert::Into<std::option::Option<crate::model::Module>>>(
            mut self,
            v: T,
        ) -> Self {
            self.load_module = v.into();
            self
        }

        /// Sets the value of [source_version][crate::model::stack_trace::StackFrame::source_version].
        pub fn set_source_version<
            T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_version = v.into();
            self
        }
    }

    impl wkt::message::Message for StackFrame {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.StackTrace.StackFrame"
        }
    }

    /// A collection of stack frames, which can be truncated.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StackFrames {
        /// Stack frames in this call stack.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub frame: std::vec::Vec<crate::model::stack_trace::StackFrame>,

        /// The number of stack frames that were dropped because there
        /// were too many stack frames.
        /// If this value is 0, then no stack frames were dropped.
        pub dropped_frames_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StackFrames {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dropped_frames_count][crate::model::stack_trace::StackFrames::dropped_frames_count].
        pub fn set_dropped_frames_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_frames_count = v.into();
            self
        }

        /// Sets the value of [frame][crate::model::stack_trace::StackFrames::frame].
        pub fn set_frame<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::stack_trace::StackFrame>,
        {
            use std::iter::Iterator;
            self.frame = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StackFrames {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.StackTrace.StackFrames"
        }
    }
}

/// Binary module.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Module {
    /// For example: main binary, kernel modules, and dynamic libraries
    /// such as libc.so, sharedlib.so (up to 256 bytes).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub module: std::option::Option<crate::model::TruncatableString>,

    /// A unique identifier for the module, usually a hash of its
    /// contents (up to 128 bytes).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_id: std::option::Option<crate::model::TruncatableString>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Module {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [module][crate::model::Module::module].
    pub fn set_module<
        T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.module = v.into();
        self
    }

    /// Sets the value of [build_id][crate::model::Module::build_id].
    pub fn set_build_id<
        T: std::convert::Into<std::option::Option<crate::model::TruncatableString>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_id = v.into();
        self
    }
}

impl wkt::message::Message for Module {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.Module"
    }
}

/// Represents a string that might be shortened to a specified length.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TruncatableString {
    /// The shortened string. For example, if the original string is 500
    /// bytes long and the limit of the string is 128 bytes, then
    /// `value` contains the first 128 bytes of the 500-byte string.
    ///
    /// Truncation always happens on a UTF8 character boundary. If there
    /// are multi-byte characters in the string, then the length of the
    /// shortened string might be less than the size limit.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// The number of bytes removed from the original string. If this
    /// value is 0, then the string was not shortened.
    pub truncated_byte_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TruncatableString {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TruncatableString::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [truncated_byte_count][crate::model::TruncatableString::truncated_byte_count].
    pub fn set_truncated_byte_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.truncated_byte_count = v.into();
        self
    }
}

impl wkt::message::Message for TruncatableString {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.TruncatableString"
    }
}

/// The request message for the `BatchWriteSpans` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchWriteSpansRequest {
    /// Required. The name of the project where the spans belong. The format is
    /// `projects/[PROJECT_ID]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. A list of new spans. The span names must not match existing
    /// spans, otherwise the results are undefined.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub spans: std::vec::Vec<crate::model::Span>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchWriteSpansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchWriteSpansRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spans][crate::model::BatchWriteSpansRequest::spans].
    pub fn set_spans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Span>,
    {
        use std::iter::Iterator;
        self.spans = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchWriteSpansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.BatchWriteSpansRequest"
    }
}
