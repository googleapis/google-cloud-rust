// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A span represents a single operation within a trace. Spans can be
/// nested to form a trace tree. Often, a trace contains a root span
/// that describes the end-to-end latency, and one or more subspans for
/// its sub-operations.
///
/// A trace can also contain multiple root spans, or none at all.
/// Spans do not need to be contiguous. There might be
/// gaps or overlaps between spans in a trace.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Span {
    /// Required. The resource name of the span in the following format:
    ///
    /// * `projects/[PROJECT_ID]/traces/[TRACE_ID]/spans/[SPAN_ID]`
    ///
    /// `[TRACE_ID]` is a unique identifier for a trace within a project;
    /// it is a 32-character hexadecimal encoding of a 16-byte array. It should
    /// not be zero.
    ///
    /// `[SPAN_ID]` is a unique identifier for a span within a trace; it
    /// is a 16-character hexadecimal encoding of an 8-byte array. It should not
    /// be zero.
    /// .
    pub name: std::string::String,

    /// Required. The `[SPAN_ID]` portion of the span's resource name.
    pub span_id: std::string::String,

    /// The `[SPAN_ID]` of this span's parent span. If this is a root span,
    /// then this field must be empty.
    pub parent_span_id: std::string::String,

    /// Required. A description of the span's operation (up to 128 bytes).
    /// Cloud Trace displays the description in the
    /// Cloud console.
    /// For example, the display name can be a qualified method name or a file name
    /// and a line number where the operation is called. A best practice is to use
    /// the same display name within an application and at the same call point.
    /// This makes it easier to correlate spans in different traces.
    pub display_name: std::option::Option<crate::model::TruncatableString>,

    /// Required. The start time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution starts. On the server
    /// side, this is the time when the server's application handler starts
    /// running.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. The end time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution ends. On the server
    /// side, this is the time when the server application handler stops running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// A set of attributes on the span. You can have up to 32 attributes per
    /// span.
    pub attributes: std::option::Option<crate::model::span::Attributes>,

    /// Stack trace captured at the start of the span.
    pub stack_trace: std::option::Option<crate::model::StackTrace>,

    /// A set of time events. You can have up to 32 annotations and 128 message
    /// events per span.
    pub time_events: std::option::Option<crate::model::span::TimeEvents>,

    /// Links associated with the span. You can have up to 128 links per Span.
    pub links: std::option::Option<crate::model::span::Links>,

    /// Optional. The final status for this span.
    pub status: std::option::Option<rpc::model::Status>,

    /// Optional. Set this parameter to indicate whether this span is in
    /// the same process as its parent. If you do not set this parameter,
    /// Trace is unable to take advantage of this helpful information.
    pub same_process_as_parent_span: std::option::Option<wkt::BoolValue>,

    /// Optional. The number of child spans that were generated while this span
    /// was active. If set, allows implementation to detect missing child spans.
    pub child_span_count: std::option::Option<wkt::Int32Value>,

    /// Optional. Distinguishes between spans generated in a particular context.
    /// For example, two spans with the same name may be distinguished using
    /// `CLIENT` (caller) and `SERVER` (callee) to identify an RPC call.
    pub span_kind: crate::model::span::SpanKind,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Span {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Span::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [span_id][crate::model::Span::span_id].
    pub fn set_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.span_id = v.into();
        self
    }

    /// Sets the value of [parent_span_id][crate::model::Span::parent_span_id].
    pub fn set_parent_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_span_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Span::display_name].
    pub fn set_display_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TruncatableString>,
    {
        self.display_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_name][crate::model::Span::display_name].
    pub fn set_or_clear_display_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TruncatableString>,
    {
        self.display_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Span::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Span::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Span::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Span::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::Span::attributes].
    pub fn set_attributes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::span::Attributes>,
    {
        self.attributes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attributes][crate::model::Span::attributes].
    pub fn set_or_clear_attributes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::span::Attributes>,
    {
        self.attributes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stack_trace][crate::model::Span::stack_trace].
    pub fn set_stack_trace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StackTrace>,
    {
        self.stack_trace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stack_trace][crate::model::Span::stack_trace].
    pub fn set_or_clear_stack_trace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StackTrace>,
    {
        self.stack_trace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_events][crate::model::Span::time_events].
    pub fn set_time_events<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::span::TimeEvents>,
    {
        self.time_events = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_events][crate::model::Span::time_events].
    pub fn set_or_clear_time_events<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::span::TimeEvents>,
    {
        self.time_events = v.map(|x| x.into());
        self
    }

    /// Sets the value of [links][crate::model::Span::links].
    pub fn set_links<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::span::Links>,
    {
        self.links = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [links][crate::model::Span::links].
    pub fn set_or_clear_links<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::span::Links>,
    {
        self.links = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Span::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Span::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [same_process_as_parent_span][crate::model::Span::same_process_as_parent_span].
    pub fn set_same_process_as_parent_span<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.same_process_as_parent_span = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [same_process_as_parent_span][crate::model::Span::same_process_as_parent_span].
    pub fn set_or_clear_same_process_as_parent_span<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.same_process_as_parent_span = v.map(|x| x.into());
        self
    }

    /// Sets the value of [child_span_count][crate::model::Span::child_span_count].
    pub fn set_child_span_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.child_span_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [child_span_count][crate::model::Span::child_span_count].
    pub fn set_or_clear_child_span_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.child_span_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [span_kind][crate::model::Span::span_kind].
    pub fn set_span_kind<T: std::convert::Into<crate::model::span::SpanKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.span_kind = v.into();
        self
    }
}

impl wkt::message::Message for Span {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.Span"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Span {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __span_id,
            __parent_span_id,
            __display_name,
            __start_time,
            __end_time,
            __attributes,
            __stack_trace,
            __time_events,
            __links,
            __status,
            __same_process_as_parent_span,
            __child_span_count,
            __span_kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Span")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "spanId" => Ok(__FieldTag::__span_id),
                            "span_id" => Ok(__FieldTag::__span_id),
                            "parentSpanId" => Ok(__FieldTag::__parent_span_id),
                            "parent_span_id" => Ok(__FieldTag::__parent_span_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "stackTrace" => Ok(__FieldTag::__stack_trace),
                            "stack_trace" => Ok(__FieldTag::__stack_trace),
                            "timeEvents" => Ok(__FieldTag::__time_events),
                            "time_events" => Ok(__FieldTag::__time_events),
                            "links" => Ok(__FieldTag::__links),
                            "status" => Ok(__FieldTag::__status),
                            "sameProcessAsParentSpan" => {
                                Ok(__FieldTag::__same_process_as_parent_span)
                            }
                            "same_process_as_parent_span" => {
                                Ok(__FieldTag::__same_process_as_parent_span)
                            }
                            "childSpanCount" => Ok(__FieldTag::__child_span_count),
                            "child_span_count" => Ok(__FieldTag::__child_span_count),
                            "spanKind" => Ok(__FieldTag::__span_kind),
                            "span_kind" => Ok(__FieldTag::__span_kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Span;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Span")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__span_id => {
                            if !fields.insert(__FieldTag::__span_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for span_id",
                                ));
                            }
                            result.span_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_span_id => {
                            if !fields.insert(__FieldTag::__parent_span_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_span_id",
                                ));
                            }
                            result.parent_span_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<crate::model::TruncatableString>>(
                                )?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<crate::model::span::Attributes>>(
                                )?;
                        }
                        __FieldTag::__stack_trace => {
                            if !fields.insert(__FieldTag::__stack_trace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_trace",
                                ));
                            }
                            result.stack_trace =
                                map.next_value::<std::option::Option<crate::model::StackTrace>>()?;
                        }
                        __FieldTag::__time_events => {
                            if !fields.insert(__FieldTag::__time_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_events",
                                ));
                            }
                            result.time_events = map
                                .next_value::<std::option::Option<crate::model::span::TimeEvents>>(
                                )?;
                        }
                        __FieldTag::__links => {
                            if !fields.insert(__FieldTag::__links) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for links",
                                ));
                            }
                            result.links =
                                map.next_value::<std::option::Option<crate::model::span::Links>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__same_process_as_parent_span => {
                            if !fields.insert(__FieldTag::__same_process_as_parent_span) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for same_process_as_parent_span",
                                ));
                            }
                            result.same_process_as_parent_span =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__child_span_count => {
                            if !fields.insert(__FieldTag::__child_span_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for child_span_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.child_span_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__span_kind => {
                            if !fields.insert(__FieldTag::__span_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for span_kind",
                                ));
                            }
                            result.span_kind = map
                                .next_value::<std::option::Option<crate::model::span::SpanKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Span {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.span_id.is_empty() {
            state.serialize_entry("spanId", &self.span_id)?;
        }
        if !self.parent_span_id.is_empty() {
            state.serialize_entry("parentSpanId", &self.parent_span_id)?;
        }
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.attributes.is_some() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if self.stack_trace.is_some() {
            state.serialize_entry("stackTrace", &self.stack_trace)?;
        }
        if self.time_events.is_some() {
            state.serialize_entry("timeEvents", &self.time_events)?;
        }
        if self.links.is_some() {
            state.serialize_entry("links", &self.links)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.same_process_as_parent_span.is_some() {
            state.serialize_entry("sameProcessAsParentSpan", &self.same_process_as_parent_span)?;
        }
        if self.child_span_count.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("childSpanCount", &__With(&self.child_span_count))?;
        }
        if !wkt::internal::is_default(&self.span_kind) {
            state.serialize_entry("spanKind", &self.span_kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Span].
pub mod span {
    #[allow(unused_imports)]
    use super::*;

    /// A set of attributes as key-value pairs.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Attributes {
        /// A set of attributes. Each attribute's key can be up to 128 bytes
        /// long. The value can be a string up to 256 bytes, a signed 64-bit integer,
        /// or the boolean values `true` or `false`. For example:
        ///
        /// ```norust
        /// "/instance_id": { "string_value": { "value": "my-instance" } }
        /// "/http/request_bytes": { "int_value": 300 }
        /// "abc.com/myattribute": { "bool_value": false }
        /// ```
        pub attribute_map:
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,

        /// The number of attributes that were discarded. Attributes can be discarded
        /// because their keys are too long or because there are too many attributes.
        /// If this value is 0 then all attributes are valid.
        pub dropped_attributes_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Attributes {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attribute_map][crate::model::span::Attributes::attribute_map].
        pub fn set_attribute_map<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::AttributeValue>,
        {
            use std::iter::Iterator;
            self.attribute_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [dropped_attributes_count][crate::model::span::Attributes::dropped_attributes_count].
        pub fn set_dropped_attributes_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_attributes_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Attributes {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.Attributes"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Attributes {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __attribute_map,
                __dropped_attributes_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Attributes")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "attributeMap" => Ok(__FieldTag::__attribute_map),
                                "attribute_map" => Ok(__FieldTag::__attribute_map),
                                "droppedAttributesCount" => {
                                    Ok(__FieldTag::__dropped_attributes_count)
                                }
                                "dropped_attributes_count" => {
                                    Ok(__FieldTag::__dropped_attributes_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Attributes;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Attributes")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__attribute_map => {
                                if !fields.insert(__FieldTag::__attribute_map) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attribute_map",
                                    ));
                                }
                                result.attribute_map = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::AttributeValue,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dropped_attributes_count => {
                                if !fields.insert(__FieldTag::__dropped_attributes_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dropped_attributes_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.dropped_attributes_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Attributes {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.attribute_map.is_empty() {
                state.serialize_entry("attributeMap", &self.attribute_map)?;
            }
            if !wkt::internal::is_default(&self.dropped_attributes_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "droppedAttributesCount",
                    &__With(&self.dropped_attributes_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A time-stamped annotation or message event in the Span.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeEvent {
        /// The timestamp indicating the time the event occurred.
        pub time: std::option::Option<wkt::Timestamp>,

        /// A `TimeEvent` can contain either an `Annotation` object or a
        /// `MessageEvent` object, but not both.
        pub value: std::option::Option<crate::model::span::time_event::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeEvent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time][crate::model::span::TimeEvent::time].
        pub fn set_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time][crate::model::span::TimeEvent::time].
        pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [value][crate::model::span::TimeEvent::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::span::time_event::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::span::TimeEvent::value]
        /// if it holds a `Annotation`, `None` if the field is not set or
        /// holds a different branch.
        pub fn annotation(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::span::time_event::Annotation>>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::span::time_event::Value::Annotation(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::span::TimeEvent::value]
        /// to hold a `Annotation`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_annotation<
            T: std::convert::Into<std::boxed::Box<crate::model::span::time_event::Annotation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::span::time_event::Value::Annotation(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::span::TimeEvent::value]
        /// if it holds a `MessageEvent`, `None` if the field is not set or
        /// holds a different branch.
        pub fn message_event(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::span::time_event::MessageEvent>>
        {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::span::time_event::Value::MessageEvent(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::span::TimeEvent::value]
        /// to hold a `MessageEvent`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_message_event<
            T: std::convert::Into<std::boxed::Box<crate::model::span::time_event::MessageEvent>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::span::time_event::Value::MessageEvent(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for TimeEvent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvent"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeEvent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time,
                __annotation,
                __message_event,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeEvent")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "time" => Ok(__FieldTag::__time),
                                "annotation" => Ok(__FieldTag::__annotation),
                                "messageEvent" => Ok(__FieldTag::__message_event),
                                "message_event" => Ok(__FieldTag::__message_event),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeEvent;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeEvent")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time => {
                                if !fields.insert(__FieldTag::__time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time",
                                    ));
                                }
                                result.time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__annotation => {
                                if !fields.insert(__FieldTag::__annotation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for annotation",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.Span.TimeEvent.annotation, latest field was annotation",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::span::time_event::Value::Annotation(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::span::time_event::Annotation,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__message_event => {
                                if !fields.insert(__FieldTag::__message_event) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message_event",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.Span.TimeEvent.message_event, latest field was messageEvent",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::span::time_event::Value::MessageEvent(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::span::time_event::MessageEvent,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeEvent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.time.is_some() {
                state.serialize_entry("time", &self.time)?;
            }
            if let Some(value) = self.annotation() {
                state.serialize_entry("annotation", value)?;
            }
            if let Some(value) = self.message_event() {
                state.serialize_entry("messageEvent", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TimeEvent].
    pub mod time_event {
        #[allow(unused_imports)]
        use super::*;

        /// Text annotation with a set of attributes.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Annotation {
            /// A user-supplied message describing the event. The maximum length for
            /// the description is 256 bytes.
            pub description: std::option::Option<crate::model::TruncatableString>,

            /// A set of attributes on the annotation. You can have up to 4 attributes
            /// per Annotation.
            pub attributes: std::option::Option<crate::model::span::Attributes>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Annotation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [description][crate::model::span::time_event::Annotation::description].
            pub fn set_description<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::TruncatableString>,
            {
                self.description = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [description][crate::model::span::time_event::Annotation::description].
            pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::TruncatableString>,
            {
                self.description = v.map(|x| x.into());
                self
            }

            /// Sets the value of [attributes][crate::model::span::time_event::Annotation::attributes].
            pub fn set_attributes<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::span::Attributes>,
            {
                self.attributes = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [attributes][crate::model::span::time_event::Annotation::attributes].
            pub fn set_or_clear_attributes<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::span::Attributes>,
            {
                self.attributes = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Annotation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvent.Annotation"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Annotation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __description,
                    __attributes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Annotation")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "description" => Ok(__FieldTag::__description),
                                    "attributes" => Ok(__FieldTag::__attributes),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Annotation;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Annotation")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__description => {
                                    if !fields.insert(__FieldTag::__description) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for description",
                                            ),
                                        );
                                    }
                                    result.description = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                        ;
                                }
                                __FieldTag::__attributes => {
                                    if !fields.insert(__FieldTag::__attributes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for attributes",
                                            ),
                                        );
                                    }
                                    result.attributes = map.next_value::<std::option::Option<crate::model::span::Attributes>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Annotation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.description.is_some() {
                    state.serialize_entry("description", &self.description)?;
                }
                if self.attributes.is_some() {
                    state.serialize_entry("attributes", &self.attributes)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// An event describing a message sent/received between Spans.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MessageEvent {
            /// Type of MessageEvent. Indicates whether the message was sent or
            /// received.
            pub r#type: crate::model::span::time_event::message_event::Type,

            /// An identifier for the MessageEvent's message that can be used to match
            /// `SENT` and `RECEIVED` MessageEvents.
            pub id: i64,

            /// The number of uncompressed bytes sent or received.
            pub uncompressed_size_bytes: i64,

            /// The number of compressed bytes sent or received. If missing, the
            /// compressed size is assumed to be the same size as the uncompressed
            /// size.
            pub compressed_size_bytes: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MessageEvent {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::span::time_event::MessageEvent::type].
            pub fn set_type<
                T: std::convert::Into<crate::model::span::time_event::message_event::Type>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [id][crate::model::span::time_event::MessageEvent::id].
            pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.id = v.into();
                self
            }

            /// Sets the value of [uncompressed_size_bytes][crate::model::span::time_event::MessageEvent::uncompressed_size_bytes].
            pub fn set_uncompressed_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.uncompressed_size_bytes = v.into();
                self
            }

            /// Sets the value of [compressed_size_bytes][crate::model::span::time_event::MessageEvent::compressed_size_bytes].
            pub fn set_compressed_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.compressed_size_bytes = v.into();
                self
            }
        }

        impl wkt::message::Message for MessageEvent {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvent.MessageEvent"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MessageEvent {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __type,
                    __id,
                    __uncompressed_size_bytes,
                    __compressed_size_bytes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MessageEvent")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "type" => Ok(__FieldTag::__type),
                                    "id" => Ok(__FieldTag::__id),
                                    "uncompressedSizeBytes" => {
                                        Ok(__FieldTag::__uncompressed_size_bytes)
                                    }
                                    "uncompressed_size_bytes" => {
                                        Ok(__FieldTag::__uncompressed_size_bytes)
                                    }
                                    "compressedSizeBytes" => {
                                        Ok(__FieldTag::__compressed_size_bytes)
                                    }
                                    "compressed_size_bytes" => {
                                        Ok(__FieldTag::__compressed_size_bytes)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MessageEvent;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MessageEvent")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map
                                        .next_value::<std::option::Option<
                                            crate::model::span::time_event::message_event::Type,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__id => {
                                    if !fields.insert(__FieldTag::__id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for id"),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__uncompressed_size_bytes => {
                                    if !fields.insert(__FieldTag::__uncompressed_size_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for uncompressed_size_bytes",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.uncompressed_size_bytes =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__compressed_size_bytes => {
                                    if !fields.insert(__FieldTag::__compressed_size_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for compressed_size_bytes",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.compressed_size_bytes =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MessageEvent {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.r#type) {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !wkt::internal::is_default(&self.id) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("id", &__With(&self.id))?;
                }
                if !wkt::internal::is_default(&self.uncompressed_size_bytes) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "uncompressedSizeBytes",
                        &__With(&self.uncompressed_size_bytes),
                    )?;
                }
                if !wkt::internal::is_default(&self.compressed_size_bytes) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "compressedSizeBytes",
                        &__With(&self.compressed_size_bytes),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [MessageEvent].
        pub mod message_event {
            #[allow(unused_imports)]
            use super::*;

            /// Indicates whether the message was sent or received.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// Unknown event type.
                Unspecified,
                /// Indicates a sent message.
                Sent,
                /// Indicates a received message.
                Received,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Type::value] or
                /// [Type::name].
                UnknownValue(r#type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod r#type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Type {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Sent => std::option::Option::Some(1),
                        Self::Received => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                        Self::Sent => std::option::Option::Some("SENT"),
                        Self::Received => std::option::Option::Some("RECEIVED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Type {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Type {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Sent,
                        2 => Self::Received,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Type {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "TYPE_UNSPECIFIED" => Self::Unspecified,
                        "SENT" => Self::Sent,
                        "RECEIVED" => Self::Received,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Type {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Sent => serializer.serialize_i32(1),
                        Self::Received => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Type {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                        ".google.devtools.cloudtrace.v2.Span.TimeEvent.MessageEvent.Type",
                    ))
                }
            }
        }

        /// A `TimeEvent` can contain either an `Annotation` object or a
        /// `MessageEvent` object, but not both.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// Text annotation with a set of attributes.
            Annotation(std::boxed::Box<crate::model::span::time_event::Annotation>),
            /// An event describing a message sent/received between Spans.
            MessageEvent(std::boxed::Box<crate::model::span::time_event::MessageEvent>),
        }
    }

    /// A collection of `TimeEvent`s. A `TimeEvent` is a time-stamped annotation
    /// on the span, consisting of either user-supplied key:value pairs, or
    /// details of a message sent/received between Spans.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeEvents {
        /// A collection of `TimeEvent`s.
        pub time_event: std::vec::Vec<crate::model::span::TimeEvent>,

        /// The number of dropped annotations in all the included time events.
        /// If the value is 0, then no annotations were dropped.
        pub dropped_annotations_count: i32,

        /// The number of dropped message events in all the included time events.
        /// If the value is 0, then no message events were dropped.
        pub dropped_message_events_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeEvents {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_event][crate::model::span::TimeEvents::time_event].
        pub fn set_time_event<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::span::TimeEvent>,
        {
            use std::iter::Iterator;
            self.time_event = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dropped_annotations_count][crate::model::span::TimeEvents::dropped_annotations_count].
        pub fn set_dropped_annotations_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_annotations_count = v.into();
            self
        }

        /// Sets the value of [dropped_message_events_count][crate::model::span::TimeEvents::dropped_message_events_count].
        pub fn set_dropped_message_events_count<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.dropped_message_events_count = v.into();
            self
        }
    }

    impl wkt::message::Message for TimeEvents {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.TimeEvents"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeEvents {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_event,
                __dropped_annotations_count,
                __dropped_message_events_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeEvents")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeEvent" => Ok(__FieldTag::__time_event),
                                "time_event" => Ok(__FieldTag::__time_event),
                                "droppedAnnotationsCount" => {
                                    Ok(__FieldTag::__dropped_annotations_count)
                                }
                                "dropped_annotations_count" => {
                                    Ok(__FieldTag::__dropped_annotations_count)
                                }
                                "droppedMessageEventsCount" => {
                                    Ok(__FieldTag::__dropped_message_events_count)
                                }
                                "dropped_message_events_count" => {
                                    Ok(__FieldTag::__dropped_message_events_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeEvents;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeEvents")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_event => {
                                if !fields.insert(__FieldTag::__time_event) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_event",
                                    ));
                                }
                                result.time_event = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::span::TimeEvent>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dropped_annotations_count => {
                                if !fields.insert(__FieldTag::__dropped_annotations_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dropped_annotations_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.dropped_annotations_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__dropped_message_events_count => {
                                if !fields.insert(__FieldTag::__dropped_message_events_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dropped_message_events_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.dropped_message_events_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeEvents {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.time_event.is_empty() {
                state.serialize_entry("timeEvent", &self.time_event)?;
            }
            if !wkt::internal::is_default(&self.dropped_annotations_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "droppedAnnotationsCount",
                    &__With(&self.dropped_annotations_count),
                )?;
            }
            if !wkt::internal::is_default(&self.dropped_message_events_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "droppedMessageEventsCount",
                    &__With(&self.dropped_message_events_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A pointer from the current span to another span in the same trace or in a
    /// different trace. For example, this can be used in batching operations,
    /// where a single batch handler processes multiple requests from different
    /// traces or when the handler receives a request from a different project.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Link {
        /// The `[TRACE_ID]` for a trace within a project.
        pub trace_id: std::string::String,

        /// The `[SPAN_ID]` for a span within a trace.
        pub span_id: std::string::String,

        /// The relationship of the current span relative to the linked span.
        pub r#type: crate::model::span::link::Type,

        /// A set of attributes on the link. Up to 32 attributes can be
        /// specified per link.
        pub attributes: std::option::Option<crate::model::span::Attributes>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Link {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trace_id][crate::model::span::Link::trace_id].
        pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trace_id = v.into();
            self
        }

        /// Sets the value of [span_id][crate::model::span::Link::span_id].
        pub fn set_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.span_id = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::span::Link::type].
        pub fn set_type<T: std::convert::Into<crate::model::span::link::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [attributes][crate::model::span::Link::attributes].
        pub fn set_attributes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::span::Attributes>,
        {
            self.attributes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [attributes][crate::model::span::Link::attributes].
        pub fn set_or_clear_attributes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::span::Attributes>,
        {
            self.attributes = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Link {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.Link"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Link {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __trace_id,
                __span_id,
                __type,
                __attributes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Link")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "traceId" => Ok(__FieldTag::__trace_id),
                                "trace_id" => Ok(__FieldTag::__trace_id),
                                "spanId" => Ok(__FieldTag::__span_id),
                                "span_id" => Ok(__FieldTag::__span_id),
                                "type" => Ok(__FieldTag::__type),
                                "attributes" => Ok(__FieldTag::__attributes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Link;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Link")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__trace_id => {
                                if !fields.insert(__FieldTag::__trace_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for trace_id",
                                    ));
                                }
                                result.trace_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__span_id => {
                                if !fields.insert(__FieldTag::__span_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for span_id",
                                    ));
                                }
                                result.span_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map.next_value::<std::option::Option<crate::model::span::link::Type>>()?.unwrap_or_default();
                            }
                            __FieldTag::__attributes => {
                                if !fields.insert(__FieldTag::__attributes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attributes",
                                    ));
                                }
                                result.attributes = map.next_value::<std::option::Option<crate::model::span::Attributes>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Link {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.trace_id.is_empty() {
                state.serialize_entry("traceId", &self.trace_id)?;
            }
            if !self.span_id.is_empty() {
                state.serialize_entry("spanId", &self.span_id)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if self.attributes.is_some() {
                state.serialize_entry("attributes", &self.attributes)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Link].
    pub mod link {
        #[allow(unused_imports)]
        use super::*;

        /// The relationship of the current span relative to the linked span: child,
        /// parent, or unspecified.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// The relationship of the two spans is unknown.
            Unspecified,
            /// The linked span is a child of the current span.
            ChildLinkedSpan,
            /// The linked span is a parent of the current span.
            ParentLinkedSpan,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ChildLinkedSpan => std::option::Option::Some(1),
                    Self::ParentLinkedSpan => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::ChildLinkedSpan => std::option::Option::Some("CHILD_LINKED_SPAN"),
                    Self::ParentLinkedSpan => std::option::Option::Some("PARENT_LINKED_SPAN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ChildLinkedSpan,
                    2 => Self::ParentLinkedSpan,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "CHILD_LINKED_SPAN" => Self::ChildLinkedSpan,
                    "PARENT_LINKED_SPAN" => Self::ParentLinkedSpan,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ChildLinkedSpan => serializer.serialize_i32(1),
                    Self::ParentLinkedSpan => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.devtools.cloudtrace.v2.Span.Link.Type",
                ))
            }
        }
    }

    /// A collection of links, which are references from this span to a span
    /// in the same or different trace.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Links {
        /// A collection of links.
        pub link: std::vec::Vec<crate::model::span::Link>,

        /// The number of dropped links after the maximum size was enforced. If
        /// this value is 0, then no links were dropped.
        pub dropped_links_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Links {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [link][crate::model::span::Links::link].
        pub fn set_link<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::span::Link>,
        {
            use std::iter::Iterator;
            self.link = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dropped_links_count][crate::model::span::Links::dropped_links_count].
        pub fn set_dropped_links_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_links_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Links {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.Span.Links"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Links {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __link,
                __dropped_links_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Links")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "link" => Ok(__FieldTag::__link),
                                "droppedLinksCount" => Ok(__FieldTag::__dropped_links_count),
                                "dropped_links_count" => Ok(__FieldTag::__dropped_links_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Links;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Links")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__link => {
                                if !fields.insert(__FieldTag::__link) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for link",
                                    ));
                                }
                                result.link =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::span::Link>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dropped_links_count => {
                                if !fields.insert(__FieldTag::__dropped_links_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dropped_links_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.dropped_links_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Links {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.link.is_empty() {
                state.serialize_entry("link", &self.link)?;
            }
            if !wkt::internal::is_default(&self.dropped_links_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("droppedLinksCount", &__With(&self.dropped_links_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Type of span. Can be used to specify additional relationships between spans
    /// in addition to a parent/child relationship.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SpanKind {
        /// Unspecified. Do NOT use as default.
        /// Implementations MAY assume SpanKind.INTERNAL to be default.
        Unspecified,
        /// Indicates that the span is used internally. Default value.
        Internal,
        /// Indicates that the span covers server-side handling of an RPC or other
        /// remote network request.
        Server,
        /// Indicates that the span covers the client-side wrapper around an RPC or
        /// other remote request.
        Client,
        /// Indicates that the span describes producer sending a message to a broker.
        /// Unlike client and  server, there is no direct critical path latency
        /// relationship between producer and consumer spans (e.g. publishing a
        /// message to a pubsub service).
        Producer,
        /// Indicates that the span describes consumer receiving a message from a
        /// broker. Unlike client and  server, there is no direct critical path
        /// latency relationship between producer and consumer spans (e.g. receiving
        /// a message from a pubsub service subscription).
        Consumer,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SpanKind::value] or
        /// [SpanKind::name].
        UnknownValue(span_kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod span_kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SpanKind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Internal => std::option::Option::Some(1),
                Self::Server => std::option::Option::Some(2),
                Self::Client => std::option::Option::Some(3),
                Self::Producer => std::option::Option::Some(4),
                Self::Consumer => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SPAN_KIND_UNSPECIFIED"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::Server => std::option::Option::Some("SERVER"),
                Self::Client => std::option::Option::Some("CLIENT"),
                Self::Producer => std::option::Option::Some("PRODUCER"),
                Self::Consumer => std::option::Option::Some("CONSUMER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SpanKind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SpanKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SpanKind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Internal,
                2 => Self::Server,
                3 => Self::Client,
                4 => Self::Producer,
                5 => Self::Consumer,
                _ => Self::UnknownValue(span_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SpanKind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SPAN_KIND_UNSPECIFIED" => Self::Unspecified,
                "INTERNAL" => Self::Internal,
                "SERVER" => Self::Server,
                "CLIENT" => Self::Client,
                "PRODUCER" => Self::Producer,
                "CONSUMER" => Self::Consumer,
                _ => Self::UnknownValue(span_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SpanKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Internal => serializer.serialize_i32(1),
                Self::Server => serializer.serialize_i32(2),
                Self::Client => serializer.serialize_i32(3),
                Self::Producer => serializer.serialize_i32(4),
                Self::Consumer => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SpanKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SpanKind>::new(
                ".google.devtools.cloudtrace.v2.Span.SpanKind",
            ))
        }
    }
}

/// The allowed types for `[VALUE]` in a `[KEY]:[VALUE]` attribute.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttributeValue {
    /// The type of the value.
    pub value: std::option::Option<crate::model::attribute_value::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributeValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AttributeValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::attribute_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::AttributeValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TruncatableString>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<
        T: std::convert::Into<std::boxed::Box<crate::model::TruncatableString>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_value::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::AttributeValue::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_value::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValue::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_value::Value::IntValue(v.into()));
        self
    }

    /// The value of [value][crate::model::AttributeValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::attribute_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::AttributeValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::attribute_value::Value::BoolValue(v.into()));
        self
    }
}

impl wkt::message::Message for AttributeValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.AttributeValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttributeValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_value,
            __int_value,
            __bool_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributeValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "intValue" => Ok(__FieldTag::__int_value),
                            "int_value" => Ok(__FieldTag::__int_value),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttributeValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributeValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.AttributeValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_value::Value::StringValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TruncatableString>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int_value => {
                            if !fields.insert(__FieldTag::__int_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.AttributeValue.int_value, latest field was intValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_value::Value::IntValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.AttributeValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_value::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttributeValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.int_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("intValue", &__With(value))?;
        }
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AttributeValue].
pub mod attribute_value {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the value.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A string up to 256 bytes long.
        StringValue(std::boxed::Box<crate::model::TruncatableString>),
        /// A 64-bit signed integer.
        IntValue(i64),
        /// A Boolean value represented by `true` or `false`.
        BoolValue(bool),
    }
}

/// A call stack appearing in a trace.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StackTrace {
    /// Stack frames in this stack trace. A maximum of 128 frames are allowed.
    pub stack_frames: std::option::Option<crate::model::stack_trace::StackFrames>,

    /// The hash ID is used to conserve network bandwidth for duplicate
    /// stack traces within a single trace.
    ///
    /// Often multiple spans will have identical stack traces.
    /// The first occurrence of a stack trace should contain both the
    /// `stackFrame` content and a value in `stackTraceHashId`.
    ///
    /// Subsequent spans within the same request can refer
    /// to that stack trace by only setting `stackTraceHashId`.
    pub stack_trace_hash_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StackTrace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stack_frames][crate::model::StackTrace::stack_frames].
    pub fn set_stack_frames<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::stack_trace::StackFrames>,
    {
        self.stack_frames = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stack_frames][crate::model::StackTrace::stack_frames].
    pub fn set_or_clear_stack_frames<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::stack_trace::StackFrames>,
    {
        self.stack_frames = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stack_trace_hash_id][crate::model::StackTrace::stack_trace_hash_id].
    pub fn set_stack_trace_hash_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.stack_trace_hash_id = v.into();
        self
    }
}

impl wkt::message::Message for StackTrace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.StackTrace"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StackTrace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stack_frames,
            __stack_trace_hash_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StackTrace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stackFrames" => Ok(__FieldTag::__stack_frames),
                            "stack_frames" => Ok(__FieldTag::__stack_frames),
                            "stackTraceHashId" => Ok(__FieldTag::__stack_trace_hash_id),
                            "stack_trace_hash_id" => Ok(__FieldTag::__stack_trace_hash_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StackTrace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StackTrace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stack_frames => {
                            if !fields.insert(__FieldTag::__stack_frames) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_frames",
                                ));
                            }
                            result.stack_frames = map.next_value::<std::option::Option<crate::model::stack_trace::StackFrames>>()?
                                ;
                        }
                        __FieldTag::__stack_trace_hash_id => {
                            if !fields.insert(__FieldTag::__stack_trace_hash_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_trace_hash_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stack_trace_hash_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StackTrace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.stack_frames.is_some() {
            state.serialize_entry("stackFrames", &self.stack_frames)?;
        }
        if !wkt::internal::is_default(&self.stack_trace_hash_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("stackTraceHashId", &__With(&self.stack_trace_hash_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StackTrace].
pub mod stack_trace {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a single stack frame in a stack trace.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StackFrame {
        /// The fully-qualified name that uniquely identifies the function or
        /// method that is active in this frame (up to 1024 bytes).
        pub function_name: std::option::Option<crate::model::TruncatableString>,

        /// An un-mangled function name, if `function_name` is mangled.
        /// To get information about name mangling, run
        /// [this search](https://www.google.com/search?q=cxx+name+mangling).
        /// The name can be fully-qualified (up to 1024 bytes).
        pub original_function_name: std::option::Option<crate::model::TruncatableString>,

        /// The name of the source file where the function call appears (up to 256
        /// bytes).
        pub file_name: std::option::Option<crate::model::TruncatableString>,

        /// The line number in `file_name` where the function call appears.
        pub line_number: i64,

        /// The column number where the function call appears, if available.
        /// This is important in JavaScript because of its anonymous functions.
        pub column_number: i64,

        /// The binary module from where the code was loaded.
        pub load_module: std::option::Option<crate::model::Module>,

        /// The version of the deployed source code (up to 128 bytes).
        pub source_version: std::option::Option<crate::model::TruncatableString>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StackFrame {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [function_name][crate::model::stack_trace::StackFrame::function_name].
        pub fn set_function_name<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.function_name = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [function_name][crate::model::stack_trace::StackFrame::function_name].
        pub fn set_or_clear_function_name<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.function_name = v.map(|x| x.into());
            self
        }

        /// Sets the value of [original_function_name][crate::model::stack_trace::StackFrame::original_function_name].
        pub fn set_original_function_name<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.original_function_name = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [original_function_name][crate::model::stack_trace::StackFrame::original_function_name].
        pub fn set_or_clear_original_function_name<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.original_function_name = v.map(|x| x.into());
            self
        }

        /// Sets the value of [file_name][crate::model::stack_trace::StackFrame::file_name].
        pub fn set_file_name<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.file_name = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [file_name][crate::model::stack_trace::StackFrame::file_name].
        pub fn set_or_clear_file_name<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.file_name = v.map(|x| x.into());
            self
        }

        /// Sets the value of [line_number][crate::model::stack_trace::StackFrame::line_number].
        pub fn set_line_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.line_number = v.into();
            self
        }

        /// Sets the value of [column_number][crate::model::stack_trace::StackFrame::column_number].
        pub fn set_column_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.column_number = v.into();
            self
        }

        /// Sets the value of [load_module][crate::model::stack_trace::StackFrame::load_module].
        pub fn set_load_module<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Module>,
        {
            self.load_module = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [load_module][crate::model::stack_trace::StackFrame::load_module].
        pub fn set_or_clear_load_module<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Module>,
        {
            self.load_module = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source_version][crate::model::stack_trace::StackFrame::source_version].
        pub fn set_source_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.source_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_version][crate::model::stack_trace::StackFrame::source_version].
        pub fn set_or_clear_source_version<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TruncatableString>,
        {
            self.source_version = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for StackFrame {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.StackTrace.StackFrame"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StackFrame {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __function_name,
                __original_function_name,
                __file_name,
                __line_number,
                __column_number,
                __load_module,
                __source_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StackFrame")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "functionName" => Ok(__FieldTag::__function_name),
                                "function_name" => Ok(__FieldTag::__function_name),
                                "originalFunctionName" => Ok(__FieldTag::__original_function_name),
                                "original_function_name" => {
                                    Ok(__FieldTag::__original_function_name)
                                }
                                "fileName" => Ok(__FieldTag::__file_name),
                                "file_name" => Ok(__FieldTag::__file_name),
                                "lineNumber" => Ok(__FieldTag::__line_number),
                                "line_number" => Ok(__FieldTag::__line_number),
                                "columnNumber" => Ok(__FieldTag::__column_number),
                                "column_number" => Ok(__FieldTag::__column_number),
                                "loadModule" => Ok(__FieldTag::__load_module),
                                "load_module" => Ok(__FieldTag::__load_module),
                                "sourceVersion" => Ok(__FieldTag::__source_version),
                                "source_version" => Ok(__FieldTag::__source_version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StackFrame;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StackFrame")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__function_name => {
                                if !fields.insert(__FieldTag::__function_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for function_name",
                                    ));
                                }
                                result.function_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                    ;
                            }
                            __FieldTag::__original_function_name => {
                                if !fields.insert(__FieldTag::__original_function_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for original_function_name",
                                    ));
                                }
                                result.original_function_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                    ;
                            }
                            __FieldTag::__file_name => {
                                if !fields.insert(__FieldTag::__file_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_name",
                                    ));
                                }
                                result.file_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                    ;
                            }
                            __FieldTag::__line_number => {
                                if !fields.insert(__FieldTag::__line_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for line_number",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.line_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__column_number => {
                                if !fields.insert(__FieldTag::__column_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column_number",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.column_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__load_module => {
                                if !fields.insert(__FieldTag::__load_module) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for load_module",
                                    ));
                                }
                                result.load_module =
                                    map.next_value::<std::option::Option<crate::model::Module>>()?;
                            }
                            __FieldTag::__source_version => {
                                if !fields.insert(__FieldTag::__source_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_version",
                                    ));
                                }
                                result.source_version = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StackFrame {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.function_name.is_some() {
                state.serialize_entry("functionName", &self.function_name)?;
            }
            if self.original_function_name.is_some() {
                state.serialize_entry("originalFunctionName", &self.original_function_name)?;
            }
            if self.file_name.is_some() {
                state.serialize_entry("fileName", &self.file_name)?;
            }
            if !wkt::internal::is_default(&self.line_number) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("lineNumber", &__With(&self.line_number))?;
            }
            if !wkt::internal::is_default(&self.column_number) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("columnNumber", &__With(&self.column_number))?;
            }
            if self.load_module.is_some() {
                state.serialize_entry("loadModule", &self.load_module)?;
            }
            if self.source_version.is_some() {
                state.serialize_entry("sourceVersion", &self.source_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A collection of stack frames, which can be truncated.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StackFrames {
        /// Stack frames in this call stack.
        pub frame: std::vec::Vec<crate::model::stack_trace::StackFrame>,

        /// The number of stack frames that were dropped because there
        /// were too many stack frames.
        /// If this value is 0, then no stack frames were dropped.
        pub dropped_frames_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StackFrames {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [frame][crate::model::stack_trace::StackFrames::frame].
        pub fn set_frame<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::stack_trace::StackFrame>,
        {
            use std::iter::Iterator;
            self.frame = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dropped_frames_count][crate::model::stack_trace::StackFrames::dropped_frames_count].
        pub fn set_dropped_frames_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dropped_frames_count = v.into();
            self
        }
    }

    impl wkt::message::Message for StackFrames {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudtrace.v2.StackTrace.StackFrames"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StackFrames {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __frame,
                __dropped_frames_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StackFrames")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "frame" => Ok(__FieldTag::__frame),
                                "droppedFramesCount" => Ok(__FieldTag::__dropped_frames_count),
                                "dropped_frames_count" => Ok(__FieldTag::__dropped_frames_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StackFrames;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StackFrames")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__frame => {
                                if !fields.insert(__FieldTag::__frame) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for frame",
                                    ));
                                }
                                result.frame = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::stack_trace::StackFrame>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dropped_frames_count => {
                                if !fields.insert(__FieldTag::__dropped_frames_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dropped_frames_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.dropped_frames_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StackFrames {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.frame.is_empty() {
                state.serialize_entry("frame", &self.frame)?;
            }
            if !wkt::internal::is_default(&self.dropped_frames_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("droppedFramesCount", &__With(&self.dropped_frames_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Binary module.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Module {
    /// For example: main binary, kernel modules, and dynamic libraries
    /// such as libc.so, sharedlib.so (up to 256 bytes).
    pub module: std::option::Option<crate::model::TruncatableString>,

    /// A unique identifier for the module, usually a hash of its
    /// contents (up to 128 bytes).
    pub build_id: std::option::Option<crate::model::TruncatableString>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Module {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [module][crate::model::Module::module].
    pub fn set_module<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TruncatableString>,
    {
        self.module = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [module][crate::model::Module::module].
    pub fn set_or_clear_module<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TruncatableString>,
    {
        self.module = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_id][crate::model::Module::build_id].
    pub fn set_build_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TruncatableString>,
    {
        self.build_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_id][crate::model::Module::build_id].
    pub fn set_or_clear_build_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TruncatableString>,
    {
        self.build_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Module {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.Module"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Module {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __module,
            __build_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Module")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "module" => Ok(__FieldTag::__module),
                            "buildId" => Ok(__FieldTag::__build_id),
                            "build_id" => Ok(__FieldTag::__build_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Module;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Module")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__module => {
                            if !fields.insert(__FieldTag::__module) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for module",
                                ));
                            }
                            result.module = map
                                .next_value::<std::option::Option<crate::model::TruncatableString>>(
                                )?;
                        }
                        __FieldTag::__build_id => {
                            if !fields.insert(__FieldTag::__build_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_id",
                                ));
                            }
                            result.build_id = map
                                .next_value::<std::option::Option<crate::model::TruncatableString>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Module {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.module.is_some() {
            state.serialize_entry("module", &self.module)?;
        }
        if self.build_id.is_some() {
            state.serialize_entry("buildId", &self.build_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a string that might be shortened to a specified length.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TruncatableString {
    /// The shortened string. For example, if the original string is 500
    /// bytes long and the limit of the string is 128 bytes, then
    /// `value` contains the first 128 bytes of the 500-byte string.
    ///
    /// Truncation always happens on a UTF8 character boundary. If there
    /// are multi-byte characters in the string, then the length of the
    /// shortened string might be less than the size limit.
    pub value: std::string::String,

    /// The number of bytes removed from the original string. If this
    /// value is 0, then the string was not shortened.
    pub truncated_byte_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TruncatableString {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TruncatableString::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [truncated_byte_count][crate::model::TruncatableString::truncated_byte_count].
    pub fn set_truncated_byte_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.truncated_byte_count = v.into();
        self
    }
}

impl wkt::message::Message for TruncatableString {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.TruncatableString"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TruncatableString {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __truncated_byte_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TruncatableString")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "truncatedByteCount" => Ok(__FieldTag::__truncated_byte_count),
                            "truncated_byte_count" => Ok(__FieldTag::__truncated_byte_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TruncatableString;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TruncatableString")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__truncated_byte_count => {
                            if !fields.insert(__FieldTag::__truncated_byte_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for truncated_byte_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.truncated_byte_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TruncatableString {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.truncated_byte_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("truncatedByteCount", &__With(&self.truncated_byte_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the `BatchWriteSpans` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchWriteSpansRequest {
    /// Required. The name of the project where the spans belong. The format is
    /// `projects/[PROJECT_ID]`.
    pub name: std::string::String,

    /// Required. A list of new spans. The span names must not match existing
    /// spans, otherwise the results are undefined.
    pub spans: std::vec::Vec<crate::model::Span>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchWriteSpansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchWriteSpansRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [spans][crate::model::BatchWriteSpansRequest::spans].
    pub fn set_spans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Span>,
    {
        use std::iter::Iterator;
        self.spans = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchWriteSpansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v2.BatchWriteSpansRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchWriteSpansRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __spans,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchWriteSpansRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "spans" => Ok(__FieldTag::__spans),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchWriteSpansRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchWriteSpansRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spans => {
                            if !fields.insert(__FieldTag::__spans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spans",
                                ));
                            }
                            result.spans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Span>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchWriteSpansRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.spans.is_empty() {
            state.serialize_entry("spans", &self.spans)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
