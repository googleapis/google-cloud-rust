// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Span {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __span_id,
            __parent_span_id,
            __display_name,
            __start_time,
            __end_time,
            __attributes,
            __stack_trace,
            __time_events,
            __links,
            __status,
            __same_process_as_parent_span,
            __child_span_count,
            __span_kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Span")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "spanId" => Ok(__FieldTag::__span_id),
                            "span_id" => Ok(__FieldTag::__span_id),
                            "parentSpanId" => Ok(__FieldTag::__parent_span_id),
                            "parent_span_id" => Ok(__FieldTag::__parent_span_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "stackTrace" => Ok(__FieldTag::__stack_trace),
                            "stack_trace" => Ok(__FieldTag::__stack_trace),
                            "timeEvents" => Ok(__FieldTag::__time_events),
                            "time_events" => Ok(__FieldTag::__time_events),
                            "links" => Ok(__FieldTag::__links),
                            "status" => Ok(__FieldTag::__status),
                            "sameProcessAsParentSpan" => Ok(__FieldTag::__same_process_as_parent_span),
                            "same_process_as_parent_span" => Ok(__FieldTag::__same_process_as_parent_span),
                            "childSpanCount" => Ok(__FieldTag::__child_span_count),
                            "child_span_count" => Ok(__FieldTag::__child_span_count),
                            "spanKind" => Ok(__FieldTag::__span_kind),
                            "span_kind" => Ok(__FieldTag::__span_kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Span;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Span")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__span_id => {
                            if !fields.insert(__FieldTag::__span_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for span_id"));
                            }
                            result.span_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parent_span_id => {
                            if !fields.insert(__FieldTag::__parent_span_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent_span_id"));
                            }
                            result.parent_span_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start_time"));
                            }
                            result.start_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_time"));
                            }
                            result.end_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attributes"));
                            }
                            result.attributes = map.next_value::<std::option::Option<crate::model::span::Attributes>>()?
                                ;
                        },
                        __FieldTag::__stack_trace => {
                            if !fields.insert(__FieldTag::__stack_trace) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stack_trace"));
                            }
                            result.stack_trace = map.next_value::<std::option::Option<crate::model::StackTrace>>()?
                                ;
                        },
                        __FieldTag::__time_events => {
                            if !fields.insert(__FieldTag::__time_events) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time_events"));
                            }
                            result.time_events = map.next_value::<std::option::Option<crate::model::span::TimeEvents>>()?
                                ;
                        },
                        __FieldTag::__links => {
                            if !fields.insert(__FieldTag::__links) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for links"));
                            }
                            result.links = map.next_value::<std::option::Option<crate::model::span::Links>>()?
                                ;
                        },
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status"));
                            }
                            result.status = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::__same_process_as_parent_span => {
                            if !fields.insert(__FieldTag::__same_process_as_parent_span) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for same_process_as_parent_span"));
                            }
                            result.same_process_as_parent_span = map.next_value::<std::option::Option<wkt::BoolValue>>()?
                                ;
                        },
                        __FieldTag::__child_span_count => {
                            if !fields.insert(__FieldTag::__child_span_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for child_span_count"));
                            }
                            struct __With( std::option::Option<wkt::Int32Value> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.child_span_count = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__span_kind => {
                            if !fields.insert(__FieldTag::__span_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for span_kind"));
                            }
                            result.span_kind = map.next_value::<std::option::Option<crate::model::span::SpanKind>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::Attributes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute_map,
            __dropped_attributes_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Attributes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributeMap" => Ok(__FieldTag::__attribute_map),
                            "attribute_map" => Ok(__FieldTag::__attribute_map),
                            "droppedAttributesCount" => Ok(__FieldTag::__dropped_attributes_count),
                            "dropped_attributes_count" => Ok(__FieldTag::__dropped_attributes_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::Attributes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Attributes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute_map => {
                            if !fields.insert(__FieldTag::__attribute_map) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attribute_map"));
                            }
                            result.attribute_map = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::AttributeValue>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dropped_attributes_count => {
                            if !fields.insert(__FieldTag::__dropped_attributes_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dropped_attributes_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dropped_attributes_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::TimeEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time,
            __annotation,
            __message_event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "time" => Ok(__FieldTag::__time),
                            "annotation" => Ok(__FieldTag::__annotation),
                            "messageEvent" => Ok(__FieldTag::__message_event),
                            "message_event" => Ok(__FieldTag::__message_event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::TimeEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time => {
                            if !fields.insert(__FieldTag::__time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time"));
                            }
                            result.time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__annotation => {
                            if !fields.insert(__FieldTag::__annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for annotation"));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.Span.TimeEvent.annotation, latest field was annotation",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::span::time_event::Value::Annotation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::span::time_event::Annotation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__message_event => {
                            if !fields.insert(__FieldTag::__message_event) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_event"));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.Span.TimeEvent.message_event, latest field was messageEvent",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::span::time_event::Value::MessageEvent(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::span::time_event::MessageEvent>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::time_event::Annotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Annotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::time_event::Annotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Annotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attributes"));
                            }
                            result.attributes = map.next_value::<std::option::Option<crate::model::span::Attributes>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::time_event::MessageEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __id,
            __uncompressed_size_bytes,
            __compressed_size_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "id" => Ok(__FieldTag::__id),
                            "uncompressedSizeBytes" => Ok(__FieldTag::__uncompressed_size_bytes),
                            "uncompressed_size_bytes" => Ok(__FieldTag::__uncompressed_size_bytes),
                            "compressedSizeBytes" => Ok(__FieldTag::__compressed_size_bytes),
                            "compressed_size_bytes" => Ok(__FieldTag::__compressed_size_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::time_event::MessageEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::span::time_event::message_event::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for id"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__uncompressed_size_bytes => {
                            if !fields.insert(__FieldTag::__uncompressed_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uncompressed_size_bytes"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.uncompressed_size_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__compressed_size_bytes => {
                            if !fields.insert(__FieldTag::__compressed_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for compressed_size_bytes"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compressed_size_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::TimeEvents {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_event,
            __dropped_annotations_count,
            __dropped_message_events_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeEvents")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeEvent" => Ok(__FieldTag::__time_event),
                            "time_event" => Ok(__FieldTag::__time_event),
                            "droppedAnnotationsCount" => Ok(__FieldTag::__dropped_annotations_count),
                            "dropped_annotations_count" => Ok(__FieldTag::__dropped_annotations_count),
                            "droppedMessageEventsCount" => Ok(__FieldTag::__dropped_message_events_count),
                            "dropped_message_events_count" => Ok(__FieldTag::__dropped_message_events_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::TimeEvents;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeEvents")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_event => {
                            if !fields.insert(__FieldTag::__time_event) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time_event"));
                            }
                            result.time_event = map.next_value::<std::option::Option<std::vec::Vec<crate::model::span::TimeEvent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dropped_annotations_count => {
                            if !fields.insert(__FieldTag::__dropped_annotations_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dropped_annotations_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dropped_annotations_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__dropped_message_events_count => {
                            if !fields.insert(__FieldTag::__dropped_message_events_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dropped_message_events_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dropped_message_events_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::Link {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __trace_id,
            __span_id,
            __type,
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Link")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "traceId" => Ok(__FieldTag::__trace_id),
                            "trace_id" => Ok(__FieldTag::__trace_id),
                            "spanId" => Ok(__FieldTag::__span_id),
                            "span_id" => Ok(__FieldTag::__span_id),
                            "type" => Ok(__FieldTag::__type),
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::Link;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Link")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__trace_id => {
                            if !fields.insert(__FieldTag::__trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for trace_id"));
                            }
                            result.trace_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__span_id => {
                            if !fields.insert(__FieldTag::__span_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for span_id"));
                            }
                            result.span_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::span::link::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attributes"));
                            }
                            result.attributes = map.next_value::<std::option::Option<crate::model::span::Attributes>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::span::Links {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __link,
            __dropped_links_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Links")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "link" => Ok(__FieldTag::__link),
                            "droppedLinksCount" => Ok(__FieldTag::__dropped_links_count),
                            "dropped_links_count" => Ok(__FieldTag::__dropped_links_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::span::Links;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Links")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__link => {
                            if !fields.insert(__FieldTag::__link) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for link"));
                            }
                            result.link = map.next_value::<std::option::Option<std::vec::Vec<crate::model::span::Link>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dropped_links_count => {
                            if !fields.insert(__FieldTag::__dropped_links_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dropped_links_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dropped_links_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AttributeValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_value,
            __int_value,
            __bool_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributeValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "intValue" => Ok(__FieldTag::__int_value),
                            "int_value" => Ok(__FieldTag::__int_value),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AttributeValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributeValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for string_value"));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.AttributeValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_value::Value::StringValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TruncatableString>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__int_value => {
                            if !fields.insert(__FieldTag::__int_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for int_value"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.AttributeValue.int_value, latest field was intValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_value::Value::IntValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bool_value"));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.devtools.cloudtrace.v2.AttributeValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::attribute_value::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StackTrace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stack_frames,
            __stack_trace_hash_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StackTrace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stackFrames" => Ok(__FieldTag::__stack_frames),
                            "stack_frames" => Ok(__FieldTag::__stack_frames),
                            "stackTraceHashId" => Ok(__FieldTag::__stack_trace_hash_id),
                            "stack_trace_hash_id" => Ok(__FieldTag::__stack_trace_hash_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StackTrace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StackTrace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stack_frames => {
                            if !fields.insert(__FieldTag::__stack_frames) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stack_frames"));
                            }
                            result.stack_frames = map.next_value::<std::option::Option<crate::model::stack_trace::StackFrames>>()?
                                ;
                        },
                        __FieldTag::__stack_trace_hash_id => {
                            if !fields.insert(__FieldTag::__stack_trace_hash_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stack_trace_hash_id"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stack_trace_hash_id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::stack_trace::StackFrame {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __function_name,
            __original_function_name,
            __file_name,
            __line_number,
            __column_number,
            __load_module,
            __source_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StackFrame")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "functionName" => Ok(__FieldTag::__function_name),
                            "function_name" => Ok(__FieldTag::__function_name),
                            "originalFunctionName" => Ok(__FieldTag::__original_function_name),
                            "original_function_name" => Ok(__FieldTag::__original_function_name),
                            "fileName" => Ok(__FieldTag::__file_name),
                            "file_name" => Ok(__FieldTag::__file_name),
                            "lineNumber" => Ok(__FieldTag::__line_number),
                            "line_number" => Ok(__FieldTag::__line_number),
                            "columnNumber" => Ok(__FieldTag::__column_number),
                            "column_number" => Ok(__FieldTag::__column_number),
                            "loadModule" => Ok(__FieldTag::__load_module),
                            "load_module" => Ok(__FieldTag::__load_module),
                            "sourceVersion" => Ok(__FieldTag::__source_version),
                            "source_version" => Ok(__FieldTag::__source_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::stack_trace::StackFrame;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StackFrame")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__function_name => {
                            if !fields.insert(__FieldTag::__function_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for function_name"));
                            }
                            result.function_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::__original_function_name => {
                            if !fields.insert(__FieldTag::__original_function_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for original_function_name"));
                            }
                            result.original_function_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::__file_name => {
                            if !fields.insert(__FieldTag::__file_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for file_name"));
                            }
                            result.file_name = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::__line_number => {
                            if !fields.insert(__FieldTag::__line_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for line_number"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.line_number = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__column_number => {
                            if !fields.insert(__FieldTag::__column_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for column_number"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.column_number = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__load_module => {
                            if !fields.insert(__FieldTag::__load_module) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_module"));
                            }
                            result.load_module = map.next_value::<std::option::Option<crate::model::Module>>()?
                                ;
                        },
                        __FieldTag::__source_version => {
                            if !fields.insert(__FieldTag::__source_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_version"));
                            }
                            result.source_version = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::stack_trace::StackFrames {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __frame,
            __dropped_frames_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StackFrames")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "frame" => Ok(__FieldTag::__frame),
                            "droppedFramesCount" => Ok(__FieldTag::__dropped_frames_count),
                            "dropped_frames_count" => Ok(__FieldTag::__dropped_frames_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::stack_trace::StackFrames;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StackFrames")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__frame => {
                            if !fields.insert(__FieldTag::__frame) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for frame"));
                            }
                            result.frame = map.next_value::<std::option::Option<std::vec::Vec<crate::model::stack_trace::StackFrame>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dropped_frames_count => {
                            if !fields.insert(__FieldTag::__dropped_frames_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dropped_frames_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dropped_frames_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Module {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __module,
            __build_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Module")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "module" => Ok(__FieldTag::__module),
                            "buildId" => Ok(__FieldTag::__build_id),
                            "build_id" => Ok(__FieldTag::__build_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Module;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Module")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__module => {
                            if !fields.insert(__FieldTag::__module) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for module"));
                            }
                            result.module = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::__build_id => {
                            if !fields.insert(__FieldTag::__build_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for build_id"));
                            }
                            result.build_id = map.next_value::<std::option::Option<crate::model::TruncatableString>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TruncatableString {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __truncated_byte_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TruncatableString")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "truncatedByteCount" => Ok(__FieldTag::__truncated_byte_count),
                            "truncated_byte_count" => Ok(__FieldTag::__truncated_byte_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TruncatableString;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TruncatableString")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for value"));
                            }
                            result.value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__truncated_byte_count => {
                            if !fields.insert(__FieldTag::__truncated_byte_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for truncated_byte_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.truncated_byte_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchWriteSpansRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __spans,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchWriteSpansRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "spans" => Ok(__FieldTag::__spans),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchWriteSpansRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchWriteSpansRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__spans => {
                            if !fields.insert(__FieldTag::__spans) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for spans"));
                            }
                            result.spans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Span>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
