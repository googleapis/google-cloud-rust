// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A trace describes how long it takes for an application to perform an
/// operation. It consists of a set of spans, each of which represent a single
/// timed event within the operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Trace {

    /// Project ID of the Cloud project where the trace data is stored.
    pub project_id: std::string::String,

    /// Globally unique identifier for the trace. This identifier is a 128-bit
    /// numeric value formatted as a 32-byte hex string. For example,
    /// `382d4f4c6b7bb2f4a972559d9085001d`.
    pub trace_id: std::string::String,

    /// Collection of spans in the trace.
    pub spans: std::vec::Vec<crate::model::TraceSpan>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Trace::project_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::Trace;
    /// let x = Trace::new().set_project_id("example");
    /// ```
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::Trace::trace_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::Trace;
    /// let x = Trace::new().set_trace_id("example");
    /// ```
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [spans][crate::model::Trace::spans].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::Trace;
    /// use google_cloud_trace_v1::model::TraceSpan;
    /// let x = Trace::new()
    ///     .set_spans([
    ///         TraceSpan::default()/* use setters */,
    ///         TraceSpan::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_spans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TraceSpan>
    {
        use std::iter::Iterator;
        self.spans = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Trace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.Trace"
    }
}

/// List of new or updated traces.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Traces {

    /// List of traces.
    pub traces: std::vec::Vec<crate::model::Trace>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Traces {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [traces][crate::model::Traces::traces].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::Traces;
    /// use google_cloud_trace_v1::model::Trace;
    /// let x = Traces::new()
    ///     .set_traces([
    ///         Trace::default()/* use setters */,
    ///         Trace::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trace>
    {
        use std::iter::Iterator;
        self.traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Traces {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.Traces"
    }
}

/// A span represents a single timed event within a trace. Spans can be nested
/// and form a trace tree. Often, a trace contains a root span that describes the
/// end-to-end latency of an operation and, optionally, one or more subspans for
/// its suboperations. Spans do not need to be contiguous. There may be gaps
/// between spans in a trace.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TraceSpan {

    /// Identifier for the span. Must be a 64-bit integer other than 0 and
    /// unique within a trace. For example, `2205310701640571284`.
    pub span_id: u64,

    /// Distinguishes between spans generated in a particular context. For example,
    /// two spans with the same name may be distinguished using `RPC_CLIENT`
    /// and `RPC_SERVER` to identify queueing latency associated with the span.
    pub kind: crate::model::trace_span::SpanKind,

    /// Name of the span. Must be less than 128 bytes. The span name is sanitized
    /// and displayed in the Stackdriver Trace tool in the
    /// Google Cloud Platform Console.
    /// The name may be a method name or some other per-call site name.
    /// For the same executable and the same call point, a best practice is
    /// to use a consistent name, which makes it easier to correlate
    /// cross-trace spans.
    pub name: std::string::String,

    /// Start time of the span in nanoseconds from the UNIX epoch.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of the span in nanoseconds from the UNIX epoch.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. ID of the parent span, if any.
    pub parent_span_id: u64,

    /// Collection of labels associated with the span. Label keys must be less than
    /// 128 bytes. Label values must be less than 16 kilobytes (10MB for
    /// `/stacktrace` values).
    ///
    /// Some predefined label keys exist, or you may create your own. When creating
    /// your own, we recommend the following formats:
    ///
    /// * `/category/product/key` for agents of well-known products (e.g.
    ///   `/db/mongodb/read_size`).
    /// * `short_host/path/key` for domain-specific keys (e.g.
    ///   `foo.com/myproduct/bar`)
    ///
    /// Predefined labels include:
    ///
    /// * `/agent`
    /// * `/component`
    /// * `/error/message`
    /// * `/error/name`
    /// * `/http/client_city`
    /// * `/http/client_country`
    /// * `/http/client_protocol`
    /// * `/http/client_region`
    /// * `/http/host`
    /// * `/http/method`
    /// * `/http/path`
    /// * `/http/redirected_url`
    /// * `/http/request/size`
    /// * `/http/response/size`
    /// * `/http/route`
    /// * `/http/status_code`
    /// * `/http/url`
    /// * `/http/user_agent`
    /// * `/pid`
    /// * `/stacktrace`
    /// * `/tid`
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TraceSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [span_id][crate::model::TraceSpan::span_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// let x = TraceSpan::new().set_span_id(42_u32);
    /// ```
    pub fn set_span_id<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.span_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::TraceSpan::kind].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// use google_cloud_trace_v1::model::trace_span::SpanKind;
    /// let x0 = TraceSpan::new().set_kind(SpanKind::RpcServer);
    /// let x1 = TraceSpan::new().set_kind(SpanKind::RpcClient);
    /// ```
    pub fn set_kind<T: std::convert::Into<crate::model::trace_span::SpanKind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [name][crate::model::TraceSpan::name].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// let x = TraceSpan::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TraceSpan::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// use wkt::Timestamp;
    /// let x = TraceSpan::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TraceSpan::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// use wkt::Timestamp;
    /// let x = TraceSpan::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = TraceSpan::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TraceSpan::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// use wkt::Timestamp;
    /// let x = TraceSpan::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TraceSpan::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// use wkt::Timestamp;
    /// let x = TraceSpan::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = TraceSpan::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent_span_id][crate::model::TraceSpan::parent_span_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// let x = TraceSpan::new().set_parent_span_id(42_u32);
    /// ```
    pub fn set_parent_span_id<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.parent_span_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TraceSpan::labels].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::TraceSpan;
    /// let x = TraceSpan::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TraceSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.TraceSpan"
    }
}

/// Defines additional types related to [TraceSpan].
pub mod trace_span {
    #[allow(unused_imports)]
    use super::*;


    /// Type of span. Can be used to specify additional relationships between spans
    /// in addition to a parent/child relationship.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SpanKind {
        /// Unspecified.
        Unspecified,
        /// Indicates that the span covers server-side handling of an RPC or other
        /// remote network request.
        RpcServer,
        /// Indicates that the span covers the client-side wrapper around an RPC or
        /// other remote request.
        RpcClient,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SpanKind::value] or
        /// [SpanKind::name].
        UnknownValue(span_kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod span_kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SpanKind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RpcServer => std::option::Option::Some(1),
                Self::RpcClient => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SPAN_KIND_UNSPECIFIED"),
                Self::RpcServer => std::option::Option::Some("RPC_SERVER"),
                Self::RpcClient => std::option::Option::Some("RPC_CLIENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SpanKind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SpanKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SpanKind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RpcServer,
                2 => Self::RpcClient,
                _ => Self::UnknownValue(span_kind::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SpanKind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SPAN_KIND_UNSPECIFIED" => Self::Unspecified,
                "RPC_SERVER" => Self::RpcServer,
                "RPC_CLIENT" => Self::RpcClient,
                _ => Self::UnknownValue(span_kind::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SpanKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RpcServer => serializer.serialize_i32(1),
                Self::RpcClient => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SpanKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SpanKind>::new(
                ".google.devtools.cloudtrace.v1.TraceSpan.SpanKind"))
        }
    }
}

/// The request message for the `ListTraces` method. All fields are required
/// unless specified.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTracesRequest {

    /// Required. ID of the Cloud project where the trace data is stored.
    pub project_id: std::string::String,

    /// Optional. Type of data returned for traces in the list. Default is
    /// `MINIMAL`.
    pub view: crate::model::list_traces_request::ViewType,

    /// Optional. Maximum number of traces to return. If not specified or <= 0, the
    /// implementation selects a reasonable value.  The implementation may
    /// return fewer traces than the requested page size.
    pub page_size: i32,

    /// Token identifying the page of results to return. If provided, use the
    /// value of the `next_page_token` field from a previous request.
    pub page_token: std::string::String,

    /// Start of the time interval (inclusive) during which the trace data was
    /// collected from the application.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End of the time interval (inclusive) during which the trace data was
    /// collected from the application.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A filter against labels for the request.
    ///
    /// By default, searches use prefix matching. To specify exact match, prepend
    /// a plus symbol (`+`) to the search term.
    /// Multiple terms are ANDed. Syntax:
    ///
    /// * `root:NAME_PREFIX` or `NAME_PREFIX`: Return traces where any root
    ///   span starts with `NAME_PREFIX`.
    /// * `+root:NAME` or `+NAME`: Return traces where any root span's name is
    ///   exactly `NAME`.
    /// * `span:NAME_PREFIX`: Return traces where any span starts with
    ///   `NAME_PREFIX`.
    /// * `+span:NAME`: Return traces where any span's name is exactly
    ///   `NAME`.
    /// * `latency:DURATION`: Return traces whose overall latency is
    ///   greater or equal to than `DURATION`. Accepted units are nanoseconds
    ///   (`ns`), milliseconds (`ms`), and seconds (`s`). Default is `ms`. For
    ///   example, `latency:24ms` returns traces whose overall latency
    ///   is greater than or equal to 24 milliseconds.
    /// * `label:LABEL_KEY`: Return all traces containing the specified
    ///   label key (exact match, case-sensitive) regardless of the key:value
    ///   pair's value (including empty values).
    /// * `LABEL_KEY:VALUE_PREFIX`: Return all traces containing the specified
    ///   label key (exact match, case-sensitive) whose value starts with
    ///   `VALUE_PREFIX`. Both a key and a value must be specified.
    /// * `+LABEL_KEY:VALUE`: Return all traces containing a key:value pair
    ///   exactly matching the specified text. Both a key and a value must be
    ///   specified.
    /// * `method:VALUE`: Equivalent to `/http/method:VALUE`.
    /// * `url:VALUE`: Equivalent to `/http/url:VALUE`.
    pub filter: std::string::String,

    /// Optional. Field used to sort the returned traces.
    /// Can be one of the following:
    ///
    /// * `trace_id`
    /// * `name` (`name` field of root span in the trace)
    /// * `duration` (difference between `end_time` and `start_time` fields of
    ///   the root span)
    /// * `start` (`start_time` field of the root span)
    ///
    /// Descending order can be specified by appending `desc` to the sort field
    /// (for example, `name desc`).
    ///
    /// Only one sort field is permitted.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTracesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListTracesRequest::project_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// let x = ListTracesRequest::new().set_project_id("example");
    /// ```
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListTracesRequest::view].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// use google_cloud_trace_v1::model::list_traces_request::ViewType;
    /// let x0 = ListTracesRequest::new().set_view(ViewType::Minimal);
    /// let x1 = ListTracesRequest::new().set_view(ViewType::Rootspan);
    /// let x2 = ListTracesRequest::new().set_view(ViewType::Complete);
    /// ```
    pub fn set_view<T: std::convert::Into<crate::model::list_traces_request::ViewType>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTracesRequest::page_size].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// let x = ListTracesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTracesRequest::page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// let x = ListTracesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ListTracesRequest::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// use wkt::Timestamp;
    /// let x = ListTracesRequest::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ListTracesRequest::start_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// use wkt::Timestamp;
    /// let x = ListTracesRequest::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = ListTracesRequest::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ListTracesRequest::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// use wkt::Timestamp;
    /// let x = ListTracesRequest::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ListTracesRequest::end_time].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// use wkt::Timestamp;
    /// let x = ListTracesRequest::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = ListTracesRequest::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::ListTracesRequest::filter].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// let x = ListTracesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTracesRequest::order_by].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesRequest;
    /// let x = ListTracesRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTracesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.ListTracesRequest"
    }
}

/// Defines additional types related to [ListTracesRequest].
pub mod list_traces_request {
    #[allow(unused_imports)]
    use super::*;


    /// Type of data returned for traces in the list.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ViewType {
        /// Default is `MINIMAL` if unspecified.
        Unspecified,
        /// Minimal view of the trace record that contains only the project
        /// and trace IDs.
        Minimal,
        /// Root span view of the trace record that returns the root spans along
        /// with the minimal trace data.
        Rootspan,
        /// Complete view of the trace record that contains the actual trace data.
        /// This is equivalent to calling the REST `get` or RPC `GetTrace` method
        /// using the ID of each listed trace.
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ViewType::value] or
        /// [ViewType::name].
        UnknownValue(view_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod view_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ViewType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Minimal => std::option::Option::Some(1),
                Self::Rootspan => std::option::Option::Some(2),
                Self::Complete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VIEW_TYPE_UNSPECIFIED"),
                Self::Minimal => std::option::Option::Some("MINIMAL"),
                Self::Rootspan => std::option::Option::Some("ROOTSPAN"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ViewType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ViewType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ViewType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Minimal,
                2 => Self::Rootspan,
                3 => Self::Complete,
                _ => Self::UnknownValue(view_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ViewType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VIEW_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MINIMAL" => Self::Minimal,
                "ROOTSPAN" => Self::Rootspan,
                "COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(view_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ViewType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Minimal => serializer.serialize_i32(1),
                Self::Rootspan => serializer.serialize_i32(2),
                Self::Complete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ViewType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ViewType>::new(
                ".google.devtools.cloudtrace.v1.ListTracesRequest.ViewType"))
        }
    }
}

/// The response message for the `ListTraces` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTracesResponse {

    /// List of trace records as specified by the view parameter.
    pub traces: std::vec::Vec<crate::model::Trace>,

    /// If defined, indicates that there are more traces that match the request
    /// and that this value should be passed to the next request to continue
    /// retrieving additional traces.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTracesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [traces][crate::model::ListTracesResponse::traces].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesResponse;
    /// use google_cloud_trace_v1::model::Trace;
    /// let x = ListTracesResponse::new()
    ///     .set_traces([
    ///         Trace::default()/* use setters */,
    ///         Trace::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trace>
    {
        use std::iter::Iterator;
        self.traces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTracesResponse::next_page_token].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::ListTracesResponse;
    /// let x = ListTracesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTracesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.ListTracesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTracesResponse {
    type PageItem = crate::model::Trace;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.traces
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the `GetTrace` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTraceRequest {

    /// Required. ID of the Cloud project where the trace data is stored.
    pub project_id: std::string::String,

    /// Required. ID of the trace to return.
    pub trace_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTraceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetTraceRequest::project_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::GetTraceRequest;
    /// let x = GetTraceRequest::new().set_project_id("example");
    /// ```
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trace_id][crate::model::GetTraceRequest::trace_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::GetTraceRequest;
    /// let x = GetTraceRequest::new().set_trace_id("example");
    /// ```
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }
}

impl wkt::message::Message for GetTraceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.GetTraceRequest"
    }
}

/// The request message for the `PatchTraces` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchTracesRequest {

    /// Required. ID of the Cloud project where the trace data is stored.
    pub project_id: std::string::String,

    /// Required. The body of the message.
    pub traces: std::option::Option<crate::model::Traces>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchTracesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PatchTracesRequest::project_id].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::PatchTracesRequest;
    /// let x = PatchTracesRequest::new().set_project_id("example");
    /// ```
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [traces][crate::model::PatchTracesRequest::traces].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::PatchTracesRequest;
    /// use google_cloud_trace_v1::model::Traces;
    /// let x = PatchTracesRequest::new().set_traces(Traces::default()/* use setters */);
    /// ```
    pub fn set_traces<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Traces>
    {
        self.traces = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [traces][crate::model::PatchTracesRequest::traces].
    ///
    /// # Example
    /// ```ignore,no_run
    /// # use google_cloud_trace_v1::model::PatchTracesRequest;
    /// use google_cloud_trace_v1::model::Traces;
    /// let x = PatchTracesRequest::new().set_or_clear_traces(Some(Traces::default()/* use setters */));
    /// let x = PatchTracesRequest::new().set_or_clear_traces(None::<Traces>);
    /// ```
    pub fn set_or_clear_traces<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Traces>
    {
        self.traces = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PatchTracesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudtrace.v1.PatchTracesRequest"
    }
}
