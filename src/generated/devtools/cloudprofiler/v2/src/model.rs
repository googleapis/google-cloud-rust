// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// CreateProfileRequest describes a profile resource online creation request.
/// The deployment field must be populated. The profile_type specifies the list
/// of profile types supported by the agent. The creation call will hang until a
/// profile of one of these types needs to be collected.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateProfileRequest {
    /// Parent project to create the profile in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Deployment details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// One or more profile types that the agent is capable of providing.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub profile_type: std::vec::Vec<crate::model::ProfileType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::CreateProfileRequest::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }

    /// Sets the value of [profile_type][crate::model::CreateProfileRequest::profile_type].
    pub fn set_profile_type<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProfileType>,
    {
        use std::iter::Iterator;
        self.profile_type = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.CreateProfileRequest"
    }
}

/// CreateOfflineProfileRequest describes a profile resource offline creation
/// request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateOfflineProfileRequest {
    /// Parent project to create the profile in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Contents of the profile to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile: std::option::Option<crate::model::Profile>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOfflineProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOfflineProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [profile][crate::model::CreateOfflineProfileRequest::profile].
    pub fn set_profile<T: std::convert::Into<std::option::Option<crate::model::Profile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }
}

impl wkt::message::Message for CreateOfflineProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.CreateOfflineProfileRequest"
    }
}

/// UpdateProfileRequest contains the profile to update.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateProfileRequest {
    /// Profile to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile: std::option::Option<crate::model::Profile>,

    /// Field mask used to specify the fields to be overwritten. Currently only
    /// profile_bytes and labels fields are supported by UpdateProfile, so only
    /// those fields can be specified in the mask. When no mask is provided, all
    /// fields are overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profile][crate::model::UpdateProfileRequest::profile].
    pub fn set_profile<T: std::convert::Into<std::option::Option<crate::model::Profile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProfileRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.UpdateProfileRequest"
    }
}

/// Profile resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Profile {
    /// Output only. Opaque, server-assigned, unique ID for this profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Type of profile.
    /// For offline mode, this must be specified when creating the profile. For
    /// online mode it is assigned and returned by the server.
    pub profile_type: crate::model::ProfileType,

    /// Deployment this profile corresponds to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Duration of the profiling session.
    /// Input (for the offline mode) or output (for the online mode).
    /// The field represents requested profiling duration. It may slightly differ
    /// from the effective profiling duration, which is recorded in the profile
    /// data, in case the profiling can't be stopped immediately (e.g. in case
    /// stopping the profiling is handled asynchronously).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Input only. Profile bytes, as a gzip compressed serialized proto, the
    /// format is <https://github.com/google/pprof/blob/master/proto/profile.proto>.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub profile_bytes: ::bytes::Bytes,

    /// Input only. Labels associated to this specific profile. These labels will
    /// get merged with the deployment labels for the final data set. See
    /// documentation on deployment labels for validation rules and limits.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Start time for the profile.
    /// This output is only present in response from the ListProfiles method.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Profile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Profile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [profile_type][crate::model::Profile::profile_type].
    pub fn set_profile_type<T: std::convert::Into<crate::model::ProfileType>>(
        mut self,
        v: T,
    ) -> Self {
        self.profile_type = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::Profile::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::Profile::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [profile_bytes][crate::model::Profile::profile_bytes].
    pub fn set_profile_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.profile_bytes = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Profile::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::Profile::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }
}

impl wkt::message::Message for Profile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.Profile"
    }
}

/// Deployment contains the deployment identification information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Deployment {
    /// Project ID is the ID of a cloud project.
    /// Validation regex: `^[a-z][-a-z0-9:.]{4,61}[a-z0-9]$`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Target is the service name used to group related deployments:
    ///
    /// * Service name for App Engine Flex / Standard.
    /// * Cluster and container name for GKE.
    /// * User-specified string for direct Compute Engine profiling (e.g. Java).
    /// * Job name for Dataflow.
    ///   Validation regex: `^[a-z0-9]([-a-z0-9_.]{0,253}[a-z0-9])?$`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Labels identify the deployment within the user universe and same target.
    /// Validation regex for label names: `^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$`.
    /// Value for an individual label must be <= 512 bytes, the total
    /// size of all label names and values must be <= 1024 bytes.
    ///
    /// Label named "language" can be used to record the programming language of
    /// the profiled deployment. The standard choices for the value include "java",
    /// "go", "python", "ruby", "nodejs", "php", "dotnet".
    ///
    /// For deployments running on Google Cloud Platform, "zone" or "region" label
    /// should be present describing the deployment location. An example of a zone
    /// is "us-central1-a", an example of a region is "us-central1" or
    /// "us-central".
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Deployment::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [target][crate::model::Deployment::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Deployment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.Deployment"
    }
}

/// ListProfilesRequest contains request parameters for listing profiles for
/// deployments in projects which the user has permissions to view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProfilesRequest {
    /// Required. The parent, which owns this collection of profiles.
    /// Format: projects/{user_project_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    /// Default page_size is 1000.
    /// Max limit is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The token to continue pagination and get profiles from a particular page.
    /// When paginating, all other parameters provided to `ListProfiles` must match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.ListProfilesRequest"
    }
}

/// ListProfileResponse contains the list of collected profiles for deployments
/// in projects which the user has permissions to view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProfilesResponse {
    /// List of profiles fetched.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub profiles: std::vec::Vec<crate::model::Profile>,

    /// Token to receive the next page of results.
    /// This field maybe empty if there are no more profiles to fetch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Number of profiles that were skipped in the current page since they were
    /// not able to be fetched successfully. This should typically be zero. A
    /// non-zero value may indicate a transient failure, in which case if the
    /// number is too high for your use case, the call may be retried.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skipped_profiles: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profiles][crate::model::ListProfilesResponse::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Profile>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [skipped_profiles][crate::model::ListProfilesResponse::skipped_profiles].
    pub fn set_skipped_profiles<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.skipped_profiles = v.into();
        self
    }
}

impl wkt::message::Message for ListProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudprofiler.v2.ListProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProfilesResponse {
    type PageItem = crate::model::Profile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// ProfileType is type of profiling data.
/// NOTE: the enumeration member names are used (in lowercase) as unique string
/// identifiers of profile types, so they must not be renamed.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ProfileType {
    /// Unspecified profile type.
    Unspecified,
    /// Thread CPU time sampling.
    Cpu,
    /// Wallclock time sampling. More expensive as stops all threads.
    Wall,
    /// In-use heap profile. Represents a snapshot of the allocations that are
    /// live at the time of the profiling.
    Heap,
    /// Single-shot collection of all thread stacks.
    Threads,
    /// Synchronization contention profile.
    Contention,
    /// Peak heap profile.
    PeakHeap,
    /// Heap allocation profile. It represents the aggregation of all allocations
    /// made over the duration of the profile. All allocations are included,
    /// including those that might have been freed by the end of the profiling
    /// interval. The profile is in particular useful for garbage collecting
    /// languages to understand which parts of the code create most of the garbage
    /// collection pressure to see if those can be optimized.
    HeapAlloc,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ProfileType::value] or
    /// [ProfileType::name].
    UnknownValue(profile_type::UnknownValue),
}

#[doc(hidden)]
pub mod profile_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ProfileType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Cpu => std::option::Option::Some(1),
            Self::Wall => std::option::Option::Some(2),
            Self::Heap => std::option::Option::Some(3),
            Self::Threads => std::option::Option::Some(4),
            Self::Contention => std::option::Option::Some(5),
            Self::PeakHeap => std::option::Option::Some(6),
            Self::HeapAlloc => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PROFILE_TYPE_UNSPECIFIED"),
            Self::Cpu => std::option::Option::Some("CPU"),
            Self::Wall => std::option::Option::Some("WALL"),
            Self::Heap => std::option::Option::Some("HEAP"),
            Self::Threads => std::option::Option::Some("THREADS"),
            Self::Contention => std::option::Option::Some("CONTENTION"),
            Self::PeakHeap => std::option::Option::Some("PEAK_HEAP"),
            Self::HeapAlloc => std::option::Option::Some("HEAP_ALLOC"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ProfileType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ProfileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ProfileType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Cpu,
            2 => Self::Wall,
            3 => Self::Heap,
            4 => Self::Threads,
            5 => Self::Contention,
            6 => Self::PeakHeap,
            7 => Self::HeapAlloc,
            _ => Self::UnknownValue(profile_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ProfileType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PROFILE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "CPU" => Self::Cpu,
            "WALL" => Self::Wall,
            "HEAP" => Self::Heap,
            "THREADS" => Self::Threads,
            "CONTENTION" => Self::Contention,
            "PEAK_HEAP" => Self::PeakHeap,
            "HEAP_ALLOC" => Self::HeapAlloc,
            _ => Self::UnknownValue(profile_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ProfileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Cpu => serializer.serialize_i32(1),
            Self::Wall => serializer.serialize_i32(2),
            Self::Heap => serializer.serialize_i32(3),
            Self::Threads => serializer.serialize_i32(4),
            Self::Contention => serializer.serialize_i32(5),
            Self::PeakHeap => serializer.serialize_i32(6),
            Self::HeapAlloc => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ProfileType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProfileType>::new(
            ".google.devtools.cloudprofiler.v2.ProfileType",
        ))
    }
}
