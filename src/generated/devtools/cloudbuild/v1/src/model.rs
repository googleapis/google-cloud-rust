// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Specifies a build to retry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryBuildRequest {
    /// The name of the `Build` to retry.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Build ID of the original build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,
}

impl RetryBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetryBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RetryBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::RetryBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for RetryBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RetryBuildRequest"
    }
}

/// Specifies a build trigger to run and the source to use.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunBuildTriggerRequest {
    /// The name of the `Trigger` to run.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. ID of the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,

    /// Source to build against this trigger.
    /// Branch and tag names cannot consist of regular expressions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::RepoSource>,
}

impl RunBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RunBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::RunBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::RunBuildTriggerRequest::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::RepoSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for RunBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RunBuildTriggerRequest"
    }
}

/// Location of the source in an archive file in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageSource {
    /// Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Cloud Storage object containing the source.
    ///
    /// This object must be a zipped (`.zip`) or gzipped archive file (`.tar.gz`)
    /// containing source to build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Option to specify the tool to fetch the source file for the build.
    pub source_fetcher: crate::model::storage_source::SourceFetcher,
}

impl StorageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSource::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSource::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [source_fetcher][crate::model::StorageSource::source_fetcher].
    pub fn set_source_fetcher<
        T: std::convert::Into<crate::model::storage_source::SourceFetcher>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_fetcher = v.into();
        self
    }
}

impl wkt::message::Message for StorageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.StorageSource"
    }
}

/// Defines additional types related to StorageSource
pub mod storage_source {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the tool to fetch the source file for the build.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SourceFetcher(std::borrow::Cow<'static, str>);

    impl SourceFetcher {
        /// Creates a new SourceFetcher instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SourceFetcher](SourceFetcher)
    pub mod source_fetcher {
        use super::SourceFetcher;

        /// Unspecified. Defaults to GSUTIL.
        pub const SOURCE_FETCHER_UNSPECIFIED: SourceFetcher =
            SourceFetcher::new("SOURCE_FETCHER_UNSPECIFIED");

        /// Use the "gsutil" tool to download the source file.
        pub const GSUTIL: SourceFetcher = SourceFetcher::new("GSUTIL");

        /// Use the Cloud Storage Fetcher tool to download the source file.
        pub const GCS_FETCHER: SourceFetcher = SourceFetcher::new("GCS_FETCHER");
    }

    impl std::convert::From<std::string::String> for SourceFetcher {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Location of the source in any accessible Git repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitSource {
    /// Location of the Git repo to build.
    ///
    /// This will be used as a `git remote`, see
    /// <https://git-scm.com/docs/git-remote>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dir: std::string::String,

    /// The revision to fetch from the Git repository such as a branch, a tag, a
    /// commit SHA, or any Git ref.
    ///
    /// Cloud Build uses `git fetch` to fetch the revision from the Git
    /// repository; therefore make sure that the string you provide for `revision`
    /// is parsable  by the command. For information on string values accepted by
    /// `git fetch`, see
    /// <https://git-scm.com/docs/gitrevisions#_specifying_revisions>. For
    /// information on `git fetch`, see <https://git-scm.com/docs/git-fetch>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,
}

impl GitSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::GitSource::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::GitSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GitSource::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }
}

impl wkt::message::Message for GitSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitSource"
    }
}

/// Location of the source in a Google Cloud Source Repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepoSource {
    /// ID of the project that owns the Cloud Source Repository. If omitted, the
    /// project ID requesting the build is assumed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Name of the Cloud Source Repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repo_name: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dir: std::string::String,

    /// Only trigger a build if the revision regex does NOT match the revision
    /// regex.
    pub invert_regex: bool,

    /// Substitutions to use in a triggered build.
    /// Should only be used with RunBuildTrigger
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub revision: std::option::Option<crate::model::repo_source::Revision>,
}

impl RepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RepoSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::RepoSource::repo_name].
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::RepoSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::RepoSource::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::RepoSource::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `revision`.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::repo_source::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `BranchName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_branch_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::BranchName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `TagName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tag_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::TagName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `CommitSha`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_commit_sha(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::CommitSha(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `BranchName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_branch_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::BranchName(v.into()));
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `TagName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_tag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::TagName(v.into()));
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `CommitSha`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::CommitSha(v.into()));
        self
    }
}

impl wkt::message::Message for RepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RepoSource"
    }
}

/// Defines additional types related to RepoSource
pub mod repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Revision {
        /// Regex matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        BranchName(std::string::String),
        /// Regex matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        TagName(std::string::String),
        /// Explicit commit SHA to build.
        CommitSha(std::string::String),
    }
}

/// Location of the source manifest in Cloud Storage.
/// This feature is in Preview; see description
/// [here](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageSourceManifest {
    /// Cloud Storage bucket containing the source manifest (see [Bucket
    /// Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Cloud Storage object containing the source manifest.
    ///
    /// This object must be a JSON file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,
}

impl StorageSourceManifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSourceManifest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSourceManifest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSourceManifest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }
}

impl wkt::message::Message for StorageSourceManifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.StorageSourceManifest"
    }
}

/// Location of the source in a supported storage service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Source {
    /// Location of source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::source::Source>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `source`.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::source::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_storage_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `RepoSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_repo_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RepoSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::RepoSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_git_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GitSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::GitSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSourceManifest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_storage_source_manifest(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSourceManifest>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSourceManifest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source::Source::StorageSource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `RepoSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repo_source<T: std::convert::Into<std::boxed::Box<crate::model::RepoSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::RepoSource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git_source<T: std::convert::Into<std::boxed::Box<crate::model::GitSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::GitSource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSourceManifest`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source_manifest<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSourceManifest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::source::Source::StorageSourceManifest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Source"
    }
}

/// Defines additional types related to Source
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    /// Location of source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// If provided, get the source from this location in Cloud Storage.
        StorageSource(std::boxed::Box<crate::model::StorageSource>),
        /// If provided, get the source from this location in a Cloud Source
        /// Repository.
        RepoSource(std::boxed::Box<crate::model::RepoSource>),
        /// If provided, get the source from this Git repository.
        GitSource(std::boxed::Box<crate::model::GitSource>),
        /// If provided, get the source from this manifest in Cloud Storage.
        /// This feature is in Preview; see description
        /// [here](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher).
        StorageSourceManifest(std::boxed::Box<crate::model::StorageSourceManifest>),
    }
}

/// An image built by the pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuiltImage {
    /// Name used to push the container image to Google Container Registry, as
    /// presented to `docker push`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Docker Registry 2.0 digest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub digest: std::string::String,

    /// Output only. Stores timing information for pushing the specified image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,
}

impl BuiltImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuiltImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::BuiltImage::digest].
    pub fn set_digest<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.digest = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::BuiltImage::push_timing].
    pub fn set_push_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.push_timing = v.into();
        self
    }
}

impl wkt::message::Message for BuiltImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuiltImage"
    }
}

/// Artifact uploaded using the PythonPackage directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedPythonPackage {
    /// URI of the uploaded artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Hash types and values of the Python Artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,
}

impl UploadedPythonPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedPythonPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedPythonPackage::file_hashes].
    pub fn set_file_hashes<T: std::convert::Into<std::option::Option<crate::model::FileHashes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_hashes = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedPythonPackage::push_timing].
    pub fn set_push_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.push_timing = v.into();
        self
    }
}

impl wkt::message::Message for UploadedPythonPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedPythonPackage"
    }
}

/// A Maven artifact uploaded using the MavenArtifact directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedMavenArtifact {
    /// URI of the uploaded artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Hash types and values of the Maven Artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,
}

impl UploadedMavenArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedMavenArtifact::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedMavenArtifact::file_hashes].
    pub fn set_file_hashes<T: std::convert::Into<std::option::Option<crate::model::FileHashes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_hashes = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedMavenArtifact::push_timing].
    pub fn set_push_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.push_timing = v.into();
        self
    }
}

impl wkt::message::Message for UploadedMavenArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedMavenArtifact"
    }
}

/// A Go module artifact uploaded to Artifact Registry using the GoModule
/// directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedGoModule {
    /// URI of the uploaded artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Hash types and values of the Go Module Artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,
}

impl UploadedGoModule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedGoModule::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedGoModule::file_hashes].
    pub fn set_file_hashes<T: std::convert::Into<std::option::Option<crate::model::FileHashes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_hashes = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedGoModule::push_timing].
    pub fn set_push_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.push_timing = v.into();
        self
    }
}

impl wkt::message::Message for UploadedGoModule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedGoModule"
    }
}

/// An npm package uploaded to Artifact Registry using the NpmPackage
/// directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedNpmPackage {
    /// URI of the uploaded npm package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Hash types and values of the npm package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,
}

impl UploadedNpmPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedNpmPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedNpmPackage::file_hashes].
    pub fn set_file_hashes<T: std::convert::Into<std::option::Option<crate::model::FileHashes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_hashes = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedNpmPackage::push_timing].
    pub fn set_push_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.push_timing = v.into();
        self
    }
}

impl wkt::message::Message for UploadedNpmPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedNpmPackage"
    }
}

/// A step in the build pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildStep {
    /// Required. The name of the container image that will run this particular
    /// build step.
    ///
    /// If the image is available in the host's Docker daemon's cache, it
    /// will be run directly. If not, the host will attempt to pull the image
    /// first, using the builder service account's credentials if necessary.
    ///
    /// The Docker daemon's cache will already have the latest versions of all of
    /// the officially supported build steps
    /// ([<https://github.com/GoogleCloudPlatform/cloud-builders>](https://github.com/GoogleCloudPlatform/cloud-builders)).
    /// The Docker daemon will also have cached many of the layers for some popular
    /// images, like "ubuntu", "debian", but they will be refreshed at the time you
    /// attempt to use them.
    ///
    /// If you built an image in a previous build step, it will be stored in the
    /// host's Docker daemon's cache and is available to use as the name for a
    /// later build step.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A list of environment variable definitions to be used when running a step.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<std::string::String>,

    /// A list of arguments that will be presented to the step when it is started.
    ///
    /// If the image used to run the step's container has an entrypoint, the `args`
    /// are used as arguments to that entrypoint. If the image does not define
    /// an entrypoint, the first element in args is used as the entrypoint,
    /// and the remainder will be used as arguments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Working directory to use when running this step's container.
    ///
    /// If this value is a relative path, it is relative to the build's working
    /// directory. If this value is absolute, it may be outside the build's working
    /// directory, in which case the contents of the path may not be persisted
    /// across build step executions, unless a `volume` for that path is specified.
    ///
    /// If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
    /// which specifies an absolute path, the `RepoSource` `dir` is ignored for
    /// the step's execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dir: std::string::String,

    /// Unique identifier for this build step, used in `wait_for` to
    /// reference this build step as a dependency.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in `wait_for`
    /// have completed successfully. If `wait_for` is empty, this build step will
    /// start when all previous build steps in the `Build.Steps` list have
    /// completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub wait_for: std::vec::Vec<std::string::String>,

    /// Entrypoint to be used instead of the build step image's default entrypoint.
    /// If unset, the image's default entrypoint is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entrypoint: std::string::String,

    /// A list of environment variables which are encrypted using a Cloud Key
    /// Management Service crypto key. These values must be specified in the
    /// build's `Secret`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secret_env: std::vec::Vec<std::string::String>,

    /// List of volumes to mount into the build step.
    ///
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents are
    /// discarded.
    ///
    /// Using a named volume in only one step is not valid as it is indicative
    /// of a build request with an incorrect configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Output only. Stores timing information for executing this build step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timing: std::option::Option<crate::model::TimeSpan>,

    /// Output only. Stores timing information for pulling this build step's
    /// builder image only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pull_timing: std::option::Option<crate::model::TimeSpan>,

    /// Time limit for executing this build step. If not defined, the step has no
    /// time limit and will be allowed to continue to run until either it completes
    /// or the build itself times out.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Output only. Status of the build step. At this time, build step status is
    /// only updated on build completion; step status is not updated in real-time
    /// as the build progresses.
    pub status: crate::model::build::Status,

    /// Allow this build step to fail without failing the entire build.
    ///
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failure_detail field.
    pub allow_failure: bool,

    /// Output only. Return code from running the step.
    pub exit_code: i32,

    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes. If allow_failure
    /// is also specified, this field will take precedence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allow_exit_codes: std::vec::Vec<i32>,

    /// A shell script to be executed in the step.
    ///
    /// When script is provided, the user cannot specify the entrypoint or args.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,

    /// Option to include built-in and custom substitutions as env variables
    /// for this build step. This option will override the global option
    /// in BuildOption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automap_substitutions: std::option::Option<bool>,
}

impl BuildStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuildStep::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::BuildStep::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BuildStep::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [entrypoint][crate::model::BuildStep::entrypoint].
    pub fn set_entrypoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entrypoint = v.into();
        self
    }

    /// Sets the value of [timing][crate::model::BuildStep::timing].
    pub fn set_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timing = v.into();
        self
    }

    /// Sets the value of [pull_timing][crate::model::BuildStep::pull_timing].
    pub fn set_pull_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pull_timing = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::BuildStep::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [status][crate::model::BuildStep::status].
    pub fn set_status<T: std::convert::Into<crate::model::build::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [allow_failure][crate::model::BuildStep::allow_failure].
    pub fn set_allow_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_failure = v.into();
        self
    }

    /// Sets the value of [exit_code][crate::model::BuildStep::exit_code].
    pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.exit_code = v.into();
        self
    }

    /// Sets the value of [script][crate::model::BuildStep::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }

    /// Sets the value of [automap_substitutions][crate::model::BuildStep::automap_substitutions].
    pub fn set_automap_substitutions<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.automap_substitutions = v.into();
        self
    }

    /// Sets the value of [env][crate::model::BuildStep::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::BuildStep::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [wait_for][crate::model::BuildStep::wait_for].
    pub fn set_wait_for<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.wait_for = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_env][crate::model::BuildStep::secret_env].
    pub fn set_secret_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::BuildStep::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_exit_codes][crate::model::BuildStep::allow_exit_codes].
    pub fn set_allow_exit_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.allow_exit_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BuildStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildStep"
    }
}

/// Volume describes a Docker container volume which is mounted into build steps
/// in order to persist files across build step execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Name of the volume to mount.
    ///
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Path at which to mount the volume.
    ///
    /// Paths must be absolute and cannot conflict with other volume paths on the
    /// same build step or with certain reserved volume paths.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Volume::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Volume"
    }
}

/// Artifacts created by the build pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Results {
    /// Container images that were built as a part of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub images: std::vec::Vec<crate::model::BuiltImage>,

    /// List of build step digests, in the order corresponding to build step
    /// indices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub build_step_images: std::vec::Vec<std::string::String>,

    /// Path to the artifact manifest for non-container artifacts uploaded to Cloud
    /// Storage. Only populated when artifacts are uploaded to Cloud Storage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_manifest: std::string::String,

    /// Number of non-container artifacts uploaded to Cloud Storage. Only populated
    /// when artifacts are uploaded to Cloud Storage.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub num_artifacts: i64,

    /// List of build step outputs, produced by builder images, in the order
    /// corresponding to build step indices.
    ///
    /// [Cloud Builders](https://cloud.google.com/cloud-build/docs/cloud-builders)
    /// can produce this output by writing to `$BUILDER_OUTPUT/output`. Only the
    /// first 50KB of data is stored. Note that the `$BUILDER_OUTPUT` variable is
    /// read-only and can't be substituted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub build_step_outputs: std::vec::Vec<bytes::Bytes>,

    /// Time to push all non-container artifacts to Cloud Storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact_timing: std::option::Option<crate::model::TimeSpan>,

    /// Python artifacts uploaded to Artifact Registry at the end of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub python_packages: std::vec::Vec<crate::model::UploadedPythonPackage>,

    /// Maven artifacts uploaded to Artifact Registry at the end of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub maven_artifacts: std::vec::Vec<crate::model::UploadedMavenArtifact>,

    /// Optional. Go module artifacts uploaded to Artifact Registry at the end of
    /// the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub go_modules: std::vec::Vec<crate::model::UploadedGoModule>,

    /// Npm packages uploaded to Artifact Registry at the end of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub npm_packages: std::vec::Vec<crate::model::UploadedNpmPackage>,
}

impl Results {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_manifest][crate::model::Results::artifact_manifest].
    pub fn set_artifact_manifest<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_manifest = v.into();
        self
    }

    /// Sets the value of [num_artifacts][crate::model::Results::num_artifacts].
    pub fn set_num_artifacts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.num_artifacts = v.into();
        self
    }

    /// Sets the value of [artifact_timing][crate::model::Results::artifact_timing].
    pub fn set_artifact_timing<
        T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_timing = v.into();
        self
    }

    /// Sets the value of [images][crate::model::Results::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuiltImage>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [build_step_images][crate::model::Results::build_step_images].
    pub fn set_build_step_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_step_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [build_step_outputs][crate::model::Results::build_step_outputs].
    pub fn set_build_step_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.build_step_outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_packages][crate::model::Results::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedPythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::Results::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedMavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [go_modules][crate::model::Results::go_modules].
    pub fn set_go_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedGoModule>,
    {
        use std::iter::Iterator;
        self.go_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [npm_packages][crate::model::Results::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedNpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Results {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Results"
    }
}

/// An artifact that was uploaded during a build. This
/// is a single record in the artifact manifest JSON file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ArtifactResult {
    /// The path of an artifact in a Cloud Storage bucket, with the
    /// generation number. For example,
    /// `gs://mybucket/path/to/output.jar#generation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The file hash of the artifact.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_hash: std::vec::Vec<crate::model::FileHashes>,
}

impl ArtifactResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ArtifactResult::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [file_hash][crate::model::ArtifactResult::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ArtifactResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ArtifactResult"
    }
}

/// A build resource in the Cloud Build API.
///
/// At a high level, a `Build` describes where to find source code, how to build
/// it (for example, the builder image to run on the source), and where to store
/// the built artifacts.
///
/// Fields can include the following variables, which will be expanded when the
/// build is created:
///
/// - $PROJECT_ID: the project ID of the build.
/// - $PROJECT_NUMBER: the project number of the build.
/// - $LOCATION: the location/region of the build.
/// - $BUILD_ID: the autogenerated ID of the build.
/// - $REPO_NAME: the source repository name specified by RepoSource.
/// - $BRANCH_NAME: the branch name specified by RepoSource.
/// - $TAG_NAME: the tag name specified by RepoSource.
/// - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or
///   resolved from the specified branch or tag.
/// - $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Build {
    /// Output only. The 'Build' name with format:
    /// `projects/{project}/locations/{location}/builds/{build}`, where {build}
    /// is a unique identifier generated by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Output only. Status of the build.
    pub status: crate::model::build::Status,

    /// Output only. Customer-readable message about the current status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_detail: std::string::String,

    /// The location of the source files to build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// Required. The operations to be performed on the workspace.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::BuildStep>,

    /// Output only. Results of the build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub results: std::option::Option<crate::model::Results>,

    /// Output only. Time at which the request to create the build was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which execution of the build was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which execution of the build was finished.
    ///
    /// The difference between finish_time and start_time is the duration of the
    /// build's execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Amount of time that this build should be allowed to run, to second
    /// granularity. If this amount of time elapses, work on the build will cease
    /// and the build status will be `TIMEOUT`.
    ///
    /// `timeout` starts ticking from `startTime`.
    ///
    /// Default time is 60 minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images are pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the `Build` resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build status is marked
    /// `FAILURE`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub images: std::vec::Vec<std::string::String>,

    /// TTL in queue for this build. If provided and the build is enqueued longer
    /// than this value, the build will expire and the build status will be
    /// `EXPIRED`.
    ///
    /// The TTL starts ticking from create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queue_ttl: std::option::Option<wkt::Duration>,

    /// Artifacts produced by the build that should be uploaded upon
    /// successful completion of all build steps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifacts: std::option::Option<crate::model::Artifacts>,

    /// Cloud Storage bucket where logs should be written (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    /// Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub logs_bucket: std::string::String,

    /// Output only. A permanent fixed identifier for source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_provenance: std::option::Option<crate::model::SourceProvenance>,

    /// Output only. The ID of the `BuildTrigger` that triggered this build, if it
    /// was triggered automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub build_trigger_id: std::string::String,

    /// Special options for this build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub options: std::option::Option<crate::model::BuildOptions>,

    /// Output only. URL to logs for this build in Google Cloud Console.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_url: std::string::String,

    /// Substitutions data for `Build` resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Tags for annotation of a `Build`. These are not docker tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Secrets to decrypt using Cloud Key Management Service.
    /// Note: Secret Manager is the recommended technique
    /// for managing sensitive data with Cloud Build. Use `available_secrets` to
    /// configure builds to access secrets from Secret Manager. For instructions,
    /// see: <https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secrets: std::vec::Vec<crate::model::Secret>,

    /// Output only. Stores timing information for phases of the build. Valid keys
    /// are:
    ///
    /// * BUILD: time to execute all build steps.
    /// * PUSH: time to push all artifacts including docker images and non docker
    ///   artifacts.
    /// * FETCHSOURCE: time to fetch source.
    /// * SETUPBUILD: time to set up build.
    ///
    /// If the build does not specify source or images,
    /// these keys will not be included.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub timing: std::collections::HashMap<std::string::String, crate::model::TimeSpan>,

    /// Output only. Describes this build's approval configuration, status,
    /// and result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval: std::option::Option<crate::model::BuildApproval>,

    /// IAM service account whose credentials will be used at build runtime.
    /// Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
    /// ACCOUNT can be email address or uniqueId of the service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Secrets and secret environment variables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub available_secrets: std::option::Option<crate::model::Secrets>,

    /// Output only. Non-fatal problems encountered during the execution of the
    /// build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<crate::model::build::Warning>,

    /// Optional. Configuration for git operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub git_config: std::option::Option<crate::model::GitConfig>,

    /// Output only. Contains information about the build when status=FAILURE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failure_info: std::option::Option<crate::model::build::FailureInfo>,

    /// Optional. Dependencies that the Cloud Build worker will fetch before
    /// executing user steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dependencies: std::vec::Vec<crate::model::Dependency>,
}

impl Build {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Build::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Build::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Build::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Build::status].
    pub fn set_status<T: std::convert::Into<crate::model::build::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::Build::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Build::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [results][crate::model::Build::results].
    pub fn set_results<T: std::convert::Into<std::option::Option<crate::model::Results>>>(
        mut self,
        v: T,
    ) -> Self {
        self.results = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Build::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Build::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::Build::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::Build::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [queue_ttl][crate::model::Build::queue_ttl].
    pub fn set_queue_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queue_ttl = v.into();
        self
    }

    /// Sets the value of [artifacts][crate::model::Build::artifacts].
    pub fn set_artifacts<T: std::convert::Into<std::option::Option<crate::model::Artifacts>>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifacts = v.into();
        self
    }

    /// Sets the value of [logs_bucket][crate::model::Build::logs_bucket].
    pub fn set_logs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logs_bucket = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::Build::source_provenance].
    pub fn set_source_provenance<
        T: std::convert::Into<std::option::Option<crate::model::SourceProvenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_provenance = v.into();
        self
    }

    /// Sets the value of [build_trigger_id][crate::model::Build::build_trigger_id].
    pub fn set_build_trigger_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_trigger_id = v.into();
        self
    }

    /// Sets the value of [options][crate::model::Build::options].
    pub fn set_options<T: std::convert::Into<std::option::Option<crate::model::BuildOptions>>>(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// Sets the value of [log_url][crate::model::Build::log_url].
    pub fn set_log_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_url = v.into();
        self
    }

    /// Sets the value of [approval][crate::model::Build::approval].
    pub fn set_approval<T: std::convert::Into<std::option::Option<crate::model::BuildApproval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.approval = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Build::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [available_secrets][crate::model::Build::available_secrets].
    pub fn set_available_secrets<
        T: std::convert::Into<std::option::Option<crate::model::Secrets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.available_secrets = v.into();
        self
    }

    /// Sets the value of [git_config][crate::model::Build::git_config].
    pub fn set_git_config<T: std::convert::Into<std::option::Option<crate::model::GitConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_config = v.into();
        self
    }

    /// Sets the value of [failure_info][crate::model::Build::failure_info].
    pub fn set_failure_info<
        T: std::convert::Into<std::option::Option<crate::model::build::FailureInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failure_info = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::Build::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [images][crate::model::Build::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Build::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secrets][crate::model::Build::secrets].
    pub fn set_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Secret>,
    {
        use std::iter::Iterator;
        self.secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::Build::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::build::Warning>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dependencies][crate::model::Build::dependencies].
    pub fn set_dependencies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dependency>,
    {
        use std::iter::Iterator;
        self.dependencies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [substitutions][crate::model::Build::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [timing][crate::model::Build::timing].
    pub fn set_timing<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TimeSpan>,
    {
        use std::iter::Iterator;
        self.timing = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Build {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Build"
    }
}

/// Defines additional types related to Build
pub mod build {
    #[allow(unused_imports)]
    use super::*;

    /// A non-fatal problem encountered during the execution of the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Warning {
        /// Explanation of the warning generated.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,

        /// The priority for this warning.
        pub priority: crate::model::build::warning::Priority,
    }

    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::build::Warning::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [priority][crate::model::build::Warning::priority].
        pub fn set_priority<T: std::convert::Into<crate::model::build::warning::Priority>>(
            mut self,
            v: T,
        ) -> Self {
            self.priority = v.into();
            self
        }
    }

    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Build.Warning"
        }
    }

    /// Defines additional types related to Warning
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The relative importance of this warning.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Priority(std::borrow::Cow<'static, str>);

        impl Priority {
            /// Creates a new Priority instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Priority](Priority)
        pub mod priority {
            use super::Priority;

            /// Should not be used.
            pub const PRIORITY_UNSPECIFIED: Priority = Priority::new("PRIORITY_UNSPECIFIED");

            /// e.g. deprecation warnings and alternative feature highlights.
            pub const INFO: Priority = Priority::new("INFO");

            /// e.g. automated detection of possible issues with the build.
            pub const WARNING: Priority = Priority::new("WARNING");

            /// e.g. alerts that a feature used in the build is pending removal
            pub const ALERT: Priority = Priority::new("ALERT");
        }

        impl std::convert::From<std::string::String> for Priority {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// A fatal problem encountered during the execution of the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FailureInfo {
        /// The name of the failure.
        #[serde(rename = "type")]
        pub r#type: crate::model::build::failure_info::FailureType,

        /// Explains the failure issue in more detail using hard-coded text.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub detail: std::string::String,
    }

    impl FailureInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::build::FailureInfo::type].
        pub fn set_type<T: std::convert::Into<crate::model::build::failure_info::FailureType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [detail][crate::model::build::FailureInfo::detail].
        pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.detail = v.into();
            self
        }
    }

    impl wkt::message::Message for FailureInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Build.FailureInfo"
        }
    }

    /// Defines additional types related to FailureInfo
    pub mod failure_info {
        #[allow(unused_imports)]
        use super::*;

        /// The name of a fatal problem encountered during the execution of the
        /// build.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct FailureType(std::borrow::Cow<'static, str>);

        impl FailureType {
            /// Creates a new FailureType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [FailureType](FailureType)
        pub mod failure_type {
            use super::FailureType;

            /// Type unspecified
            pub const FAILURE_TYPE_UNSPECIFIED: FailureType =
                FailureType::new("FAILURE_TYPE_UNSPECIFIED");

            /// Unable to push the image to the repository.
            pub const PUSH_FAILED: FailureType = FailureType::new("PUSH_FAILED");

            /// Final image not found.
            pub const PUSH_IMAGE_NOT_FOUND: FailureType = FailureType::new("PUSH_IMAGE_NOT_FOUND");

            /// Unauthorized push of the final image.
            pub const PUSH_NOT_AUTHORIZED: FailureType = FailureType::new("PUSH_NOT_AUTHORIZED");

            /// Backend logging failures. Should retry.
            pub const LOGGING_FAILURE: FailureType = FailureType::new("LOGGING_FAILURE");

            /// A build step has failed.
            pub const USER_BUILD_STEP: FailureType = FailureType::new("USER_BUILD_STEP");

            /// The source fetching has failed.
            pub const FETCH_SOURCE_FAILED: FailureType = FailureType::new("FETCH_SOURCE_FAILED");
        }

        impl std::convert::From<std::string::String> for FailureType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Possible status of a build or build step.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Status(std::borrow::Cow<'static, str>);

    impl Status {
        /// Creates a new Status instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Status](Status)
    pub mod status {
        use super::Status;

        /// Status of the build is unknown.
        pub const STATUS_UNKNOWN: Status = Status::new("STATUS_UNKNOWN");

        /// Build has been created and is pending execution and queuing. It has not
        /// been queued.
        pub const PENDING: Status = Status::new("PENDING");

        /// Build or step is queued; work has not yet begun.
        pub const QUEUED: Status = Status::new("QUEUED");

        /// Build or step is being executed.
        pub const WORKING: Status = Status::new("WORKING");

        /// Build or step finished successfully.
        pub const SUCCESS: Status = Status::new("SUCCESS");

        /// Build or step failed to complete successfully.
        pub const FAILURE: Status = Status::new("FAILURE");

        /// Build or step failed due to an internal cause.
        pub const INTERNAL_ERROR: Status = Status::new("INTERNAL_ERROR");

        /// Build or step took longer than was allowed.
        pub const TIMEOUT: Status = Status::new("TIMEOUT");

        /// Build or step was canceled by a user.
        pub const CANCELLED: Status = Status::new("CANCELLED");

        /// Build was enqueued for longer than the value of `queue_ttl`.
        pub const EXPIRED: Status = Status::new("EXPIRED");
    }

    impl std::convert::From<std::string::String> for Status {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A dependency that the Cloud Build worker will fetch before executing user
/// steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dependency {
    /// The type of dependency to fetch.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub dep: std::option::Option<crate::model::dependency::Dep>,
}

impl Dependency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `dep`.
    pub fn set_dep<T: std::convert::Into<std::option::Option<crate::model::dependency::Dep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dep = v.into();
        self
    }

    /// The value of [dep][crate::model::Dependency::dep]
    /// if it holds a `Empty`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_empty(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.dep.as_ref().and_then(|v| match v {
            crate::model::dependency::Dep::Empty(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [dep][crate::model::Dependency::dep]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_git_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dependency::GitSourceDependency>> {
        #[allow(unreachable_patterns)]
        self.dep.as_ref().and_then(|v| match v {
            crate::model::dependency::Dep::GitSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dep][crate::model::Dependency::dep]
    /// to hold a `Empty`.
    ///
    /// Note that all the setters affecting `dep` are
    /// mutually exclusive.
    pub fn set_empty<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dep = std::option::Option::Some(crate::model::dependency::Dep::Empty(v.into()));
        self
    }

    /// Sets the value of [dep][crate::model::Dependency::dep]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `dep` are
    /// mutually exclusive.
    pub fn set_git_source<
        T: std::convert::Into<std::boxed::Box<crate::model::dependency::GitSourceDependency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dep = std::option::Option::Some(crate::model::dependency::Dep::GitSource(v.into()));
        self
    }
}

impl wkt::message::Message for Dependency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency"
    }
}

/// Defines additional types related to Dependency
pub mod dependency {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a git repository as a build dependency.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GitSourceDependency {
        /// Required. The kind of repo (url or dev connect).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub repository: std::option::Option<crate::model::dependency::GitSourceRepository>,

        /// Required. The revision that we will fetch the repo at.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub revision: std::string::String,

        /// Optional. True if submodules should be fetched too (default false).
        pub recurse_submodules: bool,

        /// Optional. How much history should be fetched for the build (default 1, -1
        /// for all history).
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub depth: i64,

        /// Required. Where should the files be placed on the worker.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dest_path: std::string::String,
    }

    impl GitSourceDependency {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::dependency::GitSourceDependency::repository].
        pub fn set_repository<
            T: std::convert::Into<std::option::Option<crate::model::dependency::GitSourceRepository>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [revision][crate::model::dependency::GitSourceDependency::revision].
        pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }

        /// Sets the value of [recurse_submodules][crate::model::dependency::GitSourceDependency::recurse_submodules].
        pub fn set_recurse_submodules<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.recurse_submodules = v.into();
            self
        }

        /// Sets the value of [depth][crate::model::dependency::GitSourceDependency::depth].
        pub fn set_depth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.depth = v.into();
            self
        }

        /// Sets the value of [dest_path][crate::model::dependency::GitSourceDependency::dest_path].
        pub fn set_dest_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dest_path = v.into();
            self
        }
    }

    impl wkt::message::Message for GitSourceDependency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency.GitSourceDependency"
        }
    }

    /// A repository for a git source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GitSourceRepository {
        /// The type of git source repo (url or dev connect).
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub repotype:
            std::option::Option<crate::model::dependency::git_source_repository::Repotype>,
    }

    impl GitSourceRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `repotype`.
        pub fn set_repotype<
            T: std::convert::Into<
                std::option::Option<crate::model::dependency::git_source_repository::Repotype>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.repotype = v.into();
            self
        }

        /// The value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// if it holds a `Url`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_url(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.repotype.as_ref().and_then(|v| match v {
                crate::model::dependency::git_source_repository::Repotype::Url(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// if it holds a `DeveloperConnect`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_developer_connect(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.repotype.as_ref().and_then(|v| match v {
                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// to hold a `Url`.
        ///
        /// Note that all the setters affecting `repotype` are
        /// mutually exclusive.
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repotype = std::option::Option::Some(
                crate::model::dependency::git_source_repository::Repotype::Url(v.into()),
            );
            self
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// to hold a `DeveloperConnect`.
        ///
        /// Note that all the setters affecting `repotype` are
        /// mutually exclusive.
        pub fn set_developer_connect<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repotype = std::option::Option::Some(
                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for GitSourceRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency.GitSourceRepository"
        }
    }

    /// Defines additional types related to GitSourceRepository
    pub mod git_source_repository {
        #[allow(unused_imports)]
        use super::*;

        /// The type of git source repo (url or dev connect).
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Repotype {
            /// Location of the Git repository.
            Url(std::string::String),
            /// The Developer Connect Git repository link or the url that matches a
            /// repository link in the current project, formatted as
            /// `projects/*/locations/*/connections/*/gitRepositoryLink/*`
            DeveloperConnect(std::string::String),
        }
    }

    /// The type of dependency to fetch.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Dep {
        /// If set to true disable all dependency fetching (ignoring the default
        /// source as well).
        Empty(bool),
        /// Represents a git repository as a build dependency.
        GitSource(std::boxed::Box<crate::model::dependency::GitSourceDependency>),
    }
}

/// GitConfig is a configuration for git operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitConfig {
    /// Configuration for HTTP related git operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http: std::option::Option<crate::model::git_config::HttpConfig>,
}

impl GitConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http][crate::model::GitConfig::http].
    pub fn set_http<
        T: std::convert::Into<std::option::Option<crate::model::git_config::HttpConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.http = v.into();
        self
    }
}

impl wkt::message::Message for GitConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitConfig"
    }
}

/// Defines additional types related to GitConfig
pub mod git_config {
    #[allow(unused_imports)]
    use super::*;

    /// HttpConfig is a configuration for HTTP related git operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpConfig {
        /// SecretVersion resource of the HTTP proxy URL. The Service Account used in
        /// the build (either the default Service Account or
        /// user-specified Service Account) should have
        /// `secretmanager.versions.access` permissions on this secret. The proxy URL
        /// should be in format `[protocol://][user[:password]@]proxyhost[:port]`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub proxy_secret_version_name: std::string::String,
    }

    impl HttpConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [proxy_secret_version_name][crate::model::git_config::HttpConfig::proxy_secret_version_name].
        pub fn set_proxy_secret_version_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.proxy_secret_version_name = v.into();
            self
        }
    }

    impl wkt::message::Message for HttpConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.GitConfig.HttpConfig"
        }
    }
}

/// Artifacts produced by a build that should be uploaded upon
/// successful completion of all build steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Artifacts {
    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images will be pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the Build resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub images: std::vec::Vec<std::string::String>,

    /// A list of objects to be uploaded to Cloud Storage upon successful
    /// completion of all build steps.
    ///
    /// Files in the workspace matching specified paths globs will be uploaded to
    /// the specified Cloud Storage location using the builder service account's
    /// credentials.
    ///
    /// The location and generation of the uploaded objects will be stored in the
    /// Build resource's results field.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub objects: std::option::Option<crate::model::artifacts::ArtifactObjects>,

    /// A list of Maven artifacts to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Artifacts in the workspace matching specified paths globs will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any artifacts fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub maven_artifacts: std::vec::Vec<crate::model::artifacts::MavenArtifact>,

    /// Optional. A list of Go modules to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub go_modules: std::vec::Vec<crate::model::artifacts::GoModule>,

    /// A list of Python packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// The build service account credentials will be used to perform the upload.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub python_packages: std::vec::Vec<crate::model::artifacts::PythonPackage>,

    /// A list of npm packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Npm packages in the specified paths will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any packages fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub npm_packages: std::vec::Vec<crate::model::artifacts::NpmPackage>,
}

impl Artifacts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objects][crate::model::Artifacts::objects].
    pub fn set_objects<
        T: std::convert::Into<std::option::Option<crate::model::artifacts::ArtifactObjects>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.objects = v.into();
        self
    }

    /// Sets the value of [images][crate::model::Artifacts::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::Artifacts::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::MavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [go_modules][crate::model::Artifacts::go_modules].
    pub fn set_go_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::GoModule>,
    {
        use std::iter::Iterator;
        self.go_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_packages][crate::model::Artifacts::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::PythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [npm_packages][crate::model::Artifacts::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::NpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Artifacts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts"
    }
}

/// Defines additional types related to Artifacts
pub mod artifacts {
    #[allow(unused_imports)]
    use super::*;

    /// Files in the workspace to upload to Cloud Storage upon successful
    /// completion of all build steps.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArtifactObjects {
        /// Cloud Storage bucket and optional object path, in the form
        /// "gs://bucket/path/to/somewhere/". (see [Bucket Name
        /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Cloud Storage with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        /// Path globs used to match files in the build's workspace.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub paths: std::vec::Vec<std::string::String>,

        /// Output only. Stores timing information for pushing all artifact objects.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub timing: std::option::Option<crate::model::TimeSpan>,
    }

    impl ArtifactObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::artifacts::ArtifactObjects::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [timing][crate::model::artifacts::ArtifactObjects::timing].
        pub fn set_timing<T: std::convert::Into<std::option::Option<crate::model::TimeSpan>>>(
            mut self,
            v: T,
        ) -> Self {
            self.timing = v.into();
            self
        }

        /// Sets the value of [paths][crate::model::artifacts::ArtifactObjects::paths].
        pub fn set_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.paths = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ArtifactObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.ArtifactObjects"
        }
    }

    /// A Maven artifact to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MavenArtifact {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-maven.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Artifact in the workspace specified by path will be uploaded to
        /// Artifact Registry with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub repository: std::string::String,

        /// Path to an artifact in the build's workspace to be uploaded to
        /// Artifact Registry.
        /// This can be either an absolute path,
        /// e.g. /workspace/my-app/target/my-app-1.0.SNAPSHOT.jar
        /// or a relative path from /workspace,
        /// e.g. my-app/target/my-app-1.0.SNAPSHOT.jar.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        /// Maven `artifactId` value used when uploading the artifact to Artifact
        /// Registry.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub artifact_id: std::string::String,

        /// Maven `groupId` value used when uploading the artifact to Artifact
        /// Registry.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub group_id: std::string::String,

        /// Maven `version` value used when uploading the artifact to Artifact
        /// Registry.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,
    }

    impl MavenArtifact {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::MavenArtifact::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [path][crate::model::artifacts::MavenArtifact::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [artifact_id][crate::model::artifacts::MavenArtifact::artifact_id].
        pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.artifact_id = v.into();
            self
        }

        /// Sets the value of [group_id][crate::model::artifacts::MavenArtifact::group_id].
        pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::artifacts::MavenArtifact::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for MavenArtifact {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.MavenArtifact"
        }
    }

    /// Go module to upload to Artifact Registry upon successful completion of all
    /// build steps. A module refers to all dependencies in a go.mod file.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GoModule {
        /// Optional. Artifact Registry repository name.
        ///
        /// Specified Go modules will be zipped and uploaded to Artifact Registry
        /// with this location as a prefix.
        /// e.g. my-go-repo
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub repository_name: std::string::String,

        /// Optional. Location of the Artifact Registry repository. i.e. us-east1
        /// Defaults to the build’s location.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub repository_location: std::string::String,

        /// Optional. Project ID of the Artifact Registry repository.
        /// Defaults to the build project.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub repository_project_id: std::string::String,

        /// Optional. Source path of the go.mod file in the build's workspace. If not
        /// specified, this will default to the current directory.
        /// e.g. ~/code/go/mypackage
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_path: std::string::String,

        /// Optional. The Go module's "module path".
        /// e.g. example.com/foo/v2
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub module_path: std::string::String,

        /// Optional. The Go module's semantic version in the form vX.Y.Z. e.g.
        /// v0.1.1 Pre-release identifiers can also be added by appending a dash and
        /// dot separated ASCII alphanumeric characters and hyphens.
        /// e.g. v0.2.3-alpha.x.12m.5
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub module_version: std::string::String,
    }

    impl GoModule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository_name][crate::model::artifacts::GoModule::repository_name].
        pub fn set_repository_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_name = v.into();
            self
        }

        /// Sets the value of [repository_location][crate::model::artifacts::GoModule::repository_location].
        pub fn set_repository_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_location = v.into();
            self
        }

        /// Sets the value of [repository_project_id][crate::model::artifacts::GoModule::repository_project_id].
        pub fn set_repository_project_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_project_id = v.into();
            self
        }

        /// Sets the value of [source_path][crate::model::artifacts::GoModule::source_path].
        pub fn set_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_path = v.into();
            self
        }

        /// Sets the value of [module_path][crate::model::artifacts::GoModule::module_path].
        pub fn set_module_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.module_path = v.into();
            self
        }

        /// Sets the value of [module_version][crate::model::artifacts::GoModule::module_version].
        pub fn set_module_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.module_version = v.into();
            self
        }
    }

    impl wkt::message::Message for GoModule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.GoModule"
        }
    }

    /// Python package to upload to Artifact Registry upon successful completion
    /// of all build steps. A package can encapsulate multiple objects to be
    /// uploaded to a single repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PythonPackage {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-python.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Artifact Registry with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub repository: std::string::String,

        /// Path globs used to match files in the build's workspace. For Python/
        /// Twine, this is usually `dist/*`, and sometimes additionally an `.asc`
        /// file.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub paths: std::vec::Vec<std::string::String>,
    }

    impl PythonPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::PythonPackage::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [paths][crate::model::artifacts::PythonPackage::paths].
        pub fn set_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.paths = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PythonPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.PythonPackage"
        }
    }

    /// Npm package to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NpmPackage {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-npm.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Npm package in the workspace specified by path will be zipped and
        /// uploaded to Artifact Registry with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub repository: std::string::String,

        /// Path to the package.json.
        /// e.g. workspace/path/to/package
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub package_path: std::string::String,
    }

    impl NpmPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::NpmPackage::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [package_path][crate::model::artifacts::NpmPackage::package_path].
        pub fn set_package_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_path = v.into();
            self
        }
    }

    impl wkt::message::Message for NpmPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.NpmPackage"
        }
    }
}

/// Start and end times for a build execution phase.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSpan {
    /// Start of time span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End of time span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl TimeSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeSpan::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TimeSpan::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for TimeSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.TimeSpan"
    }
}

/// Metadata for build operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildOperationMetadata {
    /// The build that the operation is tracking.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build: std::option::Option<crate::model::Build>,
}

impl BuildOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::BuildOperationMetadata::build].
    pub fn set_build<T: std::convert::Into<std::option::Option<crate::model::Build>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build = v.into();
        self
    }
}

impl wkt::message::Message for BuildOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOperationMetadata"
    }
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceProvenance {
    /// A copy of the build's `source.storage_source`, if exists, with any
    /// generations resolved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_storage_source: std::option::Option<crate::model::StorageSource>,

    /// A copy of the build's `source.repo_source`, if exists, with any
    /// revisions resolved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_repo_source: std::option::Option<crate::model::RepoSource>,

    /// A copy of the build's `source.storage_source_manifest`, if exists, with any
    /// revisions resolved.
    /// This feature is in Preview.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_storage_source_manifest: std::option::Option<crate::model::StorageSourceManifest>,

    /// Output only. Hash(es) of the build source, which can be used to verify that
    /// the original source integrity was maintained in the build. Note that
    /// `FileHashes` will only be populated if `BuildOptions` has requested a
    /// `SourceProvenanceHash`.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (`.tar.gz`), the `FileHash` will be for the single path to that file.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub file_hashes: std::collections::HashMap<std::string::String, crate::model::FileHashes>,
}

impl SourceProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resolved_storage_source][crate::model::SourceProvenance::resolved_storage_source].
    pub fn set_resolved_storage_source<
        T: std::convert::Into<std::option::Option<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_storage_source = v.into();
        self
    }

    /// Sets the value of [resolved_repo_source][crate::model::SourceProvenance::resolved_repo_source].
    pub fn set_resolved_repo_source<
        T: std::convert::Into<std::option::Option<crate::model::RepoSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_repo_source = v.into();
        self
    }

    /// Sets the value of [resolved_storage_source_manifest][crate::model::SourceProvenance::resolved_storage_source_manifest].
    pub fn set_resolved_storage_source_manifest<
        T: std::convert::Into<std::option::Option<crate::model::StorageSourceManifest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_storage_source_manifest = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::SourceProvenance::file_hashes].
    pub fn set_file_hashes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hashes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SourceProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.SourceProvenance"
    }
}

/// Container message for hashes of byte content of files, used in
/// SourceProvenance messages to verify integrity of source input to the build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileHashes {
    /// Collection of file hashes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_hash: std::vec::Vec<crate::model::Hash>,
}

impl FileHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_hash][crate::model::FileHashes::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.FileHashes"
    }
}

/// Container message for hash values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Hash {
    /// The type of hash that was performed.
    #[serde(rename = "type")]
    pub r#type: crate::model::hash::HashType,

    /// The hash value.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub value: bytes::Bytes,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    pub fn set_type<T: std::convert::Into<crate::model::hash::HashType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    pub fn set_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Hash"
    }
}

/// Defines additional types related to Hash
pub mod hash {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the hash algorithm, if any.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HashType(std::borrow::Cow<'static, str>);

    impl HashType {
        /// Creates a new HashType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HashType](HashType)
    pub mod hash_type {
        use super::HashType;

        /// No hash requested.
        pub const NONE: HashType = HashType::new("NONE");

        /// Use a sha256 hash.
        pub const SHA256: HashType = HashType::new("SHA256");

        /// Use a md5 hash.
        pub const MD5: HashType = HashType::new("MD5");

        /// Dirhash of a Go module's source code which is then hex-encoded.
        pub const GO_MODULE_H1: HashType = HashType::new("GO_MODULE_H1");

        /// Use a sha512 hash.
        pub const SHA512: HashType = HashType::new("SHA512");
    }

    impl std::convert::From<std::string::String> for HashType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Secrets and secret environment variables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Secrets {
    /// Secrets in Secret Manager and associated secret environment variable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secret_manager: std::vec::Vec<crate::model::SecretManagerSecret>,

    /// Secrets encrypted with KMS key and the associated secret environment
    /// variable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inline: std::vec::Vec<crate::model::InlineSecret>,
}

impl Secrets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_manager][crate::model::Secrets::secret_manager].
    pub fn set_secret_manager<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretManagerSecret>,
    {
        use std::iter::Iterator;
        self.secret_manager = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inline][crate::model::Secrets::inline].
    pub fn set_inline<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InlineSecret>,
    {
        use std::iter::Iterator;
        self.inline = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Secrets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Secrets"
    }
}

/// Pairs a set of secret environment variables mapped to encrypted
/// values with the Cloud KMS key to use to decrypt the value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InlineSecret {
    /// Resource name of Cloud KMS crypto key to decrypt the encrypted value.
    /// In format: projects/*/locations/*/keyRings/*/cryptoKeys/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, serde_with::base64::Base64>")]
    pub env_map: std::collections::HashMap<std::string::String, bytes::Bytes>,
}

impl InlineSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::InlineSecret::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [env_map][crate::model::InlineSecret::env_map].
    pub fn set_env_map<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.env_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InlineSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.InlineSecret"
    }
}

/// Pairs a secret environment variable with a SecretVersion in Secret Manager.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretManagerSecret {
    /// Resource name of the SecretVersion. In format:
    /// projects/*/secrets/*/versions/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_name: std::string::String,

    /// Environment variable name to associate with the secret.
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub env: std::string::String,
}

impl SecretManagerSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version_name][crate::model::SecretManagerSecret::version_name].
    pub fn set_version_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::SecretManagerSecret::env].
    pub fn set_env<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.env = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.SecretManagerSecret"
    }
}

/// Pairs a set of secret environment variables containing encrypted
/// values with the Cloud KMS key to use to decrypt the value.
/// Note: Use `kmsKeyName` with  `available_secrets` instead of using
/// `kmsKeyName` with `secret`. For instructions see:
/// <https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-credentials>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Secret {
    /// Cloud KMS key name to use to decrypt these envs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, serde_with::base64::Base64>")]
    pub secret_env: std::collections::HashMap<std::string::String, bytes::Bytes>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::Secret::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [secret_env][crate::model::Secret::secret_env].
    pub fn set_secret_env<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Secret"
    }
}

/// Request to create a new build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBuildRequest {
    /// The parent resource where this build will be created.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Build resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build: std::option::Option<crate::model::Build>,
}

impl CreateBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBuildRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CreateBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [build][crate::model::CreateBuildRequest::build].
    pub fn set_build<T: std::convert::Into<std::option::Option<crate::model::Build>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build = v.into();
        self
    }
}

impl wkt::message::Message for CreateBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateBuildRequest"
    }
}

/// Request to get a build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBuildRequest {
    /// The name of the `Build` to retrieve.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. ID of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,
}

impl GetBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::GetBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for GetBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetBuildRequest"
    }
}

/// Request to list builds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildsRequest {
    /// The parent of the collection of `Builds`.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// The page token for the next page of Builds.
    ///
    /// If unspecified, the first page of results is returned.
    ///
    /// If the token is rejected for any reason, INVALID_ARGUMENT will be thrown.
    /// In this case, the token should be discarded, and pagination should be
    /// restarted from the first page of results.
    ///
    /// See <https://google.aip.dev/158> for more.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The raw filter text to constrain the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListBuildsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBuildsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ListBuildsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBuildsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBuildsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBuildsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildsRequest"
    }
}

/// Response including listed builds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildsResponse {
    /// Builds will be sorted by `create_time`, descending.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub builds: std::vec::Vec<crate::model::Build>,

    /// Token to receive the next page of results.
    /// This will be absent if the end of the response list has been reached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListBuildsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBuildsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [builds][crate::model::ListBuildsResponse::builds].
    pub fn set_builds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Build>,
    {
        use std::iter::Iterator;
        self.builds = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBuildsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBuildsResponse {
    type PageItem = crate::model::Build;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.builds
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request to cancel an ongoing build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelBuildRequest {
    /// The name of the `Build` to cancel.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. ID of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,
}

impl CancelBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CancelBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::CancelBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for CancelBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CancelBuildRequest"
    }
}

/// Request to approve or reject a pending build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveBuildRequest {
    /// Required. Name of the target build.
    /// For example: "projects/{$project_id}/builds/{$build_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Approval decision and metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval_result: std::option::Option<crate::model::ApprovalResult>,
}

impl ApproveBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [approval_result][crate::model::ApproveBuildRequest::approval_result].
    pub fn set_approval_result<
        T: std::convert::Into<std::option::Option<crate::model::ApprovalResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approval_result = v.into();
        self
    }
}

impl wkt::message::Message for ApproveBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApproveBuildRequest"
    }
}

/// BuildApproval describes a build's approval configuration, state, and
/// result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildApproval {
    /// Output only. The state of this build's approval.
    pub state: crate::model::build_approval::State,

    /// Output only. Configuration for manual approval of this build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::ApprovalConfig>,

    /// Output only. Result of manual approval for this Build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::ApprovalResult>,
}

impl BuildApproval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BuildApproval::state].
    pub fn set_state<T: std::convert::Into<crate::model::build_approval::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [config][crate::model::BuildApproval::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::ApprovalConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [result][crate::model::BuildApproval::result].
    pub fn set_result<T: std::convert::Into<std::option::Option<crate::model::ApprovalResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }
}

impl wkt::message::Message for BuildApproval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildApproval"
    }
}

/// Defines additional types related to BuildApproval
pub mod build_approval {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the current state of a build's approval.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default enum type. This should not be used.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Build approval is pending.
        pub const PENDING: State = State::new("PENDING");

        /// Build approval has been approved.
        pub const APPROVED: State = State::new("APPROVED");

        /// Build approval has been rejected.
        pub const REJECTED: State = State::new("REJECTED");

        /// Build was cancelled while it was still pending approval.
        pub const CANCELLED: State = State::new("CANCELLED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// ApprovalConfig describes configuration for manual approval of a build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will
    /// become pending when created, and will need to be explicitly approved
    /// to start.
    pub approval_required: bool,
}

impl ApprovalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approval_required][crate::model::ApprovalConfig::approval_required].
    pub fn set_approval_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.approval_required = v.into();
        self
    }
}

impl wkt::message::Message for ApprovalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApprovalConfig"
    }
}

/// ApprovalResult describes the decision and associated metadata of a manual
/// approval of a build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApprovalResult {
    /// Output only. Email of the user that called the ApproveBuild API to
    /// approve or reject a build at the time that the API was called.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub approver_account: std::string::String,

    /// Output only. The time when the approval decision was made.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval_time: std::option::Option<wkt::Timestamp>,

    /// Required. The decision of this manual approval.
    pub decision: crate::model::approval_result::Decision,

    /// Optional. An optional comment for this manual approval result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,

    /// Optional. An optional URL tied to this manual approval result. This field
    /// is essentially the same as comment, except that it will be rendered by the
    /// UI differently. An example use case is a link to an external job that
    /// approved this Build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,
}

impl ApprovalResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approver_account][crate::model::ApprovalResult::approver_account].
    pub fn set_approver_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.approver_account = v.into();
        self
    }

    /// Sets the value of [approval_time][crate::model::ApprovalResult::approval_time].
    pub fn set_approval_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.approval_time = v.into();
        self
    }

    /// Sets the value of [decision][crate::model::ApprovalResult::decision].
    pub fn set_decision<T: std::convert::Into<crate::model::approval_result::Decision>>(
        mut self,
        v: T,
    ) -> Self {
        self.decision = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::ApprovalResult::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [url][crate::model::ApprovalResult::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for ApprovalResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApprovalResult"
    }
}

/// Defines additional types related to ApprovalResult
pub mod approval_result {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether or not this manual approval result is to approve
    /// or reject a build.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Decision(std::borrow::Cow<'static, str>);

    impl Decision {
        /// Creates a new Decision instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Decision](Decision)
    pub mod decision {
        use super::Decision;

        /// Default enum type. This should not be used.
        pub const DECISION_UNSPECIFIED: Decision = Decision::new("DECISION_UNSPECIFIED");

        /// Build is approved.
        pub const APPROVED: Decision = Decision::new("APPROVED");

        /// Build is rejected.
        pub const REJECTED: Decision = Decision::new("REJECTED");
    }

    impl std::convert::From<std::string::String> for Decision {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// GitRepoSource describes a repo and ref of a code repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitRepoSource {
    /// The URI of the repo (e.g. <https://github.com/user/repo.git>).
    /// Either `uri` or `repository` can be specified and is required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The branch or tag to use. Must start with "refs/" (required).
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#ref: std::string::String,

    /// See RepoType below.
    pub repo_type: crate::model::git_file_source::RepoType,

    /// The source of the SCM repo.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::git_repo_source::Source>,

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub enterprise_config: std::option::Option<crate::model::git_repo_source::EnterpriseConfig>,
}

impl GitRepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GitRepoSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [r#ref][crate::model::GitRepoSource::ref].
    pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#ref = v.into();
        self
    }

    /// Sets the value of [repo_type][crate::model::GitRepoSource::repo_type].
    pub fn set_repo_type<T: std::convert::Into<crate::model::git_file_source::RepoType>>(
        mut self,
        v: T,
    ) -> Self {
        self.repo_type = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::git_repo_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GitRepoSource::source]
    /// if it holds a `Repository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_repository(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::git_repo_source::Source::Repository(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GitRepoSource::source]
    /// to hold a `Repository`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::git_repo_source::Source::Repository(v.into()));
        self
    }

    /// Sets the value of `enterprise_config`.
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::git_repo_source::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// The value of [enterprise_config][crate::model::GitRepoSource::enterprise_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_github_enterprise_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.enterprise_config.as_ref().and_then(|v| match v {
            crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enterprise_config][crate::model::GitRepoSource::enterprise_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `enterprise_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = std::option::Option::Some(
            crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GitRepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitRepoSource"
    }
}

/// Defines additional types related to GitRepoSource
pub mod git_repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the SCM repo.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The connected repository resource name, in the format
        /// `projects/*/locations/*/connections/*/repositories/*`. Either `uri` or
        /// `repository` can be specified and is required.
        Repository(std::string::String),
    }

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        GithubEnterpriseConfig(std::string::String),
    }
}

/// GitFileSource describes a file within a (possibly remote) code repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitFileSource {
    /// The path of the file, with the repo root as the root of the path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// The URI of the repo.
    /// Either uri or repository can be specified.
    /// If unspecified, the repo from which the trigger invocation originated is
    /// assumed to be the repo from which to read the specified path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// See RepoType above.
    pub repo_type: crate::model::git_file_source::RepoType,

    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when
    /// resolving the filename (optional).
    /// This field respects the same syntax/resolution as described here:
    /// <https://git-scm.com/docs/gitrevisions>
    /// If unspecified, the revision from which the trigger invocation originated
    /// is assumed to be the revision from which to read the specified path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    /// The source of the SCM repo.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::git_file_source::Source>,

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub enterprise_config: std::option::Option<crate::model::git_file_source::EnterpriseConfig>,
}

impl GitFileSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::GitFileSource::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::GitFileSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [repo_type][crate::model::GitFileSource::repo_type].
    pub fn set_repo_type<T: std::convert::Into<crate::model::git_file_source::RepoType>>(
        mut self,
        v: T,
    ) -> Self {
        self.repo_type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GitFileSource::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::git_file_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GitFileSource::source]
    /// if it holds a `Repository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_repository(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::git_file_source::Source::Repository(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GitFileSource::source]
    /// to hold a `Repository`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::git_file_source::Source::Repository(v.into()));
        self
    }

    /// Sets the value of `enterprise_config`.
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::git_file_source::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// The value of [enterprise_config][crate::model::GitFileSource::enterprise_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_github_enterprise_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.enterprise_config.as_ref().and_then(|v| match v {
            crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enterprise_config][crate::model::GitFileSource::enterprise_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `enterprise_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = std::option::Option::Some(
            crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GitFileSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitFileSource"
    }
}

/// Defines additional types related to GitFileSource
pub mod git_file_source {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the repo, since it may not be explicit from the `repo` field
    /// (e.g from a URL).
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RepoType(std::borrow::Cow<'static, str>);

    impl RepoType {
        /// Creates a new RepoType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [RepoType](RepoType)
    pub mod repo_type {
        use super::RepoType;

        /// The default, unknown repo type. Don't use it, instead use one of
        /// the other repo types.
        pub const UNKNOWN: RepoType = RepoType::new("UNKNOWN");

        /// A Google Cloud Source Repositories-hosted repo.
        pub const CLOUD_SOURCE_REPOSITORIES: RepoType = RepoType::new("CLOUD_SOURCE_REPOSITORIES");

        /// A GitHub-hosted repo not necessarily on "github.com" (i.e. GitHub
        /// Enterprise).
        pub const GITHUB: RepoType = RepoType::new("GITHUB");

        /// A Bitbucket Server-hosted repo.
        pub const BITBUCKET_SERVER: RepoType = RepoType::new("BITBUCKET_SERVER");

        /// A GitLab-hosted repo.
        pub const GITLAB: RepoType = RepoType::new("GITLAB");
    }

    impl std::convert::From<std::string::String> for RepoType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The source of the SCM repo.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The fully qualified resource name of the Repos API repository.
        /// Either URI or repository can be specified.
        /// If unspecified, the repo from which the trigger invocation originated is
        /// assumed to be the repo from which to read the specified path.
        Repository(std::string::String),
    }

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        GithubEnterpriseConfig(std::string::String),
    }
}

/// Configuration for an automated build in response to source repository
/// changes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildTrigger {
    /// The `Trigger` name with format:
    /// `projects/{project}/locations/{location}/triggers/{trigger}`, where
    /// {trigger} is a unique identifier generated by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_name: std::string::String,

    /// Output only. Unique identifier of the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Human-readable description of this trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// User-assigned name of the trigger. Must be unique within the project.
    /// Trigger names must meet the following requirements:
    ///
    /// + They must contain only alphanumeric characters and dashes.
    /// + They can be 1-64 characters long.
    /// + They must begin and end with an alphanumeric character.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Tags for annotation of a `BuildTrigger`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Template describing the types of source changes to trigger a build.
    ///
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular expression
    /// will trigger a build.
    ///
    /// Mutually exclusive with `github`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger_template: std::option::Option<crate::model::RepoSource>,

    /// GitHubEventsConfig describes the configuration of a trigger that creates
    /// a build whenever a GitHub event is received.
    ///
    /// Mutually exclusive with `trigger_template`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub github: std::option::Option<crate::model::GitHubEventsConfig>,

    /// PubsubConfig describes the configuration of a trigger that
    /// creates a build whenever a Pub/Sub message is published.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pubsub_config: std::option::Option<crate::model::PubsubConfig>,

    /// WebhookConfig describes the configuration of a trigger that
    /// creates a build whenever a webhook is sent to a trigger's webhook URL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub webhook_config: std::option::Option<crate::model::WebhookConfig>,

    /// Output only. Time when the trigger was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// If true, the trigger will never automatically execute a build.
    pub disabled: bool,

    /// Substitutions for Build resource. The keys must match the following
    /// regular expression: `^_[A-Z0-9_]+$`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// ignored_files and included_files are file glob matches using
    /// <https://golang.org/pkg/path/filepath/#Match> extended with support for "**".
    ///
    /// If ignored_files and changed files are both empty, then they are
    /// not used to determine whether or not to trigger a build.
    ///
    /// If ignored_files is not empty, then we ignore any files that match
    /// any of the ignored_file globs. If the change has no files that are
    /// outside of the ignored_files globs, then we do not trigger a build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ignored_files: std::vec::Vec<std::string::String>,

    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is empty, then as far as this filter is
    /// concerned, we should trigger the build.
    ///
    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is not empty, then we make sure that at
    /// least one of those files matches a included_files glob. If not,
    /// then we do not trigger a build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub included_files: std::vec::Vec<std::string::String>,

    /// Optional. A Common Expression Language string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The repo and ref of the repository from which to build. This field
    /// is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit
    /// caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron
    /// triggers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_to_build: std::option::Option<crate::model::GitRepoSource>,

    /// The service account used for all user-controlled operations including
    /// UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild.
    /// If no service account is set and the legacy Cloud Build service account
    /// (`[PROJECT_NUM]@cloudbuild.gserviceaccount.com`) is the default for the
    /// project then it will be used instead.
    /// Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The configuration of a trigger that creates a build whenever an event from
    /// Repo API is received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repository_event_config: std::option::Option<crate::model::RepositoryEventConfig>,

    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub build_template: std::option::Option<crate::model::build_trigger::BuildTemplate>,
}

impl BuildTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_name][crate::model::BuildTrigger::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BuildTrigger::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BuildTrigger::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [name][crate::model::BuildTrigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trigger_template][crate::model::BuildTrigger::trigger_template].
    pub fn set_trigger_template<
        T: std::convert::Into<std::option::Option<crate::model::RepoSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trigger_template = v.into();
        self
    }

    /// Sets the value of [github][crate::model::BuildTrigger::github].
    pub fn set_github<
        T: std::convert::Into<std::option::Option<crate::model::GitHubEventsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.github = v.into();
        self
    }

    /// Sets the value of [pubsub_config][crate::model::BuildTrigger::pubsub_config].
    pub fn set_pubsub_config<
        T: std::convert::Into<std::option::Option<crate::model::PubsubConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pubsub_config = v.into();
        self
    }

    /// Sets the value of [webhook_config][crate::model::BuildTrigger::webhook_config].
    pub fn set_webhook_config<
        T: std::convert::Into<std::option::Option<crate::model::WebhookConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BuildTrigger::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::BuildTrigger::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BuildTrigger::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [source_to_build][crate::model::BuildTrigger::source_to_build].
    pub fn set_source_to_build<
        T: std::convert::Into<std::option::Option<crate::model::GitRepoSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_to_build = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BuildTrigger::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [repository_event_config][crate::model::BuildTrigger::repository_event_config].
    pub fn set_repository_event_config<
        T: std::convert::Into<std::option::Option<crate::model::RepositoryEventConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repository_event_config = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::BuildTrigger::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignored_files][crate::model::BuildTrigger::ignored_files].
    pub fn set_ignored_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ignored_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_files][crate::model::BuildTrigger::included_files].
    pub fn set_included_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.included_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [substitutions][crate::model::BuildTrigger::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `build_template`.
    pub fn set_build_template<
        T: std::convert::Into<std::option::Option<crate::model::build_trigger::BuildTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_template = v.into();
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Autodetect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_autodetect(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Autodetect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_build(&self) -> std::option::Option<&std::boxed::Box<crate::model::Build>> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Filename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_filename(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Filename(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `GitFileSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_git_file_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitFileSource>> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::GitFileSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Autodetect`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_autodetect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::Autodetect(v.into()),
        );
        self
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::Build>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_template =
            std::option::Option::Some(crate::model::build_trigger::BuildTemplate::Build(v.into()));
        self
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Filename`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_filename<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::Filename(v.into()),
        );
        self
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `GitFileSource`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_git_file_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GitFileSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::GitFileSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BuildTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildTrigger"
    }
}

/// Defines additional types related to BuildTrigger
pub mod build_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BuildTemplate {
        /// Autodetect build configuration.  The following precedence is used (case
        /// insensitive):
        ///
        /// . cloudbuild.yaml
        /// . cloudbuild.yml
        /// . cloudbuild.json
        /// . Dockerfile
        ///
        /// Currently only available for GitHub App Triggers.
        Autodetect(bool),
        /// Contents of the build template.
        Build(std::boxed::Box<crate::model::Build>),
        /// Path, from the source root, to the build configuration file
        /// (i.e. cloudbuild.yaml).
        Filename(std::string::String),
        /// The file source describing the local or remote Build template.
        GitFileSource(std::boxed::Box<crate::model::GitFileSource>),
    }
}

/// The configuration of a trigger that creates a build whenever an event from
/// Repo API is received.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepositoryEventConfig {
    /// The resource name of the Repo API resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Output only. The type of the SCM vendor the repository points to.
    pub repository_type: crate::model::repository_event_config::RepositoryType,

    /// The types of filter to trigger a build.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::repository_event_config::Filter>,
}

impl RepositoryEventConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::RepositoryEventConfig::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [repository_type][crate::model::RepositoryEventConfig::repository_type].
    pub fn set_repository_type<
        T: std::convert::Into<crate::model::repository_event_config::RepositoryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repository_type = v.into();
        self
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::repository_event_config::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::RepositoryEventConfig::filter]
    /// if it holds a `PullRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pull_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PullRequestFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::repository_event_config::Filter::PullRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::RepositoryEventConfig::filter]
    /// if it holds a `Push`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_push(&self) -> std::option::Option<&std::boxed::Box<crate::model::PushFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::repository_event_config::Filter::Push(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter]
    /// to hold a `PullRequest`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_pull_request<
        T: std::convert::Into<std::boxed::Box<crate::model::PullRequestFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::repository_event_config::Filter::PullRequest(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter]
    /// to hold a `Push`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_push<T: std::convert::Into<std::boxed::Box<crate::model::PushFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::repository_event_config::Filter::Push(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RepositoryEventConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RepositoryEventConfig"
    }
}

/// Defines additional types related to RepositoryEventConfig
pub mod repository_event_config {
    #[allow(unused_imports)]
    use super::*;

    /// All possible SCM repo types from Repo API.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RepositoryType(std::borrow::Cow<'static, str>);

    impl RepositoryType {
        /// Creates a new RepositoryType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [RepositoryType](RepositoryType)
    pub mod repository_type {
        use super::RepositoryType;

        /// If unspecified, RepositoryType defaults to GITHUB.
        pub const REPOSITORY_TYPE_UNSPECIFIED: RepositoryType =
            RepositoryType::new("REPOSITORY_TYPE_UNSPECIFIED");

        /// The SCM repo is GITHUB.
        pub const GITHUB: RepositoryType = RepositoryType::new("GITHUB");

        /// The SCM repo is GITHUB Enterprise.
        pub const GITHUB_ENTERPRISE: RepositoryType = RepositoryType::new("GITHUB_ENTERPRISE");

        /// The SCM repo is GITLAB Enterprise.
        pub const GITLAB_ENTERPRISE: RepositoryType = RepositoryType::new("GITLAB_ENTERPRISE");
    }

    impl std::convert::From<std::string::String> for RepositoryType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The types of filter to trigger a build.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// Filter to match changes in pull requests.
        PullRequest(std::boxed::Box<crate::model::PullRequestFilter>),
        /// Filter to match changes in refs like branches, tags.
        Push(std::boxed::Box<crate::model::PushFilter>),
    }
}

/// GitHubEventsConfig describes the configuration of a trigger that creates a
/// build whenever a GitHub event is received.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEventsConfig {
    /// The installationID that emits the GitHub event.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub installation_id: i64,

    /// Owner of the repository. For example: The owner for
    /// <https://github.com/googlecloudplatform/cloud-builders> is
    /// "googlecloudplatform".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub owner: std::string::String,

    /// Name of the repository. For example: The name for
    /// <https://github.com/googlecloudplatform/cloud-builders> is "cloud-builders".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub event: std::option::Option<crate::model::git_hub_events_config::Event>,
}

impl GitHubEventsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [installation_id][crate::model::GitHubEventsConfig::installation_id].
    pub fn set_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.installation_id = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::GitHubEventsConfig::owner].
    pub fn set_owner<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GitHubEventsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `event`.
    pub fn set_event<
        T: std::convert::Into<std::option::Option<crate::model::git_hub_events_config::Event>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }

    /// The value of [event][crate::model::GitHubEventsConfig::event]
    /// if it holds a `PullRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pull_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PullRequestFilter>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::git_hub_events_config::Event::PullRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [event][crate::model::GitHubEventsConfig::event]
    /// if it holds a `Push`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_push(&self) -> std::option::Option<&std::boxed::Box<crate::model::PushFilter>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::git_hub_events_config::Event::Push(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event]
    /// to hold a `PullRequest`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_pull_request<
        T: std::convert::Into<std::boxed::Box<crate::model::PullRequestFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = std::option::Option::Some(
            crate::model::git_hub_events_config::Event::PullRequest(v.into()),
        );
        self
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event]
    /// to hold a `Push`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_push<T: std::convert::Into<std::boxed::Box<crate::model::PushFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event =
            std::option::Option::Some(crate::model::git_hub_events_config::Event::Push(v.into()));
        self
    }
}

impl wkt::message::Message for GitHubEventsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEventsConfig"
    }
}

/// Defines additional types related to GitHubEventsConfig
pub mod git_hub_events_config {
    #[allow(unused_imports)]
    use super::*;

    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Event {
        /// filter to match changes in pull requests.
        PullRequest(std::boxed::Box<crate::model::PullRequestFilter>),
        /// filter to match changes in refs like branches, tags.
        Push(std::boxed::Box<crate::model::PushFilter>),
    }
}

/// PubsubConfig describes the configuration of a trigger that
/// creates a build whenever a Pub/Sub message is published.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PubsubConfig {
    /// Output only. Name of the subscription. Format is
    /// `projects/{project}/subscriptions/{subscription}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subscription: std::string::String,

    /// The name of the topic from which this subscription is receiving messages.
    /// Format is `projects/{project}/topics/{topic}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub topic: std::string::String,

    /// Service account that will make the push request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    pub state: crate::model::pubsub_config::State,
}

impl PubsubConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::PubsubConfig::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::PubsubConfig::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::PubsubConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PubsubConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::pubsub_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for PubsubConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PubsubConfig"
    }
}

/// Defines additional types related to PubsubConfig
pub mod pubsub_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates potential issues with the underlying Pub/Sub subscription
    /// configuration.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The subscription configuration has not been checked.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The Pub/Sub subscription is properly configured.
        pub const OK: State = State::new("OK");

        /// The subscription has been deleted.
        pub const SUBSCRIPTION_DELETED: State = State::new("SUBSCRIPTION_DELETED");

        /// The topic has been deleted.
        pub const TOPIC_DELETED: State = State::new("TOPIC_DELETED");

        /// Some of the subscription's field are misconfigured.
        pub const SUBSCRIPTION_MISCONFIGURED: State = State::new("SUBSCRIPTION_MISCONFIGURED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// WebhookConfig describes the configuration of a trigger that
/// creates a build whenever a webhook is sent to a trigger's webhook URL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebhookConfig {
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    pub state: crate::model::webhook_config::State,

    /// Auth method specifies how the webhook authenticates with GCP.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub auth_method: std::option::Option<crate::model::webhook_config::AuthMethod>,
}

impl WebhookConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::WebhookConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::webhook_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of `auth_method`.
    pub fn set_auth_method<
        T: std::convert::Into<std::option::Option<crate::model::webhook_config::AuthMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_method = v.into();
        self
    }

    /// The value of [auth_method][crate::model::WebhookConfig::auth_method]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_secret(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.auth_method.as_ref().and_then(|v| match v {
            crate::model::webhook_config::AuthMethod::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [auth_method][crate::model::WebhookConfig::auth_method]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `auth_method` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.auth_method =
            std::option::Option::Some(crate::model::webhook_config::AuthMethod::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for WebhookConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.WebhookConfig"
    }
}

/// Defines additional types related to WebhookConfig
pub mod webhook_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates potential issues with the Secret Manager secret provided by the
    /// user.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The webhook auth configuration not been checked.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The auth configuration is properly setup.
        pub const OK: State = State::new("OK");

        /// The secret provided in auth_method has been deleted.
        pub const SECRET_DELETED: State = State::new("SECRET_DELETED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Auth method specifies how the webhook authenticates with GCP.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthMethod {
        /// Required. Resource name for the secret required as a URL parameter.
        Secret(std::string::String),
    }
}

/// PullRequestFilter contains filter properties for matching GitHub Pull
/// Requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PullRequestFilter {
    /// If CommentControl is enabled, depending on the setting, builds may not
    /// fire until a repository writer comments `/gcbrun` on a pull
    /// request or `/gcbrun` is in the pull request description.
    /// Only PR comments that contain `/gcbrun` will trigger builds.
    ///
    /// If CommentControl is set to disabled, comments with `/gcbrun` from a user
    /// with repository write permission or above will
    /// still trigger builds to run.
    pub comment_control: crate::model::pull_request_filter::CommentControl,

    /// If true, branches that do NOT match the git_ref will trigger a build.
    pub invert_regex: bool,

    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub git_ref: std::option::Option<crate::model::pull_request_filter::GitRef>,
}

impl PullRequestFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [comment_control][crate::model::PullRequestFilter::comment_control].
    pub fn set_comment_control<
        T: std::convert::Into<crate::model::pull_request_filter::CommentControl>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.comment_control = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::PullRequestFilter::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of `git_ref`.
    pub fn set_git_ref<
        T: std::convert::Into<std::option::Option<crate::model::pull_request_filter::GitRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.git_ref = v.into();
        self
    }

    /// The value of [git_ref][crate::model::PullRequestFilter::git_ref]
    /// if it holds a `Branch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_branch(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::pull_request_filter::GitRef::Branch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PullRequestFilter::git_ref]
    /// to hold a `Branch`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref =
            std::option::Option::Some(crate::model::pull_request_filter::GitRef::Branch(v.into()));
        self
    }
}

impl wkt::message::Message for PullRequestFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PullRequestFilter"
    }
}

/// Defines additional types related to PullRequestFilter
pub mod pull_request_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Controls whether or not a `/gcbrun` comment is required from a user with
    /// repository write permission or above in order to
    /// trigger Build runs for pull requests. Pull Request update events differ
    /// between repo types.
    /// Check repo specific guides
    /// ([GitHub](https://cloud.google.com/build/docs/automating-builds/github/build-repos-from-github-enterprise#creating_a_github_enterprise_trigger),
    /// [Bitbucket](https://cloud.google.com/build/docs/automating-builds/bitbucket/build-repos-from-bitbucket-server#creating_a_bitbucket_server_trigger),
    /// [GitLab](https://cloud.google.com/build/docs/automating-builds/gitlab/build-repos-from-gitlab#creating_a_gitlab_trigger)
    /// for details.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CommentControl(std::borrow::Cow<'static, str>);

    impl CommentControl {
        /// Creates a new CommentControl instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CommentControl](CommentControl)
    pub mod comment_control {
        use super::CommentControl;

        /// Do not require `/gcbrun` comments from a user with repository write
        /// permission or above on pull requests before builds are triggered.
        /// Comments that contain `/gcbrun` will still fire builds so this should
        /// be thought of as comments not required.
        pub const COMMENTS_DISABLED: CommentControl = CommentControl::new("COMMENTS_DISABLED");

        /// Builds will only fire in response to pull requests if:
        ///
        /// . The pull request author has repository write permission or above and
        ///   `/gcbrun` is in the PR description.
        /// . A user with repository writer permissions or above comments `/gcbrun`
        ///   on a pull request authored by any user.
        pub const COMMENTS_ENABLED: CommentControl = CommentControl::new("COMMENTS_ENABLED");

        /// Builds will only fire in response to pull requests if:
        ///
        /// . The pull request author is a repository writer or above.
        /// . If the author does not have write permissions, a user with write
        ///   permissions or above must comment `/gcbrun` in order to fire a build.
        pub const COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY: CommentControl =
            CommentControl::new("COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY");
    }

    impl std::convert::From<std::string::String> for CommentControl {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GitRef {
        /// Regex of branches to match.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Branch(std::string::String),
    }
}

/// Push contains filter properties for matching GitHub git pushes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PushFilter {
    /// When true, only trigger a build if the revision regex does NOT match the
    /// git_ref regex.
    pub invert_regex: bool,

    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub git_ref: std::option::Option<crate::model::push_filter::GitRef>,
}

impl PushFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [invert_regex][crate::model::PushFilter::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of `git_ref`.
    pub fn set_git_ref<
        T: std::convert::Into<std::option::Option<crate::model::push_filter::GitRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.git_ref = v.into();
        self
    }

    /// The value of [git_ref][crate::model::PushFilter::git_ref]
    /// if it holds a `Branch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_branch(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::push_filter::GitRef::Branch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [git_ref][crate::model::PushFilter::git_ref]
    /// if it holds a `Tag`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tag(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::push_filter::GitRef::Tag(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref]
    /// to hold a `Branch`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref =
            std::option::Option::Some(crate::model::push_filter::GitRef::Branch(v.into()));
        self
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref]
    /// to hold a `Tag`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref = std::option::Option::Some(crate::model::push_filter::GitRef::Tag(v.into()));
        self
    }
}

impl wkt::message::Message for PushFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PushFilter"
    }
}

/// Defines additional types related to PushFilter
pub mod push_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GitRef {
        /// Regexes matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Branch(std::string::String),
        /// Regexes matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Tag(std::string::String),
    }
}

/// Request to create a new `BuildTrigger`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBuildTriggerRequest {
    /// The parent resource where this trigger will be created.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the project for which to configure automatic builds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. `BuildTrigger` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger: std::option::Option<crate::model::BuildTrigger>,
}

impl CreateBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBuildTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CreateBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::CreateBuildTriggerRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::option::Option<crate::model::BuildTrigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }
}

impl wkt::message::Message for CreateBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateBuildTriggerRequest"
    }
}

/// Returns the `BuildTrigger` with the specified ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBuildTriggerRequest {
    /// The name of the `Trigger` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. ID of the project that owns the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Identifier (`id` or `name`) of the `BuildTrigger` to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,
}

impl GetBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::GetBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for GetBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetBuildTriggerRequest"
    }
}

/// Request to list existing `BuildTriggers`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildTriggersRequest {
    /// The parent of the collection of `Triggers`.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the project for which to list BuildTriggers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListBuildTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBuildTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ListBuildTriggersRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBuildTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBuildTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildTriggersRequest"
    }
}

/// Response containing existing `BuildTriggers`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildTriggersResponse {
    /// `BuildTriggers` for the project, sorted by `create_time` descending.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggers: std::vec::Vec<crate::model::BuildTrigger>,

    /// Token to receive the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListBuildTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBuildTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [triggers][crate::model::ListBuildTriggersResponse::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildTrigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBuildTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildTriggersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBuildTriggersResponse {
    type PageItem = crate::model::BuildTrigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.triggers
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request to delete a `BuildTrigger`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBuildTriggerRequest {
    /// The name of the `Trigger` to delete.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. ID of the project that owns the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. ID of the `BuildTrigger` to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,
}

impl DeleteBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DeleteBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::DeleteBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteBuildTriggerRequest"
    }
}

/// Request to update an existing `BuildTrigger`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBuildTriggerRequest {
    /// Required. ID of the project that owns the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. ID of the `BuildTrigger` to update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_id: std::string::String,

    /// Required. `BuildTrigger` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger: std::option::Option<crate::model::BuildTrigger>,

    /// Update mask for the resource. If this is set,
    /// the server will only update the fields specified in the field mask.
    /// Otherwise, a full update of the mutable resource fields will be performed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::UpdateBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::UpdateBuildTriggerRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::option::Option<crate::model::BuildTrigger>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBuildTriggerRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateBuildTriggerRequest"
    }
}

/// Optional arguments to enable specific features of builds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildOptions {
    /// Requested hash for SourceProvenance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_provenance_hash: std::vec::Vec<crate::model::hash::HashType>,

    /// Requested verifiability options.
    pub requested_verify_option: crate::model::build_options::VerifyOption,

    /// Compute Engine machine type on which to run the build.
    pub machine_type: crate::model::build_options::MachineType,

    /// Requested disk size for the VM that runs the build. Note that this is *NOT*
    /// "disk free"; some of the space will be used by the operating system and
    /// build utilities. Also note that this is the minimum disk size that will be
    /// allocated for the build -- the build may run with a larger disk than
    /// requested. At present, the maximum disk size is 4000GB; builds that request
    /// more than the maximum are rejected with an error.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_size_gb: i64,

    /// Option to specify behavior when there is an error in the substitution
    /// checks.
    ///
    /// NOTE: this is always set to ALLOW_LOOSE for triggered builds and cannot
    /// be overridden in the build configuration file.
    pub substitution_option: crate::model::build_options::SubstitutionOption,

    /// Option to specify whether or not to apply bash style string
    /// operations to the substitutions.
    ///
    /// NOTE: this is always enabled for triggered builds and cannot be
    /// overridden in the build configuration file.
    pub dynamic_substitutions: bool,

    /// Option to include built-in and custom substitutions as env variables
    /// for all build steps.
    pub automap_substitutions: bool,

    /// Option to define build log streaming behavior to Cloud
    /// Storage.
    pub log_streaming_option: crate::model::build_options::LogStreamingOption,

    /// This field deprecated; please use `pool.name` instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// Optional. Specification for execution on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool)
    /// for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pool: std::option::Option<crate::model::build_options::PoolOption>,

    /// Option to specify the logging mode, which determines if and where build
    /// logs are stored.
    pub logging: crate::model::build_options::LoggingMode,

    /// A list of global environment variable definitions that will exist for all
    /// build steps in this build. If a variable is defined in both globally and in
    /// a build step, the variable will use the build step value.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<std::string::String>,

    /// A list of global environment variables, which are encrypted using a Cloud
    /// Key Management Service crypto key. These values must be specified in the
    /// build's `Secret`. These variables will be available to all build steps
    /// in this build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secret_env: std::vec::Vec<std::string::String>,

    /// Global list of volumes to mount for ALL build steps
    ///
    /// Each volume is created as an empty volume prior to starting the build
    /// process. Upon completion of the build, volumes and their contents are
    /// discarded. Global volume names and paths cannot conflict with the volumes
    /// defined a build step.
    ///
    /// Using a global volume in a build with only one step is not valid as
    /// it is indicative of a build request with an incorrect configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. Option to specify how default logs buckets are setup.
    pub default_logs_bucket_behavior: crate::model::build_options::DefaultLogsBucketBehavior,

    /// Optional. Option to specify whether structured logging is enabled.
    ///
    /// If true, JSON-formatted logs are parsed as structured logs.
    pub enable_structured_logging: bool,
}

impl BuildOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_verify_option][crate::model::BuildOptions::requested_verify_option].
    pub fn set_requested_verify_option<
        T: std::convert::Into<crate::model::build_options::VerifyOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_verify_option = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::BuildOptions::machine_type].
    pub fn set_machine_type<T: std::convert::Into<crate::model::build_options::MachineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::BuildOptions::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [substitution_option][crate::model::BuildOptions::substitution_option].
    pub fn set_substitution_option<
        T: std::convert::Into<crate::model::build_options::SubstitutionOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.substitution_option = v.into();
        self
    }

    /// Sets the value of [dynamic_substitutions][crate::model::BuildOptions::dynamic_substitutions].
    pub fn set_dynamic_substitutions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dynamic_substitutions = v.into();
        self
    }

    /// Sets the value of [automap_substitutions][crate::model::BuildOptions::automap_substitutions].
    pub fn set_automap_substitutions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.automap_substitutions = v.into();
        self
    }

    /// Sets the value of [log_streaming_option][crate::model::BuildOptions::log_streaming_option].
    pub fn set_log_streaming_option<
        T: std::convert::Into<crate::model::build_options::LogStreamingOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_streaming_option = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::BuildOptions::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [pool][crate::model::BuildOptions::pool].
    pub fn set_pool<
        T: std::convert::Into<std::option::Option<crate::model::build_options::PoolOption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pool = v.into();
        self
    }

    /// Sets the value of [logging][crate::model::BuildOptions::logging].
    pub fn set_logging<T: std::convert::Into<crate::model::build_options::LoggingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.logging = v.into();
        self
    }

    /// Sets the value of [default_logs_bucket_behavior][crate::model::BuildOptions::default_logs_bucket_behavior].
    pub fn set_default_logs_bucket_behavior<
        T: std::convert::Into<crate::model::build_options::DefaultLogsBucketBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_logs_bucket_behavior = v.into();
        self
    }

    /// Sets the value of [enable_structured_logging][crate::model::BuildOptions::enable_structured_logging].
    pub fn set_enable_structured_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_structured_logging = v.into();
        self
    }

    /// Sets the value of [source_provenance_hash][crate::model::BuildOptions::source_provenance_hash].
    pub fn set_source_provenance_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::hash::HashType>,
    {
        use std::iter::Iterator;
        self.source_provenance_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::BuildOptions::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_env][crate::model::BuildOptions::secret_env].
    pub fn set_secret_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::BuildOptions::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BuildOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOptions"
    }
}

/// Defines additional types related to BuildOptions
pub mod build_options {
    #[allow(unused_imports)]
    use super::*;

    /// Details about how a build should be executed on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool)
    /// for more information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PoolOption {
        /// The `WorkerPool` resource to execute the build on.
        /// You must have `cloudbuild.workerpools.use` on the project hosting the
        /// WorkerPool.
        ///
        /// Format projects/{project}/locations/{location}/workerPools/{workerPoolId}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,
    }

    impl PoolOption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::build_options::PoolOption::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for PoolOption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOptions.PoolOption"
        }
    }

    /// Specifies the manner in which the build should be verified, if at all.
    ///
    /// If a verified build is requested, and any part of the process to generate
    /// and upload provenance fails, the build will also fail.
    ///
    /// If the build does not request verification then that process may occur, but
    /// is not guaranteed to. If it does occur and fails, the build will not fail.
    ///
    /// For more information, see [Viewing Build
    /// Provenance](https://cloud.google.com/build/docs/securing-builds/view-build-provenance).
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VerifyOption(std::borrow::Cow<'static, str>);

    impl VerifyOption {
        /// Creates a new VerifyOption instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [VerifyOption](VerifyOption)
    pub mod verify_option {
        use super::VerifyOption;

        /// Not a verifiable build (the default).
        pub const NOT_VERIFIED: VerifyOption = VerifyOption::new("NOT_VERIFIED");

        /// Build must be verified.
        pub const VERIFIED: VerifyOption = VerifyOption::new("VERIFIED");
    }

    impl std::convert::From<std::string::String> for VerifyOption {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Supported Compute Engine machine types.
    /// For more information, see [Machine
    /// types](https://cloud.google.com/compute/docs/machine-types).
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MachineType(std::borrow::Cow<'static, str>);

    impl MachineType {
        /// Creates a new MachineType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [MachineType](MachineType)
    pub mod machine_type {
        use super::MachineType;

        /// Standard machine type.
        pub const UNSPECIFIED: MachineType = MachineType::new("UNSPECIFIED");

        /// Highcpu machine with 8 CPUs.
        pub const N1_HIGHCPU_8: MachineType = MachineType::new("N1_HIGHCPU_8");

        /// Highcpu machine with 32 CPUs.
        pub const N1_HIGHCPU_32: MachineType = MachineType::new("N1_HIGHCPU_32");

        /// Highcpu e2 machine with 8 CPUs.
        pub const E2_HIGHCPU_8: MachineType = MachineType::new("E2_HIGHCPU_8");

        /// Highcpu e2 machine with 32 CPUs.
        pub const E2_HIGHCPU_32: MachineType = MachineType::new("E2_HIGHCPU_32");

        /// E2 machine with 1 CPU.
        pub const E2_MEDIUM: MachineType = MachineType::new("E2_MEDIUM");
    }

    impl std::convert::From<std::string::String> for MachineType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Specifies the behavior when there is an error in the substitution checks.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SubstitutionOption(std::borrow::Cow<'static, str>);

    impl SubstitutionOption {
        /// Creates a new SubstitutionOption instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SubstitutionOption](SubstitutionOption)
    pub mod substitution_option {
        use super::SubstitutionOption;

        /// Fails the build if error in substitutions checks, like missing
        /// a substitution in the template or in the map.
        pub const MUST_MATCH: SubstitutionOption = SubstitutionOption::new("MUST_MATCH");

        /// Do not fail the build if error in substitutions checks.
        pub const ALLOW_LOOSE: SubstitutionOption = SubstitutionOption::new("ALLOW_LOOSE");
    }

    impl std::convert::From<std::string::String> for SubstitutionOption {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Specifies the behavior when writing build logs to Cloud Storage.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LogStreamingOption(std::borrow::Cow<'static, str>);

    impl LogStreamingOption {
        /// Creates a new LogStreamingOption instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [LogStreamingOption](LogStreamingOption)
    pub mod log_streaming_option {
        use super::LogStreamingOption;

        /// Service may automatically determine build log streaming behavior.
        pub const STREAM_DEFAULT: LogStreamingOption = LogStreamingOption::new("STREAM_DEFAULT");

        /// Build logs should be streamed to Cloud Storage.
        pub const STREAM_ON: LogStreamingOption = LogStreamingOption::new("STREAM_ON");

        /// Build logs should not be streamed to Cloud Storage; they will be
        /// written when the build is completed.
        pub const STREAM_OFF: LogStreamingOption = LogStreamingOption::new("STREAM_OFF");
    }

    impl std::convert::From<std::string::String> for LogStreamingOption {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Specifies the logging mode.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LoggingMode(std::borrow::Cow<'static, str>);

    impl LoggingMode {
        /// Creates a new LoggingMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [LoggingMode](LoggingMode)
    pub mod logging_mode {
        use super::LoggingMode;

        /// The service determines the logging mode. The default is `LEGACY`. Do not
        /// rely on the default logging behavior as it may change in the future.
        pub const LOGGING_UNSPECIFIED: LoggingMode = LoggingMode::new("LOGGING_UNSPECIFIED");

        /// Build logs are stored in Cloud Logging and Cloud Storage.
        pub const LEGACY: LoggingMode = LoggingMode::new("LEGACY");

        /// Build logs are stored in Cloud Storage.
        pub const GCS_ONLY: LoggingMode = LoggingMode::new("GCS_ONLY");

        /// This option is the same as CLOUD_LOGGING_ONLY.
        pub const STACKDRIVER_ONLY: LoggingMode = LoggingMode::new("STACKDRIVER_ONLY");

        /// Build logs are stored in Cloud Logging. Selecting this option will not
        /// allow [logs
        /// streaming](https://cloud.google.com/sdk/gcloud/reference/builds/log).
        pub const CLOUD_LOGGING_ONLY: LoggingMode = LoggingMode::new("CLOUD_LOGGING_ONLY");

        /// Turn off all logging. No build logs will be captured.
        pub const NONE: LoggingMode = LoggingMode::new("NONE");
    }

    impl std::convert::From<std::string::String> for LoggingMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Default Cloud Storage log bucket behavior options.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DefaultLogsBucketBehavior(std::borrow::Cow<'static, str>);

    impl DefaultLogsBucketBehavior {
        /// Creates a new DefaultLogsBucketBehavior instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DefaultLogsBucketBehavior](DefaultLogsBucketBehavior)
    pub mod default_logs_bucket_behavior {
        use super::DefaultLogsBucketBehavior;

        /// Unspecified.
        pub const DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED: DefaultLogsBucketBehavior =
            DefaultLogsBucketBehavior::new("DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED");

        /// Bucket is located in user-owned project in the same region as the
        /// build. The builder service account must have access to create and write
        /// to Cloud Storage buckets in the build project.
        pub const REGIONAL_USER_OWNED_BUCKET: DefaultLogsBucketBehavior =
            DefaultLogsBucketBehavior::new("REGIONAL_USER_OWNED_BUCKET");

        /// Bucket is located in a Google-owned project and is not regionalized.
        pub const LEGACY_BUCKET: DefaultLogsBucketBehavior =
            DefaultLogsBucketBehavior::new("LEGACY_BUCKET");
    }

    impl std::convert::From<std::string::String> for DefaultLogsBucketBehavior {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// ReceiveTriggerWebhookRequest [Experimental] is the request object accepted by
/// the ReceiveTriggerWebhook method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReceiveTriggerWebhookRequest {
    /// The name of the `ReceiveTriggerWebhook` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// HTTP request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<api::model::HttpBody>,

    /// Project in which the specified trigger lives
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Name of the trigger to run the payload against
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger: std::string::String,

    /// Secret token used for authorization if an OAuth token isn't provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret: std::string::String,
}

impl ReceiveTriggerWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReceiveTriggerWebhookRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [body][crate::model::ReceiveTriggerWebhookRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<api::model::HttpBody>>>(
        mut self,
        v: T,
    ) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ReceiveTriggerWebhookRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::ReceiveTriggerWebhookRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::ReceiveTriggerWebhookRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }
}

impl wkt::message::Message for ReceiveTriggerWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ReceiveTriggerWebhookRequest"
    }
}

/// ReceiveTriggerWebhookResponse [Experimental] is the response object for the
/// ReceiveTriggerWebhook method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReceiveTriggerWebhookResponse {}

impl ReceiveTriggerWebhookResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReceiveTriggerWebhookResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ReceiveTriggerWebhookResponse"
    }
}

/// GitHubEnterpriseConfig represents a configuration for a GitHub Enterprise
/// server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEnterpriseConfig {
    /// Optional. The full resource name for the GitHubEnterpriseConfig
    /// For example:
    /// "projects/{$project_id}/locations/{$location_id}/githubEnterpriseConfigs/{$config_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The URL of the github enterprise host the configuration is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_url: std::string::String,

    /// Required. The GitHub app id of the Cloud Build app on the GitHub Enterprise
    /// server.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub app_id: i64,

    /// Output only. Time when the installation was associated with the project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The key that should be attached to webhook calls to the ReceiveWebhook
    /// endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_key: std::string::String,

    /// Optional. The network to be used when reaching out to the GitHub
    /// Enterprise server. The VPC network must be enabled for private
    /// service connection. This should be set if the GitHub Enterprise server is
    /// hosted on-premises and not reachable by public internet.
    /// If this field is left empty, no network peering will occur and calls to
    /// the GitHub Enterprise server will be made over the public internet.
    /// Must be in the format
    /// `projects/{project}/global/networks/{network}`, where {project}
    /// is a project number or id and {network} is the name of a
    /// VPC network in the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peered_network: std::string::String,

    /// Names of secrets in Secret Manager.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secrets: std::option::Option<crate::model::GitHubEnterpriseSecrets>,

    /// Name to display for this config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. SSL certificate to use for requests to GitHub Enterprise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_ca: std::string::String,
}

impl GitHubEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GitHubEnterpriseConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [host_url][crate::model::GitHubEnterpriseConfig::host_url].
    pub fn set_host_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_url = v.into();
        self
    }

    /// Sets the value of [app_id][crate::model::GitHubEnterpriseConfig::app_id].
    pub fn set_app_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GitHubEnterpriseConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [webhook_key][crate::model::GitHubEnterpriseConfig::webhook_key].
    pub fn set_webhook_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_key = v.into();
        self
    }

    /// Sets the value of [peered_network][crate::model::GitHubEnterpriseConfig::peered_network].
    pub fn set_peered_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peered_network = v.into();
        self
    }

    /// Sets the value of [secrets][crate::model::GitHubEnterpriseConfig::secrets].
    pub fn set_secrets<
        T: std::convert::Into<std::option::Option<crate::model::GitHubEnterpriseSecrets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secrets = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::GitHubEnterpriseConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [ssl_ca][crate::model::GitHubEnterpriseConfig::ssl_ca].
    pub fn set_ssl_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_ca = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEnterpriseConfig"
    }
}

/// GitHubEnterpriseSecrets represents the names of all necessary secrets in
/// Secret Manager for a GitHub Enterprise server.
/// Format is: projects/\<project number\>/secrets/\<secret name\>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEnterpriseSecrets {
    /// The resource name for the private key secret version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_key_version_name: std::string::String,

    /// The resource name for the webhook secret secret version in Secret Manager.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_version_name: std::string::String,

    /// The resource name for the OAuth secret secret version in Secret Manager.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oauth_secret_version_name: std::string::String,

    /// The resource name for the OAuth client ID secret version in Secret Manager.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oauth_client_id_version_name: std::string::String,
}

impl GitHubEnterpriseSecrets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key_version_name][crate::model::GitHubEnterpriseSecrets::private_key_version_name].
    pub fn set_private_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_key_version_name = v.into();
        self
    }

    /// Sets the value of [webhook_secret_version_name][crate::model::GitHubEnterpriseSecrets::webhook_secret_version_name].
    pub fn set_webhook_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_version_name = v.into();
        self
    }

    /// Sets the value of [oauth_secret_version_name][crate::model::GitHubEnterpriseSecrets::oauth_secret_version_name].
    pub fn set_oauth_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_secret_version_name = v.into();
        self
    }

    /// Sets the value of [oauth_client_id_version_name][crate::model::GitHubEnterpriseSecrets::oauth_client_id_version_name].
    pub fn set_oauth_client_id_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_client_id_version_name = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseSecrets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEnterpriseSecrets"
    }
}

/// Configuration for a `WorkerPool`.
///
/// Cloud Build owns and maintains a pool of workers for general use and have no
/// access to a project's private network. By default, builds submitted to
/// Cloud Build will use a worker from this pool.
///
/// If your build needs access to resources on a private network,
/// create and use a `WorkerPool` to run your builds. Private `WorkerPool`s give
/// your builds access to any single VPC network that you
/// administer, including any on-prem resources connected to that VPC
/// network. For an overview of private pools, see
/// [Private pools
/// overview](https://cloud.google.com/build/docs/private-pools/private-pools-overview).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkerPool {
    /// Output only. The resource name of the `WorkerPool`, with format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// The value of `{worker_pool}` is provided by `worker_pool_id` in
    /// `CreateWorkerPool` request and the value of `{location}` is determined by
    /// the endpoint accessed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A user-specified, human-readable name for the `WorkerPool`. If provided,
    /// this value must be 1-63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. A unique identifier for the `WorkerPool`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// User specified annotations. See <https://google.aip.dev/128#annotations>
    /// for more details such as format and size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the request to create the `WorkerPool` was
    /// received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the request to update the `WorkerPool` was
    /// received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the request to delete the `WorkerPool` was
    /// received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `WorkerPool` state.
    pub state: crate::model::worker_pool::State,

    /// Output only. Checksum computed by the server. May be sent on update and
    /// delete requests to ensure that the client has an up-to-date value before
    /// proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Configuration for the `WorkerPool`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::worker_pool::Config>,
}

impl WorkerPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkerPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkerPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkerPool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkerPool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::WorkerPool::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkerPool::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::WorkerPool::state].
    pub fn set_state<T: std::convert::Into<crate::model::worker_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::WorkerPool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkerPool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `config`.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::worker_pool::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::WorkerPool::config]
    /// if it holds a `PrivatePoolV1Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_private_pool_v1_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivatePoolV1Config>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::worker_pool::Config::PrivatePoolV1Config(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::WorkerPool::config]
    /// to hold a `PrivatePoolV1Config`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_private_pool_v1_config<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivatePoolV1Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::worker_pool::Config::PrivatePoolV1Config(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkerPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.WorkerPool"
    }
}

/// Defines additional types related to WorkerPool
pub mod worker_pool {
    #[allow(unused_imports)]
    use super::*;

    /// State of the `WorkerPool`.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// State of the `WorkerPool` is unknown.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// `WorkerPool` is being created.
        pub const CREATING: State = State::new("CREATING");

        /// `WorkerPool` is running.
        pub const RUNNING: State = State::new("RUNNING");

        /// `WorkerPool` is being deleted: cancelling builds and draining workers.
        pub const DELETING: State = State::new("DELETING");

        /// `WorkerPool` is deleted.
        pub const DELETED: State = State::new("DELETED");

        /// `WorkerPool` is being updated; new builds cannot be run.
        pub const UPDATING: State = State::new("UPDATING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Configuration for the `WorkerPool`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// Legacy Private Pool configuration.
        PrivatePoolV1Config(std::boxed::Box<crate::model::PrivatePoolV1Config>),
    }
}

/// Configuration for a V1 `PrivatePool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivatePoolV1Config {
    /// Machine configuration for the workers in the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_config: std::option::Option<crate::model::private_pool_v_1_config::WorkerConfig>,

    /// Network configuration for the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::private_pool_v_1_config::NetworkConfig>,

    /// Immutable. Private Service Connect(PSC) Network configuration for the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_service_connect:
        std::option::Option<crate::model::private_pool_v_1_config::PrivateServiceConnect>,
}

impl PrivatePoolV1Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_config][crate::model::PrivatePoolV1Config::worker_config].
    pub fn set_worker_config<
        T: std::convert::Into<
            std::option::Option<crate::model::private_pool_v_1_config::WorkerConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.worker_config = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::PrivatePoolV1Config::network_config].
    pub fn set_network_config<
        T: std::convert::Into<
            std::option::Option<crate::model::private_pool_v_1_config::NetworkConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [private_service_connect][crate::model::PrivatePoolV1Config::private_service_connect].
    pub fn set_private_service_connect<
        T: std::convert::Into<
            std::option::Option<crate::model::private_pool_v_1_config::PrivateServiceConnect>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_service_connect = v.into();
        self
    }
}

impl wkt::message::Message for PrivatePoolV1Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config"
    }
}

/// Defines additional types related to PrivatePoolV1Config
pub mod private_pool_v_1_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the configuration to be used for creating workers in
    /// the pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WorkerConfig {
        /// Machine type of a worker, such as `e2-medium`.
        /// See [Worker pool config
        /// file](https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema).
        /// If left blank, Cloud Build will use a sensible default.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub machine_type: std::string::String,

        /// Size of the disk attached to the worker, in GB.
        /// See [Worker pool config
        /// file](https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema).
        /// Specify a value of up to 2000. If `0` is specified, Cloud Build will use
        /// a standard disk size.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub disk_size_gb: i64,
    }

    impl WorkerConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::private_pool_v_1_config::WorkerConfig::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [disk_size_gb][crate::model::private_pool_v_1_config::WorkerConfig::disk_size_gb].
        pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.disk_size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for WorkerConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.WorkerConfig"
        }
    }

    /// Defines the network configuration for the pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// Required. Immutable. The network definition that the workers are peered
        /// to. If this section is left empty, the workers will be peered to
        /// `WorkerPool.project_id` on the service producer network. Must be in the
        /// format `projects/{project}/global/networks/{network}`, where `{project}`
        /// is a project number, such as `12345`, and `{network}` is the name of a
        /// VPC network in the project. See
        /// [Understanding network configuration
        /// options](https://cloud.google.com/build/docs/private-pools/set-up-private-pool-environment)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub peered_network: std::string::String,

        /// Option to configure network egress for the workers.
        pub egress_option: crate::model::private_pool_v_1_config::network_config::EgressOption,

        /// Immutable. Subnet IP range within the peered network. This is specified
        /// in CIDR notation with a slash and the subnet prefix size. You can
        /// optionally specify an IP address before the subnet prefix value. e.g.
        /// `192.168.0.0/29` would specify an IP range starting at 192.168.0.0 with a
        /// prefix size of 29 bits.
        /// `/16` would specify a prefix size of 16 bits, with an automatically
        /// determined IP within the peered VPC.
        /// If unspecified, a value of `/24` will be used.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub peered_network_ip_range: std::string::String,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peered_network][crate::model::private_pool_v_1_config::NetworkConfig::peered_network].
        pub fn set_peered_network<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network = v.into();
            self
        }

        /// Sets the value of [egress_option][crate::model::private_pool_v_1_config::NetworkConfig::egress_option].
        pub fn set_egress_option<
            T: std::convert::Into<crate::model::private_pool_v_1_config::network_config::EgressOption>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.egress_option = v.into();
            self
        }

        /// Sets the value of [peered_network_ip_range][crate::model::private_pool_v_1_config::NetworkConfig::peered_network_ip_range].
        pub fn set_peered_network_ip_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network_ip_range = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.NetworkConfig"
        }
    }

    /// Defines additional types related to NetworkConfig
    pub mod network_config {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the egress option for the pool.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct EgressOption(std::borrow::Cow<'static, str>);

        impl EgressOption {
            /// Creates a new EgressOption instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [EgressOption](EgressOption)
        pub mod egress_option {
            use super::EgressOption;

            /// If set, defaults to PUBLIC_EGRESS.
            pub const EGRESS_OPTION_UNSPECIFIED: EgressOption =
                EgressOption::new("EGRESS_OPTION_UNSPECIFIED");

            /// If set, workers are created without any public address, which prevents
            /// network egress to public IPs unless a network proxy is configured.
            pub const NO_PUBLIC_EGRESS: EgressOption = EgressOption::new("NO_PUBLIC_EGRESS");

            /// If set, workers are created with a public address which allows for
            /// public internet egress.
            pub const PUBLIC_EGRESS: EgressOption = EgressOption::new("PUBLIC_EGRESS");
        }

        impl std::convert::From<std::string::String> for EgressOption {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Defines the Private Service Connect network configuration for the pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrivateServiceConnect {
        /// Required. Immutable. The network attachment that the worker network
        /// interface is peered to. Must be in the format
        /// `projects/{project}/regions/{region}/networkAttachments/{networkAttachment}`.
        /// The region of network attachment must be the same as the worker pool.
        /// See [Network
        /// Attachments](https://cloud.google.com/vpc/docs/about-network-attachments)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network_attachment: std::string::String,

        /// Required. Immutable. Disable public IP on the primary network interface.
        ///
        /// If true, workers are created without any public address, which prevents
        /// network egress to public IPs unless a network proxy is configured.
        /// If false, workers are created with a public address which allows for
        /// public internet egress. The public address only applies to traffic
        /// through the primary network interface.
        /// If `route_all_traffic` is set to true, all traffic will go through the
        /// non-primary network interface, this boolean has no effect.
        pub public_ip_address_disabled: bool,

        /// Immutable. Route all traffic through PSC interface. Enable this if you
        /// want full control of traffic in the private pool. Configure Cloud NAT for
        /// the subnet of network attachment if you need to access public Internet.
        ///
        /// If false, Only route private IPs, e.g. 10.0.0.0/8, 172.16.0.0/12, and
        /// 192.168.0.0/16 through PSC interface.
        pub route_all_traffic: bool,
    }

    impl PrivateServiceConnect {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_attachment][crate::model::private_pool_v_1_config::PrivateServiceConnect::network_attachment].
        pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_attachment = v.into();
            self
        }

        /// Sets the value of [public_ip_address_disabled][crate::model::private_pool_v_1_config::PrivateServiceConnect::public_ip_address_disabled].
        pub fn set_public_ip_address_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.public_ip_address_disabled = v.into();
            self
        }

        /// Sets the value of [route_all_traffic][crate::model::private_pool_v_1_config::PrivateServiceConnect::route_all_traffic].
        pub fn set_route_all_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.route_all_traffic = v.into();
            self
        }
    }

    impl wkt::message::Message for PrivateServiceConnect {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.PrivateServiceConnect"
        }
    }
}

/// Request to create a new `WorkerPool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkerPoolRequest {
    /// Required. The parent resource where this worker pool will be created.
    /// Format: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. `WorkerPool` resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_pool: std::option::Option<crate::model::WorkerPool>,

    /// Required. Immutable. The ID to use for the `WorkerPool`, which will become
    /// the final component of the resource name.
    ///
    /// This value should be 1-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool_id: std::string::String,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    pub validate_only: bool,
}

impl CreateWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkerPoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::CreateWorkerPoolRequest::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::option::Option<crate::model::WorkerPool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [worker_pool_id][crate::model::CreateWorkerPoolRequest::worker_pool_id].
    pub fn set_worker_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateWorkerPoolRequest"
    }
}

/// Request to get a `WorkerPool` with the specified name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to retrieve.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkerPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetWorkerPoolRequest"
    }
}

/// Request to delete a `WorkerPool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, it must match the server's etag on the workerpool
    /// for the request to be processed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// If set to true, and the `WorkerPool` is not found, the request will succeed
    /// but no action will be taken on the server.
    pub allow_missing: bool,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    pub validate_only: bool,
}

impl DeleteWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkerPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkerPoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteWorkerPoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteWorkerPoolRequest"
    }
}

/// Request to update a `WorkerPool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkerPoolRequest {
    /// Required. The `WorkerPool` to update.
    ///
    /// The `name` field is used to identify the `WorkerPool` to update.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_pool: std::option::Option<crate::model::WorkerPool>,

    /// A mask specifying which fields in `worker_pool` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    pub validate_only: bool,
}

impl UpdateWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::UpdateWorkerPoolRequest::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::option::Option<crate::model::WorkerPool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkerPoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateWorkerPoolRequest"
    }
}

/// Request to list `WorkerPool`s.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkerPoolsRequest {
    /// Required. The parent of the collection of `WorkerPools`.
    /// Format: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of `WorkerPool`s to return. The service may return
    /// fewer than this value. If omitted, the server will use a sensible default.
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkerPools` call. Provide this
    /// to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListWorkerPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkerPoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkerPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkerPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkerPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListWorkerPoolsRequest"
    }
}

/// Response containing existing `WorkerPools`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkerPoolsResponse {
    /// `WorkerPools` for the specified project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub worker_pools: std::vec::Vec<crate::model::WorkerPool>,

    /// Continuation token used to page through large result sets. Provide this
    /// value in a subsequent ListWorkerPoolsRequest to return the next page of
    /// results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListWorkerPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkerPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [worker_pools][crate::model::ListWorkerPoolsResponse::worker_pools].
    pub fn set_worker_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkerPool>,
    {
        use std::iter::Iterator;
        self.worker_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkerPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListWorkerPoolsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListWorkerPoolsResponse {
    type PageItem = crate::model::WorkerPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.worker_pools
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Metadata for the `CreateWorkerPool` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` to create.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,
}

impl CreateWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::CreateWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::CreateWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.complete_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateWorkerPoolOperationMetadata"
    }
}

/// Metadata for the `UpdateWorkerPool` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being updated.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,
}

impl UpdateWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::UpdateWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UpdateWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::UpdateWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.complete_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateWorkerPoolOperationMetadata"
    }
}

/// Metadata for the `DeleteWorkerPool` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,
}

impl DeleteWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::DeleteWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::DeleteWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.complete_time = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteWorkerPoolOperationMetadata"
    }
}
