// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Specifies a build to retry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryBuildRequest {
    /// The name of the `Build` to retry.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. Build ID of the original build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetryBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RetryBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::RetryBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for RetryBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RetryBuildRequest"
    }
}

/// Specifies a build trigger to run and the source to use.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunBuildTriggerRequest {
    /// The name of the `Trigger` to run.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. ID of the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trigger_id: std::string::String,

    /// Source to build against this trigger.
    /// Branch and tag names cannot consist of regular expressions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::RepoSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RunBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::RunBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::RunBuildTriggerRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::RunBuildTriggerRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RunBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RunBuildTriggerRequest"
    }
}

/// Location of the source in an archive file in Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageSource {
    /// Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub bucket: std::string::String,

    /// Cloud Storage object containing the source.
    ///
    /// This object must be a zipped (`.zip`) or gzipped archive file (`.tar.gz`)
    /// containing source to build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub object: std::string::String,

    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub generation: i64,

    /// Option to specify the tool to fetch the source file for the build.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub source_fetcher: crate::model::storage_source::SourceFetcher,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSource::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSource::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [source_fetcher][crate::model::StorageSource::source_fetcher].
    pub fn set_source_fetcher<
        T: std::convert::Into<crate::model::storage_source::SourceFetcher>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_fetcher = v.into();
        self
    }
}

impl wkt::message::Message for StorageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.StorageSource"
    }
}

/// Defines additional types related to [StorageSource].
pub mod storage_source {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the tool to fetch the source file for the build.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceFetcher {
        /// Unspecified. Defaults to GSUTIL.
        Unspecified,
        /// Use the "gsutil" tool to download the source file.
        Gsutil,
        /// Use the Cloud Storage Fetcher tool to download the source file.
        GcsFetcher,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceFetcher::value] or
        /// [SourceFetcher::name].
        UnknownValue(source_fetcher::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_fetcher {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceFetcher {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gsutil => std::option::Option::Some(1),
                Self::GcsFetcher => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_FETCHER_UNSPECIFIED"),
                Self::Gsutil => std::option::Option::Some("GSUTIL"),
                Self::GcsFetcher => std::option::Option::Some("GCS_FETCHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceFetcher {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceFetcher {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceFetcher {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gsutil,
                2 => Self::GcsFetcher,
                _ => Self::UnknownValue(source_fetcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceFetcher {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_FETCHER_UNSPECIFIED" => Self::Unspecified,
                "GSUTIL" => Self::Gsutil,
                "GCS_FETCHER" => Self::GcsFetcher,
                _ => Self::UnknownValue(source_fetcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceFetcher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gsutil => serializer.serialize_i32(1),
                Self::GcsFetcher => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceFetcher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceFetcher>::new(
                ".google.devtools.cloudbuild.v1.StorageSource.SourceFetcher",
            ))
        }
    }
}

/// Location of the source in any accessible Git repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitSource {
    /// Location of the Git repo to build.
    ///
    /// This will be used as a `git remote`, see
    /// <https://git-scm.com/docs/git-remote>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub url: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dir: std::string::String,

    /// The revision to fetch from the Git repository such as a branch, a tag, a
    /// commit SHA, or any Git ref.
    ///
    /// Cloud Build uses `git fetch` to fetch the revision from the Git
    /// repository; therefore make sure that the string you provide for `revision`
    /// is parsable  by the command. For information on string values accepted by
    /// `git fetch`, see
    /// <https://git-scm.com/docs/gitrevisions#_specifying_revisions>. For
    /// information on `git fetch`, see <https://git-scm.com/docs/git-fetch>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub revision: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::GitSource::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::GitSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GitSource::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }
}

impl wkt::message::Message for GitSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitSource"
    }
}

/// Location of the source in a Google Cloud Source Repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepoSource {
    /// ID of the project that owns the Cloud Source Repository. If omitted, the
    /// project ID requesting the build is assumed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Name of the Cloud Source Repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub repo_name: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dir: std::string::String,

    /// Only trigger a build if the revision regex does NOT match the revision
    /// regex.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub invert_regex: bool,

    /// Substitutions to use in a triggered build.
    /// Should only be used with RunBuildTrigger
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub revision: std::option::Option<crate::model::repo_source::Revision>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RepoSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::RepoSource::repo_name].
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::RepoSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::RepoSource::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::RepoSource::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::repo_source::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `BranchName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::BranchName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `BranchName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_branch_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::BranchName(v.into()));
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `TagName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::TagName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `TagName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_tag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::TagName(v.into()));
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `CommitSha`, `None` if the field is not set or
    /// holds a different branch.
    pub fn commit_sha(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::CommitSha(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `CommitSha`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::CommitSha(v.into()));
        self
    }
}

impl wkt::message::Message for RepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RepoSource"
    }
}

/// Defines additional types related to [RepoSource].
pub mod repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Revision {
        /// Regex matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        BranchName(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// Regex matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        TagName(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// Explicit commit SHA to build.
        CommitSha(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// Location of the source manifest in Cloud Storage.
/// This feature is in Preview; see description
/// [here](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageSourceManifest {
    /// Cloud Storage bucket containing the source manifest (see [Bucket
    /// Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub bucket: std::string::String,

    /// Cloud Storage object containing the source manifest.
    ///
    /// This object must be a JSON file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub object: std::string::String,

    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub generation: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSourceManifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSourceManifest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSourceManifest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSourceManifest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }
}

impl wkt::message::Message for StorageSourceManifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.StorageSourceManifest"
    }
}

/// Location of the source in a supported storage service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Source {
    /// Location of source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::source::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::Source::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::source::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source::Source::StorageSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `RepoSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repo_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::RepoSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::RepoSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `RepoSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repo_source<T: std::convert::Into<std::boxed::Box<crate::model::RepoSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::RepoSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GitSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::GitSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git_source<T: std::convert::Into<std::boxed::Box<crate::model::GitSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::GitSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSourceManifest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source_manifest(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSourceManifest>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSourceManifest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSourceManifest`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source_manifest<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSourceManifest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::source::Source::StorageSourceManifest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Source"
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    /// Location of source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// If provided, get the source from this location in Cloud Storage.
        StorageSource(std::boxed::Box<crate::model::StorageSource>),
        /// If provided, get the source from this location in a Cloud Source
        /// Repository.
        RepoSource(std::boxed::Box<crate::model::RepoSource>),
        /// If provided, get the source from this Git repository.
        GitSource(std::boxed::Box<crate::model::GitSource>),
        /// If provided, get the source from this manifest in Cloud Storage.
        /// This feature is in Preview; see description
        /// [here](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher).
        StorageSourceManifest(std::boxed::Box<crate::model::StorageSourceManifest>),
    }
}

/// An image built by the pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuiltImage {
    /// Name used to push the container image to Google Container Registry, as
    /// presented to `docker push`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Docker Registry 2.0 digest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub digest: std::string::String,

    /// Output only. Stores timing information for pushing the specified image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuiltImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuiltImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::BuiltImage::digest].
    pub fn set_digest<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.digest = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::BuiltImage::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::BuiltImage::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuiltImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuiltImage"
    }
}

/// Artifact uploaded using the PythonPackage directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedPythonPackage {
    /// URI of the uploaded artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// Hash types and values of the Python Artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedPythonPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedPythonPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedPythonPackage::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedPythonPackage::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedPythonPackage::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedPythonPackage::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedPythonPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedPythonPackage"
    }
}

/// A Maven artifact uploaded using the MavenArtifact directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedMavenArtifact {
    /// URI of the uploaded artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// Hash types and values of the Maven Artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedMavenArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedMavenArtifact::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedMavenArtifact::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedMavenArtifact::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedMavenArtifact::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedMavenArtifact::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedMavenArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedMavenArtifact"
    }
}

/// A Go module artifact uploaded to Artifact Registry using the GoModule
/// directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedGoModule {
    /// URI of the uploaded artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// Hash types and values of the Go Module Artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedGoModule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedGoModule::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedGoModule::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedGoModule::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedGoModule::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedGoModule::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedGoModule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedGoModule"
    }
}

/// An npm package uploaded to Artifact Registry using the NpmPackage
/// directive.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadedNpmPackage {
    /// URI of the uploaded npm package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// Hash types and values of the npm package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedNpmPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedNpmPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedNpmPackage::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedNpmPackage::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedNpmPackage::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedNpmPackage::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedNpmPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedNpmPackage"
    }
}

/// A step in the build pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildStep {
    /// Required. The name of the container image that will run this particular
    /// build step.
    ///
    /// If the image is available in the host's Docker daemon's cache, it
    /// will be run directly. If not, the host will attempt to pull the image
    /// first, using the builder service account's credentials if necessary.
    ///
    /// The Docker daemon's cache will already have the latest versions of all of
    /// the officially supported build steps
    /// ([<https://github.com/GoogleCloudPlatform/cloud-builders>](https://github.com/GoogleCloudPlatform/cloud-builders)).
    /// The Docker daemon will also have cached many of the layers for some popular
    /// images, like "ubuntu", "debian", but they will be refreshed at the time you
    /// attempt to use them.
    ///
    /// If you built an image in a previous build step, it will be stored in the
    /// host's Docker daemon's cache and is available to use as the name for a
    /// later build step.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// A list of environment variable definitions to be used when running a step.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub env: std::vec::Vec<std::string::String>,

    /// A list of arguments that will be presented to the step when it is started.
    ///
    /// If the image used to run the step's container has an entrypoint, the `args`
    /// are used as arguments to that entrypoint. If the image does not define
    /// an entrypoint, the first element in args is used as the entrypoint,
    /// and the remainder will be used as arguments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub args: std::vec::Vec<std::string::String>,

    /// Working directory to use when running this step's container.
    ///
    /// If this value is a relative path, it is relative to the build's working
    /// directory. If this value is absolute, it may be outside the build's working
    /// directory, in which case the contents of the path may not be persisted
    /// across build step executions, unless a `volume` for that path is specified.
    ///
    /// If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
    /// which specifies an absolute path, the `RepoSource` `dir` is ignored for
    /// the step's execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dir: std::string::String,

    /// Unique identifier for this build step, used in `wait_for` to
    /// reference this build step as a dependency.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in `wait_for`
    /// have completed successfully. If `wait_for` is empty, this build step will
    /// start when all previous build steps in the `Build.Steps` list have
    /// completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub wait_for: std::vec::Vec<std::string::String>,

    /// Entrypoint to be used instead of the build step image's default entrypoint.
    /// If unset, the image's default entrypoint is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub entrypoint: std::string::String,

    /// A list of environment variables which are encrypted using a Cloud Key
    /// Management Service crypto key. These values must be specified in the
    /// build's `Secret`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub secret_env: std::vec::Vec<std::string::String>,

    /// List of volumes to mount into the build step.
    ///
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents are
    /// discarded.
    ///
    /// Using a named volume in only one step is not valid as it is indicative
    /// of a build request with an incorrect configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Output only. Stores timing information for executing this build step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timing: std::option::Option<crate::model::TimeSpan>,

    /// Output only. Stores timing information for pulling this build step's
    /// builder image only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pull_timing: std::option::Option<crate::model::TimeSpan>,

    /// Time limit for executing this build step. If not defined, the step has no
    /// time limit and will be allowed to continue to run until either it completes
    /// or the build itself times out.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Output only. Status of the build step. At this time, build step status is
    /// only updated on build completion; step status is not updated in real-time
    /// as the build progresses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status: crate::model::build::Status,

    /// Allow this build step to fail without failing the entire build.
    ///
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failure_detail field.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_failure: bool,

    /// Output only. Return code from running the step.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub exit_code: i32,

    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes. If allow_failure
    /// is also specified, this field will take precedence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<wkt::internal::I32>>")]
    pub allow_exit_codes: std::vec::Vec<i32>,

    /// A shell script to be executed in the step.
    ///
    /// When script is provided, the user cannot specify the entrypoint or args.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub script: std::string::String,

    /// Option to include built-in and custom substitutions as env variables
    /// for this build step. This option will override the global option
    /// in BuildOption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automap_substitutions: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuildStep::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::BuildStep::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::BuildStep::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dir][crate::model::BuildStep::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BuildStep::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait_for][crate::model::BuildStep::wait_for].
    pub fn set_wait_for<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.wait_for = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entrypoint][crate::model::BuildStep::entrypoint].
    pub fn set_entrypoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entrypoint = v.into();
        self
    }

    /// Sets the value of [secret_env][crate::model::BuildStep::secret_env].
    pub fn set_secret_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::BuildStep::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timing][crate::model::BuildStep::timing].
    pub fn set_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timing][crate::model::BuildStep::timing].
    pub fn set_or_clear_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pull_timing][crate::model::BuildStep::pull_timing].
    pub fn set_pull_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.pull_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pull_timing][crate::model::BuildStep::pull_timing].
    pub fn set_or_clear_pull_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.pull_timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::BuildStep::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::BuildStep::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::BuildStep::status].
    pub fn set_status<T: std::convert::Into<crate::model::build::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [allow_failure][crate::model::BuildStep::allow_failure].
    pub fn set_allow_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_failure = v.into();
        self
    }

    /// Sets the value of [exit_code][crate::model::BuildStep::exit_code].
    pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.exit_code = v.into();
        self
    }

    /// Sets the value of [allow_exit_codes][crate::model::BuildStep::allow_exit_codes].
    pub fn set_allow_exit_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.allow_exit_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [script][crate::model::BuildStep::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }

    /// Sets the value of [automap_substitutions][crate::model::BuildStep::automap_substitutions].
    pub fn set_automap_substitutions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automap_substitutions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automap_substitutions][crate::model::BuildStep::automap_substitutions].
    pub fn set_or_clear_automap_substitutions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automap_substitutions = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildStep"
    }
}

/// Volume describes a Docker container volume which is mounted into build steps
/// in order to persist files across build step execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Name of the volume to mount.
    ///
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Path at which to mount the volume.
    ///
    /// Paths must be absolute and cannot conflict with other volume paths on the
    /// same build step or with certain reserved volume paths.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Volume::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Volume"
    }
}

/// Artifacts created by the build pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Results {
    /// Container images that were built as a part of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub images: std::vec::Vec<crate::model::BuiltImage>,

    /// List of build step digests, in the order corresponding to build step
    /// indices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub build_step_images: std::vec::Vec<std::string::String>,

    /// Path to the artifact manifest for non-container artifacts uploaded to Cloud
    /// Storage. Only populated when artifacts are uploaded to Cloud Storage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub artifact_manifest: std::string::String,

    /// Number of non-container artifacts uploaded to Cloud Storage. Only populated
    /// when artifacts are uploaded to Cloud Storage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub num_artifacts: i64,

    /// List of build step outputs, produced by builder images, in the order
    /// corresponding to build step indices.
    ///
    /// [Cloud Builders](https://cloud.google.com/cloud-build/docs/cloud-builders)
    /// can produce this output by writing to `$BUILDER_OUTPUT/output`. Only the
    /// first 50KB of data is stored. Note that the `$BUILDER_OUTPUT` variable is
    /// read-only and can't be substituted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<serde_with::base64::Base64>>")]
    pub build_step_outputs: std::vec::Vec<::bytes::Bytes>,

    /// Time to push all non-container artifacts to Cloud Storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact_timing: std::option::Option<crate::model::TimeSpan>,

    /// Python artifacts uploaded to Artifact Registry at the end of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub python_packages: std::vec::Vec<crate::model::UploadedPythonPackage>,

    /// Maven artifacts uploaded to Artifact Registry at the end of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub maven_artifacts: std::vec::Vec<crate::model::UploadedMavenArtifact>,

    /// Optional. Go module artifacts uploaded to Artifact Registry at the end of
    /// the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub go_modules: std::vec::Vec<crate::model::UploadedGoModule>,

    /// Npm packages uploaded to Artifact Registry at the end of the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub npm_packages: std::vec::Vec<crate::model::UploadedNpmPackage>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Results {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [images][crate::model::Results::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuiltImage>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [build_step_images][crate::model::Results::build_step_images].
    pub fn set_build_step_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_step_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [artifact_manifest][crate::model::Results::artifact_manifest].
    pub fn set_artifact_manifest<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_manifest = v.into();
        self
    }

    /// Sets the value of [num_artifacts][crate::model::Results::num_artifacts].
    pub fn set_num_artifacts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.num_artifacts = v.into();
        self
    }

    /// Sets the value of [build_step_outputs][crate::model::Results::build_step_outputs].
    pub fn set_build_step_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.build_step_outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [artifact_timing][crate::model::Results::artifact_timing].
    pub fn set_artifact_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.artifact_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [artifact_timing][crate::model::Results::artifact_timing].
    pub fn set_or_clear_artifact_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.artifact_timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [python_packages][crate::model::Results::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedPythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::Results::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedMavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [go_modules][crate::model::Results::go_modules].
    pub fn set_go_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedGoModule>,
    {
        use std::iter::Iterator;
        self.go_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [npm_packages][crate::model::Results::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedNpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Results {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Results"
    }
}

/// An artifact that was uploaded during a build. This
/// is a single record in the artifact manifest JSON file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ArtifactResult {
    /// The path of an artifact in a Cloud Storage bucket, with the
    /// generation number. For example,
    /// `gs://mybucket/path/to/output.jar#generation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub location: std::string::String,

    /// The file hash of the artifact.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub file_hash: std::vec::Vec<crate::model::FileHashes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ArtifactResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ArtifactResult::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [file_hash][crate::model::ArtifactResult::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ArtifactResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ArtifactResult"
    }
}

/// A build resource in the Cloud Build API.
///
/// At a high level, a `Build` describes where to find source code, how to build
/// it (for example, the builder image to run on the source), and where to store
/// the built artifacts.
///
/// Fields can include the following variables, which will be expanded when the
/// build is created:
///
/// - $PROJECT_ID: the project ID of the build.
/// - $PROJECT_NUMBER: the project number of the build.
/// - $LOCATION: the location/region of the build.
/// - $BUILD_ID: the autogenerated ID of the build.
/// - $REPO_NAME: the source repository name specified by RepoSource.
/// - $BRANCH_NAME: the branch name specified by RepoSource.
/// - $TAG_NAME: the tag name specified by RepoSource.
/// - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or
///   resolved from the specified branch or tag.
/// - $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Build {
    /// Output only. The 'Build' name with format:
    /// `projects/{project}/locations/{location}/builds/{build}`, where {build}
    /// is a unique identifier generated by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Output only. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Output only. Status of the build.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status: crate::model::build::Status,

    /// Output only. Customer-readable message about the current status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status_detail: std::string::String,

    /// The location of the source files to build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// Required. The operations to be performed on the workspace.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub steps: std::vec::Vec<crate::model::BuildStep>,

    /// Output only. Results of the build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub results: std::option::Option<crate::model::Results>,

    /// Output only. Time at which the request to create the build was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which execution of the build was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which execution of the build was finished.
    ///
    /// The difference between finish_time and start_time is the duration of the
    /// build's execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Amount of time that this build should be allowed to run, to second
    /// granularity. If this amount of time elapses, work on the build will cease
    /// and the build status will be `TIMEOUT`.
    ///
    /// `timeout` starts ticking from `startTime`.
    ///
    /// Default time is 60 minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images are pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the `Build` resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build status is marked
    /// `FAILURE`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub images: std::vec::Vec<std::string::String>,

    /// TTL in queue for this build. If provided and the build is enqueued longer
    /// than this value, the build will expire and the build status will be
    /// `EXPIRED`.
    ///
    /// The TTL starts ticking from create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queue_ttl: std::option::Option<wkt::Duration>,

    /// Artifacts produced by the build that should be uploaded upon
    /// successful completion of all build steps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifacts: std::option::Option<crate::model::Artifacts>,

    /// Cloud Storage bucket where logs should be written (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    /// Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub logs_bucket: std::string::String,

    /// Output only. A permanent fixed identifier for source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_provenance: std::option::Option<crate::model::SourceProvenance>,

    /// Output only. The ID of the `BuildTrigger` that triggered this build, if it
    /// was triggered automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub build_trigger_id: std::string::String,

    /// Special options for this build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub options: std::option::Option<crate::model::BuildOptions>,

    /// Output only. URL to logs for this build in Google Cloud Console.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub log_url: std::string::String,

    /// Substitutions data for `Build` resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Tags for annotation of a `Build`. These are not docker tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Secrets to decrypt using Cloud Key Management Service.
    /// Note: Secret Manager is the recommended technique
    /// for managing sensitive data with Cloud Build. Use `available_secrets` to
    /// configure builds to access secrets from Secret Manager. For instructions,
    /// see: <https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub secrets: std::vec::Vec<crate::model::Secret>,

    /// Output only. Stores timing information for phases of the build. Valid keys
    /// are:
    ///
    /// * BUILD: time to execute all build steps.
    /// * PUSH: time to push all artifacts including docker images and non docker
    ///   artifacts.
    /// * FETCHSOURCE: time to fetch source.
    /// * SETUPBUILD: time to set up build.
    ///
    /// If the build does not specify source or images,
    /// these keys will not be included.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub timing: std::collections::HashMap<std::string::String, crate::model::TimeSpan>,

    /// Output only. Describes this build's approval configuration, status,
    /// and result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval: std::option::Option<crate::model::BuildApproval>,

    /// IAM service account whose credentials will be used at build runtime.
    /// Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
    /// ACCOUNT can be email address or uniqueId of the service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Secrets and secret environment variables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub available_secrets: std::option::Option<crate::model::Secrets>,

    /// Output only. Non-fatal problems encountered during the execution of the
    /// build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub warnings: std::vec::Vec<crate::model::build::Warning>,

    /// Optional. Configuration for git operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub git_config: std::option::Option<crate::model::GitConfig>,

    /// Output only. Contains information about the build when status=FAILURE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failure_info: std::option::Option<crate::model::build::FailureInfo>,

    /// Optional. Dependencies that the Cloud Build worker will fetch before
    /// executing user steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub dependencies: std::vec::Vec<crate::model::Dependency>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Build {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Build::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Build::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Build::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Build::status].
    pub fn set_status<T: std::convert::Into<crate::model::build::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::Build::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Build::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::Build::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [steps][crate::model::Build::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [results][crate::model::Build::results].
    pub fn set_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Results>,
    {
        self.results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [results][crate::model::Build::results].
    pub fn set_or_clear_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Results>,
    {
        self.results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Build::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Build::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Build::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Build::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::Build::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::Build::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::Build::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::Build::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [images][crate::model::Build::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [queue_ttl][crate::model::Build::queue_ttl].
    pub fn set_queue_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.queue_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue_ttl][crate::model::Build::queue_ttl].
    pub fn set_or_clear_queue_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.queue_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [artifacts][crate::model::Build::artifacts].
    pub fn set_artifacts<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Artifacts>,
    {
        self.artifacts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [artifacts][crate::model::Build::artifacts].
    pub fn set_or_clear_artifacts<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Artifacts>,
    {
        self.artifacts = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logs_bucket][crate::model::Build::logs_bucket].
    pub fn set_logs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logs_bucket = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::Build::source_provenance].
    pub fn set_source_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceProvenance>,
    {
        self.source_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_provenance][crate::model::Build::source_provenance].
    pub fn set_or_clear_source_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceProvenance>,
    {
        self.source_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_trigger_id][crate::model::Build::build_trigger_id].
    pub fn set_build_trigger_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_trigger_id = v.into();
        self
    }

    /// Sets the value of [options][crate::model::Build::options].
    pub fn set_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildOptions>,
    {
        self.options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [options][crate::model::Build::options].
    pub fn set_or_clear_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildOptions>,
    {
        self.options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_url][crate::model::Build::log_url].
    pub fn set_log_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_url = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::Build::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Build::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secrets][crate::model::Build::secrets].
    pub fn set_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Secret>,
    {
        use std::iter::Iterator;
        self.secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timing][crate::model::Build::timing].
    pub fn set_timing<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TimeSpan>,
    {
        use std::iter::Iterator;
        self.timing = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [approval][crate::model::Build::approval].
    pub fn set_approval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildApproval>,
    {
        self.approval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval][crate::model::Build::approval].
    pub fn set_or_clear_approval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildApproval>,
    {
        self.approval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::Build::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [available_secrets][crate::model::Build::available_secrets].
    pub fn set_available_secrets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secrets>,
    {
        self.available_secrets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_secrets][crate::model::Build::available_secrets].
    pub fn set_or_clear_available_secrets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secrets>,
    {
        self.available_secrets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warnings][crate::model::Build::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::build::Warning>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [git_config][crate::model::Build::git_config].
    pub fn set_git_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitConfig>,
    {
        self.git_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_config][crate::model::Build::git_config].
    pub fn set_or_clear_git_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitConfig>,
    {
        self.git_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failure_info][crate::model::Build::failure_info].
    pub fn set_failure_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::build::FailureInfo>,
    {
        self.failure_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failure_info][crate::model::Build::failure_info].
    pub fn set_or_clear_failure_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::build::FailureInfo>,
    {
        self.failure_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dependencies][crate::model::Build::dependencies].
    pub fn set_dependencies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dependency>,
    {
        use std::iter::Iterator;
        self.dependencies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Build {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Build"
    }
}

/// Defines additional types related to [Build].
pub mod build {
    #[allow(unused_imports)]
    use super::*;

    /// A non-fatal problem encountered during the execution of the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Warning {
        /// Explanation of the warning generated.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub text: std::string::String,

        /// The priority for this warning.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub priority: crate::model::build::warning::Priority,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::build::Warning::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [priority][crate::model::build::Warning::priority].
        pub fn set_priority<T: std::convert::Into<crate::model::build::warning::Priority>>(
            mut self,
            v: T,
        ) -> Self {
            self.priority = v.into();
            self
        }
    }

    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Build.Warning"
        }
    }

    /// Defines additional types related to [Warning].
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The relative importance of this warning.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Priority {
            /// Should not be used.
            Unspecified,
            /// e.g. deprecation warnings and alternative feature highlights.
            Info,
            /// e.g. automated detection of possible issues with the build.
            Warning,
            /// e.g. alerts that a feature used in the build is pending removal
            Alert,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Priority::value] or
            /// [Priority::name].
            UnknownValue(priority::UnknownValue),
        }

        #[doc(hidden)]
        pub mod priority {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Priority {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Info => std::option::Option::Some(1),
                    Self::Warning => std::option::Option::Some(2),
                    Self::Alert => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PRIORITY_UNSPECIFIED"),
                    Self::Info => std::option::Option::Some("INFO"),
                    Self::Warning => std::option::Option::Some("WARNING"),
                    Self::Alert => std::option::Option::Some("ALERT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Priority {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Priority {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Priority {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Info,
                    2 => Self::Warning,
                    3 => Self::Alert,
                    _ => Self::UnknownValue(priority::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Priority {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PRIORITY_UNSPECIFIED" => Self::Unspecified,
                    "INFO" => Self::Info,
                    "WARNING" => Self::Warning,
                    "ALERT" => Self::Alert,
                    _ => Self::UnknownValue(priority::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Priority {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Info => serializer.serialize_i32(1),
                    Self::Warning => serializer.serialize_i32(2),
                    Self::Alert => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Priority {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                    ".google.devtools.cloudbuild.v1.Build.Warning.Priority",
                ))
            }
        }
    }

    /// A fatal problem encountered during the execution of the build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FailureInfo {
        /// The name of the failure.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub r#type: crate::model::build::failure_info::FailureType,

        /// Explains the failure issue in more detail using hard-coded text.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub detail: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailureInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::build::FailureInfo::type].
        pub fn set_type<T: std::convert::Into<crate::model::build::failure_info::FailureType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [detail][crate::model::build::FailureInfo::detail].
        pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.detail = v.into();
            self
        }
    }

    impl wkt::message::Message for FailureInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Build.FailureInfo"
        }
    }

    /// Defines additional types related to [FailureInfo].
    pub mod failure_info {
        #[allow(unused_imports)]
        use super::*;

        /// The name of a fatal problem encountered during the execution of the
        /// build.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FailureType {
            /// Type unspecified
            Unspecified,
            /// Unable to push the image to the repository.
            PushFailed,
            /// Final image not found.
            PushImageNotFound,
            /// Unauthorized push of the final image.
            PushNotAuthorized,
            /// Backend logging failures. Should retry.
            LoggingFailure,
            /// A build step has failed.
            UserBuildStep,
            /// The source fetching has failed.
            FetchSourceFailed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FailureType::value] or
            /// [FailureType::name].
            UnknownValue(failure_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod failure_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FailureType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::PushFailed => std::option::Option::Some(1),
                    Self::PushImageNotFound => std::option::Option::Some(2),
                    Self::PushNotAuthorized => std::option::Option::Some(3),
                    Self::LoggingFailure => std::option::Option::Some(4),
                    Self::UserBuildStep => std::option::Option::Some(5),
                    Self::FetchSourceFailed => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FAILURE_TYPE_UNSPECIFIED"),
                    Self::PushFailed => std::option::Option::Some("PUSH_FAILED"),
                    Self::PushImageNotFound => std::option::Option::Some("PUSH_IMAGE_NOT_FOUND"),
                    Self::PushNotAuthorized => std::option::Option::Some("PUSH_NOT_AUTHORIZED"),
                    Self::LoggingFailure => std::option::Option::Some("LOGGING_FAILURE"),
                    Self::UserBuildStep => std::option::Option::Some("USER_BUILD_STEP"),
                    Self::FetchSourceFailed => std::option::Option::Some("FETCH_SOURCE_FAILED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FailureType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FailureType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FailureType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::PushFailed,
                    2 => Self::PushImageNotFound,
                    3 => Self::PushNotAuthorized,
                    4 => Self::LoggingFailure,
                    5 => Self::UserBuildStep,
                    6 => Self::FetchSourceFailed,
                    _ => Self::UnknownValue(failure_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FailureType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FAILURE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "PUSH_FAILED" => Self::PushFailed,
                    "PUSH_IMAGE_NOT_FOUND" => Self::PushImageNotFound,
                    "PUSH_NOT_AUTHORIZED" => Self::PushNotAuthorized,
                    "LOGGING_FAILURE" => Self::LoggingFailure,
                    "USER_BUILD_STEP" => Self::UserBuildStep,
                    "FETCH_SOURCE_FAILED" => Self::FetchSourceFailed,
                    _ => Self::UnknownValue(failure_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FailureType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::PushFailed => serializer.serialize_i32(1),
                    Self::PushImageNotFound => serializer.serialize_i32(2),
                    Self::PushNotAuthorized => serializer.serialize_i32(3),
                    Self::LoggingFailure => serializer.serialize_i32(4),
                    Self::UserBuildStep => serializer.serialize_i32(5),
                    Self::FetchSourceFailed => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FailureType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureType>::new(
                    ".google.devtools.cloudbuild.v1.Build.FailureInfo.FailureType",
                ))
            }
        }
    }

    /// Possible status of a build or build step.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Status of the build is unknown.
        Unknown,
        /// Build has been created and is pending execution and queuing. It has not
        /// been queued.
        Pending,
        /// Build or step is queued; work has not yet begun.
        Queued,
        /// Build or step is being executed.
        Working,
        /// Build or step finished successfully.
        Success,
        /// Build or step failed to complete successfully.
        Failure,
        /// Build or step failed due to an internal cause.
        InternalError,
        /// Build or step took longer than was allowed.
        Timeout,
        /// Build or step was canceled by a user.
        Cancelled,
        /// Build was enqueued for longer than the value of `queue_ttl`.
        Expired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(10),
                Self::Queued => std::option::Option::Some(1),
                Self::Working => std::option::Option::Some(2),
                Self::Success => std::option::Option::Some(3),
                Self::Failure => std::option::Option::Some(4),
                Self::InternalError => std::option::Option::Some(5),
                Self::Timeout => std::option::Option::Some(6),
                Self::Cancelled => std::option::Option::Some(7),
                Self::Expired => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("STATUS_UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::Working => std::option::Option::Some("WORKING"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Failure => std::option::Option::Some("FAILURE"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::Timeout => std::option::Option::Some("TIMEOUT"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Queued,
                2 => Self::Working,
                3 => Self::Success,
                4 => Self::Failure,
                5 => Self::InternalError,
                6 => Self::Timeout,
                7 => Self::Cancelled,
                9 => Self::Expired,
                10 => Self::Pending,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "QUEUED" => Self::Queued,
                "WORKING" => Self::Working,
                "SUCCESS" => Self::Success,
                "FAILURE" => Self::Failure,
                "INTERNAL_ERROR" => Self::InternalError,
                "TIMEOUT" => Self::Timeout,
                "CANCELLED" => Self::Cancelled,
                "EXPIRED" => Self::Expired,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(10),
                Self::Queued => serializer.serialize_i32(1),
                Self::Working => serializer.serialize_i32(2),
                Self::Success => serializer.serialize_i32(3),
                Self::Failure => serializer.serialize_i32(4),
                Self::InternalError => serializer.serialize_i32(5),
                Self::Timeout => serializer.serialize_i32(6),
                Self::Cancelled => serializer.serialize_i32(7),
                Self::Expired => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.devtools.cloudbuild.v1.Build.Status",
            ))
        }
    }
}

/// A dependency that the Cloud Build worker will fetch before executing user
/// steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dependency {
    /// The type of dependency to fetch.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub dep: std::option::Option<crate::model::dependency::Dep>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dependency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dep][crate::model::Dependency::dep].
    ///
    /// Note that all the setters affecting `dep` are mutually
    /// exclusive.
    pub fn set_dep<T: std::convert::Into<std::option::Option<crate::model::dependency::Dep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dep = v.into();
        self
    }

    /// The value of [dep][crate::model::Dependency::dep]
    /// if it holds a `Empty`, `None` if the field is not set or
    /// holds a different branch.
    pub fn empty(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.dep.as_ref().and_then(|v| match v {
            crate::model::dependency::Dep::Empty(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dep][crate::model::Dependency::dep]
    /// to hold a `Empty`.
    ///
    /// Note that all the setters affecting `dep` are
    /// mutually exclusive.
    pub fn set_empty<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dep = std::option::Option::Some(crate::model::dependency::Dep::Empty(v.into()));
        self
    }

    /// The value of [dep][crate::model::Dependency::dep]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dependency::GitSourceDependency>> {
        #[allow(unreachable_patterns)]
        self.dep.as_ref().and_then(|v| match v {
            crate::model::dependency::Dep::GitSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dep][crate::model::Dependency::dep]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `dep` are
    /// mutually exclusive.
    pub fn set_git_source<
        T: std::convert::Into<std::boxed::Box<crate::model::dependency::GitSourceDependency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dep = std::option::Option::Some(crate::model::dependency::Dep::GitSource(v.into()));
        self
    }
}

impl wkt::message::Message for Dependency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency"
    }
}

/// Defines additional types related to [Dependency].
pub mod dependency {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a git repository as a build dependency.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GitSourceDependency {
        /// Required. The kind of repo (url or dev connect).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub repository: std::option::Option<crate::model::dependency::GitSourceRepository>,

        /// Required. The revision that we will fetch the repo at.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub revision: std::string::String,

        /// Optional. True if submodules should be fetched too (default false).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub recurse_submodules: bool,

        /// Optional. How much history should be fetched for the build (default 1, -1
        /// for all history).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
        pub depth: i64,

        /// Required. Where should the files be placed on the worker.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub dest_path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GitSourceDependency {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::dependency::GitSourceDependency::repository].
        pub fn set_repository<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::dependency::GitSourceRepository>,
        {
            self.repository = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [repository][crate::model::dependency::GitSourceDependency::repository].
        pub fn set_or_clear_repository<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::dependency::GitSourceRepository>,
        {
            self.repository = v.map(|x| x.into());
            self
        }

        /// Sets the value of [revision][crate::model::dependency::GitSourceDependency::revision].
        pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }

        /// Sets the value of [recurse_submodules][crate::model::dependency::GitSourceDependency::recurse_submodules].
        pub fn set_recurse_submodules<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.recurse_submodules = v.into();
            self
        }

        /// Sets the value of [depth][crate::model::dependency::GitSourceDependency::depth].
        pub fn set_depth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.depth = v.into();
            self
        }

        /// Sets the value of [dest_path][crate::model::dependency::GitSourceDependency::dest_path].
        pub fn set_dest_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dest_path = v.into();
            self
        }
    }

    impl wkt::message::Message for GitSourceDependency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency.GitSourceDependency"
        }
    }

    /// A repository for a git source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GitSourceRepository {
        /// The type of git source repo (url or dev connect).
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub repotype:
            std::option::Option<crate::model::dependency::git_source_repository::Repotype>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GitSourceRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype].
        ///
        /// Note that all the setters affecting `repotype` are mutually
        /// exclusive.
        pub fn set_repotype<
            T: std::convert::Into<
                    std::option::Option<crate::model::dependency::git_source_repository::Repotype>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.repotype = v.into();
            self
        }

        /// The value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// if it holds a `Url`, `None` if the field is not set or
        /// holds a different branch.
        pub fn url(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.repotype.as_ref().and_then(|v| match v {
                crate::model::dependency::git_source_repository::Repotype::Url(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// to hold a `Url`.
        ///
        /// Note that all the setters affecting `repotype` are
        /// mutually exclusive.
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repotype = std::option::Option::Some(
                crate::model::dependency::git_source_repository::Repotype::Url(v.into()),
            );
            self
        }

        /// The value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// if it holds a `DeveloperConnect`, `None` if the field is not set or
        /// holds a different branch.
        pub fn developer_connect(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.repotype.as_ref().and_then(|v| match v {
                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// to hold a `DeveloperConnect`.
        ///
        /// Note that all the setters affecting `repotype` are
        /// mutually exclusive.
        pub fn set_developer_connect<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repotype = std::option::Option::Some(
                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for GitSourceRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency.GitSourceRepository"
        }
    }

    /// Defines additional types related to [GitSourceRepository].
    pub mod git_source_repository {
        #[allow(unused_imports)]
        use super::*;

        /// The type of git source repo (url or dev connect).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Repotype {
            /// Location of the Git repository.
            Url(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
            /// The Developer Connect Git repository link or the url that matches a
            /// repository link in the current project, formatted as
            /// `projects/*/locations/*/connections/*/gitRepositoryLink/*`
            DeveloperConnect(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        }
    }

    /// The type of dependency to fetch.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Dep {
        /// If set to true disable all dependency fetching (ignoring the default
        /// source as well).
        Empty(#[serde_as(as = "serde_with::DefaultOnNull<_>")] bool),
        /// Represents a git repository as a build dependency.
        GitSource(std::boxed::Box<crate::model::dependency::GitSourceDependency>),
    }
}

/// GitConfig is a configuration for git operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitConfig {
    /// Configuration for HTTP related git operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http: std::option::Option<crate::model::git_config::HttpConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http][crate::model::GitConfig::http].
    pub fn set_http<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::git_config::HttpConfig>,
    {
        self.http = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http][crate::model::GitConfig::http].
    pub fn set_or_clear_http<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::git_config::HttpConfig>,
    {
        self.http = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GitConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitConfig"
    }
}

/// Defines additional types related to [GitConfig].
pub mod git_config {
    #[allow(unused_imports)]
    use super::*;

    /// HttpConfig is a configuration for HTTP related git operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpConfig {
        /// SecretVersion resource of the HTTP proxy URL. The Service Account used in
        /// the build (either the default Service Account or
        /// user-specified Service Account) should have
        /// `secretmanager.versions.access` permissions on this secret. The proxy URL
        /// should be in format `[protocol://][user[:password]@]proxyhost[:port]`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub proxy_secret_version_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HttpConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [proxy_secret_version_name][crate::model::git_config::HttpConfig::proxy_secret_version_name].
        pub fn set_proxy_secret_version_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.proxy_secret_version_name = v.into();
            self
        }
    }

    impl wkt::message::Message for HttpConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.GitConfig.HttpConfig"
        }
    }
}

/// Artifacts produced by a build that should be uploaded upon
/// successful completion of all build steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Artifacts {
    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images will be pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the Build resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub images: std::vec::Vec<std::string::String>,

    /// A list of objects to be uploaded to Cloud Storage upon successful
    /// completion of all build steps.
    ///
    /// Files in the workspace matching specified paths globs will be uploaded to
    /// the specified Cloud Storage location using the builder service account's
    /// credentials.
    ///
    /// The location and generation of the uploaded objects will be stored in the
    /// Build resource's results field.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub objects: std::option::Option<crate::model::artifacts::ArtifactObjects>,

    /// A list of Maven artifacts to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Artifacts in the workspace matching specified paths globs will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any artifacts fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub maven_artifacts: std::vec::Vec<crate::model::artifacts::MavenArtifact>,

    /// Optional. A list of Go modules to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub go_modules: std::vec::Vec<crate::model::artifacts::GoModule>,

    /// A list of Python packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// The build service account credentials will be used to perform the upload.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub python_packages: std::vec::Vec<crate::model::artifacts::PythonPackage>,

    /// A list of npm packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Npm packages in the specified paths will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any packages fail to be pushed, the build is marked FAILURE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub npm_packages: std::vec::Vec<crate::model::artifacts::NpmPackage>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Artifacts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [images][crate::model::Artifacts::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [objects][crate::model::Artifacts::objects].
    pub fn set_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::artifacts::ArtifactObjects>,
    {
        self.objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [objects][crate::model::Artifacts::objects].
    pub fn set_or_clear_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::artifacts::ArtifactObjects>,
    {
        self.objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::Artifacts::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::MavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [go_modules][crate::model::Artifacts::go_modules].
    pub fn set_go_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::GoModule>,
    {
        use std::iter::Iterator;
        self.go_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_packages][crate::model::Artifacts::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::PythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [npm_packages][crate::model::Artifacts::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::NpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Artifacts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts"
    }
}

/// Defines additional types related to [Artifacts].
pub mod artifacts {
    #[allow(unused_imports)]
    use super::*;

    /// Files in the workspace to upload to Cloud Storage upon successful
    /// completion of all build steps.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArtifactObjects {
        /// Cloud Storage bucket and optional object path, in the form
        /// "gs://bucket/path/to/somewhere/". (see [Bucket Name
        /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Cloud Storage with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub location: std::string::String,

        /// Path globs used to match files in the build's workspace.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
        pub paths: std::vec::Vec<std::string::String>,

        /// Output only. Stores timing information for pushing all artifact objects.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub timing: std::option::Option<crate::model::TimeSpan>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ArtifactObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::artifacts::ArtifactObjects::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [paths][crate::model::artifacts::ArtifactObjects::paths].
        pub fn set_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.paths = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [timing][crate::model::artifacts::ArtifactObjects::timing].
        pub fn set_timing<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TimeSpan>,
        {
            self.timing = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [timing][crate::model::artifacts::ArtifactObjects::timing].
        pub fn set_or_clear_timing<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TimeSpan>,
        {
            self.timing = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ArtifactObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.ArtifactObjects"
        }
    }

    /// A Maven artifact to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MavenArtifact {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-maven.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Artifact in the workspace specified by path will be uploaded to
        /// Artifact Registry with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository: std::string::String,

        /// Path to an artifact in the build's workspace to be uploaded to
        /// Artifact Registry.
        /// This can be either an absolute path,
        /// e.g. /workspace/my-app/target/my-app-1.0.SNAPSHOT.jar
        /// or a relative path from /workspace,
        /// e.g. my-app/target/my-app-1.0.SNAPSHOT.jar.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub path: std::string::String,

        /// Maven `artifactId` value used when uploading the artifact to Artifact
        /// Registry.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub artifact_id: std::string::String,

        /// Maven `groupId` value used when uploading the artifact to Artifact
        /// Registry.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub group_id: std::string::String,

        /// Maven `version` value used when uploading the artifact to Artifact
        /// Registry.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MavenArtifact {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::MavenArtifact::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [path][crate::model::artifacts::MavenArtifact::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [artifact_id][crate::model::artifacts::MavenArtifact::artifact_id].
        pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.artifact_id = v.into();
            self
        }

        /// Sets the value of [group_id][crate::model::artifacts::MavenArtifact::group_id].
        pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::artifacts::MavenArtifact::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for MavenArtifact {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.MavenArtifact"
        }
    }

    /// Go module to upload to Artifact Registry upon successful completion of all
    /// build steps. A module refers to all dependencies in a go.mod file.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GoModule {
        /// Optional. Artifact Registry repository name.
        ///
        /// Specified Go modules will be zipped and uploaded to Artifact Registry
        /// with this location as a prefix.
        /// e.g. my-go-repo
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository_name: std::string::String,

        /// Optional. Location of the Artifact Registry repository. i.e. us-east1
        /// Defaults to the builds location.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository_location: std::string::String,

        /// Optional. Project ID of the Artifact Registry repository.
        /// Defaults to the build project.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository_project_id: std::string::String,

        /// Optional. Source path of the go.mod file in the build's workspace. If not
        /// specified, this will default to the current directory.
        /// e.g. ~/code/go/mypackage
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub source_path: std::string::String,

        /// Optional. The Go module's "module path".
        /// e.g. example.com/foo/v2
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub module_path: std::string::String,

        /// Optional. The Go module's semantic version in the form vX.Y.Z. e.g.
        /// v0.1.1 Pre-release identifiers can also be added by appending a dash and
        /// dot separated ASCII alphanumeric characters and hyphens.
        /// e.g. v0.2.3-alpha.x.12m.5
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub module_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GoModule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository_name][crate::model::artifacts::GoModule::repository_name].
        pub fn set_repository_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_name = v.into();
            self
        }

        /// Sets the value of [repository_location][crate::model::artifacts::GoModule::repository_location].
        pub fn set_repository_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_location = v.into();
            self
        }

        /// Sets the value of [repository_project_id][crate::model::artifacts::GoModule::repository_project_id].
        pub fn set_repository_project_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_project_id = v.into();
            self
        }

        /// Sets the value of [source_path][crate::model::artifacts::GoModule::source_path].
        pub fn set_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_path = v.into();
            self
        }

        /// Sets the value of [module_path][crate::model::artifacts::GoModule::module_path].
        pub fn set_module_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.module_path = v.into();
            self
        }

        /// Sets the value of [module_version][crate::model::artifacts::GoModule::module_version].
        pub fn set_module_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.module_version = v.into();
            self
        }
    }

    impl wkt::message::Message for GoModule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.GoModule"
        }
    }

    /// Python package to upload to Artifact Registry upon successful completion
    /// of all build steps. A package can encapsulate multiple objects to be
    /// uploaded to a single repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PythonPackage {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-python.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Artifact Registry with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository: std::string::String,

        /// Path globs used to match files in the build's workspace. For Python/
        /// Twine, this is usually `dist/*`, and sometimes additionally an `.asc`
        /// file.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
        pub paths: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PythonPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::PythonPackage::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [paths][crate::model::artifacts::PythonPackage::paths].
        pub fn set_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.paths = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PythonPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.PythonPackage"
        }
    }

    /// Npm package to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NpmPackage {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-npm.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Npm package in the workspace specified by path will be zipped and
        /// uploaded to Artifact Registry with this location as a prefix.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository: std::string::String,

        /// Path to the package.json.
        /// e.g. workspace/path/to/package
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub package_path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NpmPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::NpmPackage::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [package_path][crate::model::artifacts::NpmPackage::package_path].
        pub fn set_package_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_path = v.into();
            self
        }
    }

    impl wkt::message::Message for NpmPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.NpmPackage"
        }
    }
}

/// Start and end times for a build execution phase.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSpan {
    /// Start of time span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End of time span.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeSpan::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeSpan::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeSpan::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeSpan::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.TimeSpan"
    }
}

/// Metadata for build operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildOperationMetadata {
    /// The build that the operation is tracking.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build: std::option::Option<crate::model::Build>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::BuildOperationMetadata::build].
    pub fn set_build<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build][crate::model::BuildOperationMetadata::build].
    pub fn set_or_clear_build<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOperationMetadata"
    }
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceProvenance {
    /// A copy of the build's `source.storage_source`, if exists, with any
    /// generations resolved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_storage_source: std::option::Option<crate::model::StorageSource>,

    /// A copy of the build's `source.repo_source`, if exists, with any
    /// revisions resolved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_repo_source: std::option::Option<crate::model::RepoSource>,

    /// A copy of the build's `source.storage_source_manifest`, if exists, with any
    /// revisions resolved.
    /// This feature is in Preview.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolved_storage_source_manifest: std::option::Option<crate::model::StorageSourceManifest>,

    /// Output only. Hash(es) of the build source, which can be used to verify that
    /// the original source integrity was maintained in the build. Note that
    /// `FileHashes` will only be populated if `BuildOptions` has requested a
    /// `SourceProvenanceHash`.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (`.tar.gz`), the `FileHash` will be for the single path to that file.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub file_hashes: std::collections::HashMap<std::string::String, crate::model::FileHashes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resolved_storage_source][crate::model::SourceProvenance::resolved_storage_source].
    pub fn set_resolved_storage_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageSource>,
    {
        self.resolved_storage_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolved_storage_source][crate::model::SourceProvenance::resolved_storage_source].
    pub fn set_or_clear_resolved_storage_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageSource>,
    {
        self.resolved_storage_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_repo_source][crate::model::SourceProvenance::resolved_repo_source].
    pub fn set_resolved_repo_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.resolved_repo_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolved_repo_source][crate::model::SourceProvenance::resolved_repo_source].
    pub fn set_or_clear_resolved_repo_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.resolved_repo_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_storage_source_manifest][crate::model::SourceProvenance::resolved_storage_source_manifest].
    pub fn set_resolved_storage_source_manifest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageSourceManifest>,
    {
        self.resolved_storage_source_manifest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolved_storage_source_manifest][crate::model::SourceProvenance::resolved_storage_source_manifest].
    pub fn set_or_clear_resolved_storage_source_manifest<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::StorageSourceManifest>,
    {
        self.resolved_storage_source_manifest = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_hashes][crate::model::SourceProvenance::file_hashes].
    pub fn set_file_hashes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hashes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SourceProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.SourceProvenance"
    }
}

/// Container message for hashes of byte content of files, used in
/// SourceProvenance messages to verify integrity of source input to the build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileHashes {
    /// Collection of file hashes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub file_hash: std::vec::Vec<crate::model::Hash>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_hash][crate::model::FileHashes::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.FileHashes"
    }
}

/// Container message for hash values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Hash {
    /// The type of hash that was performed.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::hash::HashType,

    /// The hash value.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<serde_with::base64::Base64>")]
    pub value: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    pub fn set_type<T: std::convert::Into<crate::model::hash::HashType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Hash"
    }
}

/// Defines additional types related to [Hash].
pub mod hash {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the hash algorithm, if any.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HashType {
        /// No hash requested.
        None,
        /// Use a sha256 hash.
        Sha256,
        /// Use a md5 hash.
        Md5,
        /// Dirhash of a Go module's source code which is then hex-encoded.
        GoModuleH1,
        /// Use a sha512 hash.
        Sha512,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HashType::value] or
        /// [HashType::name].
        UnknownValue(hash_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod hash_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HashType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Sha256 => std::option::Option::Some(1),
                Self::Md5 => std::option::Option::Some(2),
                Self::GoModuleH1 => std::option::Option::Some(3),
                Self::Sha512 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Sha256 => std::option::Option::Some("SHA256"),
                Self::Md5 => std::option::Option::Some("MD5"),
                Self::GoModuleH1 => std::option::Option::Some("GO_MODULE_H1"),
                Self::Sha512 => std::option::Option::Some("SHA512"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HashType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HashType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HashType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Sha256,
                2 => Self::Md5,
                3 => Self::GoModuleH1,
                4 => Self::Sha512,
                _ => Self::UnknownValue(hash_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HashType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "SHA256" => Self::Sha256,
                "MD5" => Self::Md5,
                "GO_MODULE_H1" => Self::GoModuleH1,
                "SHA512" => Self::Sha512,
                _ => Self::UnknownValue(hash_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HashType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_i32(0),
                Self::Sha256 => serializer.serialize_i32(1),
                Self::Md5 => serializer.serialize_i32(2),
                Self::GoModuleH1 => serializer.serialize_i32(3),
                Self::Sha512 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HashType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HashType>::new(
                ".google.devtools.cloudbuild.v1.Hash.HashType",
            ))
        }
    }
}

/// Secrets and secret environment variables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Secrets {
    /// Secrets in Secret Manager and associated secret environment variable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub secret_manager: std::vec::Vec<crate::model::SecretManagerSecret>,

    /// Secrets encrypted with KMS key and the associated secret environment
    /// variable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub inline: std::vec::Vec<crate::model::InlineSecret>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secrets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_manager][crate::model::Secrets::secret_manager].
    pub fn set_secret_manager<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretManagerSecret>,
    {
        use std::iter::Iterator;
        self.secret_manager = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inline][crate::model::Secrets::inline].
    pub fn set_inline<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InlineSecret>,
    {
        use std::iter::Iterator;
        self.inline = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Secrets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Secrets"
    }
}

/// Pairs a set of secret environment variables mapped to encrypted
/// values with the Cloud KMS key to use to decrypt the value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InlineSecret {
    /// Resource name of Cloud KMS crypto key to decrypt the encrypted value.
    /// In format: projects/*/locations/*/keyRings/*/cryptoKeys/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub kms_key_name: std::string::String,

    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(
        as = "serde_with::DefaultOnNull<std::collections::HashMap<_, serde_with::base64::Base64>>"
    )]
    pub env_map: std::collections::HashMap<std::string::String, ::bytes::Bytes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::InlineSecret::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [env_map][crate::model::InlineSecret::env_map].
    pub fn set_env_map<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.env_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InlineSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.InlineSecret"
    }
}

/// Pairs a secret environment variable with a SecretVersion in Secret Manager.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretManagerSecret {
    /// Resource name of the SecretVersion. In format:
    /// projects/*/secrets/*/versions/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub version_name: std::string::String,

    /// Environment variable name to associate with the secret.
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub env: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretManagerSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version_name][crate::model::SecretManagerSecret::version_name].
    pub fn set_version_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::SecretManagerSecret::env].
    pub fn set_env<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.env = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.SecretManagerSecret"
    }
}

/// Pairs a set of secret environment variables containing encrypted
/// values with the Cloud KMS key to use to decrypt the value.
/// Note: Use `kmsKeyName` with  `available_secrets` instead of using
/// `kmsKeyName` with `secret`. For instructions see:
/// <https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-credentials>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Secret {
    /// Cloud KMS key name to use to decrypt these envs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub kms_key_name: std::string::String,

    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(
        as = "serde_with::DefaultOnNull<std::collections::HashMap<_, serde_with::base64::Base64>>"
    )]
    pub secret_env: std::collections::HashMap<std::string::String, ::bytes::Bytes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::Secret::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [secret_env][crate::model::Secret::secret_env].
    pub fn set_secret_env<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Secret"
    }
}

/// Request to create a new build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBuildRequest {
    /// The parent resource where this build will be created.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. Build resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build: std::option::Option<crate::model::Build>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBuildRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CreateBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [build][crate::model::CreateBuildRequest::build].
    pub fn set_build<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build][crate::model::CreateBuildRequest::build].
    pub fn set_or_clear_build<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateBuildRequest"
    }
}

/// Request to get a build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBuildRequest {
    /// The name of the `Build` to retrieve.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. ID of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::GetBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for GetBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetBuildRequest"
    }
}

/// Request to list builds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildsRequest {
    /// The parent of the collection of `Builds`.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Number of results to return in the list.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// The page token for the next page of Builds.
    ///
    /// If unspecified, the first page of results is returned.
    ///
    /// If the token is rejected for any reason, INVALID_ARGUMENT will be thrown.
    /// In this case, the token should be discarded, and pagination should be
    /// restarted from the first page of results.
    ///
    /// See <https://google.aip.dev/158> for more.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// The raw filter text to constrain the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBuildsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ListBuildsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBuildsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBuildsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBuildsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildsRequest"
    }
}

/// Response including listed builds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildsResponse {
    /// Builds will be sorted by `create_time`, descending.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub builds: std::vec::Vec<crate::model::Build>,

    /// Token to receive the next page of results.
    /// This will be absent if the end of the response list has been reached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builds][crate::model::ListBuildsResponse::builds].
    pub fn set_builds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Build>,
    {
        use std::iter::Iterator;
        self.builds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBuildsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBuildsResponse {
    type PageItem = crate::model::Build;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.builds
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to cancel an ongoing build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelBuildRequest {
    /// The name of the `Build` to cancel.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. ID of the build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CancelBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::CancelBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for CancelBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CancelBuildRequest"
    }
}

/// Request to approve or reject a pending build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveBuildRequest {
    /// Required. Name of the target build.
    /// For example: "projects/{$project_id}/builds/{$build_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Approval decision and metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval_result: std::option::Option<crate::model::ApprovalResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [approval_result][crate::model::ApproveBuildRequest::approval_result].
    pub fn set_approval_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.approval_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval_result][crate::model::ApproveBuildRequest::approval_result].
    pub fn set_or_clear_approval_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.approval_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ApproveBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApproveBuildRequest"
    }
}

/// BuildApproval describes a build's approval configuration, state, and
/// result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildApproval {
    /// Output only. The state of this build's approval.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::build_approval::State,

    /// Output only. Configuration for manual approval of this build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::ApprovalConfig>,

    /// Output only. Result of manual approval for this Build.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::ApprovalResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildApproval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BuildApproval::state].
    pub fn set_state<T: std::convert::Into<crate::model::build_approval::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [config][crate::model::BuildApproval::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::BuildApproval::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [result][crate::model::BuildApproval::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::BuildApproval::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildApproval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildApproval"
    }
}

/// Defines additional types related to [BuildApproval].
pub mod build_approval {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the current state of a build's approval.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default enum type. This should not be used.
        Unspecified,
        /// Build approval is pending.
        Pending,
        /// Build approval has been approved.
        Approved,
        /// Build approval has been rejected.
        Rejected,
        /// Build was cancelled while it was still pending approval.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Approved => std::option::Option::Some(2),
                Self::Rejected => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Approved,
                3 => Self::Rejected,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Approved => serializer.serialize_i32(2),
                Self::Rejected => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.BuildApproval.State",
            ))
        }
    }
}

/// ApprovalConfig describes configuration for manual approval of a build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will
    /// become pending when created, and will need to be explicitly approved
    /// to start.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub approval_required: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApprovalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approval_required][crate::model::ApprovalConfig::approval_required].
    pub fn set_approval_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.approval_required = v.into();
        self
    }
}

impl wkt::message::Message for ApprovalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApprovalConfig"
    }
}

/// ApprovalResult describes the decision and associated metadata of a manual
/// approval of a build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApprovalResult {
    /// Output only. Email of the user that called the ApproveBuild API to
    /// approve or reject a build at the time that the API was called.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub approver_account: std::string::String,

    /// Output only. The time when the approval decision was made.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval_time: std::option::Option<wkt::Timestamp>,

    /// Required. The decision of this manual approval.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub decision: crate::model::approval_result::Decision,

    /// Optional. An optional comment for this manual approval result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub comment: std::string::String,

    /// Optional. An optional URL tied to this manual approval result. This field
    /// is essentially the same as comment, except that it will be rendered by the
    /// UI differently. An example use case is a link to an external job that
    /// approved this Build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApprovalResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approver_account][crate::model::ApprovalResult::approver_account].
    pub fn set_approver_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.approver_account = v.into();
        self
    }

    /// Sets the value of [approval_time][crate::model::ApprovalResult::approval_time].
    pub fn set_approval_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approval_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval_time][crate::model::ApprovalResult::approval_time].
    pub fn set_or_clear_approval_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approval_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decision][crate::model::ApprovalResult::decision].
    pub fn set_decision<T: std::convert::Into<crate::model::approval_result::Decision>>(
        mut self,
        v: T,
    ) -> Self {
        self.decision = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::ApprovalResult::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [url][crate::model::ApprovalResult::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for ApprovalResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApprovalResult"
    }
}

/// Defines additional types related to [ApprovalResult].
pub mod approval_result {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether or not this manual approval result is to approve
    /// or reject a build.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Decision {
        /// Default enum type. This should not be used.
        Unspecified,
        /// Build is approved.
        Approved,
        /// Build is rejected.
        Rejected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Decision::value] or
        /// [Decision::name].
        UnknownValue(decision::UnknownValue),
    }

    #[doc(hidden)]
    pub mod decision {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Decision {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Approved => std::option::Option::Some(1),
                Self::Rejected => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DECISION_UNSPECIFIED"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Decision {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Decision {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Decision {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Approved,
                2 => Self::Rejected,
                _ => Self::UnknownValue(decision::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Decision {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DECISION_UNSPECIFIED" => Self::Unspecified,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                _ => Self::UnknownValue(decision::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Decision {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Approved => serializer.serialize_i32(1),
                Self::Rejected => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Decision {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Decision>::new(
                ".google.devtools.cloudbuild.v1.ApprovalResult.Decision",
            ))
        }
    }
}

/// GitRepoSource describes a repo and ref of a code repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitRepoSource {
    /// The URI of the repo (e.g. <https://github.com/user/repo.git>).
    /// Either `uri` or `repository` can be specified and is required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// The branch or tag to use. Must start with "refs/" (required).
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#ref: std::string::String,

    /// See RepoType below.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub repo_type: crate::model::git_file_source::RepoType,

    /// The source of the SCM repo.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::git_repo_source::Source>,

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub enterprise_config: std::option::Option<crate::model::git_repo_source::EnterpriseConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitRepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GitRepoSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [r#ref][crate::model::GitRepoSource::ref].
    pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#ref = v.into();
        self
    }

    /// Sets the value of [repo_type][crate::model::GitRepoSource::repo_type].
    pub fn set_repo_type<T: std::convert::Into<crate::model::git_file_source::RepoType>>(
        mut self,
        v: T,
    ) -> Self {
        self.repo_type = v.into();
        self
    }

    /// Sets the value of [source][crate::model::GitRepoSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::git_repo_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GitRepoSource::source]
    /// if it holds a `Repository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repository(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::git_repo_source::Source::Repository(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GitRepoSource::source]
    /// to hold a `Repository`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::git_repo_source::Source::Repository(v.into()));
        self
    }

    /// Sets the value of [enterprise_config][crate::model::GitRepoSource::enterprise_config].
    ///
    /// Note that all the setters affecting `enterprise_config` are mutually
    /// exclusive.
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::git_repo_source::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// The value of [enterprise_config][crate::model::GitRepoSource::enterprise_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_enterprise_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.enterprise_config.as_ref().and_then(|v| match v {
            crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enterprise_config][crate::model::GitRepoSource::enterprise_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `enterprise_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = std::option::Option::Some(
            crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GitRepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitRepoSource"
    }
}

/// Defines additional types related to [GitRepoSource].
pub mod git_repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the SCM repo.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The connected repository resource name, in the format
        /// `projects/*/locations/*/connections/*/repositories/*`. Either `uri` or
        /// `repository` can be specified and is required.
        Repository(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        GithubEnterpriseConfig(
            #[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String,
        ),
    }
}

/// GitFileSource describes a file within a (possibly remote) code repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitFileSource {
    /// The path of the file, with the repo root as the root of the path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub path: std::string::String,

    /// The URI of the repo.
    /// Either uri or repository can be specified.
    /// If unspecified, the repo from which the trigger invocation originated is
    /// assumed to be the repo from which to read the specified path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uri: std::string::String,

    /// See RepoType above.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub repo_type: crate::model::git_file_source::RepoType,

    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when
    /// resolving the filename (optional).
    /// This field respects the same syntax/resolution as described here:
    /// <https://git-scm.com/docs/gitrevisions>
    /// If unspecified, the revision from which the trigger invocation originated
    /// is assumed to be the revision from which to read the specified path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub revision: std::string::String,

    /// The source of the SCM repo.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::git_file_source::Source>,

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub enterprise_config: std::option::Option<crate::model::git_file_source::EnterpriseConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitFileSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::GitFileSource::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::GitFileSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [repo_type][crate::model::GitFileSource::repo_type].
    pub fn set_repo_type<T: std::convert::Into<crate::model::git_file_source::RepoType>>(
        mut self,
        v: T,
    ) -> Self {
        self.repo_type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GitFileSource::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [source][crate::model::GitFileSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::git_file_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GitFileSource::source]
    /// if it holds a `Repository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repository(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::git_file_source::Source::Repository(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GitFileSource::source]
    /// to hold a `Repository`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::git_file_source::Source::Repository(v.into()));
        self
    }

    /// Sets the value of [enterprise_config][crate::model::GitFileSource::enterprise_config].
    ///
    /// Note that all the setters affecting `enterprise_config` are mutually
    /// exclusive.
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::git_file_source::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// The value of [enterprise_config][crate::model::GitFileSource::enterprise_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_enterprise_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.enterprise_config.as_ref().and_then(|v| match v {
            crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enterprise_config][crate::model::GitFileSource::enterprise_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `enterprise_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = std::option::Option::Some(
            crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GitFileSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitFileSource"
    }
}

/// Defines additional types related to [GitFileSource].
pub mod git_file_source {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the repo, since it may not be explicit from the `repo` field
    /// (e.g from a URL).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RepoType {
        /// The default, unknown repo type. Don't use it, instead use one of
        /// the other repo types.
        Unknown,
        /// A Google Cloud Source Repositories-hosted repo.
        CloudSourceRepositories,
        /// A GitHub-hosted repo not necessarily on "github.com" (i.e. GitHub
        /// Enterprise).
        Github,
        /// A Bitbucket Server-hosted repo.
        BitbucketServer,
        /// A GitLab-hosted repo.
        Gitlab,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RepoType::value] or
        /// [RepoType::name].
        UnknownValue(repo_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod repo_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RepoType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::CloudSourceRepositories => std::option::Option::Some(1),
                Self::Github => std::option::Option::Some(2),
                Self::BitbucketServer => std::option::Option::Some(3),
                Self::Gitlab => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::CloudSourceRepositories => {
                    std::option::Option::Some("CLOUD_SOURCE_REPOSITORIES")
                }
                Self::Github => std::option::Option::Some("GITHUB"),
                Self::BitbucketServer => std::option::Option::Some("BITBUCKET_SERVER"),
                Self::Gitlab => std::option::Option::Some("GITLAB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RepoType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RepoType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RepoType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::CloudSourceRepositories,
                2 => Self::Github,
                3 => Self::BitbucketServer,
                4 => Self::Gitlab,
                _ => Self::UnknownValue(repo_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RepoType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "CLOUD_SOURCE_REPOSITORIES" => Self::CloudSourceRepositories,
                "GITHUB" => Self::Github,
                "BITBUCKET_SERVER" => Self::BitbucketServer,
                "GITLAB" => Self::Gitlab,
                _ => Self::UnknownValue(repo_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RepoType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::CloudSourceRepositories => serializer.serialize_i32(1),
                Self::Github => serializer.serialize_i32(2),
                Self::BitbucketServer => serializer.serialize_i32(3),
                Self::Gitlab => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RepoType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepoType>::new(
                ".google.devtools.cloudbuild.v1.GitFileSource.RepoType",
            ))
        }
    }

    /// The source of the SCM repo.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The fully qualified resource name of the Repos API repository.
        /// Either URI or repository can be specified.
        /// If unspecified, the repo from which the trigger invocation originated is
        /// assumed to be the repo from which to read the specified path.
        Repository(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        GithubEnterpriseConfig(
            #[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String,
        ),
    }
}

/// Configuration for an automated build in response to source repository
/// changes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildTrigger {
    /// The `Trigger` name with format:
    /// `projects/{project}/locations/{location}/triggers/{trigger}`, where
    /// {trigger} is a unique identifier generated by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub resource_name: std::string::String,

    /// Output only. Unique identifier of the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Human-readable description of this trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// User-assigned name of the trigger. Must be unique within the project.
    /// Trigger names must meet the following requirements:
    ///
    /// + They must contain only alphanumeric characters and dashes.
    /// + They can be 1-64 characters long.
    /// + They must begin and end with an alphanumeric character.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Tags for annotation of a `BuildTrigger`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Template describing the types of source changes to trigger a build.
    ///
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular expression
    /// will trigger a build.
    ///
    /// Mutually exclusive with `github`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger_template: std::option::Option<crate::model::RepoSource>,

    /// GitHubEventsConfig describes the configuration of a trigger that creates
    /// a build whenever a GitHub event is received.
    ///
    /// Mutually exclusive with `trigger_template`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub github: std::option::Option<crate::model::GitHubEventsConfig>,

    /// PubsubConfig describes the configuration of a trigger that
    /// creates a build whenever a Pub/Sub message is published.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pubsub_config: std::option::Option<crate::model::PubsubConfig>,

    /// WebhookConfig describes the configuration of a trigger that
    /// creates a build whenever a webhook is sent to a trigger's webhook URL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub webhook_config: std::option::Option<crate::model::WebhookConfig>,

    /// Output only. Time when the trigger was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// If true, the trigger will never automatically execute a build.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub disabled: bool,

    /// Substitutions for Build resource. The keys must match the following
    /// regular expression: `^_[A-Z0-9_]+$`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// ignored_files and included_files are file glob matches using
    /// <https://golang.org/pkg/path/filepath/#Match> extended with support for "**".
    ///
    /// If ignored_files and changed files are both empty, then they are
    /// not used to determine whether or not to trigger a build.
    ///
    /// If ignored_files is not empty, then we ignore any files that match
    /// any of the ignored_file globs. If the change has no files that are
    /// outside of the ignored_files globs, then we do not trigger a build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub ignored_files: std::vec::Vec<std::string::String>,

    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is empty, then as far as this filter is
    /// concerned, we should trigger the build.
    ///
    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is not empty, then we make sure that at
    /// least one of those files matches a included_files glob. If not,
    /// then we do not trigger a build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub included_files: std::vec::Vec<std::string::String>,

    /// Optional. A Common Expression Language string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// The repo and ref of the repository from which to build. This field
    /// is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit
    /// caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron
    /// triggers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_to_build: std::option::Option<crate::model::GitRepoSource>,

    /// The service account used for all user-controlled operations including
    /// UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild.
    /// If no service account is set and the legacy Cloud Build service account
    /// (`[PROJECT_NUM]@cloudbuild.gserviceaccount.com`) is the default for the
    /// project then it will be used instead.
    /// Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// The configuration of a trigger that creates a build whenever an event from
    /// Repo API is received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repository_event_config: std::option::Option<crate::model::RepositoryEventConfig>,

    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub build_template: std::option::Option<crate::model::build_trigger::BuildTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_name][crate::model::BuildTrigger::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BuildTrigger::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BuildTrigger::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [name][crate::model::BuildTrigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::BuildTrigger::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trigger_template][crate::model::BuildTrigger::trigger_template].
    pub fn set_trigger_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.trigger_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger_template][crate::model::BuildTrigger::trigger_template].
    pub fn set_or_clear_trigger_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.trigger_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [github][crate::model::BuildTrigger::github].
    pub fn set_github<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEventsConfig>,
    {
        self.github = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [github][crate::model::BuildTrigger::github].
    pub fn set_or_clear_github<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEventsConfig>,
    {
        self.github = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pubsub_config][crate::model::BuildTrigger::pubsub_config].
    pub fn set_pubsub_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PubsubConfig>,
    {
        self.pubsub_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pubsub_config][crate::model::BuildTrigger::pubsub_config].
    pub fn set_or_clear_pubsub_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PubsubConfig>,
    {
        self.pubsub_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_config][crate::model::BuildTrigger::webhook_config].
    pub fn set_webhook_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WebhookConfig>,
    {
        self.webhook_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook_config][crate::model::BuildTrigger::webhook_config].
    pub fn set_or_clear_webhook_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WebhookConfig>,
    {
        self.webhook_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::BuildTrigger::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BuildTrigger::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::BuildTrigger::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::BuildTrigger::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [ignored_files][crate::model::BuildTrigger::ignored_files].
    pub fn set_ignored_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ignored_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_files][crate::model::BuildTrigger::included_files].
    pub fn set_included_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.included_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::BuildTrigger::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [source_to_build][crate::model::BuildTrigger::source_to_build].
    pub fn set_source_to_build<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitRepoSource>,
    {
        self.source_to_build = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_to_build][crate::model::BuildTrigger::source_to_build].
    pub fn set_or_clear_source_to_build<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitRepoSource>,
    {
        self.source_to_build = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::BuildTrigger::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [repository_event_config][crate::model::BuildTrigger::repository_event_config].
    pub fn set_repository_event_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepositoryEventConfig>,
    {
        self.repository_event_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository_event_config][crate::model::BuildTrigger::repository_event_config].
    pub fn set_or_clear_repository_event_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepositoryEventConfig>,
    {
        self.repository_event_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template].
    ///
    /// Note that all the setters affecting `build_template` are mutually
    /// exclusive.
    pub fn set_build_template<
        T: std::convert::Into<std::option::Option<crate::model::build_trigger::BuildTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_template = v.into();
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Autodetect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn autodetect(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Autodetect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Autodetect`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_autodetect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::Autodetect(v.into()),
        );
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::Build>> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::Build>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_template =
            std::option::Option::Some(crate::model::build_trigger::BuildTemplate::Build(v.into()));
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Filename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filename(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Filename(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Filename`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_filename<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::Filename(v.into()),
        );
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `GitFileSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_file_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitFileSource>> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::GitFileSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `GitFileSource`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_git_file_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GitFileSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::GitFileSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BuildTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildTrigger"
    }
}

/// Defines additional types related to [BuildTrigger].
pub mod build_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BuildTemplate {
        /// Autodetect build configuration.  The following precedence is used (case
        /// insensitive):
        ///
        /// . cloudbuild.yaml
        /// . cloudbuild.yml
        /// . cloudbuild.json
        /// . Dockerfile
        ///
        /// Currently only available for GitHub App Triggers.
        Autodetect(#[serde_as(as = "serde_with::DefaultOnNull<_>")] bool),
        /// Contents of the build template.
        Build(std::boxed::Box<crate::model::Build>),
        /// Path, from the source root, to the build configuration file
        /// (i.e. cloudbuild.yaml).
        Filename(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// The file source describing the local or remote Build template.
        GitFileSource(std::boxed::Box<crate::model::GitFileSource>),
    }
}

/// The configuration of a trigger that creates a build whenever an event from
/// Repo API is received.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepositoryEventConfig {
    /// The resource name of the Repo API resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub repository: std::string::String,

    /// Output only. The type of the SCM vendor the repository points to.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub repository_type: crate::model::repository_event_config::RepositoryType,

    /// The types of filter to trigger a build.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::repository_event_config::Filter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepositoryEventConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::RepositoryEventConfig::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [repository_type][crate::model::RepositoryEventConfig::repository_type].
    pub fn set_repository_type<
        T: std::convert::Into<crate::model::repository_event_config::RepositoryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repository_type = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::repository_event_config::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::RepositoryEventConfig::filter]
    /// if it holds a `PullRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pull_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PullRequestFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::repository_event_config::Filter::PullRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter]
    /// to hold a `PullRequest`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_pull_request<
        T: std::convert::Into<std::boxed::Box<crate::model::PullRequestFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::repository_event_config::Filter::PullRequest(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::RepositoryEventConfig::filter]
    /// if it holds a `Push`, `None` if the field is not set or
    /// holds a different branch.
    pub fn push(&self) -> std::option::Option<&std::boxed::Box<crate::model::PushFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::repository_event_config::Filter::Push(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter]
    /// to hold a `Push`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_push<T: std::convert::Into<std::boxed::Box<crate::model::PushFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::repository_event_config::Filter::Push(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RepositoryEventConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RepositoryEventConfig"
    }
}

/// Defines additional types related to [RepositoryEventConfig].
pub mod repository_event_config {
    #[allow(unused_imports)]
    use super::*;

    /// All possible SCM repo types from Repo API.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RepositoryType {
        /// If unspecified, RepositoryType defaults to GITHUB.
        Unspecified,
        /// The SCM repo is GITHUB.
        Github,
        /// The SCM repo is GITHUB Enterprise.
        GithubEnterprise,
        /// The SCM repo is GITLAB Enterprise.
        GitlabEnterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RepositoryType::value] or
        /// [RepositoryType::name].
        UnknownValue(repository_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod repository_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RepositoryType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Github => std::option::Option::Some(1),
                Self::GithubEnterprise => std::option::Option::Some(2),
                Self::GitlabEnterprise => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPOSITORY_TYPE_UNSPECIFIED"),
                Self::Github => std::option::Option::Some("GITHUB"),
                Self::GithubEnterprise => std::option::Option::Some("GITHUB_ENTERPRISE"),
                Self::GitlabEnterprise => std::option::Option::Some("GITLAB_ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RepositoryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RepositoryType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RepositoryType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Github,
                2 => Self::GithubEnterprise,
                3 => Self::GitlabEnterprise,
                _ => Self::UnknownValue(repository_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RepositoryType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPOSITORY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GITHUB" => Self::Github,
                "GITHUB_ENTERPRISE" => Self::GithubEnterprise,
                "GITLAB_ENTERPRISE" => Self::GitlabEnterprise,
                _ => Self::UnknownValue(repository_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RepositoryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Github => serializer.serialize_i32(1),
                Self::GithubEnterprise => serializer.serialize_i32(2),
                Self::GitlabEnterprise => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RepositoryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepositoryType>::new(
                ".google.devtools.cloudbuild.v1.RepositoryEventConfig.RepositoryType",
            ))
        }
    }

    /// The types of filter to trigger a build.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// Filter to match changes in pull requests.
        PullRequest(std::boxed::Box<crate::model::PullRequestFilter>),
        /// Filter to match changes in refs like branches, tags.
        Push(std::boxed::Box<crate::model::PushFilter>),
    }
}

/// GitHubEventsConfig describes the configuration of a trigger that creates a
/// build whenever a GitHub event is received.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEventsConfig {
    /// The installationID that emits the GitHub event.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    #[deprecated]
    pub installation_id: i64,

    /// Owner of the repository. For example: The owner for
    /// <https://github.com/googlecloudplatform/cloud-builders> is
    /// "googlecloudplatform".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub owner: std::string::String,

    /// Name of the repository. For example: The name for
    /// <https://github.com/googlecloudplatform/cloud-builders> is "cloud-builders".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub event: std::option::Option<crate::model::git_hub_events_config::Event>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEventsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [installation_id][crate::model::GitHubEventsConfig::installation_id].
    #[deprecated]
    pub fn set_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.installation_id = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::GitHubEventsConfig::owner].
    pub fn set_owner<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GitHubEventsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event].
    ///
    /// Note that all the setters affecting `event` are mutually
    /// exclusive.
    pub fn set_event<
        T: std::convert::Into<std::option::Option<crate::model::git_hub_events_config::Event>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }

    /// The value of [event][crate::model::GitHubEventsConfig::event]
    /// if it holds a `PullRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pull_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PullRequestFilter>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::git_hub_events_config::Event::PullRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event]
    /// to hold a `PullRequest`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_pull_request<
        T: std::convert::Into<std::boxed::Box<crate::model::PullRequestFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = std::option::Option::Some(
            crate::model::git_hub_events_config::Event::PullRequest(v.into()),
        );
        self
    }

    /// The value of [event][crate::model::GitHubEventsConfig::event]
    /// if it holds a `Push`, `None` if the field is not set or
    /// holds a different branch.
    pub fn push(&self) -> std::option::Option<&std::boxed::Box<crate::model::PushFilter>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::git_hub_events_config::Event::Push(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event]
    /// to hold a `Push`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_push<T: std::convert::Into<std::boxed::Box<crate::model::PushFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event =
            std::option::Option::Some(crate::model::git_hub_events_config::Event::Push(v.into()));
        self
    }
}

impl wkt::message::Message for GitHubEventsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEventsConfig"
    }
}

/// Defines additional types related to [GitHubEventsConfig].
pub mod git_hub_events_config {
    #[allow(unused_imports)]
    use super::*;

    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Event {
        /// filter to match changes in pull requests.
        PullRequest(std::boxed::Box<crate::model::PullRequestFilter>),
        /// filter to match changes in refs like branches, tags.
        Push(std::boxed::Box<crate::model::PushFilter>),
    }
}

/// PubsubConfig describes the configuration of a trigger that
/// creates a build whenever a Pub/Sub message is published.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PubsubConfig {
    /// Output only. Name of the subscription. Format is
    /// `projects/{project}/subscriptions/{subscription}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub subscription: std::string::String,

    /// The name of the topic from which this subscription is receiving messages.
    /// Format is `projects/{project}/topics/{topic}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub topic: std::string::String,

    /// Service account that will make the push request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account_email: std::string::String,

    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::pubsub_config::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PubsubConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::PubsubConfig::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::PubsubConfig::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::PubsubConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PubsubConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::pubsub_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for PubsubConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PubsubConfig"
    }
}

/// Defines additional types related to [PubsubConfig].
pub mod pubsub_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates potential issues with the underlying Pub/Sub subscription
    /// configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The subscription configuration has not been checked.
        Unspecified,
        /// The Pub/Sub subscription is properly configured.
        Ok,
        /// The subscription has been deleted.
        SubscriptionDeleted,
        /// The topic has been deleted.
        TopicDeleted,
        /// Some of the subscription's field are misconfigured.
        SubscriptionMisconfigured,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::SubscriptionDeleted => std::option::Option::Some(2),
                Self::TopicDeleted => std::option::Option::Some(3),
                Self::SubscriptionMisconfigured => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::SubscriptionDeleted => std::option::Option::Some("SUBSCRIPTION_DELETED"),
                Self::TopicDeleted => std::option::Option::Some("TOPIC_DELETED"),
                Self::SubscriptionMisconfigured => {
                    std::option::Option::Some("SUBSCRIPTION_MISCONFIGURED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::SubscriptionDeleted,
                3 => Self::TopicDeleted,
                4 => Self::SubscriptionMisconfigured,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "SUBSCRIPTION_DELETED" => Self::SubscriptionDeleted,
                "TOPIC_DELETED" => Self::TopicDeleted,
                "SUBSCRIPTION_MISCONFIGURED" => Self::SubscriptionMisconfigured,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::SubscriptionDeleted => serializer.serialize_i32(2),
                Self::TopicDeleted => serializer.serialize_i32(3),
                Self::SubscriptionMisconfigured => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.PubsubConfig.State",
            ))
        }
    }
}

/// WebhookConfig describes the configuration of a trigger that
/// creates a build whenever a webhook is sent to a trigger's webhook URL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebhookConfig {
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::webhook_config::State,

    /// Auth method specifies how the webhook authenticates with GCP.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub auth_method: std::option::Option<crate::model::webhook_config::AuthMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebhookConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::WebhookConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::webhook_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [auth_method][crate::model::WebhookConfig::auth_method].
    ///
    /// Note that all the setters affecting `auth_method` are mutually
    /// exclusive.
    pub fn set_auth_method<
        T: std::convert::Into<std::option::Option<crate::model::webhook_config::AuthMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_method = v.into();
        self
    }

    /// The value of [auth_method][crate::model::WebhookConfig::auth_method]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.auth_method.as_ref().and_then(|v| match v {
            crate::model::webhook_config::AuthMethod::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [auth_method][crate::model::WebhookConfig::auth_method]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `auth_method` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.auth_method =
            std::option::Option::Some(crate::model::webhook_config::AuthMethod::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for WebhookConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.WebhookConfig"
    }
}

/// Defines additional types related to [WebhookConfig].
pub mod webhook_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates potential issues with the Secret Manager secret provided by the
    /// user.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The webhook auth configuration not been checked.
        Unspecified,
        /// The auth configuration is properly setup.
        Ok,
        /// The secret provided in auth_method has been deleted.
        SecretDeleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::SecretDeleted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::SecretDeleted => std::option::Option::Some("SECRET_DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::SecretDeleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "SECRET_DELETED" => Self::SecretDeleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::SecretDeleted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.WebhookConfig.State",
            ))
        }
    }

    /// Auth method specifies how the webhook authenticates with GCP.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthMethod {
        /// Required. Resource name for the secret required as a URL parameter.
        Secret(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// PullRequestFilter contains filter properties for matching GitHub Pull
/// Requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PullRequestFilter {
    /// If CommentControl is enabled, depending on the setting, builds may not
    /// fire until a repository writer comments `/gcbrun` on a pull
    /// request or `/gcbrun` is in the pull request description.
    /// Only PR comments that contain `/gcbrun` will trigger builds.
    ///
    /// If CommentControl is set to disabled, comments with `/gcbrun` from a user
    /// with repository write permission or above will
    /// still trigger builds to run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub comment_control: crate::model::pull_request_filter::CommentControl,

    /// If true, branches that do NOT match the git_ref will trigger a build.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub invert_regex: bool,

    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub git_ref: std::option::Option<crate::model::pull_request_filter::GitRef>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PullRequestFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [comment_control][crate::model::PullRequestFilter::comment_control].
    pub fn set_comment_control<
        T: std::convert::Into<crate::model::pull_request_filter::CommentControl>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.comment_control = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::PullRequestFilter::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [git_ref][crate::model::PullRequestFilter::git_ref].
    ///
    /// Note that all the setters affecting `git_ref` are mutually
    /// exclusive.
    pub fn set_git_ref<
        T: std::convert::Into<std::option::Option<crate::model::pull_request_filter::GitRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.git_ref = v.into();
        self
    }

    /// The value of [git_ref][crate::model::PullRequestFilter::git_ref]
    /// if it holds a `Branch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::pull_request_filter::GitRef::Branch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PullRequestFilter::git_ref]
    /// to hold a `Branch`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref =
            std::option::Option::Some(crate::model::pull_request_filter::GitRef::Branch(v.into()));
        self
    }
}

impl wkt::message::Message for PullRequestFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PullRequestFilter"
    }
}

/// Defines additional types related to [PullRequestFilter].
pub mod pull_request_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Controls whether or not a `/gcbrun` comment is required from a user with
    /// repository write permission or above in order to
    /// trigger Build runs for pull requests. Pull Request update events differ
    /// between repo types.
    /// Check repo specific guides
    /// ([GitHub](https://cloud.google.com/build/docs/automating-builds/github/build-repos-from-github-enterprise#creating_a_github_enterprise_trigger),
    /// [Bitbucket](https://cloud.google.com/build/docs/automating-builds/bitbucket/build-repos-from-bitbucket-server#creating_a_bitbucket_server_trigger),
    /// [GitLab](https://cloud.google.com/build/docs/automating-builds/gitlab/build-repos-from-gitlab#creating_a_gitlab_trigger)
    /// for details.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommentControl {
        /// Do not require `/gcbrun` comments from a user with repository write
        /// permission or above on pull requests before builds are triggered.
        /// Comments that contain `/gcbrun` will still fire builds so this should
        /// be thought of as comments not required.
        CommentsDisabled,
        /// Builds will only fire in response to pull requests if:
        ///
        /// . The pull request author has repository write permission or above and
        ///   `/gcbrun` is in the PR description.
        /// . A user with repository writer permissions or above comments `/gcbrun`
        ///   on a pull request authored by any user.
        CommentsEnabled,
        /// Builds will only fire in response to pull requests if:
        ///
        /// . The pull request author is a repository writer or above.
        /// . If the author does not have write permissions, a user with write
        ///   permissions or above must comment `/gcbrun` in order to fire a build.
        CommentsEnabledForExternalContributorsOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommentControl::value] or
        /// [CommentControl::name].
        UnknownValue(comment_control::UnknownValue),
    }

    #[doc(hidden)]
    pub mod comment_control {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommentControl {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::CommentsDisabled => std::option::Option::Some(0),
                Self::CommentsEnabled => std::option::Option::Some(1),
                Self::CommentsEnabledForExternalContributorsOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::CommentsDisabled => std::option::Option::Some("COMMENTS_DISABLED"),
                Self::CommentsEnabled => std::option::Option::Some("COMMENTS_ENABLED"),
                Self::CommentsEnabledForExternalContributorsOnly => {
                    std::option::Option::Some("COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommentControl {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommentControl {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommentControl {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::CommentsDisabled,
                1 => Self::CommentsEnabled,
                2 => Self::CommentsEnabledForExternalContributorsOnly,
                _ => Self::UnknownValue(comment_control::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommentControl {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMENTS_DISABLED" => Self::CommentsDisabled,
                "COMMENTS_ENABLED" => Self::CommentsEnabled,
                "COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY" => {
                    Self::CommentsEnabledForExternalContributorsOnly
                }
                _ => Self::UnknownValue(comment_control::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommentControl {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::CommentsDisabled => serializer.serialize_i32(0),
                Self::CommentsEnabled => serializer.serialize_i32(1),
                Self::CommentsEnabledForExternalContributorsOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommentControl {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommentControl>::new(
                ".google.devtools.cloudbuild.v1.PullRequestFilter.CommentControl",
            ))
        }
    }

    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GitRef {
        /// Regex of branches to match.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Branch(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// Push contains filter properties for matching GitHub git pushes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PushFilter {
    /// When true, only trigger a build if the revision regex does NOT match the
    /// git_ref regex.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub invert_regex: bool,

    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub git_ref: std::option::Option<crate::model::push_filter::GitRef>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PushFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [invert_regex][crate::model::PushFilter::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref].
    ///
    /// Note that all the setters affecting `git_ref` are mutually
    /// exclusive.
    pub fn set_git_ref<
        T: std::convert::Into<std::option::Option<crate::model::push_filter::GitRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.git_ref = v.into();
        self
    }

    /// The value of [git_ref][crate::model::PushFilter::git_ref]
    /// if it holds a `Branch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::push_filter::GitRef::Branch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref]
    /// to hold a `Branch`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref =
            std::option::Option::Some(crate::model::push_filter::GitRef::Branch(v.into()));
        self
    }

    /// The value of [git_ref][crate::model::PushFilter::git_ref]
    /// if it holds a `Tag`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::push_filter::GitRef::Tag(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref]
    /// to hold a `Tag`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref = std::option::Option::Some(crate::model::push_filter::GitRef::Tag(v.into()));
        self
    }
}

impl wkt::message::Message for PushFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PushFilter"
    }
}

/// Defines additional types related to [PushFilter].
pub mod push_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GitRef {
        /// Regexes matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Branch(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// Regexes matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Tag(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// Request to create a new `BuildTrigger`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBuildTriggerRequest {
    /// The parent resource where this trigger will be created.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the project for which to configure automatic builds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. `BuildTrigger` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger: std::option::Option<crate::model::BuildTrigger>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBuildTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CreateBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::CreateBuildTriggerRequest::trigger].
    pub fn set_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger][crate::model::CreateBuildTriggerRequest::trigger].
    pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateBuildTriggerRequest"
    }
}

/// Returns the `BuildTrigger` with the specified ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBuildTriggerRequest {
    /// The name of the `Trigger` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the project that owns the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. Identifier (`id` or `name`) of the `BuildTrigger` to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trigger_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::GetBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for GetBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetBuildTriggerRequest"
    }
}

/// Request to list existing `BuildTriggers`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildTriggersRequest {
    /// The parent of the collection of `Triggers`.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the project for which to list BuildTriggers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Number of results to return in the list.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBuildTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ListBuildTriggersRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBuildTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBuildTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildTriggersRequest"
    }
}

/// Response containing existing `BuildTriggers`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBuildTriggersResponse {
    /// `BuildTriggers` for the project, sorted by `create_time` descending.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub triggers: std::vec::Vec<crate::model::BuildTrigger>,

    /// Token to receive the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [triggers][crate::model::ListBuildTriggersResponse::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildTrigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBuildTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildTriggersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBuildTriggersResponse {
    type PageItem = crate::model::BuildTrigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to delete a `BuildTrigger`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBuildTriggerRequest {
    /// The name of the `Trigger` to delete.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the project that owns the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. ID of the `BuildTrigger` to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trigger_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DeleteBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::DeleteBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteBuildTriggerRequest"
    }
}

/// Request to update an existing `BuildTrigger`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBuildTriggerRequest {
    /// Required. ID of the project that owns the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Required. ID of the `BuildTrigger` to update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trigger_id: std::string::String,

    /// Required. `BuildTrigger` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger: std::option::Option<crate::model::BuildTrigger>,

    /// Update mask for the resource. If this is set,
    /// the server will only update the fields specified in the field mask.
    /// Otherwise, a full update of the mutable resource fields will be performed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::UpdateBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::UpdateBuildTriggerRequest::trigger].
    pub fn set_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger][crate::model::UpdateBuildTriggerRequest::trigger].
    pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBuildTriggerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBuildTriggerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateBuildTriggerRequest"
    }
}

/// Optional arguments to enable specific features of builds.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildOptions {
    /// Requested hash for SourceProvenance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub source_provenance_hash: std::vec::Vec<crate::model::hash::HashType>,

    /// Requested verifiability options.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_verify_option: crate::model::build_options::VerifyOption,

    /// Compute Engine machine type on which to run the build.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub machine_type: crate::model::build_options::MachineType,

    /// Requested disk size for the VM that runs the build. Note that this is *NOT*
    /// "disk free"; some of the space will be used by the operating system and
    /// build utilities. Also note that this is the minimum disk size that will be
    /// allocated for the build -- the build may run with a larger disk than
    /// requested. At present, the maximum disk size is 4000GB; builds that request
    /// more than the maximum are rejected with an error.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub disk_size_gb: i64,

    /// Option to specify behavior when there is an error in the substitution
    /// checks.
    ///
    /// NOTE: this is always set to ALLOW_LOOSE for triggered builds and cannot
    /// be overridden in the build configuration file.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub substitution_option: crate::model::build_options::SubstitutionOption,

    /// Option to specify whether or not to apply bash style string
    /// operations to the substitutions.
    ///
    /// NOTE: this is always enabled for triggered builds and cannot be
    /// overridden in the build configuration file.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dynamic_substitutions: bool,

    /// Option to include built-in and custom substitutions as env variables
    /// for all build steps.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automap_substitutions: bool,

    /// Option to define build log streaming behavior to Cloud
    /// Storage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub log_streaming_option: crate::model::build_options::LogStreamingOption,

    /// This field deprecated; please use `pool.name` instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    #[deprecated]
    pub worker_pool: std::string::String,

    /// Optional. Specification for execution on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool)
    /// for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pool: std::option::Option<crate::model::build_options::PoolOption>,

    /// Option to specify the logging mode, which determines if and where build
    /// logs are stored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub logging: crate::model::build_options::LoggingMode,

    /// A list of global environment variable definitions that will exist for all
    /// build steps in this build. If a variable is defined in both globally and in
    /// a build step, the variable will use the build step value.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub env: std::vec::Vec<std::string::String>,

    /// A list of global environment variables, which are encrypted using a Cloud
    /// Key Management Service crypto key. These values must be specified in the
    /// build's `Secret`. These variables will be available to all build steps
    /// in this build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub secret_env: std::vec::Vec<std::string::String>,

    /// Global list of volumes to mount for ALL build steps
    ///
    /// Each volume is created as an empty volume prior to starting the build
    /// process. Upon completion of the build, volumes and their contents are
    /// discarded. Global volume names and paths cannot conflict with the volumes
    /// defined a build step.
    ///
    /// Using a global volume in a build with only one step is not valid as
    /// it is indicative of a build request with an incorrect configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. Option to specify how default logs buckets are setup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub default_logs_bucket_behavior: crate::model::build_options::DefaultLogsBucketBehavior,

    /// Optional. Option to specify whether structured logging is enabled.
    ///
    /// If true, JSON-formatted logs are parsed as structured logs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub enable_structured_logging: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_provenance_hash][crate::model::BuildOptions::source_provenance_hash].
    pub fn set_source_provenance_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::hash::HashType>,
    {
        use std::iter::Iterator;
        self.source_provenance_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [requested_verify_option][crate::model::BuildOptions::requested_verify_option].
    pub fn set_requested_verify_option<
        T: std::convert::Into<crate::model::build_options::VerifyOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_verify_option = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::BuildOptions::machine_type].
    pub fn set_machine_type<T: std::convert::Into<crate::model::build_options::MachineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::BuildOptions::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [substitution_option][crate::model::BuildOptions::substitution_option].
    pub fn set_substitution_option<
        T: std::convert::Into<crate::model::build_options::SubstitutionOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.substitution_option = v.into();
        self
    }

    /// Sets the value of [dynamic_substitutions][crate::model::BuildOptions::dynamic_substitutions].
    pub fn set_dynamic_substitutions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dynamic_substitutions = v.into();
        self
    }

    /// Sets the value of [automap_substitutions][crate::model::BuildOptions::automap_substitutions].
    pub fn set_automap_substitutions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.automap_substitutions = v.into();
        self
    }

    /// Sets the value of [log_streaming_option][crate::model::BuildOptions::log_streaming_option].
    pub fn set_log_streaming_option<
        T: std::convert::Into<crate::model::build_options::LogStreamingOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_streaming_option = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::BuildOptions::worker_pool].
    #[deprecated]
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [pool][crate::model::BuildOptions::pool].
    pub fn set_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::build_options::PoolOption>,
    {
        self.pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pool][crate::model::BuildOptions::pool].
    pub fn set_or_clear_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::build_options::PoolOption>,
    {
        self.pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging][crate::model::BuildOptions::logging].
    pub fn set_logging<T: std::convert::Into<crate::model::build_options::LoggingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.logging = v.into();
        self
    }

    /// Sets the value of [env][crate::model::BuildOptions::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_env][crate::model::BuildOptions::secret_env].
    pub fn set_secret_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::BuildOptions::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_logs_bucket_behavior][crate::model::BuildOptions::default_logs_bucket_behavior].
    pub fn set_default_logs_bucket_behavior<
        T: std::convert::Into<crate::model::build_options::DefaultLogsBucketBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_logs_bucket_behavior = v.into();
        self
    }

    /// Sets the value of [enable_structured_logging][crate::model::BuildOptions::enable_structured_logging].
    pub fn set_enable_structured_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_structured_logging = v.into();
        self
    }
}

impl wkt::message::Message for BuildOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOptions"
    }
}

/// Defines additional types related to [BuildOptions].
pub mod build_options {
    #[allow(unused_imports)]
    use super::*;

    /// Details about how a build should be executed on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool)
    /// for more information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PoolOption {
        /// The `WorkerPool` resource to execute the build on.
        /// You must have `cloudbuild.workerpools.use` on the project hosting the
        /// WorkerPool.
        ///
        /// Format projects/{project}/locations/{location}/workerPools/{workerPoolId}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PoolOption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::build_options::PoolOption::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for PoolOption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOptions.PoolOption"
        }
    }

    /// Specifies the manner in which the build should be verified, if at all.
    ///
    /// If a verified build is requested, and any part of the process to generate
    /// and upload provenance fails, the build will also fail.
    ///
    /// If the build does not request verification then that process may occur, but
    /// is not guaranteed to. If it does occur and fails, the build will not fail.
    ///
    /// For more information, see [Viewing Build
    /// Provenance](https://cloud.google.com/build/docs/securing-builds/view-build-provenance).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VerifyOption {
        /// Not a verifiable build (the default).
        NotVerified,
        /// Build must be verified.
        Verified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VerifyOption::value] or
        /// [VerifyOption::name].
        UnknownValue(verify_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod verify_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VerifyOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NotVerified => std::option::Option::Some(0),
                Self::Verified => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NotVerified => std::option::Option::Some("NOT_VERIFIED"),
                Self::Verified => std::option::Option::Some("VERIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VerifyOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VerifyOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VerifyOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NotVerified,
                1 => Self::Verified,
                _ => Self::UnknownValue(verify_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VerifyOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NOT_VERIFIED" => Self::NotVerified,
                "VERIFIED" => Self::Verified,
                _ => Self::UnknownValue(verify_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VerifyOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NotVerified => serializer.serialize_i32(0),
                Self::Verified => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VerifyOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VerifyOption>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.VerifyOption",
            ))
        }
    }

    /// Supported Compute Engine machine types.
    /// For more information, see [Machine
    /// types](https://cloud.google.com/compute/docs/machine-types).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MachineType {
        /// Standard machine type.
        Unspecified,
        /// Highcpu machine with 8 CPUs.
        N1Highcpu8,
        /// Highcpu machine with 32 CPUs.
        N1Highcpu32,
        /// Highcpu e2 machine with 8 CPUs.
        E2Highcpu8,
        /// Highcpu e2 machine with 32 CPUs.
        E2Highcpu32,
        /// E2 machine with 1 CPU.
        E2Medium,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MachineType::value] or
        /// [MachineType::name].
        UnknownValue(machine_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod machine_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MachineType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::N1Highcpu8 => std::option::Option::Some(1),
                Self::N1Highcpu32 => std::option::Option::Some(2),
                Self::E2Highcpu8 => std::option::Option::Some(5),
                Self::E2Highcpu32 => std::option::Option::Some(6),
                Self::E2Medium => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::N1Highcpu8 => std::option::Option::Some("N1_HIGHCPU_8"),
                Self::N1Highcpu32 => std::option::Option::Some("N1_HIGHCPU_32"),
                Self::E2Highcpu8 => std::option::Option::Some("E2_HIGHCPU_8"),
                Self::E2Highcpu32 => std::option::Option::Some("E2_HIGHCPU_32"),
                Self::E2Medium => std::option::Option::Some("E2_MEDIUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MachineType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MachineType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MachineType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::N1Highcpu8,
                2 => Self::N1Highcpu32,
                5 => Self::E2Highcpu8,
                6 => Self::E2Highcpu32,
                7 => Self::E2Medium,
                _ => Self::UnknownValue(machine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MachineType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "N1_HIGHCPU_8" => Self::N1Highcpu8,
                "N1_HIGHCPU_32" => Self::N1Highcpu32,
                "E2_HIGHCPU_8" => Self::E2Highcpu8,
                "E2_HIGHCPU_32" => Self::E2Highcpu32,
                "E2_MEDIUM" => Self::E2Medium,
                _ => Self::UnknownValue(machine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MachineType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::N1Highcpu8 => serializer.serialize_i32(1),
                Self::N1Highcpu32 => serializer.serialize_i32(2),
                Self::E2Highcpu8 => serializer.serialize_i32(5),
                Self::E2Highcpu32 => serializer.serialize_i32(6),
                Self::E2Medium => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MachineType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MachineType>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.MachineType",
            ))
        }
    }

    /// Specifies the behavior when there is an error in the substitution checks.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SubstitutionOption {
        /// Fails the build if error in substitutions checks, like missing
        /// a substitution in the template or in the map.
        MustMatch,
        /// Do not fail the build if error in substitutions checks.
        AllowLoose,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SubstitutionOption::value] or
        /// [SubstitutionOption::name].
        UnknownValue(substitution_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod substitution_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SubstitutionOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::MustMatch => std::option::Option::Some(0),
                Self::AllowLoose => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::MustMatch => std::option::Option::Some("MUST_MATCH"),
                Self::AllowLoose => std::option::Option::Some("ALLOW_LOOSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SubstitutionOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SubstitutionOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SubstitutionOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::MustMatch,
                1 => Self::AllowLoose,
                _ => Self::UnknownValue(substitution_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SubstitutionOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MUST_MATCH" => Self::MustMatch,
                "ALLOW_LOOSE" => Self::AllowLoose,
                _ => Self::UnknownValue(substitution_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SubstitutionOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::MustMatch => serializer.serialize_i32(0),
                Self::AllowLoose => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SubstitutionOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SubstitutionOption>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.SubstitutionOption",
            ))
        }
    }

    /// Specifies the behavior when writing build logs to Cloud Storage.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogStreamingOption {
        /// Service may automatically determine build log streaming behavior.
        StreamDefault,
        /// Build logs should be streamed to Cloud Storage.
        StreamOn,
        /// Build logs should not be streamed to Cloud Storage; they will be
        /// written when the build is completed.
        StreamOff,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogStreamingOption::value] or
        /// [LogStreamingOption::name].
        UnknownValue(log_streaming_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod log_streaming_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LogStreamingOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::StreamDefault => std::option::Option::Some(0),
                Self::StreamOn => std::option::Option::Some(1),
                Self::StreamOff => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::StreamDefault => std::option::Option::Some("STREAM_DEFAULT"),
                Self::StreamOn => std::option::Option::Some("STREAM_ON"),
                Self::StreamOff => std::option::Option::Some("STREAM_OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LogStreamingOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LogStreamingOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LogStreamingOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::StreamDefault,
                1 => Self::StreamOn,
                2 => Self::StreamOff,
                _ => Self::UnknownValue(log_streaming_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LogStreamingOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STREAM_DEFAULT" => Self::StreamDefault,
                "STREAM_ON" => Self::StreamOn,
                "STREAM_OFF" => Self::StreamOff,
                _ => Self::UnknownValue(log_streaming_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LogStreamingOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::StreamDefault => serializer.serialize_i32(0),
                Self::StreamOn => serializer.serialize_i32(1),
                Self::StreamOff => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LogStreamingOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogStreamingOption>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.LogStreamingOption",
            ))
        }
    }

    /// Specifies the logging mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoggingMode {
        /// The service determines the logging mode. The default is `LEGACY`. Do not
        /// rely on the default logging behavior as it may change in the future.
        LoggingUnspecified,
        /// Build logs are stored in Cloud Logging and Cloud Storage.
        Legacy,
        /// Build logs are stored in Cloud Storage.
        GcsOnly,
        /// This option is the same as CLOUD_LOGGING_ONLY.
        #[deprecated]
        StackdriverOnly,
        /// Build logs are stored in Cloud Logging. Selecting this option will not
        /// allow [logs
        /// streaming](https://cloud.google.com/sdk/gcloud/reference/builds/log).
        CloudLoggingOnly,
        /// Turn off all logging. No build logs will be captured.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoggingMode::value] or
        /// [LoggingMode::name].
        UnknownValue(logging_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod logging_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoggingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::LoggingUnspecified => std::option::Option::Some(0),
                Self::Legacy => std::option::Option::Some(1),
                Self::GcsOnly => std::option::Option::Some(2),
                Self::StackdriverOnly => std::option::Option::Some(3),
                Self::CloudLoggingOnly => std::option::Option::Some(5),
                Self::None => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::LoggingUnspecified => std::option::Option::Some("LOGGING_UNSPECIFIED"),
                Self::Legacy => std::option::Option::Some("LEGACY"),
                Self::GcsOnly => std::option::Option::Some("GCS_ONLY"),
                Self::StackdriverOnly => std::option::Option::Some("STACKDRIVER_ONLY"),
                Self::CloudLoggingOnly => std::option::Option::Some("CLOUD_LOGGING_ONLY"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoggingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoggingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoggingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::LoggingUnspecified,
                1 => Self::Legacy,
                2 => Self::GcsOnly,
                3 => Self::StackdriverOnly,
                4 => Self::None,
                5 => Self::CloudLoggingOnly,
                _ => Self::UnknownValue(logging_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoggingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOGGING_UNSPECIFIED" => Self::LoggingUnspecified,
                "LEGACY" => Self::Legacy,
                "GCS_ONLY" => Self::GcsOnly,
                "STACKDRIVER_ONLY" => Self::StackdriverOnly,
                "CLOUD_LOGGING_ONLY" => Self::CloudLoggingOnly,
                "NONE" => Self::None,
                _ => Self::UnknownValue(logging_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoggingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::LoggingUnspecified => serializer.serialize_i32(0),
                Self::Legacy => serializer.serialize_i32(1),
                Self::GcsOnly => serializer.serialize_i32(2),
                Self::StackdriverOnly => serializer.serialize_i32(3),
                Self::CloudLoggingOnly => serializer.serialize_i32(5),
                Self::None => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoggingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoggingMode>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.LoggingMode",
            ))
        }
    }

    /// Default Cloud Storage log bucket behavior options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefaultLogsBucketBehavior {
        /// Unspecified.
        Unspecified,
        /// Bucket is located in user-owned project in the same region as the
        /// build. The builder service account must have access to create and write
        /// to Cloud Storage buckets in the build project.
        RegionalUserOwnedBucket,
        /// Bucket is located in a Google-owned project and is not regionalized.
        LegacyBucket,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DefaultLogsBucketBehavior::value] or
        /// [DefaultLogsBucketBehavior::name].
        UnknownValue(default_logs_bucket_behavior::UnknownValue),
    }

    #[doc(hidden)]
    pub mod default_logs_bucket_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DefaultLogsBucketBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RegionalUserOwnedBucket => std::option::Option::Some(1),
                Self::LegacyBucket => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED")
                }
                Self::RegionalUserOwnedBucket => {
                    std::option::Option::Some("REGIONAL_USER_OWNED_BUCKET")
                }
                Self::LegacyBucket => std::option::Option::Some("LEGACY_BUCKET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DefaultLogsBucketBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DefaultLogsBucketBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DefaultLogsBucketBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RegionalUserOwnedBucket,
                2 => Self::LegacyBucket,
                _ => Self::UnknownValue(default_logs_bucket_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DefaultLogsBucketBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "REGIONAL_USER_OWNED_BUCKET" => Self::RegionalUserOwnedBucket,
                "LEGACY_BUCKET" => Self::LegacyBucket,
                _ => Self::UnknownValue(default_logs_bucket_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DefaultLogsBucketBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RegionalUserOwnedBucket => serializer.serialize_i32(1),
                Self::LegacyBucket => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DefaultLogsBucketBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<DefaultLogsBucketBehavior>::new(
                    ".google.devtools.cloudbuild.v1.BuildOptions.DefaultLogsBucketBehavior",
                ),
            )
        }
    }
}

/// ReceiveTriggerWebhookRequest [Experimental] is the request object accepted by
/// the ReceiveTriggerWebhook method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReceiveTriggerWebhookRequest {
    /// The name of the `ReceiveTriggerWebhook` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// HTTP request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<api::model::HttpBody>,

    /// Project in which the specified trigger lives
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub project_id: std::string::String,

    /// Name of the trigger to run the payload against
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trigger: std::string::String,

    /// Secret token used for authorization if an OAuth token isn't provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub secret: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReceiveTriggerWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReceiveTriggerWebhookRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [body][crate::model::ReceiveTriggerWebhookRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::HttpBody>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::ReceiveTriggerWebhookRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::HttpBody>,
    {
        self.body = v.map(|x| x.into());
        self
    }

    /// Sets the value of [project_id][crate::model::ReceiveTriggerWebhookRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::ReceiveTriggerWebhookRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::ReceiveTriggerWebhookRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }
}

impl wkt::message::Message for ReceiveTriggerWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ReceiveTriggerWebhookRequest"
    }
}

/// ReceiveTriggerWebhookResponse [Experimental] is the response object for the
/// ReceiveTriggerWebhook method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReceiveTriggerWebhookResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReceiveTriggerWebhookResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReceiveTriggerWebhookResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ReceiveTriggerWebhookResponse"
    }
}

/// GitHubEnterpriseConfig represents a configuration for a GitHub Enterprise
/// server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEnterpriseConfig {
    /// Optional. The full resource name for the GitHubEnterpriseConfig
    /// For example:
    /// "projects/{$project_id}/locations/{$location_id}/githubEnterpriseConfigs/{$config_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The URL of the github enterprise host the configuration is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub host_url: std::string::String,

    /// Required. The GitHub app id of the Cloud Build app on the GitHub Enterprise
    /// server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub app_id: i64,

    /// Output only. Time when the installation was associated with the project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The key that should be attached to webhook calls to the ReceiveWebhook
    /// endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub webhook_key: std::string::String,

    /// Optional. The network to be used when reaching out to the GitHub
    /// Enterprise server. The VPC network must be enabled for private
    /// service connection. This should be set if the GitHub Enterprise server is
    /// hosted on-premises and not reachable by public internet.
    /// If this field is left empty, no network peering will occur and calls to
    /// the GitHub Enterprise server will be made over the public internet.
    /// Must be in the format
    /// `projects/{project}/global/networks/{network}`, where {project}
    /// is a project number or id and {network} is the name of a
    /// VPC network in the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub peered_network: std::string::String,

    /// Names of secrets in Secret Manager.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secrets: std::option::Option<crate::model::GitHubEnterpriseSecrets>,

    /// Name to display for this config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Optional. SSL certificate to use for requests to GitHub Enterprise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ssl_ca: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GitHubEnterpriseConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [host_url][crate::model::GitHubEnterpriseConfig::host_url].
    pub fn set_host_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_url = v.into();
        self
    }

    /// Sets the value of [app_id][crate::model::GitHubEnterpriseConfig::app_id].
    pub fn set_app_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GitHubEnterpriseConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GitHubEnterpriseConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_key][crate::model::GitHubEnterpriseConfig::webhook_key].
    pub fn set_webhook_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_key = v.into();
        self
    }

    /// Sets the value of [peered_network][crate::model::GitHubEnterpriseConfig::peered_network].
    pub fn set_peered_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peered_network = v.into();
        self
    }

    /// Sets the value of [secrets][crate::model::GitHubEnterpriseConfig::secrets].
    pub fn set_secrets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEnterpriseSecrets>,
    {
        self.secrets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secrets][crate::model::GitHubEnterpriseConfig::secrets].
    pub fn set_or_clear_secrets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEnterpriseSecrets>,
    {
        self.secrets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::GitHubEnterpriseConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [ssl_ca][crate::model::GitHubEnterpriseConfig::ssl_ca].
    pub fn set_ssl_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_ca = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEnterpriseConfig"
    }
}

/// GitHubEnterpriseSecrets represents the names of all necessary secrets in
/// Secret Manager for a GitHub Enterprise server.
/// Format is: projects/\<project number\>/secrets/\<secret name\>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEnterpriseSecrets {
    /// The resource name for the private key secret version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub private_key_version_name: std::string::String,

    /// The resource name for the webhook secret secret version in Secret Manager.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub webhook_secret_version_name: std::string::String,

    /// The resource name for the OAuth secret secret version in Secret Manager.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub oauth_secret_version_name: std::string::String,

    /// The resource name for the OAuth client ID secret version in Secret Manager.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub oauth_client_id_version_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseSecrets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key_version_name][crate::model::GitHubEnterpriseSecrets::private_key_version_name].
    pub fn set_private_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_key_version_name = v.into();
        self
    }

    /// Sets the value of [webhook_secret_version_name][crate::model::GitHubEnterpriseSecrets::webhook_secret_version_name].
    pub fn set_webhook_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_version_name = v.into();
        self
    }

    /// Sets the value of [oauth_secret_version_name][crate::model::GitHubEnterpriseSecrets::oauth_secret_version_name].
    pub fn set_oauth_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_secret_version_name = v.into();
        self
    }

    /// Sets the value of [oauth_client_id_version_name][crate::model::GitHubEnterpriseSecrets::oauth_client_id_version_name].
    pub fn set_oauth_client_id_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_client_id_version_name = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseSecrets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEnterpriseSecrets"
    }
}

/// Configuration for a `WorkerPool`.
///
/// Cloud Build owns and maintains a pool of workers for general use and have no
/// access to a project's private network. By default, builds submitted to
/// Cloud Build will use a worker from this pool.
///
/// If your build needs access to resources on a private network,
/// create and use a `WorkerPool` to run your builds. Private `WorkerPool`s give
/// your builds access to any single VPC network that you
/// administer, including any on-prem resources connected to that VPC
/// network. For an overview of private pools, see
/// [Private pools
/// overview](https://cloud.google.com/build/docs/private-pools/private-pools-overview).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkerPool {
    /// Output only. The resource name of the `WorkerPool`, with format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// The value of `{worker_pool}` is provided by `worker_pool_id` in
    /// `CreateWorkerPool` request and the value of `{location}` is determined by
    /// the endpoint accessed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// A user-specified, human-readable name for the `WorkerPool`. If provided,
    /// this value must be 1-63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. A unique identifier for the `WorkerPool`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// User specified annotations. See <https://google.aip.dev/128#annotations>
    /// for more details such as format and size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the request to create the `WorkerPool` was
    /// received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the request to update the `WorkerPool` was
    /// received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the request to delete the `WorkerPool` was
    /// received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `WorkerPool` state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::worker_pool::State,

    /// Output only. Checksum computed by the server. May be sent on update and
    /// delete requests to ensure that the client has an up-to-date value before
    /// proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Configuration for the `WorkerPool`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::worker_pool::Config>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkerPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkerPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkerPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkerPool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkerPool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkerPool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::WorkerPool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::WorkerPool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::WorkerPool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkerPool::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::WorkerPool::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::WorkerPool::state].
    pub fn set_state<T: std::convert::Into<crate::model::worker_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::WorkerPool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [config][crate::model::WorkerPool::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::worker_pool::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::WorkerPool::config]
    /// if it holds a `PrivatePoolV1Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_pool_v1_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivatePoolV1Config>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::worker_pool::Config::PrivatePoolV1Config(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::WorkerPool::config]
    /// to hold a `PrivatePoolV1Config`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_private_pool_v1_config<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivatePoolV1Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::worker_pool::Config::PrivatePoolV1Config(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkerPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.WorkerPool"
    }
}

/// Defines additional types related to [WorkerPool].
pub mod worker_pool {
    #[allow(unused_imports)]
    use super::*;

    /// State of the `WorkerPool`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State of the `WorkerPool` is unknown.
        Unspecified,
        /// `WorkerPool` is being created.
        Creating,
        /// `WorkerPool` is running.
        Running,
        /// `WorkerPool` is being deleted: cancelling builds and draining workers.
        Deleting,
        /// `WorkerPool` is deleted.
        Deleted,
        /// `WorkerPool` is being updated; new builds cannot be run.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Running,
                3 => Self::Deleting,
                4 => Self::Deleted,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "RUNNING" => Self::Running,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.WorkerPool.State",
            ))
        }
    }

    /// Configuration for the `WorkerPool`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// Legacy Private Pool configuration.
        PrivatePoolV1Config(std::boxed::Box<crate::model::PrivatePoolV1Config>),
    }
}

/// Configuration for a V1 `PrivatePool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivatePoolV1Config {
    /// Machine configuration for the workers in the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_config: std::option::Option<crate::model::private_pool_v_1_config::WorkerConfig>,

    /// Network configuration for the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::private_pool_v_1_config::NetworkConfig>,

    /// Immutable. Private Service Connect(PSC) Network configuration for the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_service_connect:
        std::option::Option<crate::model::private_pool_v_1_config::PrivateServiceConnect>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePoolV1Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_config][crate::model::PrivatePoolV1Config::worker_config].
    pub fn set_worker_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::WorkerConfig>,
    {
        self.worker_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_config][crate::model::PrivatePoolV1Config::worker_config].
    pub fn set_or_clear_worker_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::WorkerConfig>,
    {
        self.worker_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_config][crate::model::PrivatePoolV1Config::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::PrivatePoolV1Config::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_service_connect][crate::model::PrivatePoolV1Config::private_service_connect].
    pub fn set_private_service_connect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::PrivateServiceConnect>,
    {
        self.private_service_connect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_service_connect][crate::model::PrivatePoolV1Config::private_service_connect].
    pub fn set_or_clear_private_service_connect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::PrivateServiceConnect>,
    {
        self.private_service_connect = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrivatePoolV1Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config"
    }
}

/// Defines additional types related to [PrivatePoolV1Config].
pub mod private_pool_v_1_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the configuration to be used for creating workers in
    /// the pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WorkerConfig {
        /// Machine type of a worker, such as `e2-medium`.
        /// See [Worker pool config
        /// file](https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema).
        /// If left blank, Cloud Build will use a sensible default.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub machine_type: std::string::String,

        /// Size of the disk attached to the worker, in GB.
        /// See [Worker pool config
        /// file](https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema).
        /// Specify a value of up to 2000. If `0` is specified, Cloud Build will use
        /// a standard disk size.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
        pub disk_size_gb: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WorkerConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::private_pool_v_1_config::WorkerConfig::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [disk_size_gb][crate::model::private_pool_v_1_config::WorkerConfig::disk_size_gb].
        pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.disk_size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for WorkerConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.WorkerConfig"
        }
    }

    /// Defines the network configuration for the pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// Required. Immutable. The network definition that the workers are peered
        /// to. If this section is left empty, the workers will be peered to
        /// `WorkerPool.project_id` on the service producer network. Must be in the
        /// format `projects/{project}/global/networks/{network}`, where `{project}`
        /// is a project number, such as `12345`, and `{network}` is the name of a
        /// VPC network in the project. See
        /// [Understanding network configuration
        /// options](https://cloud.google.com/build/docs/private-pools/set-up-private-pool-environment)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub peered_network: std::string::String,

        /// Option to configure network egress for the workers.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub egress_option: crate::model::private_pool_v_1_config::network_config::EgressOption,

        /// Immutable. Subnet IP range within the peered network. This is specified
        /// in CIDR notation with a slash and the subnet prefix size. You can
        /// optionally specify an IP address before the subnet prefix value. e.g.
        /// `192.168.0.0/29` would specify an IP range starting at 192.168.0.0 with a
        /// prefix size of 29 bits.
        /// `/16` would specify a prefix size of 16 bits, with an automatically
        /// determined IP within the peered VPC.
        /// If unspecified, a value of `/24` will be used.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub peered_network_ip_range: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peered_network][crate::model::private_pool_v_1_config::NetworkConfig::peered_network].
        pub fn set_peered_network<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network = v.into();
            self
        }

        /// Sets the value of [egress_option][crate::model::private_pool_v_1_config::NetworkConfig::egress_option].
        pub fn set_egress_option<
            T: std::convert::Into<crate::model::private_pool_v_1_config::network_config::EgressOption>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.egress_option = v.into();
            self
        }

        /// Sets the value of [peered_network_ip_range][crate::model::private_pool_v_1_config::NetworkConfig::peered_network_ip_range].
        pub fn set_peered_network_ip_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network_ip_range = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.NetworkConfig"
        }
    }

    /// Defines additional types related to [NetworkConfig].
    pub mod network_config {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the egress option for the pool.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EgressOption {
            /// If set, defaults to PUBLIC_EGRESS.
            Unspecified,
            /// If set, workers are created without any public address, which prevents
            /// network egress to public IPs unless a network proxy is configured.
            NoPublicEgress,
            /// If set, workers are created with a public address which allows for
            /// public internet egress.
            PublicEgress,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EgressOption::value] or
            /// [EgressOption::name].
            UnknownValue(egress_option::UnknownValue),
        }

        #[doc(hidden)]
        pub mod egress_option {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EgressOption {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::NoPublicEgress => std::option::Option::Some(1),
                    Self::PublicEgress => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("EGRESS_OPTION_UNSPECIFIED"),
                    Self::NoPublicEgress => std::option::Option::Some("NO_PUBLIC_EGRESS"),
                    Self::PublicEgress => std::option::Option::Some("PUBLIC_EGRESS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EgressOption {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EgressOption {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EgressOption {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::NoPublicEgress,
                    2 => Self::PublicEgress,
                    _ => Self::UnknownValue(egress_option::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EgressOption {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "EGRESS_OPTION_UNSPECIFIED" => Self::Unspecified,
                    "NO_PUBLIC_EGRESS" => Self::NoPublicEgress,
                    "PUBLIC_EGRESS" => Self::PublicEgress,
                    _ => Self::UnknownValue(egress_option::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EgressOption {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::NoPublicEgress => serializer.serialize_i32(1),
                    Self::PublicEgress => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EgressOption {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EgressOption>::new(
                    ".google.devtools.cloudbuild.v1.PrivatePoolV1Config.NetworkConfig.EgressOption",
                ))
            }
        }
    }

    /// Defines the Private Service Connect network configuration for the pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrivateServiceConnect {
        /// Required. Immutable. The network attachment that the worker network
        /// interface is peered to. Must be in the format
        /// `projects/{project}/regions/{region}/networkAttachments/{networkAttachment}`.
        /// The region of network attachment must be the same as the worker pool.
        /// See [Network
        /// Attachments](https://cloud.google.com/vpc/docs/about-network-attachments)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub network_attachment: std::string::String,

        /// Required. Immutable. Disable public IP on the primary network interface.
        ///
        /// If true, workers are created without any public address, which prevents
        /// network egress to public IPs unless a network proxy is configured.
        /// If false, workers are created with a public address which allows for
        /// public internet egress. The public address only applies to traffic
        /// through the primary network interface.
        /// If `route_all_traffic` is set to true, all traffic will go through the
        /// non-primary network interface, this boolean has no effect.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub public_ip_address_disabled: bool,

        /// Immutable. Route all traffic through PSC interface. Enable this if you
        /// want full control of traffic in the private pool. Configure Cloud NAT for
        /// the subnet of network attachment if you need to access public Internet.
        ///
        /// If false, Only route private IPs, e.g. 10.0.0.0/8, 172.16.0.0/12, and
        /// 192.168.0.0/16 through PSC interface.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub route_all_traffic: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrivateServiceConnect {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_attachment][crate::model::private_pool_v_1_config::PrivateServiceConnect::network_attachment].
        pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_attachment = v.into();
            self
        }

        /// Sets the value of [public_ip_address_disabled][crate::model::private_pool_v_1_config::PrivateServiceConnect::public_ip_address_disabled].
        pub fn set_public_ip_address_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.public_ip_address_disabled = v.into();
            self
        }

        /// Sets the value of [route_all_traffic][crate::model::private_pool_v_1_config::PrivateServiceConnect::route_all_traffic].
        pub fn set_route_all_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.route_all_traffic = v.into();
            self
        }
    }

    impl wkt::message::Message for PrivateServiceConnect {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.PrivateServiceConnect"
        }
    }
}

/// Request to create a new `WorkerPool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkerPoolRequest {
    /// Required. The parent resource where this worker pool will be created.
    /// Format: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. `WorkerPool` resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_pool: std::option::Option<crate::model::WorkerPool>,

    /// Required. Immutable. The ID to use for the `WorkerPool`, which will become
    /// the final component of the resource name.
    ///
    /// This value should be 1-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub worker_pool_id: std::string::String,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkerPoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::CreateWorkerPoolRequest::worker_pool].
    pub fn set_worker_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_pool][crate::model::CreateWorkerPoolRequest::worker_pool].
    pub fn set_or_clear_worker_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [worker_pool_id][crate::model::CreateWorkerPoolRequest::worker_pool_id].
    pub fn set_worker_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateWorkerPoolRequest"
    }
}

/// Request to get a `WorkerPool` with the specified name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to retrieve.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkerPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetWorkerPoolRequest"
    }
}

/// Request to delete a `WorkerPool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. If provided, it must match the server's etag on the workerpool
    /// for the request to be processed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// If set to true, and the `WorkerPool` is not found, the request will succeed
    /// but no action will be taken on the server.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkerPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkerPoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteWorkerPoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteWorkerPoolRequest"
    }
}

/// Request to update a `WorkerPool`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkerPoolRequest {
    /// Required. The `WorkerPool` to update.
    ///
    /// The `name` field is used to identify the `WorkerPool` to update.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_pool: std::option::Option<crate::model::WorkerPool>,

    /// A mask specifying which fields in `worker_pool` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::UpdateWorkerPoolRequest::worker_pool].
    pub fn set_worker_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_pool][crate::model::UpdateWorkerPoolRequest::worker_pool].
    pub fn set_or_clear_worker_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkerPoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWorkerPoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateWorkerPoolRequest"
    }
}

/// Request to list `WorkerPool`s.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkerPoolsRequest {
    /// Required. The parent of the collection of `WorkerPools`.
    /// Format: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of `WorkerPool`s to return. The service may return
    /// fewer than this value. If omitted, the server will use a sensible default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkerPools` call. Provide this
    /// to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkerPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkerPoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkerPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkerPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkerPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListWorkerPoolsRequest"
    }
}

/// Response containing existing `WorkerPools`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkerPoolsResponse {
    /// `WorkerPools` for the specified project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub worker_pools: std::vec::Vec<crate::model::WorkerPool>,

    /// Continuation token used to page through large result sets. Provide this
    /// value in a subsequent ListWorkerPoolsRequest to return the next page of
    /// results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkerPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pools][crate::model::ListWorkerPoolsResponse::worker_pools].
    pub fn set_worker_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkerPool>,
    {
        use std::iter::Iterator;
        self.worker_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkerPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkerPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListWorkerPoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkerPoolsResponse {
    type PageItem = crate::model::WorkerPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.worker_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Metadata for the `CreateWorkerPool` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` to create.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::CreateWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateWorkerPoolOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::CreateWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::CreateWorkerPoolOperationMetadata::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateWorkerPoolOperationMetadata"
    }
}

/// Metadata for the `UpdateWorkerPool` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being updated.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::UpdateWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UpdateWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UpdateWorkerPoolOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::UpdateWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::UpdateWorkerPoolOperationMetadata::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateWorkerPoolOperationMetadata"
    }
}

/// Metadata for the `DeleteWorkerPool` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::DeleteWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteWorkerPoolOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::DeleteWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::DeleteWorkerPoolOperationMetadata::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteWorkerPoolOperationMetadata"
    }
}
