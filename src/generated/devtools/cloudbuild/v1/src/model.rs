// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Specifies a build to retry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryBuildRequest {
    /// The name of the `Build` to retry.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    pub name: std::string::String,

    /// Required. ID of the project.
    pub project_id: std::string::String,

    /// Required. Build ID of the original build.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RetryBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RetryBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::RetryBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for RetryBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RetryBuildRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryBuildRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies a build trigger to run and the source to use.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunBuildTriggerRequest {
    /// The name of the `Trigger` to run.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    pub name: std::string::String,

    /// Required. ID of the project.
    pub project_id: std::string::String,

    /// Required. ID of the trigger.
    pub trigger_id: std::string::String,

    /// Source to build against this trigger.
    /// Branch and tag names cannot consist of regular expressions.
    pub source: std::option::Option<crate::model::RepoSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RunBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::RunBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::RunBuildTriggerRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::RunBuildTriggerRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RunBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RunBuildTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __trigger_id,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::RepoSource>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunBuildTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunBuildTriggerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Location of the source in an archive file in Cloud Storage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageSource {
    /// Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    pub bucket: std::string::String,

    /// Cloud Storage object containing the source.
    ///
    /// This object must be a zipped (`.zip`) or gzipped archive file (`.tar.gz`)
    /// containing source to build.
    pub object: std::string::String,

    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    pub generation: i64,

    /// Option to specify the tool to fetch the source file for the build.
    pub source_fetcher: crate::model::storage_source::SourceFetcher,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSource::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSource::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [source_fetcher][crate::model::StorageSource::source_fetcher].
    pub fn set_source_fetcher<
        T: std::convert::Into<crate::model::storage_source::SourceFetcher>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_fetcher = v.into();
        self
    }
}

impl wkt::message::Message for StorageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.StorageSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __source_fetcher,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "sourceFetcher" => Ok(__FieldTag::__source_fetcher),
                            "source_fetcher" => Ok(__FieldTag::__source_fetcher),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_fetcher => {
                            if !fields.insert(__FieldTag::__source_fetcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_fetcher",
                                ));
                            }
                            result.source_fetcher =
                                map.next_value::<std::option::Option<
                                    crate::model::storage_source::SourceFetcher,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !wkt::internal::is_default(&self.source_fetcher) {
            state.serialize_entry("sourceFetcher", &self.source_fetcher)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StorageSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageSource");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("source_fetcher", &self.source_fetcher);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [StorageSource].
pub mod storage_source {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the tool to fetch the source file for the build.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceFetcher {
        /// Unspecified. Defaults to GSUTIL.
        Unspecified,
        /// Use the "gsutil" tool to download the source file.
        Gsutil,
        /// Use the Cloud Storage Fetcher tool to download the source file.
        GcsFetcher,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceFetcher::value] or
        /// [SourceFetcher::name].
        UnknownValue(source_fetcher::UnknownValue),
    }

    #[doc(hidden)]
    pub mod source_fetcher {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SourceFetcher {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gsutil => std::option::Option::Some(1),
                Self::GcsFetcher => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SOURCE_FETCHER_UNSPECIFIED"),
                Self::Gsutil => std::option::Option::Some("GSUTIL"),
                Self::GcsFetcher => std::option::Option::Some("GCS_FETCHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SourceFetcher {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SourceFetcher {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SourceFetcher {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gsutil,
                2 => Self::GcsFetcher,
                _ => Self::UnknownValue(source_fetcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SourceFetcher {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SOURCE_FETCHER_UNSPECIFIED" => Self::Unspecified,
                "GSUTIL" => Self::Gsutil,
                "GCS_FETCHER" => Self::GcsFetcher,
                _ => Self::UnknownValue(source_fetcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SourceFetcher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gsutil => serializer.serialize_i32(1),
                Self::GcsFetcher => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SourceFetcher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceFetcher>::new(
                ".google.devtools.cloudbuild.v1.StorageSource.SourceFetcher",
            ))
        }
    }
}

/// Location of the source in any accessible Git repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitSource {
    /// Location of the Git repo to build.
    ///
    /// This will be used as a `git remote`, see
    /// <https://git-scm.com/docs/git-remote>.
    pub url: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    pub dir: std::string::String,

    /// The revision to fetch from the Git repository such as a branch, a tag, a
    /// commit SHA, or any Git ref.
    ///
    /// Cloud Build uses `git fetch` to fetch the revision from the Git
    /// repository; therefore make sure that the string you provide for `revision`
    /// is parsable  by the command. For information on string values accepted by
    /// `git fetch`, see
    /// <https://git-scm.com/docs/gitrevisions#_specifying_revisions>. For
    /// information on `git fetch`, see <https://git-scm.com/docs/git-fetch>.
    pub revision: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::GitSource::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::GitSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GitSource::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }
}

impl wkt::message::Message for GitSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __dir,
            __revision,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "dir" => Ok(__FieldTag::__dir),
                            "revision" => Ok(__FieldTag::__revision),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.dir.is_empty() {
            state.serialize_entry("dir", &self.dir)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitSource");
        debug_struct.field("url", &self.url);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Location of the source in a Google Cloud Source Repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepoSource {
    /// ID of the project that owns the Cloud Source Repository. If omitted, the
    /// project ID requesting the build is assumed.
    pub project_id: std::string::String,

    /// Name of the Cloud Source Repository.
    pub repo_name: std::string::String,

    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    pub dir: std::string::String,

    /// Only trigger a build if the revision regex does NOT match the revision
    /// regex.
    pub invert_regex: bool,

    /// Substitutions to use in a triggered build.
    /// Should only be used with RunBuildTrigger
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    pub revision: std::option::Option<crate::model::repo_source::Revision>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RepoSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [repo_name][crate::model::RepoSource::repo_name].
    pub fn set_repo_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repo_name = v.into();
        self
    }

    /// Sets the value of [dir][crate::model::RepoSource::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::RepoSource::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::RepoSource::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision].
    ///
    /// Note that all the setters affecting `revision` are mutually
    /// exclusive.
    pub fn set_revision<
        T: std::convert::Into<std::option::Option<crate::model::repo_source::Revision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.revision = v.into();
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `BranchName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::BranchName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `BranchName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_branch_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::BranchName(v.into()));
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `TagName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::TagName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `TagName`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_tag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::TagName(v.into()));
        self
    }

    /// The value of [revision][crate::model::RepoSource::revision]
    /// if it holds a `CommitSha`, `None` if the field is not set or
    /// holds a different branch.
    pub fn commit_sha(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.revision.as_ref().and_then(|v| match v {
            crate::model::repo_source::Revision::CommitSha(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [revision][crate::model::RepoSource::revision]
    /// to hold a `CommitSha`.
    ///
    /// Note that all the setters affecting `revision` are
    /// mutually exclusive.
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision =
            std::option::Option::Some(crate::model::repo_source::Revision::CommitSha(v.into()));
        self
    }
}

impl wkt::message::Message for RepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RepoSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepoSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __repo_name,
            __branch_name,
            __tag_name,
            __commit_sha,
            __dir,
            __invert_regex,
            __substitutions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepoSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "repoName" => Ok(__FieldTag::__repo_name),
                            "repo_name" => Ok(__FieldTag::__repo_name),
                            "branchName" => Ok(__FieldTag::__branch_name),
                            "branch_name" => Ok(__FieldTag::__branch_name),
                            "tagName" => Ok(__FieldTag::__tag_name),
                            "tag_name" => Ok(__FieldTag::__tag_name),
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            "dir" => Ok(__FieldTag::__dir),
                            "invertRegex" => Ok(__FieldTag::__invert_regex),
                            "invert_regex" => Ok(__FieldTag::__invert_regex),
                            "substitutions" => Ok(__FieldTag::__substitutions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepoSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepoSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repo_name => {
                            if !fields.insert(__FieldTag::__repo_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_name",
                                ));
                            }
                            result.repo_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__branch_name => {
                            if !fields.insert(__FieldTag::__branch_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch_name",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .google.devtools.cloudbuild.v1.RepoSource.branch_name, latest field was branchName",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::repo_source::Revision::BranchName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__tag_name => {
                            if !fields.insert(__FieldTag::__tag_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_name",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .google.devtools.cloudbuild.v1.RepoSource.tag_name, latest field was tagName",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::repo_source::Revision::TagName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .google.devtools.cloudbuild.v1.RepoSource.commit_sha, latest field was commitSha",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::repo_source::Revision::CommitSha(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invert_regex => {
                            if !fields.insert(__FieldTag::__invert_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invert_regex",
                                ));
                            }
                            result.invert_regex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substitutions => {
                            if !fields.insert(__FieldTag::__substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitutions",
                                ));
                            }
                            result.substitutions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepoSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.repo_name.is_empty() {
            state.serialize_entry("repoName", &self.repo_name)?;
        }
        if let Some(value) = self.branch_name() {
            state.serialize_entry("branchName", value)?;
        }
        if let Some(value) = self.tag_name() {
            state.serialize_entry("tagName", value)?;
        }
        if let Some(value) = self.commit_sha() {
            state.serialize_entry("commitSha", value)?;
        }
        if !self.dir.is_empty() {
            state.serialize_entry("dir", &self.dir)?;
        }
        if !wkt::internal::is_default(&self.invert_regex) {
            state.serialize_entry("invertRegex", &self.invert_regex)?;
        }
        if !self.substitutions.is_empty() {
            state.serialize_entry("substitutions", &self.substitutions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepoSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepoSource");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("repo_name", &self.repo_name);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("substitutions", &self.substitutions);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RepoSource].
pub mod repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Revision {
        /// Regex matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        BranchName(std::string::String),
        /// Regex matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        TagName(std::string::String),
        /// Explicit commit SHA to build.
        CommitSha(std::string::String),
    }
}

/// Location of the source manifest in Cloud Storage.
/// This feature is in Preview; see description
/// [here](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageSourceManifest {
    /// Cloud Storage bucket containing the source manifest (see [Bucket
    /// Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    pub bucket: std::string::String,

    /// Cloud Storage object containing the source manifest.
    ///
    /// This object must be a JSON file.
    pub object: std::string::String,

    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    pub generation: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSourceManifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSourceManifest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSourceManifest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSourceManifest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }
}

impl wkt::message::Message for StorageSourceManifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.StorageSourceManifest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageSourceManifest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageSourceManifest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageSourceManifest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageSourceManifest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageSourceManifest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StorageSourceManifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageSourceManifest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Location of the source in a supported storage service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {
    /// Location of source.
    pub source: std::option::Option<crate::model::source::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::Source::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::source::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source::Source::StorageSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `RepoSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repo_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::RepoSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::RepoSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `RepoSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repo_source<T: std::convert::Into<std::boxed::Box<crate::model::RepoSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::RepoSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GitSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::GitSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git_source<T: std::convert::Into<std::boxed::Box<crate::model::GitSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(crate::model::source::Source::GitSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Source::source]
    /// if it holds a `StorageSourceManifest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source_manifest(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSourceManifest>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source::Source::StorageSourceManifest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Source::source]
    /// to hold a `StorageSourceManifest`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source_manifest<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSourceManifest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::source::Source::StorageSourceManifest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Source"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_source,
            __repo_source,
            __git_source,
            __storage_source_manifest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageSource" => Ok(__FieldTag::__storage_source),
                            "storage_source" => Ok(__FieldTag::__storage_source),
                            "repoSource" => Ok(__FieldTag::__repo_source),
                            "repo_source" => Ok(__FieldTag::__repo_source),
                            "gitSource" => Ok(__FieldTag::__git_source),
                            "git_source" => Ok(__FieldTag::__git_source),
                            "storageSourceManifest" => Ok(__FieldTag::__storage_source_manifest),
                            "storage_source_manifest" => Ok(__FieldTag::__storage_source_manifest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_source => {
                            if !fields.insert(__FieldTag::__storage_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.storage_source, latest field was storageSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source::Source::StorageSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repo_source => {
                            if !fields.insert(__FieldTag::__repo_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.repo_source, latest field was repoSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source::Source::RepoSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RepoSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git_source => {
                            if !fields.insert(__FieldTag::__git_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.git_source, latest field was gitSource",
                                ));
                            }
                            result.source =
                                std::option::Option::Some(crate::model::source::Source::GitSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__storage_source_manifest => {
                            if !fields.insert(__FieldTag::__storage_source_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_source_manifest",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.storage_source_manifest, latest field was storageSourceManifest",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source::Source::StorageSourceManifest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageSourceManifest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Source {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.storage_source() {
            state.serialize_entry("storageSource", value)?;
        }
        if let Some(value) = self.repo_source() {
            state.serialize_entry("repoSource", value)?;
        }
        if let Some(value) = self.git_source() {
            state.serialize_entry("gitSource", value)?;
        }
        if let Some(value) = self.storage_source_manifest() {
            state.serialize_entry("storageSourceManifest", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    /// Location of source.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// If provided, get the source from this location in Cloud Storage.
        StorageSource(std::boxed::Box<crate::model::StorageSource>),
        /// If provided, get the source from this location in a Cloud Source
        /// Repository.
        RepoSource(std::boxed::Box<crate::model::RepoSource>),
        /// If provided, get the source from this Git repository.
        GitSource(std::boxed::Box<crate::model::GitSource>),
        /// If provided, get the source from this manifest in Cloud Storage.
        /// This feature is in Preview; see description
        /// [here](https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher).
        StorageSourceManifest(std::boxed::Box<crate::model::StorageSourceManifest>),
    }
}

/// An image built by the pipeline.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuiltImage {
    /// Name used to push the container image to Google Container Registry, as
    /// presented to `docker push`.
    pub name: std::string::String,

    /// Docker Registry 2.0 digest.
    pub digest: std::string::String,

    /// Output only. Stores timing information for pushing the specified image.
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuiltImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuiltImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::BuiltImage::digest].
    pub fn set_digest<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.digest = v.into();
        self
    }

    /// Sets the value of [push_timing][crate::model::BuiltImage::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::BuiltImage::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuiltImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuiltImage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuiltImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __digest,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuiltImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "digest" => Ok(__FieldTag::__digest),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuiltImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuiltImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuiltImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.digest.is_empty() {
            state.serialize_entry("digest", &self.digest)?;
        }
        if self.push_timing.is_some() {
            state.serialize_entry("pushTiming", &self.push_timing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuiltImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuiltImage");
        debug_struct.field("name", &self.name);
        debug_struct.field("digest", &self.digest);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Artifact uploaded using the PythonPackage directive.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadedPythonPackage {
    /// URI of the uploaded artifact.
    pub uri: std::string::String,

    /// Hash types and values of the Python Artifact.
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedPythonPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedPythonPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedPythonPackage::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedPythonPackage::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedPythonPackage::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedPythonPackage::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedPythonPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedPythonPackage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadedPythonPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedPythonPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadedPythonPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedPythonPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadedPythonPackage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.file_hashes.is_some() {
            state.serialize_entry("fileHashes", &self.file_hashes)?;
        }
        if self.push_timing.is_some() {
            state.serialize_entry("pushTiming", &self.push_timing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadedPythonPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedPythonPackage");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Maven artifact uploaded using the MavenArtifact directive.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadedMavenArtifact {
    /// URI of the uploaded artifact.
    pub uri: std::string::String,

    /// Hash types and values of the Maven Artifact.
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedMavenArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedMavenArtifact::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedMavenArtifact::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedMavenArtifact::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedMavenArtifact::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedMavenArtifact::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedMavenArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedMavenArtifact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadedMavenArtifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedMavenArtifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadedMavenArtifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedMavenArtifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadedMavenArtifact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.file_hashes.is_some() {
            state.serialize_entry("fileHashes", &self.file_hashes)?;
        }
        if self.push_timing.is_some() {
            state.serialize_entry("pushTiming", &self.push_timing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadedMavenArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedMavenArtifact");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Go module artifact uploaded to Artifact Registry using the GoModule
/// directive.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadedGoModule {
    /// URI of the uploaded artifact.
    pub uri: std::string::String,

    /// Hash types and values of the Go Module Artifact.
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedGoModule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedGoModule::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedGoModule::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedGoModule::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedGoModule::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedGoModule::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedGoModule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedGoModule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadedGoModule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedGoModule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadedGoModule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedGoModule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadedGoModule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.file_hashes.is_some() {
            state.serialize_entry("fileHashes", &self.file_hashes)?;
        }
        if self.push_timing.is_some() {
            state.serialize_entry("pushTiming", &self.push_timing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadedGoModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedGoModule");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An npm package uploaded to Artifact Registry using the NpmPackage
/// directive.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadedNpmPackage {
    /// URI of the uploaded npm package.
    pub uri: std::string::String,

    /// Hash types and values of the npm package.
    pub file_hashes: std::option::Option<crate::model::FileHashes>,

    /// Output only. Stores timing information for pushing the specified artifact.
    pub push_timing: std::option::Option<crate::model::TimeSpan>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadedNpmPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::UploadedNpmPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [file_hashes][crate::model::UploadedNpmPackage::file_hashes].
    pub fn set_file_hashes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_hashes][crate::model::UploadedNpmPackage::file_hashes].
    pub fn set_or_clear_file_hashes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileHashes>,
    {
        self.file_hashes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [push_timing][crate::model::UploadedNpmPackage::push_timing].
    pub fn set_push_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_timing][crate::model::UploadedNpmPackage::push_timing].
    pub fn set_or_clear_push_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.push_timing = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadedNpmPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UploadedNpmPackage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadedNpmPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedNpmPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadedNpmPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedNpmPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadedNpmPackage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.file_hashes.is_some() {
            state.serialize_entry("fileHashes", &self.file_hashes)?;
        }
        if self.push_timing.is_some() {
            state.serialize_entry("pushTiming", &self.push_timing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadedNpmPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedNpmPackage");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A step in the build pipeline.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildStep {
    /// Required. The name of the container image that will run this particular
    /// build step.
    ///
    /// If the image is available in the host's Docker daemon's cache, it
    /// will be run directly. If not, the host will attempt to pull the image
    /// first, using the builder service account's credentials if necessary.
    ///
    /// The Docker daemon's cache will already have the latest versions of all of
    /// the officially supported build steps
    /// ([<https://github.com/GoogleCloudPlatform/cloud-builders>](https://github.com/GoogleCloudPlatform/cloud-builders)).
    /// The Docker daemon will also have cached many of the layers for some popular
    /// images, like "ubuntu", "debian", but they will be refreshed at the time you
    /// attempt to use them.
    ///
    /// If you built an image in a previous build step, it will be stored in the
    /// host's Docker daemon's cache and is available to use as the name for a
    /// later build step.
    pub name: std::string::String,

    /// A list of environment variable definitions to be used when running a step.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    pub env: std::vec::Vec<std::string::String>,

    /// A list of arguments that will be presented to the step when it is started.
    ///
    /// If the image used to run the step's container has an entrypoint, the `args`
    /// are used as arguments to that entrypoint. If the image does not define
    /// an entrypoint, the first element in args is used as the entrypoint,
    /// and the remainder will be used as arguments.
    pub args: std::vec::Vec<std::string::String>,

    /// Working directory to use when running this step's container.
    ///
    /// If this value is a relative path, it is relative to the build's working
    /// directory. If this value is absolute, it may be outside the build's working
    /// directory, in which case the contents of the path may not be persisted
    /// across build step executions, unless a `volume` for that path is specified.
    ///
    /// If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
    /// which specifies an absolute path, the `RepoSource` `dir` is ignored for
    /// the step's execution.
    pub dir: std::string::String,

    /// Unique identifier for this build step, used in `wait_for` to
    /// reference this build step as a dependency.
    pub id: std::string::String,

    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in `wait_for`
    /// have completed successfully. If `wait_for` is empty, this build step will
    /// start when all previous build steps in the `Build.Steps` list have
    /// completed successfully.
    pub wait_for: std::vec::Vec<std::string::String>,

    /// Entrypoint to be used instead of the build step image's default entrypoint.
    /// If unset, the image's default entrypoint is used.
    pub entrypoint: std::string::String,

    /// A list of environment variables which are encrypted using a Cloud Key
    /// Management Service crypto key. These values must be specified in the
    /// build's `Secret`.
    pub secret_env: std::vec::Vec<std::string::String>,

    /// List of volumes to mount into the build step.
    ///
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents are
    /// discarded.
    ///
    /// Using a named volume in only one step is not valid as it is indicative
    /// of a build request with an incorrect configuration.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Output only. Stores timing information for executing this build step.
    pub timing: std::option::Option<crate::model::TimeSpan>,

    /// Output only. Stores timing information for pulling this build step's
    /// builder image only.
    pub pull_timing: std::option::Option<crate::model::TimeSpan>,

    /// Time limit for executing this build step. If not defined, the step has no
    /// time limit and will be allowed to continue to run until either it completes
    /// or the build itself times out.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Output only. Status of the build step. At this time, build step status is
    /// only updated on build completion; step status is not updated in real-time
    /// as the build progresses.
    pub status: crate::model::build::Status,

    /// Allow this build step to fail without failing the entire build.
    ///
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failure_detail field.
    pub allow_failure: bool,

    /// Output only. Return code from running the step.
    pub exit_code: i32,

    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes. If allow_failure
    /// is also specified, this field will take precedence.
    pub allow_exit_codes: std::vec::Vec<i32>,

    /// A shell script to be executed in the step.
    ///
    /// When script is provided, the user cannot specify the entrypoint or args.
    pub script: std::string::String,

    /// Option to include built-in and custom substitutions as env variables
    /// for this build step. This option will override the global option
    /// in BuildOption.
    pub automap_substitutions: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuildStep::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::BuildStep::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::BuildStep::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dir][crate::model::BuildStep::dir].
    pub fn set_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dir = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BuildStep::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait_for][crate::model::BuildStep::wait_for].
    pub fn set_wait_for<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.wait_for = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entrypoint][crate::model::BuildStep::entrypoint].
    pub fn set_entrypoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entrypoint = v.into();
        self
    }

    /// Sets the value of [secret_env][crate::model::BuildStep::secret_env].
    pub fn set_secret_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::BuildStep::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timing][crate::model::BuildStep::timing].
    pub fn set_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timing][crate::model::BuildStep::timing].
    pub fn set_or_clear_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pull_timing][crate::model::BuildStep::pull_timing].
    pub fn set_pull_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.pull_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pull_timing][crate::model::BuildStep::pull_timing].
    pub fn set_or_clear_pull_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.pull_timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::BuildStep::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::BuildStep::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::BuildStep::status].
    pub fn set_status<T: std::convert::Into<crate::model::build::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [allow_failure][crate::model::BuildStep::allow_failure].
    pub fn set_allow_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_failure = v.into();
        self
    }

    /// Sets the value of [exit_code][crate::model::BuildStep::exit_code].
    pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.exit_code = v.into();
        self
    }

    /// Sets the value of [allow_exit_codes][crate::model::BuildStep::allow_exit_codes].
    pub fn set_allow_exit_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.allow_exit_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [script][crate::model::BuildStep::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }

    /// Sets the value of [automap_substitutions][crate::model::BuildStep::automap_substitutions].
    pub fn set_automap_substitutions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automap_substitutions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automap_substitutions][crate::model::BuildStep::automap_substitutions].
    pub fn set_or_clear_automap_substitutions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automap_substitutions = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __env,
            __args,
            __dir,
            __id,
            __wait_for,
            __entrypoint,
            __secret_env,
            __volumes,
            __timing,
            __pull_timing,
            __timeout,
            __status,
            __allow_failure,
            __exit_code,
            __allow_exit_codes,
            __script,
            __automap_substitutions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "env" => Ok(__FieldTag::__env),
                            "args" => Ok(__FieldTag::__args),
                            "dir" => Ok(__FieldTag::__dir),
                            "id" => Ok(__FieldTag::__id),
                            "waitFor" => Ok(__FieldTag::__wait_for),
                            "wait_for" => Ok(__FieldTag::__wait_for),
                            "entrypoint" => Ok(__FieldTag::__entrypoint),
                            "secretEnv" => Ok(__FieldTag::__secret_env),
                            "secret_env" => Ok(__FieldTag::__secret_env),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "timing" => Ok(__FieldTag::__timing),
                            "pullTiming" => Ok(__FieldTag::__pull_timing),
                            "pull_timing" => Ok(__FieldTag::__pull_timing),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "status" => Ok(__FieldTag::__status),
                            "allowFailure" => Ok(__FieldTag::__allow_failure),
                            "allow_failure" => Ok(__FieldTag::__allow_failure),
                            "exitCode" => Ok(__FieldTag::__exit_code),
                            "exit_code" => Ok(__FieldTag::__exit_code),
                            "allowExitCodes" => Ok(__FieldTag::__allow_exit_codes),
                            "allow_exit_codes" => Ok(__FieldTag::__allow_exit_codes),
                            "script" => Ok(__FieldTag::__script),
                            "automapSubstitutions" => Ok(__FieldTag::__automap_substitutions),
                            "automap_substitutions" => Ok(__FieldTag::__automap_substitutions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait_for => {
                            if !fields.insert(__FieldTag::__wait_for) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_for",
                                ));
                            }
                            result.wait_for = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entrypoint => {
                            if !fields.insert(__FieldTag::__entrypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entrypoint",
                                ));
                            }
                            result.entrypoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_env => {
                            if !fields.insert(__FieldTag::__secret_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_env",
                                ));
                            }
                            result.secret_env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__timing => {
                            if !fields.insert(__FieldTag::__timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timing",
                                ));
                            }
                            result.timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::__pull_timing => {
                            if !fields.insert(__FieldTag::__pull_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_timing",
                                ));
                            }
                            result.pull_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::build::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_failure => {
                            if !fields.insert(__FieldTag::__allow_failure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_failure",
                                ));
                            }
                            result.allow_failure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exit_code => {
                            if !fields.insert(__FieldTag::__exit_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exit_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exit_code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allow_exit_codes => {
                            if !fields.insert(__FieldTag::__allow_exit_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_exit_codes",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allow_exit_codes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            result.script = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automap_substitutions => {
                            if !fields.insert(__FieldTag::__automap_substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automap_substitutions",
                                ));
                            }
                            result.automap_substitutions =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.env.is_empty() {
            state.serialize_entry("env", &self.env)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.dir.is_empty() {
            state.serialize_entry("dir", &self.dir)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.wait_for.is_empty() {
            state.serialize_entry("waitFor", &self.wait_for)?;
        }
        if !self.entrypoint.is_empty() {
            state.serialize_entry("entrypoint", &self.entrypoint)?;
        }
        if !self.secret_env.is_empty() {
            state.serialize_entry("secretEnv", &self.secret_env)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if self.timing.is_some() {
            state.serialize_entry("timing", &self.timing)?;
        }
        if self.pull_timing.is_some() {
            state.serialize_entry("pullTiming", &self.pull_timing)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !wkt::internal::is_default(&self.allow_failure) {
            state.serialize_entry("allowFailure", &self.allow_failure)?;
        }
        if !wkt::internal::is_default(&self.exit_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exitCode", &__With(&self.exit_code))?;
        }
        if !self.allow_exit_codes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("allowExitCodes", &__With(&self.allow_exit_codes))?;
        }
        if !self.script.is_empty() {
            state.serialize_entry("script", &self.script)?;
        }
        if self.automap_substitutions.is_some() {
            state.serialize_entry("automapSubstitutions", &self.automap_substitutions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuildStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildStep");
        debug_struct.field("name", &self.name);
        debug_struct.field("env", &self.env);
        debug_struct.field("args", &self.args);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("id", &self.id);
        debug_struct.field("wait_for", &self.wait_for);
        debug_struct.field("entrypoint", &self.entrypoint);
        debug_struct.field("secret_env", &self.secret_env);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("timing", &self.timing);
        debug_struct.field("pull_timing", &self.pull_timing);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("status", &self.status);
        debug_struct.field("allow_failure", &self.allow_failure);
        debug_struct.field("exit_code", &self.exit_code);
        debug_struct.field("allow_exit_codes", &self.allow_exit_codes);
        debug_struct.field("script", &self.script);
        debug_struct.field("automap_substitutions", &self.automap_substitutions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Volume describes a Docker container volume which is mounted into build steps
/// in order to persist files across build step execution.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Volume {
    /// Name of the volume to mount.
    ///
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    pub name: std::string::String,

    /// Path at which to mount the volume.
    ///
    /// Paths must be absolute and cannot conflict with other volume paths on the
    /// same build step or with certain reserved volume paths.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Volume::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Volume"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Volume {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Volume")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Volume;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Volume")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Volume {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Volume");
        debug_struct.field("name", &self.name);
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Artifacts created by the build pipeline.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Results {
    /// Container images that were built as a part of the build.
    pub images: std::vec::Vec<crate::model::BuiltImage>,

    /// List of build step digests, in the order corresponding to build step
    /// indices.
    pub build_step_images: std::vec::Vec<std::string::String>,

    /// Path to the artifact manifest for non-container artifacts uploaded to Cloud
    /// Storage. Only populated when artifacts are uploaded to Cloud Storage.
    pub artifact_manifest: std::string::String,

    /// Number of non-container artifacts uploaded to Cloud Storage. Only populated
    /// when artifacts are uploaded to Cloud Storage.
    pub num_artifacts: i64,

    /// List of build step outputs, produced by builder images, in the order
    /// corresponding to build step indices.
    ///
    /// [Cloud Builders](https://cloud.google.com/cloud-build/docs/cloud-builders)
    /// can produce this output by writing to `$BUILDER_OUTPUT/output`. Only the
    /// first 50KB of data is stored. Note that the `$BUILDER_OUTPUT` variable is
    /// read-only and can't be substituted.
    pub build_step_outputs: std::vec::Vec<::bytes::Bytes>,

    /// Time to push all non-container artifacts to Cloud Storage.
    pub artifact_timing: std::option::Option<crate::model::TimeSpan>,

    /// Python artifacts uploaded to Artifact Registry at the end of the build.
    pub python_packages: std::vec::Vec<crate::model::UploadedPythonPackage>,

    /// Maven artifacts uploaded to Artifact Registry at the end of the build.
    pub maven_artifacts: std::vec::Vec<crate::model::UploadedMavenArtifact>,

    /// Optional. Go module artifacts uploaded to Artifact Registry at the end of
    /// the build.
    pub go_modules: std::vec::Vec<crate::model::UploadedGoModule>,

    /// Npm packages uploaded to Artifact Registry at the end of the build.
    pub npm_packages: std::vec::Vec<crate::model::UploadedNpmPackage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Results {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [images][crate::model::Results::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuiltImage>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [build_step_images][crate::model::Results::build_step_images].
    pub fn set_build_step_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.build_step_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [artifact_manifest][crate::model::Results::artifact_manifest].
    pub fn set_artifact_manifest<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_manifest = v.into();
        self
    }

    /// Sets the value of [num_artifacts][crate::model::Results::num_artifacts].
    pub fn set_num_artifacts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.num_artifacts = v.into();
        self
    }

    /// Sets the value of [build_step_outputs][crate::model::Results::build_step_outputs].
    pub fn set_build_step_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.build_step_outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [artifact_timing][crate::model::Results::artifact_timing].
    pub fn set_artifact_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.artifact_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [artifact_timing][crate::model::Results::artifact_timing].
    pub fn set_or_clear_artifact_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeSpan>,
    {
        self.artifact_timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [python_packages][crate::model::Results::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedPythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::Results::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedMavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [go_modules][crate::model::Results::go_modules].
    pub fn set_go_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedGoModule>,
    {
        use std::iter::Iterator;
        self.go_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [npm_packages][crate::model::Results::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UploadedNpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Results {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Results"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Results {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __images,
            __build_step_images,
            __artifact_manifest,
            __num_artifacts,
            __build_step_outputs,
            __artifact_timing,
            __python_packages,
            __maven_artifacts,
            __go_modules,
            __npm_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Results")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "images" => Ok(__FieldTag::__images),
                            "buildStepImages" => Ok(__FieldTag::__build_step_images),
                            "build_step_images" => Ok(__FieldTag::__build_step_images),
                            "artifactManifest" => Ok(__FieldTag::__artifact_manifest),
                            "artifact_manifest" => Ok(__FieldTag::__artifact_manifest),
                            "numArtifacts" => Ok(__FieldTag::__num_artifacts),
                            "num_artifacts" => Ok(__FieldTag::__num_artifacts),
                            "buildStepOutputs" => Ok(__FieldTag::__build_step_outputs),
                            "build_step_outputs" => Ok(__FieldTag::__build_step_outputs),
                            "artifactTiming" => Ok(__FieldTag::__artifact_timing),
                            "artifact_timing" => Ok(__FieldTag::__artifact_timing),
                            "pythonPackages" => Ok(__FieldTag::__python_packages),
                            "python_packages" => Ok(__FieldTag::__python_packages),
                            "mavenArtifacts" => Ok(__FieldTag::__maven_artifacts),
                            "maven_artifacts" => Ok(__FieldTag::__maven_artifacts),
                            "goModules" => Ok(__FieldTag::__go_modules),
                            "go_modules" => Ok(__FieldTag::__go_modules),
                            "npmPackages" => Ok(__FieldTag::__npm_packages),
                            "npm_packages" => Ok(__FieldTag::__npm_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Results;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Results")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuiltImage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__build_step_images => {
                            if !fields.insert(__FieldTag::__build_step_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_step_images",
                                ));
                            }
                            result.build_step_images = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__artifact_manifest => {
                            if !fields.insert(__FieldTag::__artifact_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_manifest",
                                ));
                            }
                            result.artifact_manifest = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_artifacts => {
                            if !fields.insert(__FieldTag::__num_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_artifacts",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_artifacts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__build_step_outputs => {
                            if !fields.insert(__FieldTag::__build_step_outputs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_step_outputs",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.build_step_outputs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__artifact_timing => {
                            if !fields.insert(__FieldTag::__artifact_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_timing",
                                ));
                            }
                            result.artifact_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::__python_packages => {
                            if !fields.insert(__FieldTag::__python_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_packages",
                                ));
                            }
                            result.python_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedPythonPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maven_artifacts => {
                            if !fields.insert(__FieldTag::__maven_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maven_artifacts",
                                ));
                            }
                            result.maven_artifacts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedMavenArtifact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__go_modules => {
                            if !fields.insert(__FieldTag::__go_modules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for go_modules",
                                ));
                            }
                            result.go_modules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedGoModule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__npm_packages => {
                            if !fields.insert(__FieldTag::__npm_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for npm_packages",
                                ));
                            }
                            result.npm_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedNpmPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Results {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.images.is_empty() {
            state.serialize_entry("images", &self.images)?;
        }
        if !self.build_step_images.is_empty() {
            state.serialize_entry("buildStepImages", &self.build_step_images)?;
        }
        if !self.artifact_manifest.is_empty() {
            state.serialize_entry("artifactManifest", &self.artifact_manifest)?;
        }
        if !wkt::internal::is_default(&self.num_artifacts) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numArtifacts", &__With(&self.num_artifacts))?;
        }
        if !self.build_step_outputs.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("buildStepOutputs", &__With(&self.build_step_outputs))?;
        }
        if self.artifact_timing.is_some() {
            state.serialize_entry("artifactTiming", &self.artifact_timing)?;
        }
        if !self.python_packages.is_empty() {
            state.serialize_entry("pythonPackages", &self.python_packages)?;
        }
        if !self.maven_artifacts.is_empty() {
            state.serialize_entry("mavenArtifacts", &self.maven_artifacts)?;
        }
        if !self.go_modules.is_empty() {
            state.serialize_entry("goModules", &self.go_modules)?;
        }
        if !self.npm_packages.is_empty() {
            state.serialize_entry("npmPackages", &self.npm_packages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Results {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Results");
        debug_struct.field("images", &self.images);
        debug_struct.field("build_step_images", &self.build_step_images);
        debug_struct.field("artifact_manifest", &self.artifact_manifest);
        debug_struct.field("num_artifacts", &self.num_artifacts);
        debug_struct.field("build_step_outputs", &self.build_step_outputs);
        debug_struct.field("artifact_timing", &self.artifact_timing);
        debug_struct.field("python_packages", &self.python_packages);
        debug_struct.field("maven_artifacts", &self.maven_artifacts);
        debug_struct.field("go_modules", &self.go_modules);
        debug_struct.field("npm_packages", &self.npm_packages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An artifact that was uploaded during a build. This
/// is a single record in the artifact manifest JSON file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ArtifactResult {
    /// The path of an artifact in a Cloud Storage bucket, with the
    /// generation number. For example,
    /// `gs://mybucket/path/to/output.jar#generation`.
    pub location: std::string::String,

    /// The file hash of the artifact.
    pub file_hash: std::vec::Vec<crate::model::FileHashes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ArtifactResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ArtifactResult::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [file_hash][crate::model::ArtifactResult::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ArtifactResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ArtifactResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ArtifactResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __file_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArtifactResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "fileHash" => Ok(__FieldTag::__file_hash),
                            "file_hash" => Ok(__FieldTag::__file_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ArtifactResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArtifactResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hash => {
                            if !fields.insert(__FieldTag::__file_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hash",
                                ));
                            }
                            result.file_hash = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FileHashes>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ArtifactResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.file_hash.is_empty() {
            state.serialize_entry("fileHash", &self.file_hash)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ArtifactResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArtifactResult");
        debug_struct.field("location", &self.location);
        debug_struct.field("file_hash", &self.file_hash);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A build resource in the Cloud Build API.
///
/// At a high level, a `Build` describes where to find source code, how to build
/// it (for example, the builder image to run on the source), and where to store
/// the built artifacts.
///
/// Fields can include the following variables, which will be expanded when the
/// build is created:
///
/// - $PROJECT_ID: the project ID of the build.
/// - $PROJECT_NUMBER: the project number of the build.
/// - $LOCATION: the location/region of the build.
/// - $BUILD_ID: the autogenerated ID of the build.
/// - $REPO_NAME: the source repository name specified by RepoSource.
/// - $BRANCH_NAME: the branch name specified by RepoSource.
/// - $TAG_NAME: the tag name specified by RepoSource.
/// - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or
///   resolved from the specified branch or tag.
/// - $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Build {
    /// Output only. The 'Build' name with format:
    /// `projects/{project}/locations/{location}/builds/{build}`, where {build}
    /// is a unique identifier generated by the service.
    pub name: std::string::String,

    /// Output only. Unique identifier of the build.
    pub id: std::string::String,

    /// Output only. ID of the project.
    pub project_id: std::string::String,

    /// Output only. Status of the build.
    pub status: crate::model::build::Status,

    /// Output only. Customer-readable message about the current status.
    pub status_detail: std::string::String,

    /// The location of the source files to build.
    pub source: std::option::Option<crate::model::Source>,

    /// Required. The operations to be performed on the workspace.
    pub steps: std::vec::Vec<crate::model::BuildStep>,

    /// Output only. Results of the build.
    pub results: std::option::Option<crate::model::Results>,

    /// Output only. Time at which the request to create the build was received.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which execution of the build was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which execution of the build was finished.
    ///
    /// The difference between finish_time and start_time is the duration of the
    /// build's execution.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Amount of time that this build should be allowed to run, to second
    /// granularity. If this amount of time elapses, work on the build will cease
    /// and the build status will be `TIMEOUT`.
    ///
    /// `timeout` starts ticking from `startTime`.
    ///
    /// Default time is 60 minutes.
    pub timeout: std::option::Option<wkt::Duration>,

    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images are pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the `Build` resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build status is marked
    /// `FAILURE`.
    pub images: std::vec::Vec<std::string::String>,

    /// TTL in queue for this build. If provided and the build is enqueued longer
    /// than this value, the build will expire and the build status will be
    /// `EXPIRED`.
    ///
    /// The TTL starts ticking from create_time.
    pub queue_ttl: std::option::Option<wkt::Duration>,

    /// Artifacts produced by the build that should be uploaded upon
    /// successful completion of all build steps.
    pub artifacts: std::option::Option<crate::model::Artifacts>,

    /// Cloud Storage bucket where logs should be written (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    /// Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
    pub logs_bucket: std::string::String,

    /// Output only. A permanent fixed identifier for source.
    pub source_provenance: std::option::Option<crate::model::SourceProvenance>,

    /// Output only. The ID of the `BuildTrigger` that triggered this build, if it
    /// was triggered automatically.
    pub build_trigger_id: std::string::String,

    /// Special options for this build.
    pub options: std::option::Option<crate::model::BuildOptions>,

    /// Output only. URL to logs for this build in Google Cloud Console.
    pub log_url: std::string::String,

    /// Substitutions data for `Build` resource.
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Tags for annotation of a `Build`. These are not docker tags.
    pub tags: std::vec::Vec<std::string::String>,

    /// Secrets to decrypt using Cloud Key Management Service.
    /// Note: Secret Manager is the recommended technique
    /// for managing sensitive data with Cloud Build. Use `available_secrets` to
    /// configure builds to access secrets from Secret Manager. For instructions,
    /// see: <https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets>
    pub secrets: std::vec::Vec<crate::model::Secret>,

    /// Output only. Stores timing information for phases of the build. Valid keys
    /// are:
    ///
    /// * BUILD: time to execute all build steps.
    /// * PUSH: time to push all artifacts including docker images and non docker
    ///   artifacts.
    /// * FETCHSOURCE: time to fetch source.
    /// * SETUPBUILD: time to set up build.
    ///
    /// If the build does not specify source or images,
    /// these keys will not be included.
    pub timing: std::collections::HashMap<std::string::String, crate::model::TimeSpan>,

    /// Output only. Describes this build's approval configuration, status,
    /// and result.
    pub approval: std::option::Option<crate::model::BuildApproval>,

    /// IAM service account whose credentials will be used at build runtime.
    /// Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
    /// ACCOUNT can be email address or uniqueId of the service account.
    pub service_account: std::string::String,

    /// Secrets and secret environment variables.
    pub available_secrets: std::option::Option<crate::model::Secrets>,

    /// Output only. Non-fatal problems encountered during the execution of the
    /// build.
    pub warnings: std::vec::Vec<crate::model::build::Warning>,

    /// Optional. Configuration for git operations.
    pub git_config: std::option::Option<crate::model::GitConfig>,

    /// Output only. Contains information about the build when status=FAILURE.
    pub failure_info: std::option::Option<crate::model::build::FailureInfo>,

    /// Optional. Dependencies that the Cloud Build worker will fetch before
    /// executing user steps.
    pub dependencies: std::vec::Vec<crate::model::Dependency>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Build {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Build::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Build::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Build::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Build::status].
    pub fn set_status<T: std::convert::Into<crate::model::build::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::Build::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Build::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::Build::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [steps][crate::model::Build::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [results][crate::model::Build::results].
    pub fn set_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Results>,
    {
        self.results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [results][crate::model::Build::results].
    pub fn set_or_clear_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Results>,
    {
        self.results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Build::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Build::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Build::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Build::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::Build::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::Build::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::Build::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::Build::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [images][crate::model::Build::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [queue_ttl][crate::model::Build::queue_ttl].
    pub fn set_queue_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.queue_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue_ttl][crate::model::Build::queue_ttl].
    pub fn set_or_clear_queue_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.queue_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [artifacts][crate::model::Build::artifacts].
    pub fn set_artifacts<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Artifacts>,
    {
        self.artifacts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [artifacts][crate::model::Build::artifacts].
    pub fn set_or_clear_artifacts<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Artifacts>,
    {
        self.artifacts = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logs_bucket][crate::model::Build::logs_bucket].
    pub fn set_logs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logs_bucket = v.into();
        self
    }

    /// Sets the value of [source_provenance][crate::model::Build::source_provenance].
    pub fn set_source_provenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceProvenance>,
    {
        self.source_provenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_provenance][crate::model::Build::source_provenance].
    pub fn set_or_clear_source_provenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceProvenance>,
    {
        self.source_provenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_trigger_id][crate::model::Build::build_trigger_id].
    pub fn set_build_trigger_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_trigger_id = v.into();
        self
    }

    /// Sets the value of [options][crate::model::Build::options].
    pub fn set_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildOptions>,
    {
        self.options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [options][crate::model::Build::options].
    pub fn set_or_clear_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildOptions>,
    {
        self.options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_url][crate::model::Build::log_url].
    pub fn set_log_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_url = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::Build::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Build::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secrets][crate::model::Build::secrets].
    pub fn set_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Secret>,
    {
        use std::iter::Iterator;
        self.secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timing][crate::model::Build::timing].
    pub fn set_timing<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TimeSpan>,
    {
        use std::iter::Iterator;
        self.timing = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [approval][crate::model::Build::approval].
    pub fn set_approval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildApproval>,
    {
        self.approval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval][crate::model::Build::approval].
    pub fn set_or_clear_approval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildApproval>,
    {
        self.approval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::Build::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [available_secrets][crate::model::Build::available_secrets].
    pub fn set_available_secrets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secrets>,
    {
        self.available_secrets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_secrets][crate::model::Build::available_secrets].
    pub fn set_or_clear_available_secrets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secrets>,
    {
        self.available_secrets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warnings][crate::model::Build::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::build::Warning>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [git_config][crate::model::Build::git_config].
    pub fn set_git_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitConfig>,
    {
        self.git_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_config][crate::model::Build::git_config].
    pub fn set_or_clear_git_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitConfig>,
    {
        self.git_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failure_info][crate::model::Build::failure_info].
    pub fn set_failure_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::build::FailureInfo>,
    {
        self.failure_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failure_info][crate::model::Build::failure_info].
    pub fn set_or_clear_failure_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::build::FailureInfo>,
    {
        self.failure_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dependencies][crate::model::Build::dependencies].
    pub fn set_dependencies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dependency>,
    {
        use std::iter::Iterator;
        self.dependencies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Build {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Build"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Build {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __project_id,
            __status,
            __status_detail,
            __source,
            __steps,
            __results,
            __create_time,
            __start_time,
            __finish_time,
            __timeout,
            __images,
            __queue_ttl,
            __artifacts,
            __logs_bucket,
            __source_provenance,
            __build_trigger_id,
            __options,
            __log_url,
            __substitutions,
            __tags,
            __secrets,
            __timing,
            __approval,
            __service_account,
            __available_secrets,
            __warnings,
            __git_config,
            __failure_info,
            __dependencies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Build")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "status" => Ok(__FieldTag::__status),
                            "statusDetail" => Ok(__FieldTag::__status_detail),
                            "status_detail" => Ok(__FieldTag::__status_detail),
                            "source" => Ok(__FieldTag::__source),
                            "steps" => Ok(__FieldTag::__steps),
                            "results" => Ok(__FieldTag::__results),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "images" => Ok(__FieldTag::__images),
                            "queueTtl" => Ok(__FieldTag::__queue_ttl),
                            "queue_ttl" => Ok(__FieldTag::__queue_ttl),
                            "artifacts" => Ok(__FieldTag::__artifacts),
                            "logsBucket" => Ok(__FieldTag::__logs_bucket),
                            "logs_bucket" => Ok(__FieldTag::__logs_bucket),
                            "sourceProvenance" => Ok(__FieldTag::__source_provenance),
                            "source_provenance" => Ok(__FieldTag::__source_provenance),
                            "buildTriggerId" => Ok(__FieldTag::__build_trigger_id),
                            "build_trigger_id" => Ok(__FieldTag::__build_trigger_id),
                            "options" => Ok(__FieldTag::__options),
                            "logUrl" => Ok(__FieldTag::__log_url),
                            "log_url" => Ok(__FieldTag::__log_url),
                            "substitutions" => Ok(__FieldTag::__substitutions),
                            "tags" => Ok(__FieldTag::__tags),
                            "secrets" => Ok(__FieldTag::__secrets),
                            "timing" => Ok(__FieldTag::__timing),
                            "approval" => Ok(__FieldTag::__approval),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "availableSecrets" => Ok(__FieldTag::__available_secrets),
                            "available_secrets" => Ok(__FieldTag::__available_secrets),
                            "warnings" => Ok(__FieldTag::__warnings),
                            "gitConfig" => Ok(__FieldTag::__git_config),
                            "git_config" => Ok(__FieldTag::__git_config),
                            "failureInfo" => Ok(__FieldTag::__failure_info),
                            "failure_info" => Ok(__FieldTag::__failure_info),
                            "dependencies" => Ok(__FieldTag::__dependencies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Build;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Build")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::build::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_detail => {
                            if !fields.insert(__FieldTag::__status_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_detail",
                                ));
                            }
                            result.status_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuildStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results =
                                map.next_value::<std::option::Option<crate::model::Results>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__queue_ttl => {
                            if !fields.insert(__FieldTag::__queue_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queue_ttl",
                                ));
                            }
                            result.queue_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__artifacts => {
                            if !fields.insert(__FieldTag::__artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifacts",
                                ));
                            }
                            result.artifacts =
                                map.next_value::<std::option::Option<crate::model::Artifacts>>()?;
                        }
                        __FieldTag::__logs_bucket => {
                            if !fields.insert(__FieldTag::__logs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logs_bucket",
                                ));
                            }
                            result.logs_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_provenance => {
                            if !fields.insert(__FieldTag::__source_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_provenance",
                                ));
                            }
                            result.source_provenance = map
                                .next_value::<std::option::Option<crate::model::SourceProvenance>>(
                                )?;
                        }
                        __FieldTag::__build_trigger_id => {
                            if !fields.insert(__FieldTag::__build_trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_trigger_id",
                                ));
                            }
                            result.build_trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map
                                .next_value::<std::option::Option<crate::model::BuildOptions>>()?;
                        }
                        __FieldTag::__log_url => {
                            if !fields.insert(__FieldTag::__log_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_url",
                                ));
                            }
                            result.log_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substitutions => {
                            if !fields.insert(__FieldTag::__substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitutions",
                                ));
                            }
                            result.substitutions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__secrets => {
                            if !fields.insert(__FieldTag::__secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secrets",
                                ));
                            }
                            result.secrets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Secret>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__timing => {
                            if !fields.insert(__FieldTag::__timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timing",
                                ));
                            }
                            result.timing = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TimeSpan,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval => {
                            if !fields.insert(__FieldTag::__approval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval",
                                ));
                            }
                            result.approval = map
                                .next_value::<std::option::Option<crate::model::BuildApproval>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_secrets => {
                            if !fields.insert(__FieldTag::__available_secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_secrets",
                                ));
                            }
                            result.available_secrets =
                                map.next_value::<std::option::Option<crate::model::Secrets>>()?;
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::build::Warning>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_config => {
                            if !fields.insert(__FieldTag::__git_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_config",
                                ));
                            }
                            result.git_config =
                                map.next_value::<std::option::Option<crate::model::GitConfig>>()?;
                        }
                        __FieldTag::__failure_info => {
                            if !fields.insert(__FieldTag::__failure_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_info",
                                ));
                            }
                            result.failure_info = map.next_value::<std::option::Option<crate::model::build::FailureInfo>>()?
                                ;
                        }
                        __FieldTag::__dependencies => {
                            if !fields.insert(__FieldTag::__dependencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependencies",
                                ));
                            }
                            result.dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dependency>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Build {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_detail.is_empty() {
            state.serialize_entry("statusDetail", &self.status_detail)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if self.results.is_some() {
            state.serialize_entry("results", &self.results)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self.images.is_empty() {
            state.serialize_entry("images", &self.images)?;
        }
        if self.queue_ttl.is_some() {
            state.serialize_entry("queueTtl", &self.queue_ttl)?;
        }
        if self.artifacts.is_some() {
            state.serialize_entry("artifacts", &self.artifacts)?;
        }
        if !self.logs_bucket.is_empty() {
            state.serialize_entry("logsBucket", &self.logs_bucket)?;
        }
        if self.source_provenance.is_some() {
            state.serialize_entry("sourceProvenance", &self.source_provenance)?;
        }
        if !self.build_trigger_id.is_empty() {
            state.serialize_entry("buildTriggerId", &self.build_trigger_id)?;
        }
        if self.options.is_some() {
            state.serialize_entry("options", &self.options)?;
        }
        if !self.log_url.is_empty() {
            state.serialize_entry("logUrl", &self.log_url)?;
        }
        if !self.substitutions.is_empty() {
            state.serialize_entry("substitutions", &self.substitutions)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.secrets.is_empty() {
            state.serialize_entry("secrets", &self.secrets)?;
        }
        if !self.timing.is_empty() {
            state.serialize_entry("timing", &self.timing)?;
        }
        if self.approval.is_some() {
            state.serialize_entry("approval", &self.approval)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.available_secrets.is_some() {
            state.serialize_entry("availableSecrets", &self.available_secrets)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if self.git_config.is_some() {
            state.serialize_entry("gitConfig", &self.git_config)?;
        }
        if self.failure_info.is_some() {
            state.serialize_entry("failureInfo", &self.failure_info)?;
        }
        if !self.dependencies.is_empty() {
            state.serialize_entry("dependencies", &self.dependencies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Build {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Build");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_detail", &self.status_detail);
        debug_struct.field("source", &self.source);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("results", &self.results);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("finish_time", &self.finish_time);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("images", &self.images);
        debug_struct.field("queue_ttl", &self.queue_ttl);
        debug_struct.field("artifacts", &self.artifacts);
        debug_struct.field("logs_bucket", &self.logs_bucket);
        debug_struct.field("source_provenance", &self.source_provenance);
        debug_struct.field("build_trigger_id", &self.build_trigger_id);
        debug_struct.field("options", &self.options);
        debug_struct.field("log_url", &self.log_url);
        debug_struct.field("substitutions", &self.substitutions);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("secrets", &self.secrets);
        debug_struct.field("timing", &self.timing);
        debug_struct.field("approval", &self.approval);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("available_secrets", &self.available_secrets);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("git_config", &self.git_config);
        debug_struct.field("failure_info", &self.failure_info);
        debug_struct.field("dependencies", &self.dependencies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Build].
pub mod build {
    #[allow(unused_imports)]
    use super::*;

    /// A non-fatal problem encountered during the execution of the build.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// Explanation of the warning generated.
        pub text: std::string::String,

        /// The priority for this warning.
        pub priority: crate::model::build::warning::Priority,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::build::Warning::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [priority][crate::model::build::Warning::priority].
        pub fn set_priority<T: std::convert::Into<crate::model::build::warning::Priority>>(
            mut self,
            v: T,
        ) -> Self {
            self.priority = v.into();
            self
        }
    }

    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Build.Warning"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Warning {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __priority,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Warning")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "priority" => Ok(__FieldTag::__priority),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Warning;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Warning")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__priority => {
                                if !fields.insert(__FieldTag::__priority) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for priority",
                                    ));
                                }
                                result.priority = map.next_value::<std::option::Option<crate::model::build::warning::Priority>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Warning {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !wkt::internal::is_default(&self.priority) {
                state.serialize_entry("priority", &self.priority)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Warning {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Warning");
            debug_struct.field("text", &self.text);
            debug_struct.field("priority", &self.priority);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Warning].
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The relative importance of this warning.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Priority {
            /// Should not be used.
            Unspecified,
            /// e.g. deprecation warnings and alternative feature highlights.
            Info,
            /// e.g. automated detection of possible issues with the build.
            Warning,
            /// e.g. alerts that a feature used in the build is pending removal
            Alert,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Priority::value] or
            /// [Priority::name].
            UnknownValue(priority::UnknownValue),
        }

        #[doc(hidden)]
        pub mod priority {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Priority {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Info => std::option::Option::Some(1),
                    Self::Warning => std::option::Option::Some(2),
                    Self::Alert => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PRIORITY_UNSPECIFIED"),
                    Self::Info => std::option::Option::Some("INFO"),
                    Self::Warning => std::option::Option::Some("WARNING"),
                    Self::Alert => std::option::Option::Some("ALERT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Priority {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Priority {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Priority {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Info,
                    2 => Self::Warning,
                    3 => Self::Alert,
                    _ => Self::UnknownValue(priority::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Priority {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PRIORITY_UNSPECIFIED" => Self::Unspecified,
                    "INFO" => Self::Info,
                    "WARNING" => Self::Warning,
                    "ALERT" => Self::Alert,
                    _ => Self::UnknownValue(priority::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Priority {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Info => serializer.serialize_i32(1),
                    Self::Warning => serializer.serialize_i32(2),
                    Self::Alert => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Priority {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                    ".google.devtools.cloudbuild.v1.Build.Warning.Priority",
                ))
            }
        }
    }

    /// A fatal problem encountered during the execution of the build.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FailureInfo {
        /// The name of the failure.
        pub r#type: crate::model::build::failure_info::FailureType,

        /// Explains the failure issue in more detail using hard-coded text.
        pub detail: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailureInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::build::FailureInfo::type].
        pub fn set_type<T: std::convert::Into<crate::model::build::failure_info::FailureType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [detail][crate::model::build::FailureInfo::detail].
        pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.detail = v.into();
            self
        }
    }

    impl wkt::message::Message for FailureInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Build.FailureInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FailureInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __detail,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FailureInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "detail" => Ok(__FieldTag::__detail),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FailureInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FailureInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::build::failure_info::FailureType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__detail => {
                                if !fields.insert(__FieldTag::__detail) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detail",
                                    ));
                                }
                                result.detail = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FailureInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.detail.is_empty() {
                state.serialize_entry("detail", &self.detail)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FailureInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FailureInfo");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("detail", &self.detail);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [FailureInfo].
    pub mod failure_info {
        #[allow(unused_imports)]
        use super::*;

        /// The name of a fatal problem encountered during the execution of the
        /// build.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FailureType {
            /// Type unspecified
            Unspecified,
            /// Unable to push the image to the repository.
            PushFailed,
            /// Final image not found.
            PushImageNotFound,
            /// Unauthorized push of the final image.
            PushNotAuthorized,
            /// Backend logging failures. Should retry.
            LoggingFailure,
            /// A build step has failed.
            UserBuildStep,
            /// The source fetching has failed.
            FetchSourceFailed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FailureType::value] or
            /// [FailureType::name].
            UnknownValue(failure_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod failure_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FailureType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::PushFailed => std::option::Option::Some(1),
                    Self::PushImageNotFound => std::option::Option::Some(2),
                    Self::PushNotAuthorized => std::option::Option::Some(3),
                    Self::LoggingFailure => std::option::Option::Some(4),
                    Self::UserBuildStep => std::option::Option::Some(5),
                    Self::FetchSourceFailed => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FAILURE_TYPE_UNSPECIFIED"),
                    Self::PushFailed => std::option::Option::Some("PUSH_FAILED"),
                    Self::PushImageNotFound => std::option::Option::Some("PUSH_IMAGE_NOT_FOUND"),
                    Self::PushNotAuthorized => std::option::Option::Some("PUSH_NOT_AUTHORIZED"),
                    Self::LoggingFailure => std::option::Option::Some("LOGGING_FAILURE"),
                    Self::UserBuildStep => std::option::Option::Some("USER_BUILD_STEP"),
                    Self::FetchSourceFailed => std::option::Option::Some("FETCH_SOURCE_FAILED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FailureType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FailureType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FailureType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::PushFailed,
                    2 => Self::PushImageNotFound,
                    3 => Self::PushNotAuthorized,
                    4 => Self::LoggingFailure,
                    5 => Self::UserBuildStep,
                    6 => Self::FetchSourceFailed,
                    _ => Self::UnknownValue(failure_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FailureType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FAILURE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "PUSH_FAILED" => Self::PushFailed,
                    "PUSH_IMAGE_NOT_FOUND" => Self::PushImageNotFound,
                    "PUSH_NOT_AUTHORIZED" => Self::PushNotAuthorized,
                    "LOGGING_FAILURE" => Self::LoggingFailure,
                    "USER_BUILD_STEP" => Self::UserBuildStep,
                    "FETCH_SOURCE_FAILED" => Self::FetchSourceFailed,
                    _ => Self::UnknownValue(failure_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FailureType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::PushFailed => serializer.serialize_i32(1),
                    Self::PushImageNotFound => serializer.serialize_i32(2),
                    Self::PushNotAuthorized => serializer.serialize_i32(3),
                    Self::LoggingFailure => serializer.serialize_i32(4),
                    Self::UserBuildStep => serializer.serialize_i32(5),
                    Self::FetchSourceFailed => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FailureType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureType>::new(
                    ".google.devtools.cloudbuild.v1.Build.FailureInfo.FailureType",
                ))
            }
        }
    }

    /// Possible status of a build or build step.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Status of the build is unknown.
        Unknown,
        /// Build has been created and is pending execution and queuing. It has not
        /// been queued.
        Pending,
        /// Build or step is queued; work has not yet begun.
        Queued,
        /// Build or step is being executed.
        Working,
        /// Build or step finished successfully.
        Success,
        /// Build or step failed to complete successfully.
        Failure,
        /// Build or step failed due to an internal cause.
        InternalError,
        /// Build or step took longer than was allowed.
        Timeout,
        /// Build or step was canceled by a user.
        Cancelled,
        /// Build was enqueued for longer than the value of `queue_ttl`.
        Expired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(10),
                Self::Queued => std::option::Option::Some(1),
                Self::Working => std::option::Option::Some(2),
                Self::Success => std::option::Option::Some(3),
                Self::Failure => std::option::Option::Some(4),
                Self::InternalError => std::option::Option::Some(5),
                Self::Timeout => std::option::Option::Some(6),
                Self::Cancelled => std::option::Option::Some(7),
                Self::Expired => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("STATUS_UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::Working => std::option::Option::Some("WORKING"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Failure => std::option::Option::Some("FAILURE"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::Timeout => std::option::Option::Some("TIMEOUT"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Queued,
                2 => Self::Working,
                3 => Self::Success,
                4 => Self::Failure,
                5 => Self::InternalError,
                6 => Self::Timeout,
                7 => Self::Cancelled,
                9 => Self::Expired,
                10 => Self::Pending,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "QUEUED" => Self::Queued,
                "WORKING" => Self::Working,
                "SUCCESS" => Self::Success,
                "FAILURE" => Self::Failure,
                "INTERNAL_ERROR" => Self::InternalError,
                "TIMEOUT" => Self::Timeout,
                "CANCELLED" => Self::Cancelled,
                "EXPIRED" => Self::Expired,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(10),
                Self::Queued => serializer.serialize_i32(1),
                Self::Working => serializer.serialize_i32(2),
                Self::Success => serializer.serialize_i32(3),
                Self::Failure => serializer.serialize_i32(4),
                Self::InternalError => serializer.serialize_i32(5),
                Self::Timeout => serializer.serialize_i32(6),
                Self::Cancelled => serializer.serialize_i32(7),
                Self::Expired => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.devtools.cloudbuild.v1.Build.Status",
            ))
        }
    }
}

/// A dependency that the Cloud Build worker will fetch before executing user
/// steps.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Dependency {
    /// The type of dependency to fetch.
    pub dep: std::option::Option<crate::model::dependency::Dep>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dependency {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dep][crate::model::Dependency::dep].
    ///
    /// Note that all the setters affecting `dep` are mutually
    /// exclusive.
    pub fn set_dep<T: std::convert::Into<std::option::Option<crate::model::dependency::Dep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dep = v.into();
        self
    }

    /// The value of [dep][crate::model::Dependency::dep]
    /// if it holds a `Empty`, `None` if the field is not set or
    /// holds a different branch.
    pub fn empty(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.dep.as_ref().and_then(|v| match v {
            crate::model::dependency::Dep::Empty(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dep][crate::model::Dependency::dep]
    /// to hold a `Empty`.
    ///
    /// Note that all the setters affecting `dep` are
    /// mutually exclusive.
    pub fn set_empty<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dep = std::option::Option::Some(crate::model::dependency::Dep::Empty(v.into()));
        self
    }

    /// The value of [dep][crate::model::Dependency::dep]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dependency::GitSourceDependency>> {
        #[allow(unreachable_patterns)]
        self.dep.as_ref().and_then(|v| match v {
            crate::model::dependency::Dep::GitSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dep][crate::model::Dependency::dep]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `dep` are
    /// mutually exclusive.
    pub fn set_git_source<
        T: std::convert::Into<std::boxed::Box<crate::model::dependency::GitSourceDependency>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dep = std::option::Option::Some(crate::model::dependency::Dep::GitSource(v.into()));
        self
    }
}

impl wkt::message::Message for Dependency {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dependency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __empty,
            __git_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dependency")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "empty" => Ok(__FieldTag::__empty),
                            "gitSource" => Ok(__FieldTag::__git_source),
                            "git_source" => Ok(__FieldTag::__git_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dependency;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dependency")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__empty => {
                            if !fields.insert(__FieldTag::__empty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for empty",
                                ));
                            }
                            if result.dep.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dep`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.empty, latest field was empty",
                                ));
                            }
                            result.dep =
                                std::option::Option::Some(crate::model::dependency::Dep::Empty(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__git_source => {
                            if !fields.insert(__FieldTag::__git_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_source",
                                ));
                            }
                            if result.dep.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dep`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.git_source, latest field was gitSource",
                                ));
                            }
                            result.dep = std::option::Option::Some(
                                crate::model::dependency::Dep::GitSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::dependency::GitSourceDependency,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dependency {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.empty() {
            state.serialize_entry("empty", value)?;
        }
        if let Some(value) = self.git_source() {
            state.serialize_entry("gitSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Dependency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dependency");
        debug_struct.field("dep", &self.dep);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Dependency].
pub mod dependency {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a git repository as a build dependency.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GitSourceDependency {
        /// Required. The kind of repo (url or dev connect).
        pub repository: std::option::Option<crate::model::dependency::GitSourceRepository>,

        /// Required. The revision that we will fetch the repo at.
        pub revision: std::string::String,

        /// Optional. True if submodules should be fetched too (default false).
        pub recurse_submodules: bool,

        /// Optional. How much history should be fetched for the build (default 1, -1
        /// for all history).
        pub depth: i64,

        /// Required. Where should the files be placed on the worker.
        pub dest_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GitSourceDependency {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::dependency::GitSourceDependency::repository].
        pub fn set_repository<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::dependency::GitSourceRepository>,
        {
            self.repository = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [repository][crate::model::dependency::GitSourceDependency::repository].
        pub fn set_or_clear_repository<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::dependency::GitSourceRepository>,
        {
            self.repository = v.map(|x| x.into());
            self
        }

        /// Sets the value of [revision][crate::model::dependency::GitSourceDependency::revision].
        pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }

        /// Sets the value of [recurse_submodules][crate::model::dependency::GitSourceDependency::recurse_submodules].
        pub fn set_recurse_submodules<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.recurse_submodules = v.into();
            self
        }

        /// Sets the value of [depth][crate::model::dependency::GitSourceDependency::depth].
        pub fn set_depth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.depth = v.into();
            self
        }

        /// Sets the value of [dest_path][crate::model::dependency::GitSourceDependency::dest_path].
        pub fn set_dest_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dest_path = v.into();
            self
        }
    }

    impl wkt::message::Message for GitSourceDependency {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency.GitSourceDependency"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GitSourceDependency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repository,
                __revision,
                __recurse_submodules,
                __depth,
                __dest_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GitSourceDependency")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repository" => Ok(__FieldTag::__repository),
                                "revision" => Ok(__FieldTag::__revision),
                                "recurseSubmodules" => Ok(__FieldTag::__recurse_submodules),
                                "recurse_submodules" => Ok(__FieldTag::__recurse_submodules),
                                "depth" => Ok(__FieldTag::__depth),
                                "destPath" => Ok(__FieldTag::__dest_path),
                                "dest_path" => Ok(__FieldTag::__dest_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GitSourceDependency;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GitSourceDependency")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repository => {
                                if !fields.insert(__FieldTag::__repository) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository",
                                    ));
                                }
                                result.repository = map.next_value::<std::option::Option<
                                    crate::model::dependency::GitSourceRepository,
                                >>()?;
                            }
                            __FieldTag::__revision => {
                                if !fields.insert(__FieldTag::__revision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revision",
                                    ));
                                }
                                result.revision = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__recurse_submodules => {
                                if !fields.insert(__FieldTag::__recurse_submodules) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recurse_submodules",
                                    ));
                                }
                                result.recurse_submodules = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__depth => {
                                if !fields.insert(__FieldTag::__depth) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for depth",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.depth = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__dest_path => {
                                if !fields.insert(__FieldTag::__dest_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dest_path",
                                    ));
                                }
                                result.dest_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GitSourceDependency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.repository.is_some() {
                state.serialize_entry("repository", &self.repository)?;
            }
            if !self.revision.is_empty() {
                state.serialize_entry("revision", &self.revision)?;
            }
            if !wkt::internal::is_default(&self.recurse_submodules) {
                state.serialize_entry("recurseSubmodules", &self.recurse_submodules)?;
            }
            if !wkt::internal::is_default(&self.depth) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("depth", &__With(&self.depth))?;
            }
            if !self.dest_path.is_empty() {
                state.serialize_entry("destPath", &self.dest_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GitSourceDependency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GitSourceDependency");
            debug_struct.field("repository", &self.repository);
            debug_struct.field("revision", &self.revision);
            debug_struct.field("recurse_submodules", &self.recurse_submodules);
            debug_struct.field("depth", &self.depth);
            debug_struct.field("dest_path", &self.dest_path);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A repository for a git source.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GitSourceRepository {
        /// The type of git source repo (url or dev connect).
        pub repotype:
            std::option::Option<crate::model::dependency::git_source_repository::Repotype>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GitSourceRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype].
        ///
        /// Note that all the setters affecting `repotype` are mutually
        /// exclusive.
        pub fn set_repotype<
            T: std::convert::Into<
                    std::option::Option<crate::model::dependency::git_source_repository::Repotype>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.repotype = v.into();
            self
        }

        /// The value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// if it holds a `Url`, `None` if the field is not set or
        /// holds a different branch.
        pub fn url(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.repotype.as_ref().and_then(|v| match v {
                crate::model::dependency::git_source_repository::Repotype::Url(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// to hold a `Url`.
        ///
        /// Note that all the setters affecting `repotype` are
        /// mutually exclusive.
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repotype = std::option::Option::Some(
                crate::model::dependency::git_source_repository::Repotype::Url(v.into()),
            );
            self
        }

        /// The value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// if it holds a `DeveloperConnect`, `None` if the field is not set or
        /// holds a different branch.
        pub fn developer_connect(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.repotype.as_ref().and_then(|v| match v {
                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [repotype][crate::model::dependency::GitSourceRepository::repotype]
        /// to hold a `DeveloperConnect`.
        ///
        /// Note that all the setters affecting `repotype` are
        /// mutually exclusive.
        pub fn set_developer_connect<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repotype = std::option::Option::Some(
                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for GitSourceRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Dependency.GitSourceRepository"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GitSourceRepository {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __url,
                __developer_connect,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GitSourceRepository")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "url" => Ok(__FieldTag::__url),
                                "developerConnect" => Ok(__FieldTag::__developer_connect),
                                "developer_connect" => Ok(__FieldTag::__developer_connect),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GitSourceRepository;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GitSourceRepository")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__url => {
                                if !fields.insert(__FieldTag::__url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for url",
                                    ));
                                }
                                if result.repotype.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `repotype`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.GitSourceRepository.url, latest field was url",
                                    ));
                                }
                                result.repotype = std::option::Option::Some(
                                    crate::model::dependency::git_source_repository::Repotype::Url(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__developer_connect => {
                                if !fields.insert(__FieldTag::__developer_connect) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for developer_connect",
                                    ));
                                }
                                if result.repotype.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `repotype`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.GitSourceRepository.developer_connect, latest field was developerConnect",
                                    ));
                                }
                                result.repotype = std::option::Option::Some(
                                    crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GitSourceRepository {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.url() {
                state.serialize_entry("url", value)?;
            }
            if let Some(value) = self.developer_connect() {
                state.serialize_entry("developerConnect", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GitSourceRepository {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GitSourceRepository");
            debug_struct.field("repotype", &self.repotype);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GitSourceRepository].
    pub mod git_source_repository {
        #[allow(unused_imports)]
        use super::*;

        /// The type of git source repo (url or dev connect).
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Repotype {
            /// Location of the Git repository.
            Url(std::string::String),
            /// The Developer Connect Git repository link or the url that matches a
            /// repository link in the current project, formatted as
            /// `projects/*/locations/*/connections/*/gitRepositoryLink/*`
            DeveloperConnect(std::string::String),
        }
    }

    /// The type of dependency to fetch.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Dep {
        /// If set to true disable all dependency fetching (ignoring the default
        /// source as well).
        Empty(bool),
        /// Represents a git repository as a build dependency.
        GitSource(std::boxed::Box<crate::model::dependency::GitSourceDependency>),
    }
}

/// GitConfig is a configuration for git operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitConfig {
    /// Configuration for HTTP related git operations.
    pub http: std::option::Option<crate::model::git_config::HttpConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http][crate::model::GitConfig::http].
    pub fn set_http<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::git_config::HttpConfig>,
    {
        self.http = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http][crate::model::GitConfig::http].
    pub fn set_or_clear_http<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::git_config::HttpConfig>,
    {
        self.http = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GitConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "http" => Ok(__FieldTag::__http),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http => {
                            if !fields.insert(__FieldTag::__http) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http",
                                ));
                            }
                            result.http = map.next_value::<std::option::Option<crate::model::git_config::HttpConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.http.is_some() {
            state.serialize_entry("http", &self.http)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitConfig");
        debug_struct.field("http", &self.http);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GitConfig].
pub mod git_config {
    #[allow(unused_imports)]
    use super::*;

    /// HttpConfig is a configuration for HTTP related git operations.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HttpConfig {
        /// SecretVersion resource of the HTTP proxy URL. The Service Account used in
        /// the build (either the default Service Account or
        /// user-specified Service Account) should have
        /// `secretmanager.versions.access` permissions on this secret. The proxy URL
        /// should be in format `[protocol://][user[:password]@]proxyhost[:port]`.
        pub proxy_secret_version_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HttpConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [proxy_secret_version_name][crate::model::git_config::HttpConfig::proxy_secret_version_name].
        pub fn set_proxy_secret_version_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.proxy_secret_version_name = v.into();
            self
        }
    }

    impl wkt::message::Message for HttpConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.GitConfig.HttpConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HttpConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __proxy_secret_version_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HttpConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "proxySecretVersionName" => {
                                    Ok(__FieldTag::__proxy_secret_version_name)
                                }
                                "proxy_secret_version_name" => {
                                    Ok(__FieldTag::__proxy_secret_version_name)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HttpConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HttpConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__proxy_secret_version_name => {
                                if !fields.insert(__FieldTag::__proxy_secret_version_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for proxy_secret_version_name",
                                    ));
                                }
                                result.proxy_secret_version_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HttpConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.proxy_secret_version_name.is_empty() {
                state.serialize_entry("proxySecretVersionName", &self.proxy_secret_version_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for HttpConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("HttpConfig");
            debug_struct.field("proxy_secret_version_name", &self.proxy_secret_version_name);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Artifacts produced by a build that should be uploaded upon
/// successful completion of all build steps.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Artifacts {
    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images will be pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the Build resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build is marked FAILURE.
    pub images: std::vec::Vec<std::string::String>,

    /// A list of objects to be uploaded to Cloud Storage upon successful
    /// completion of all build steps.
    ///
    /// Files in the workspace matching specified paths globs will be uploaded to
    /// the specified Cloud Storage location using the builder service account's
    /// credentials.
    ///
    /// The location and generation of the uploaded objects will be stored in the
    /// Build resource's results field.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    pub objects: std::option::Option<crate::model::artifacts::ArtifactObjects>,

    /// A list of Maven artifacts to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Artifacts in the workspace matching specified paths globs will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any artifacts fail to be pushed, the build is marked FAILURE.
    pub maven_artifacts: std::vec::Vec<crate::model::artifacts::MavenArtifact>,

    /// Optional. A list of Go modules to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    pub go_modules: std::vec::Vec<crate::model::artifacts::GoModule>,

    /// A list of Python packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// The build service account credentials will be used to perform the upload.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    pub python_packages: std::vec::Vec<crate::model::artifacts::PythonPackage>,

    /// A list of npm packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Npm packages in the specified paths will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any packages fail to be pushed, the build is marked FAILURE.
    pub npm_packages: std::vec::Vec<crate::model::artifacts::NpmPackage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Artifacts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [images][crate::model::Artifacts::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [objects][crate::model::Artifacts::objects].
    pub fn set_objects<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::artifacts::ArtifactObjects>,
    {
        self.objects = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [objects][crate::model::Artifacts::objects].
    pub fn set_or_clear_objects<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::artifacts::ArtifactObjects>,
    {
        self.objects = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::Artifacts::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::MavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [go_modules][crate::model::Artifacts::go_modules].
    pub fn set_go_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::GoModule>,
    {
        use std::iter::Iterator;
        self.go_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_packages][crate::model::Artifacts::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::PythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [npm_packages][crate::model::Artifacts::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::artifacts::NpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Artifacts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Artifacts {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __images,
            __objects,
            __maven_artifacts,
            __go_modules,
            __python_packages,
            __npm_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Artifacts")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "images" => Ok(__FieldTag::__images),
                            "objects" => Ok(__FieldTag::__objects),
                            "mavenArtifacts" => Ok(__FieldTag::__maven_artifacts),
                            "maven_artifacts" => Ok(__FieldTag::__maven_artifacts),
                            "goModules" => Ok(__FieldTag::__go_modules),
                            "go_modules" => Ok(__FieldTag::__go_modules),
                            "pythonPackages" => Ok(__FieldTag::__python_packages),
                            "python_packages" => Ok(__FieldTag::__python_packages),
                            "npmPackages" => Ok(__FieldTag::__npm_packages),
                            "npm_packages" => Ok(__FieldTag::__npm_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Artifacts;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Artifacts")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__objects => {
                            if !fields.insert(__FieldTag::__objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects",
                                ));
                            }
                            result.objects = map.next_value::<std::option::Option<crate::model::artifacts::ArtifactObjects>>()?
                                ;
                        }
                        __FieldTag::__maven_artifacts => {
                            if !fields.insert(__FieldTag::__maven_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maven_artifacts",
                                ));
                            }
                            result.maven_artifacts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::MavenArtifact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__go_modules => {
                            if !fields.insert(__FieldTag::__go_modules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for go_modules",
                                ));
                            }
                            result.go_modules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::GoModule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__python_packages => {
                            if !fields.insert(__FieldTag::__python_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_packages",
                                ));
                            }
                            result.python_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::PythonPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__npm_packages => {
                            if !fields.insert(__FieldTag::__npm_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for npm_packages",
                                ));
                            }
                            result.npm_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::NpmPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Artifacts {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.images.is_empty() {
            state.serialize_entry("images", &self.images)?;
        }
        if self.objects.is_some() {
            state.serialize_entry("objects", &self.objects)?;
        }
        if !self.maven_artifacts.is_empty() {
            state.serialize_entry("mavenArtifacts", &self.maven_artifacts)?;
        }
        if !self.go_modules.is_empty() {
            state.serialize_entry("goModules", &self.go_modules)?;
        }
        if !self.python_packages.is_empty() {
            state.serialize_entry("pythonPackages", &self.python_packages)?;
        }
        if !self.npm_packages.is_empty() {
            state.serialize_entry("npmPackages", &self.npm_packages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Artifacts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Artifacts");
        debug_struct.field("images", &self.images);
        debug_struct.field("objects", &self.objects);
        debug_struct.field("maven_artifacts", &self.maven_artifacts);
        debug_struct.field("go_modules", &self.go_modules);
        debug_struct.field("python_packages", &self.python_packages);
        debug_struct.field("npm_packages", &self.npm_packages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Artifacts].
pub mod artifacts {
    #[allow(unused_imports)]
    use super::*;

    /// Files in the workspace to upload to Cloud Storage upon successful
    /// completion of all build steps.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ArtifactObjects {
        /// Cloud Storage bucket and optional object path, in the form
        /// "gs://bucket/path/to/somewhere/". (see [Bucket Name
        /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Cloud Storage with this location as a prefix.
        pub location: std::string::String,

        /// Path globs used to match files in the build's workspace.
        pub paths: std::vec::Vec<std::string::String>,

        /// Output only. Stores timing information for pushing all artifact objects.
        pub timing: std::option::Option<crate::model::TimeSpan>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ArtifactObjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location][crate::model::artifacts::ArtifactObjects::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }

        /// Sets the value of [paths][crate::model::artifacts::ArtifactObjects::paths].
        pub fn set_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.paths = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [timing][crate::model::artifacts::ArtifactObjects::timing].
        pub fn set_timing<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TimeSpan>,
        {
            self.timing = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [timing][crate::model::artifacts::ArtifactObjects::timing].
        pub fn set_or_clear_timing<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TimeSpan>,
        {
            self.timing = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ArtifactObjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.ArtifactObjects"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ArtifactObjects {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __location,
                __paths,
                __timing,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ArtifactObjects")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "location" => Ok(__FieldTag::__location),
                                "paths" => Ok(__FieldTag::__paths),
                                "timing" => Ok(__FieldTag::__timing),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ArtifactObjects;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ArtifactObjects")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__paths => {
                                if !fields.insert(__FieldTag::__paths) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for paths",
                                    ));
                                }
                                result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__timing => {
                                if !fields.insert(__FieldTag::__timing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for timing",
                                    ));
                                }
                                result.timing = map
                                    .next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ArtifactObjects {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self.paths.is_empty() {
                state.serialize_entry("paths", &self.paths)?;
            }
            if self.timing.is_some() {
                state.serialize_entry("timing", &self.timing)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ArtifactObjects {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ArtifactObjects");
            debug_struct.field("location", &self.location);
            debug_struct.field("paths", &self.paths);
            debug_struct.field("timing", &self.timing);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A Maven artifact to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MavenArtifact {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-maven.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Artifact in the workspace specified by path will be uploaded to
        /// Artifact Registry with this location as a prefix.
        pub repository: std::string::String,

        /// Path to an artifact in the build's workspace to be uploaded to
        /// Artifact Registry.
        /// This can be either an absolute path,
        /// e.g. /workspace/my-app/target/my-app-1.0.SNAPSHOT.jar
        /// or a relative path from /workspace,
        /// e.g. my-app/target/my-app-1.0.SNAPSHOT.jar.
        pub path: std::string::String,

        /// Maven `artifactId` value used when uploading the artifact to Artifact
        /// Registry.
        pub artifact_id: std::string::String,

        /// Maven `groupId` value used when uploading the artifact to Artifact
        /// Registry.
        pub group_id: std::string::String,

        /// Maven `version` value used when uploading the artifact to Artifact
        /// Registry.
        pub version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MavenArtifact {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::MavenArtifact::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [path][crate::model::artifacts::MavenArtifact::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [artifact_id][crate::model::artifacts::MavenArtifact::artifact_id].
        pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.artifact_id = v.into();
            self
        }

        /// Sets the value of [group_id][crate::model::artifacts::MavenArtifact::group_id].
        pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::artifacts::MavenArtifact::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for MavenArtifact {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.MavenArtifact"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MavenArtifact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repository,
                __path,
                __artifact_id,
                __group_id,
                __version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MavenArtifact")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repository" => Ok(__FieldTag::__repository),
                                "path" => Ok(__FieldTag::__path),
                                "artifactId" => Ok(__FieldTag::__artifact_id),
                                "artifact_id" => Ok(__FieldTag::__artifact_id),
                                "groupId" => Ok(__FieldTag::__group_id),
                                "group_id" => Ok(__FieldTag::__group_id),
                                "version" => Ok(__FieldTag::__version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MavenArtifact;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MavenArtifact")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repository => {
                                if !fields.insert(__FieldTag::__repository) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository",
                                    ));
                                }
                                result.repository = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__artifact_id => {
                                if !fields.insert(__FieldTag::__artifact_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for artifact_id",
                                    ));
                                }
                                result.artifact_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__group_id => {
                                if !fields.insert(__FieldTag::__group_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_id",
                                    ));
                                }
                                result.group_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MavenArtifact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.repository.is_empty() {
                state.serialize_entry("repository", &self.repository)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self.artifact_id.is_empty() {
                state.serialize_entry("artifactId", &self.artifact_id)?;
            }
            if !self.group_id.is_empty() {
                state.serialize_entry("groupId", &self.group_id)?;
            }
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MavenArtifact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MavenArtifact");
            debug_struct.field("repository", &self.repository);
            debug_struct.field("path", &self.path);
            debug_struct.field("artifact_id", &self.artifact_id);
            debug_struct.field("group_id", &self.group_id);
            debug_struct.field("version", &self.version);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Go module to upload to Artifact Registry upon successful completion of all
    /// build steps. A module refers to all dependencies in a go.mod file.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GoModule {
        /// Optional. Artifact Registry repository name.
        ///
        /// Specified Go modules will be zipped and uploaded to Artifact Registry
        /// with this location as a prefix.
        /// e.g. my-go-repo
        pub repository_name: std::string::String,

        /// Optional. Location of the Artifact Registry repository. i.e. us-east1
        /// Defaults to the builds location.
        pub repository_location: std::string::String,

        /// Optional. Project ID of the Artifact Registry repository.
        /// Defaults to the build project.
        pub repository_project_id: std::string::String,

        /// Optional. Source path of the go.mod file in the build's workspace. If not
        /// specified, this will default to the current directory.
        /// e.g. ~/code/go/mypackage
        pub source_path: std::string::String,

        /// Optional. The Go module's "module path".
        /// e.g. example.com/foo/v2
        pub module_path: std::string::String,

        /// Optional. The Go module's semantic version in the form vX.Y.Z. e.g.
        /// v0.1.1 Pre-release identifiers can also be added by appending a dash and
        /// dot separated ASCII alphanumeric characters and hyphens.
        /// e.g. v0.2.3-alpha.x.12m.5
        pub module_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GoModule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository_name][crate::model::artifacts::GoModule::repository_name].
        pub fn set_repository_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_name = v.into();
            self
        }

        /// Sets the value of [repository_location][crate::model::artifacts::GoModule::repository_location].
        pub fn set_repository_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_location = v.into();
            self
        }

        /// Sets the value of [repository_project_id][crate::model::artifacts::GoModule::repository_project_id].
        pub fn set_repository_project_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.repository_project_id = v.into();
            self
        }

        /// Sets the value of [source_path][crate::model::artifacts::GoModule::source_path].
        pub fn set_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_path = v.into();
            self
        }

        /// Sets the value of [module_path][crate::model::artifacts::GoModule::module_path].
        pub fn set_module_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.module_path = v.into();
            self
        }

        /// Sets the value of [module_version][crate::model::artifacts::GoModule::module_version].
        pub fn set_module_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.module_version = v.into();
            self
        }
    }

    impl wkt::message::Message for GoModule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.GoModule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GoModule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repository_name,
                __repository_location,
                __repository_project_id,
                __source_path,
                __module_path,
                __module_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GoModule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repositoryName" => Ok(__FieldTag::__repository_name),
                                "repository_name" => Ok(__FieldTag::__repository_name),
                                "repositoryLocation" => Ok(__FieldTag::__repository_location),
                                "repository_location" => Ok(__FieldTag::__repository_location),
                                "repositoryProjectId" => Ok(__FieldTag::__repository_project_id),
                                "repository_project_id" => Ok(__FieldTag::__repository_project_id),
                                "sourcePath" => Ok(__FieldTag::__source_path),
                                "source_path" => Ok(__FieldTag::__source_path),
                                "modulePath" => Ok(__FieldTag::__module_path),
                                "module_path" => Ok(__FieldTag::__module_path),
                                "moduleVersion" => Ok(__FieldTag::__module_version),
                                "module_version" => Ok(__FieldTag::__module_version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GoModule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GoModule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repository_name => {
                                if !fields.insert(__FieldTag::__repository_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository_name",
                                    ));
                                }
                                result.repository_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__repository_location => {
                                if !fields.insert(__FieldTag::__repository_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository_location",
                                    ));
                                }
                                result.repository_location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__repository_project_id => {
                                if !fields.insert(__FieldTag::__repository_project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository_project_id",
                                    ));
                                }
                                result.repository_project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__source_path => {
                                if !fields.insert(__FieldTag::__source_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_path",
                                    ));
                                }
                                result.source_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__module_path => {
                                if !fields.insert(__FieldTag::__module_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for module_path",
                                    ));
                                }
                                result.module_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__module_version => {
                                if !fields.insert(__FieldTag::__module_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for module_version",
                                    ));
                                }
                                result.module_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GoModule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.repository_name.is_empty() {
                state.serialize_entry("repositoryName", &self.repository_name)?;
            }
            if !self.repository_location.is_empty() {
                state.serialize_entry("repositoryLocation", &self.repository_location)?;
            }
            if !self.repository_project_id.is_empty() {
                state.serialize_entry("repositoryProjectId", &self.repository_project_id)?;
            }
            if !self.source_path.is_empty() {
                state.serialize_entry("sourcePath", &self.source_path)?;
            }
            if !self.module_path.is_empty() {
                state.serialize_entry("modulePath", &self.module_path)?;
            }
            if !self.module_version.is_empty() {
                state.serialize_entry("moduleVersion", &self.module_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GoModule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GoModule");
            debug_struct.field("repository_name", &self.repository_name);
            debug_struct.field("repository_location", &self.repository_location);
            debug_struct.field("repository_project_id", &self.repository_project_id);
            debug_struct.field("source_path", &self.source_path);
            debug_struct.field("module_path", &self.module_path);
            debug_struct.field("module_version", &self.module_version);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Python package to upload to Artifact Registry upon successful completion
    /// of all build steps. A package can encapsulate multiple objects to be
    /// uploaded to a single repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PythonPackage {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-python.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Artifact Registry with this location as a prefix.
        pub repository: std::string::String,

        /// Path globs used to match files in the build's workspace. For Python/
        /// Twine, this is usually `dist/*`, and sometimes additionally an `.asc`
        /// file.
        pub paths: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PythonPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::PythonPackage::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [paths][crate::model::artifacts::PythonPackage::paths].
        pub fn set_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.paths = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PythonPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.PythonPackage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PythonPackage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repository,
                __paths,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PythonPackage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repository" => Ok(__FieldTag::__repository),
                                "paths" => Ok(__FieldTag::__paths),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PythonPackage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PythonPackage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repository => {
                                if !fields.insert(__FieldTag::__repository) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository",
                                    ));
                                }
                                result.repository = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__paths => {
                                if !fields.insert(__FieldTag::__paths) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for paths",
                                    ));
                                }
                                result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PythonPackage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.repository.is_empty() {
                state.serialize_entry("repository", &self.repository)?;
            }
            if !self.paths.is_empty() {
                state.serialize_entry("paths", &self.paths)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PythonPackage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PythonPackage");
            debug_struct.field("repository", &self.repository);
            debug_struct.field("paths", &self.paths);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Npm package to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NpmPackage {
        /// Artifact Registry repository, in the form
        /// "https://$REGION-npm.pkg.dev/$PROJECT/$REPOSITORY"
        ///
        /// Npm package in the workspace specified by path will be zipped and
        /// uploaded to Artifact Registry with this location as a prefix.
        pub repository: std::string::String,

        /// Path to the package.json.
        /// e.g. workspace/path/to/package
        pub package_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NpmPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::artifacts::NpmPackage::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [package_path][crate::model::artifacts::NpmPackage::package_path].
        pub fn set_package_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_path = v.into();
            self
        }
    }

    impl wkt::message::Message for NpmPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.Artifacts.NpmPackage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NpmPackage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repository,
                __package_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NpmPackage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repository" => Ok(__FieldTag::__repository),
                                "packagePath" => Ok(__FieldTag::__package_path),
                                "package_path" => Ok(__FieldTag::__package_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NpmPackage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NpmPackage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repository => {
                                if !fields.insert(__FieldTag::__repository) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository",
                                    ));
                                }
                                result.repository = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__package_path => {
                                if !fields.insert(__FieldTag::__package_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for package_path",
                                    ));
                                }
                                result.package_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NpmPackage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.repository.is_empty() {
                state.serialize_entry("repository", &self.repository)?;
            }
            if !self.package_path.is_empty() {
                state.serialize_entry("packagePath", &self.package_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NpmPackage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NpmPackage");
            debug_struct.field("repository", &self.repository);
            debug_struct.field("package_path", &self.package_path);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Start and end times for a build execution phase.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSpan {
    /// Start of time span.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End of time span.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSpan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeSpan::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeSpan::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeSpan::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeSpan::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeSpan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.TimeSpan"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSpan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSpan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSpan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSpan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSpan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeSpan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeSpan");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for build operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildOperationMetadata {
    /// The build that the operation is tracking.
    pub build: std::option::Option<crate::model::Build>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::BuildOperationMetadata::build].
    pub fn set_build<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build][crate::model::BuildOperationMetadata::build].
    pub fn set_or_clear_build<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "build" => Ok(__FieldTag::__build),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build =
                                map.next_value::<std::option::Option<crate::model::Build>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.build.is_some() {
            state.serialize_entry("build", &self.build)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuildOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildOperationMetadata");
        debug_struct.field("build", &self.build);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceProvenance {
    /// A copy of the build's `source.storage_source`, if exists, with any
    /// generations resolved.
    pub resolved_storage_source: std::option::Option<crate::model::StorageSource>,

    /// A copy of the build's `source.repo_source`, if exists, with any
    /// revisions resolved.
    pub resolved_repo_source: std::option::Option<crate::model::RepoSource>,

    /// A copy of the build's `source.storage_source_manifest`, if exists, with any
    /// revisions resolved.
    /// This feature is in Preview.
    pub resolved_storage_source_manifest: std::option::Option<crate::model::StorageSourceManifest>,

    /// Output only. Hash(es) of the build source, which can be used to verify that
    /// the original source integrity was maintained in the build. Note that
    /// `FileHashes` will only be populated if `BuildOptions` has requested a
    /// `SourceProvenanceHash`.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (`.tar.gz`), the `FileHash` will be for the single path to that file.
    pub file_hashes: std::collections::HashMap<std::string::String, crate::model::FileHashes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceProvenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resolved_storage_source][crate::model::SourceProvenance::resolved_storage_source].
    pub fn set_resolved_storage_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageSource>,
    {
        self.resolved_storage_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolved_storage_source][crate::model::SourceProvenance::resolved_storage_source].
    pub fn set_or_clear_resolved_storage_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageSource>,
    {
        self.resolved_storage_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_repo_source][crate::model::SourceProvenance::resolved_repo_source].
    pub fn set_resolved_repo_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.resolved_repo_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolved_repo_source][crate::model::SourceProvenance::resolved_repo_source].
    pub fn set_or_clear_resolved_repo_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.resolved_repo_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_storage_source_manifest][crate::model::SourceProvenance::resolved_storage_source_manifest].
    pub fn set_resolved_storage_source_manifest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageSourceManifest>,
    {
        self.resolved_storage_source_manifest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolved_storage_source_manifest][crate::model::SourceProvenance::resolved_storage_source_manifest].
    pub fn set_or_clear_resolved_storage_source_manifest<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::StorageSourceManifest>,
    {
        self.resolved_storage_source_manifest = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_hashes][crate::model::SourceProvenance::file_hashes].
    pub fn set_file_hashes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FileHashes>,
    {
        use std::iter::Iterator;
        self.file_hashes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SourceProvenance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.SourceProvenance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resolved_storage_source,
            __resolved_repo_source,
            __resolved_storage_source_manifest,
            __file_hashes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resolvedStorageSource" => Ok(__FieldTag::__resolved_storage_source),
                            "resolved_storage_source" => Ok(__FieldTag::__resolved_storage_source),
                            "resolvedRepoSource" => Ok(__FieldTag::__resolved_repo_source),
                            "resolved_repo_source" => Ok(__FieldTag::__resolved_repo_source),
                            "resolvedStorageSourceManifest" => {
                                Ok(__FieldTag::__resolved_storage_source_manifest)
                            }
                            "resolved_storage_source_manifest" => {
                                Ok(__FieldTag::__resolved_storage_source_manifest)
                            }
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resolved_storage_source => {
                            if !fields.insert(__FieldTag::__resolved_storage_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_storage_source",
                                ));
                            }
                            result.resolved_storage_source = map
                                .next_value::<std::option::Option<crate::model::StorageSource>>()?;
                        }
                        __FieldTag::__resolved_repo_source => {
                            if !fields.insert(__FieldTag::__resolved_repo_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_repo_source",
                                ));
                            }
                            result.resolved_repo_source =
                                map.next_value::<std::option::Option<crate::model::RepoSource>>()?;
                        }
                        __FieldTag::__resolved_storage_source_manifest => {
                            if !fields.insert(__FieldTag::__resolved_storage_source_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_storage_source_manifest",
                                ));
                            }
                            result.resolved_storage_source_manifest = map.next_value::<std::option::Option<crate::model::StorageSourceManifest>>()?
                                ;
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::FileHashes,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceProvenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resolved_storage_source.is_some() {
            state.serialize_entry("resolvedStorageSource", &self.resolved_storage_source)?;
        }
        if self.resolved_repo_source.is_some() {
            state.serialize_entry("resolvedRepoSource", &self.resolved_repo_source)?;
        }
        if self.resolved_storage_source_manifest.is_some() {
            state.serialize_entry(
                "resolvedStorageSourceManifest",
                &self.resolved_storage_source_manifest,
            )?;
        }
        if !self.file_hashes.is_empty() {
            state.serialize_entry("fileHashes", &self.file_hashes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceProvenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceProvenance");
        debug_struct.field("resolved_storage_source", &self.resolved_storage_source);
        debug_struct.field("resolved_repo_source", &self.resolved_repo_source);
        debug_struct.field(
            "resolved_storage_source_manifest",
            &self.resolved_storage_source_manifest,
        );
        debug_struct.field("file_hashes", &self.file_hashes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Container message for hashes of byte content of files, used in
/// SourceProvenance messages to verify integrity of source input to the build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileHashes {
    /// Collection of file hashes.
    pub file_hash: std::vec::Vec<crate::model::Hash>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileHashes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_hash][crate::model::FileHashes::file_hash].
    pub fn set_file_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.file_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FileHashes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.FileHashes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileHashes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileHashes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileHash" => Ok(__FieldTag::__file_hash),
                            "file_hash" => Ok(__FieldTag::__file_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileHashes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileHashes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_hash => {
                            if !fields.insert(__FieldTag::__file_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hash",
                                ));
                            }
                            result.file_hash = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Hash>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileHashes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_hash.is_empty() {
            state.serialize_entry("fileHash", &self.file_hash)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FileHashes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FileHashes");
        debug_struct.field("file_hash", &self.file_hash);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Container message for hash values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Hash {
    /// The type of hash that was performed.
    pub r#type: crate::model::hash::HashType,

    /// The hash value.
    pub value: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    pub fn set_type<T: std::convert::Into<crate::model::hash::HashType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Hash"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Hash {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Hash")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Hash;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Hash")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::hash::HashType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Hash {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Hash");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Hash].
pub mod hash {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the hash algorithm, if any.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HashType {
        /// No hash requested.
        None,
        /// Use a sha256 hash.
        Sha256,
        /// Use a md5 hash.
        Md5,
        /// Dirhash of a Go module's source code which is then hex-encoded.
        GoModuleH1,
        /// Use a sha512 hash.
        Sha512,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HashType::value] or
        /// [HashType::name].
        UnknownValue(hash_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod hash_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HashType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Sha256 => std::option::Option::Some(1),
                Self::Md5 => std::option::Option::Some(2),
                Self::GoModuleH1 => std::option::Option::Some(3),
                Self::Sha512 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Sha256 => std::option::Option::Some("SHA256"),
                Self::Md5 => std::option::Option::Some("MD5"),
                Self::GoModuleH1 => std::option::Option::Some("GO_MODULE_H1"),
                Self::Sha512 => std::option::Option::Some("SHA512"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HashType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HashType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HashType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Sha256,
                2 => Self::Md5,
                3 => Self::GoModuleH1,
                4 => Self::Sha512,
                _ => Self::UnknownValue(hash_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HashType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "SHA256" => Self::Sha256,
                "MD5" => Self::Md5,
                "GO_MODULE_H1" => Self::GoModuleH1,
                "SHA512" => Self::Sha512,
                _ => Self::UnknownValue(hash_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HashType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_i32(0),
                Self::Sha256 => serializer.serialize_i32(1),
                Self::Md5 => serializer.serialize_i32(2),
                Self::GoModuleH1 => serializer.serialize_i32(3),
                Self::Sha512 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HashType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HashType>::new(
                ".google.devtools.cloudbuild.v1.Hash.HashType",
            ))
        }
    }
}

/// Secrets and secret environment variables.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Secrets {
    /// Secrets in Secret Manager and associated secret environment variable.
    pub secret_manager: std::vec::Vec<crate::model::SecretManagerSecret>,

    /// Secrets encrypted with KMS key and the associated secret environment
    /// variable.
    pub inline: std::vec::Vec<crate::model::InlineSecret>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secrets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_manager][crate::model::Secrets::secret_manager].
    pub fn set_secret_manager<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretManagerSecret>,
    {
        use std::iter::Iterator;
        self.secret_manager = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inline][crate::model::Secrets::inline].
    pub fn set_inline<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InlineSecret>,
    {
        use std::iter::Iterator;
        self.inline = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Secrets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Secrets"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Secrets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_manager,
            __inline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secrets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretManager" => Ok(__FieldTag::__secret_manager),
                            "secret_manager" => Ok(__FieldTag::__secret_manager),
                            "inline" => Ok(__FieldTag::__inline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Secrets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secrets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_manager => {
                            if !fields.insert(__FieldTag::__secret_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager",
                                ));
                            }
                            result.secret_manager = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecretManagerSecret>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inline => {
                            if !fields.insert(__FieldTag::__inline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline",
                                ));
                            }
                            result.inline = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InlineSecret>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Secrets {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret_manager.is_empty() {
            state.serialize_entry("secretManager", &self.secret_manager)?;
        }
        if !self.inline.is_empty() {
            state.serialize_entry("inline", &self.inline)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Secrets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secrets");
        debug_struct.field("secret_manager", &self.secret_manager);
        debug_struct.field("inline", &self.inline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Pairs a set of secret environment variables mapped to encrypted
/// values with the Cloud KMS key to use to decrypt the value.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineSecret {
    /// Resource name of Cloud KMS crypto key to decrypt the encrypted value.
    /// In format: projects/*/locations/*/keyRings/*/cryptoKeys/*
    pub kms_key_name: std::string::String,

    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    pub env_map: std::collections::HashMap<std::string::String, ::bytes::Bytes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::InlineSecret::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [env_map][crate::model::InlineSecret::env_map].
    pub fn set_env_map<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.env_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InlineSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.InlineSecret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InlineSecret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            __env_map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineSecret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "envMap" => Ok(__FieldTag::__env_map),
                            "env_map" => Ok(__FieldTag::__env_map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InlineSecret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineSecret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env_map => {
                            if !fields.insert(__FieldTag::__env_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env_map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, ::bytes::Bytes>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.env_map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InlineSecret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.env_map.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, ::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<serde_with::Same, serde_with::base64::Base64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("envMap", &__With(&self.env_map))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InlineSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InlineSecret");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("env_map", &self.env_map);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Pairs a secret environment variable with a SecretVersion in Secret Manager.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretManagerSecret {
    /// Resource name of the SecretVersion. In format:
    /// projects/*/secrets/*/versions/*
    pub version_name: std::string::String,

    /// Environment variable name to associate with the secret.
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step.
    pub env: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretManagerSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version_name][crate::model::SecretManagerSecret::version_name].
    pub fn set_version_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_name = v.into();
        self
    }

    /// Sets the value of [env][crate::model::SecretManagerSecret::env].
    pub fn set_env<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.env = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.SecretManagerSecret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretManagerSecret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version_name,
            __env,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretManagerSecret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versionName" => Ok(__FieldTag::__version_name),
                            "version_name" => Ok(__FieldTag::__version_name),
                            "env" => Ok(__FieldTag::__env),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretManagerSecret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretManagerSecret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version_name => {
                            if !fields.insert(__FieldTag::__version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_name",
                                ));
                            }
                            result.version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretManagerSecret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version_name.is_empty() {
            state.serialize_entry("versionName", &self.version_name)?;
        }
        if !self.env.is_empty() {
            state.serialize_entry("env", &self.env)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecretManagerSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretManagerSecret");
        debug_struct.field("version_name", &self.version_name);
        debug_struct.field("env", &self.env);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Pairs a set of secret environment variables containing encrypted
/// values with the Cloud KMS key to use to decrypt the value.
/// Note: Use `kmsKeyName` with  `available_secrets` instead of using
/// `kmsKeyName` with `secret`. For instructions see:
/// <https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-credentials>.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Secret {
    /// Cloud KMS key name to use to decrypt these envs.
    pub kms_key_name: std::string::String,

    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    pub secret_env: std::collections::HashMap<std::string::String, ::bytes::Bytes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::Secret::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [secret_env][crate::model::Secret::secret_env].
    pub fn set_secret_env<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.Secret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Secret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            __secret_env,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "secretEnv" => Ok(__FieldTag::__secret_env),
                            "secret_env" => Ok(__FieldTag::__secret_env),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Secret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_env => {
                            if !fields.insert(__FieldTag::__secret_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_env",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, ::bytes::Bytes>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.secret_env = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Secret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.secret_env.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, ::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<serde_with::Same, serde_with::base64::Base64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("secretEnv", &__With(&self.secret_env))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secret");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("secret_env", &self.secret_env);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to create a new build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBuildRequest {
    /// The parent resource where this build will be created.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. ID of the project.
    pub project_id: std::string::String,

    /// Required. Build resource to create.
    pub build: std::option::Option<crate::model::Build>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBuildRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CreateBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [build][crate::model::CreateBuildRequest::build].
    pub fn set_build<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build][crate::model::CreateBuildRequest::build].
    pub fn set_or_clear_build<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Build>,
    {
        self.build = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateBuildRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __build,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "build" => Ok(__FieldTag::__build),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build =
                                map.next_value::<std::option::Option<crate::model::Build>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBuildRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.build.is_some() {
            state.serialize_entry("build", &self.build)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBuildRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("build", &self.build);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get a build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBuildRequest {
    /// The name of the `Build` to retrieve.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    pub name: std::string::String,

    /// Required. ID of the project.
    pub project_id: std::string::String,

    /// Required. ID of the build.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::GetBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for GetBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetBuildRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBuildRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list builds.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBuildsRequest {
    /// The parent of the collection of `Builds`.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. ID of the project.
    pub project_id: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// The page token for the next page of Builds.
    ///
    /// If unspecified, the first page of results is returned.
    ///
    /// If the token is rejected for any reason, INVALID_ARGUMENT will be thrown.
    /// In this case, the token should be discarded, and pagination should be
    /// restarted from the first page of results.
    ///
    /// See <https://google.aip.dev/158> for more.
    pub page_token: std::string::String,

    /// The raw filter text to constrain the results.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBuildsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ListBuildsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBuildsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBuildsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBuildsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBuildsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBuildsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBuildsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBuildsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response including listed builds.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBuildsResponse {
    /// Builds will be sorted by `create_time`, descending.
    pub builds: std::vec::Vec<crate::model::Build>,

    /// Token to receive the next page of results.
    /// This will be absent if the end of the response list has been reached.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [builds][crate::model::ListBuildsResponse::builds].
    pub fn set_builds<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Build>,
    {
        use std::iter::Iterator;
        self.builds = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBuildsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBuildsResponse {
    type PageItem = crate::model::Build;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.builds
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBuildsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builds,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builds" => Ok(__FieldTag::__builds),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBuildsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builds => {
                            if !fields.insert(__FieldTag::__builds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builds",
                                ));
                            }
                            result.builds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Build>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBuildsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.builds.is_empty() {
            state.serialize_entry("builds", &self.builds)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBuildsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildsResponse");
        debug_struct.field("builds", &self.builds);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to cancel an ongoing build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelBuildRequest {
    /// The name of the `Build` to cancel.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    pub name: std::string::String,

    /// Required. ID of the project.
    pub project_id: std::string::String,

    /// Required. ID of the build.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CancelBuildRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::CancelBuildRequest::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for CancelBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CancelBuildRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelBuildRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to approve or reject a pending build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApproveBuildRequest {
    /// Required. Name of the target build.
    /// For example: "projects/{$project_id}/builds/{$build_id}"
    pub name: std::string::String,

    /// Approval decision and metadata.
    pub approval_result: std::option::Option<crate::model::ApprovalResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveBuildRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [approval_result][crate::model::ApproveBuildRequest::approval_result].
    pub fn set_approval_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.approval_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval_result][crate::model::ApproveBuildRequest::approval_result].
    pub fn set_or_clear_approval_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.approval_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ApproveBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApproveBuildRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApproveBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __approval_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "approvalResult" => Ok(__FieldTag::__approval_result),
                            "approval_result" => Ok(__FieldTag::__approval_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApproveBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval_result => {
                            if !fields.insert(__FieldTag::__approval_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_result",
                                ));
                            }
                            result.approval_result = map
                                .next_value::<std::option::Option<crate::model::ApprovalResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApproveBuildRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.approval_result.is_some() {
            state.serialize_entry("approvalResult", &self.approval_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApproveBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApproveBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("approval_result", &self.approval_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// BuildApproval describes a build's approval configuration, state, and
/// result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildApproval {
    /// Output only. The state of this build's approval.
    pub state: crate::model::build_approval::State,

    /// Output only. Configuration for manual approval of this build.
    pub config: std::option::Option<crate::model::ApprovalConfig>,

    /// Output only. Result of manual approval for this Build.
    pub result: std::option::Option<crate::model::ApprovalResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildApproval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BuildApproval::state].
    pub fn set_state<T: std::convert::Into<crate::model::build_approval::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [config][crate::model::BuildApproval::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::BuildApproval::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [result][crate::model::BuildApproval::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::BuildApproval::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalResult>,
    {
        self.result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BuildApproval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildApproval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildApproval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __config,
            __result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildApproval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "config" => Ok(__FieldTag::__config),
                            "result" => Ok(__FieldTag::__result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildApproval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildApproval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::build_approval::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::ApprovalConfig>>(
                                )?;
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<crate::model::ApprovalResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildApproval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuildApproval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildApproval");
        debug_struct.field("state", &self.state);
        debug_struct.field("config", &self.config);
        debug_struct.field("result", &self.result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BuildApproval].
pub mod build_approval {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the current state of a build's approval.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default enum type. This should not be used.
        Unspecified,
        /// Build approval is pending.
        Pending,
        /// Build approval has been approved.
        Approved,
        /// Build approval has been rejected.
        Rejected,
        /// Build was cancelled while it was still pending approval.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Approved => std::option::Option::Some(2),
                Self::Rejected => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Approved,
                3 => Self::Rejected,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Approved => serializer.serialize_i32(2),
                Self::Rejected => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.BuildApproval.State",
            ))
        }
    }
}

/// ApprovalConfig describes configuration for manual approval of a build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will
    /// become pending when created, and will need to be explicitly approved
    /// to start.
    pub approval_required: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApprovalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approval_required][crate::model::ApprovalConfig::approval_required].
    pub fn set_approval_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.approval_required = v.into();
        self
    }
}

impl wkt::message::Message for ApprovalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApprovalConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApprovalConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approval_required,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApprovalConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approvalRequired" => Ok(__FieldTag::__approval_required),
                            "approval_required" => Ok(__FieldTag::__approval_required),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApprovalConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApprovalConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approval_required => {
                            if !fields.insert(__FieldTag::__approval_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_required",
                                ));
                            }
                            result.approval_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApprovalConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.approval_required) {
            state.serialize_entry("approvalRequired", &self.approval_required)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApprovalConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApprovalConfig");
        debug_struct.field("approval_required", &self.approval_required);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ApprovalResult describes the decision and associated metadata of a manual
/// approval of a build.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApprovalResult {
    /// Output only. Email of the user that called the ApproveBuild API to
    /// approve or reject a build at the time that the API was called.
    pub approver_account: std::string::String,

    /// Output only. The time when the approval decision was made.
    pub approval_time: std::option::Option<wkt::Timestamp>,

    /// Required. The decision of this manual approval.
    pub decision: crate::model::approval_result::Decision,

    /// Optional. An optional comment for this manual approval result.
    pub comment: std::string::String,

    /// Optional. An optional URL tied to this manual approval result. This field
    /// is essentially the same as comment, except that it will be rendered by the
    /// UI differently. An example use case is a link to an external job that
    /// approved this Build.
    pub url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApprovalResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approver_account][crate::model::ApprovalResult::approver_account].
    pub fn set_approver_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.approver_account = v.into();
        self
    }

    /// Sets the value of [approval_time][crate::model::ApprovalResult::approval_time].
    pub fn set_approval_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approval_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval_time][crate::model::ApprovalResult::approval_time].
    pub fn set_or_clear_approval_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approval_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decision][crate::model::ApprovalResult::decision].
    pub fn set_decision<T: std::convert::Into<crate::model::approval_result::Decision>>(
        mut self,
        v: T,
    ) -> Self {
        self.decision = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::ApprovalResult::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [url][crate::model::ApprovalResult::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }
}

impl wkt::message::Message for ApprovalResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ApprovalResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApprovalResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approver_account,
            __approval_time,
            __decision,
            __comment,
            __url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApprovalResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approverAccount" => Ok(__FieldTag::__approver_account),
                            "approver_account" => Ok(__FieldTag::__approver_account),
                            "approvalTime" => Ok(__FieldTag::__approval_time),
                            "approval_time" => Ok(__FieldTag::__approval_time),
                            "decision" => Ok(__FieldTag::__decision),
                            "comment" => Ok(__FieldTag::__comment),
                            "url" => Ok(__FieldTag::__url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApprovalResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApprovalResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approver_account => {
                            if !fields.insert(__FieldTag::__approver_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approver_account",
                                ));
                            }
                            result.approver_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval_time => {
                            if !fields.insert(__FieldTag::__approval_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_time",
                                ));
                            }
                            result.approval_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__decision => {
                            if !fields.insert(__FieldTag::__decision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decision",
                                ));
                            }
                            result.decision = map.next_value::<std::option::Option<crate::model::approval_result::Decision>>()?.unwrap_or_default();
                        }
                        __FieldTag::__comment => {
                            if !fields.insert(__FieldTag::__comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment",
                                ));
                            }
                            result.comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApprovalResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.approver_account.is_empty() {
            state.serialize_entry("approverAccount", &self.approver_account)?;
        }
        if self.approval_time.is_some() {
            state.serialize_entry("approvalTime", &self.approval_time)?;
        }
        if !wkt::internal::is_default(&self.decision) {
            state.serialize_entry("decision", &self.decision)?;
        }
        if !self.comment.is_empty() {
            state.serialize_entry("comment", &self.comment)?;
        }
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApprovalResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApprovalResult");
        debug_struct.field("approver_account", &self.approver_account);
        debug_struct.field("approval_time", &self.approval_time);
        debug_struct.field("decision", &self.decision);
        debug_struct.field("comment", &self.comment);
        debug_struct.field("url", &self.url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApprovalResult].
pub mod approval_result {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether or not this manual approval result is to approve
    /// or reject a build.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Decision {
        /// Default enum type. This should not be used.
        Unspecified,
        /// Build is approved.
        Approved,
        /// Build is rejected.
        Rejected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Decision::value] or
        /// [Decision::name].
        UnknownValue(decision::UnknownValue),
    }

    #[doc(hidden)]
    pub mod decision {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Decision {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Approved => std::option::Option::Some(1),
                Self::Rejected => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DECISION_UNSPECIFIED"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Decision {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Decision {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Decision {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Approved,
                2 => Self::Rejected,
                _ => Self::UnknownValue(decision::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Decision {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DECISION_UNSPECIFIED" => Self::Unspecified,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                _ => Self::UnknownValue(decision::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Decision {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Approved => serializer.serialize_i32(1),
                Self::Rejected => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Decision {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Decision>::new(
                ".google.devtools.cloudbuild.v1.ApprovalResult.Decision",
            ))
        }
    }
}

/// GitRepoSource describes a repo and ref of a code repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitRepoSource {
    /// The URI of the repo (e.g. <https://github.com/user/repo.git>).
    /// Either `uri` or `repository` can be specified and is required.
    pub uri: std::string::String,

    /// The branch or tag to use. Must start with "refs/" (required).
    pub r#ref: std::string::String,

    /// See RepoType below.
    pub repo_type: crate::model::git_file_source::RepoType,

    /// The source of the SCM repo.
    pub source: std::option::Option<crate::model::git_repo_source::Source>,

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    pub enterprise_config: std::option::Option<crate::model::git_repo_source::EnterpriseConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitRepoSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GitRepoSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [r#ref][crate::model::GitRepoSource::ref].
    pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#ref = v.into();
        self
    }

    /// Sets the value of [repo_type][crate::model::GitRepoSource::repo_type].
    pub fn set_repo_type<T: std::convert::Into<crate::model::git_file_source::RepoType>>(
        mut self,
        v: T,
    ) -> Self {
        self.repo_type = v.into();
        self
    }

    /// Sets the value of [source][crate::model::GitRepoSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::git_repo_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GitRepoSource::source]
    /// if it holds a `Repository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repository(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::git_repo_source::Source::Repository(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GitRepoSource::source]
    /// to hold a `Repository`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::git_repo_source::Source::Repository(v.into()));
        self
    }

    /// Sets the value of [enterprise_config][crate::model::GitRepoSource::enterprise_config].
    ///
    /// Note that all the setters affecting `enterprise_config` are mutually
    /// exclusive.
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::git_repo_source::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// The value of [enterprise_config][crate::model::GitRepoSource::enterprise_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_enterprise_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.enterprise_config.as_ref().and_then(|v| match v {
            crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enterprise_config][crate::model::GitRepoSource::enterprise_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `enterprise_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = std::option::Option::Some(
            crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GitRepoSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitRepoSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitRepoSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __repository,
            __ref,
            __repo_type,
            __github_enterprise_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitRepoSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "repository" => Ok(__FieldTag::__repository),
                            "ref" => Ok(__FieldTag::__ref),
                            "repoType" => Ok(__FieldTag::__repo_type),
                            "repo_type" => Ok(__FieldTag::__repo_type),
                            "githubEnterpriseConfig" => Ok(__FieldTag::__github_enterprise_config),
                            "github_enterprise_config" => {
                                Ok(__FieldTag::__github_enterprise_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitRepoSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitRepoSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.GitRepoSource.repository, latest field was repository",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::git_repo_source::Source::Repository(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ref => {
                            if !fields.insert(__FieldTag::__ref) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ref",
                                ));
                            }
                            result.r#ref = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repo_type => {
                            if !fields.insert(__FieldTag::__repo_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_type",
                                ));
                            }
                            result.repo_type = map.next_value::<std::option::Option<crate::model::git_file_source::RepoType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__github_enterprise_config => {
                            if !fields.insert(__FieldTag::__github_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_enterprise_config",
                                ));
                            }
                            if result.enterprise_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enterprise_config`, a oneof with full ID .google.devtools.cloudbuild.v1.GitRepoSource.github_enterprise_config, latest field was githubEnterpriseConfig",
                                ));
                            }
                            result.enterprise_config = std::option::Option::Some(
                                crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitRepoSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if let Some(value) = self.repository() {
            state.serialize_entry("repository", value)?;
        }
        if !self.r#ref.is_empty() {
            state.serialize_entry("ref", &self.r#ref)?;
        }
        if !wkt::internal::is_default(&self.repo_type) {
            state.serialize_entry("repoType", &self.repo_type)?;
        }
        if let Some(value) = self.github_enterprise_config() {
            state.serialize_entry("githubEnterpriseConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitRepoSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitRepoSource");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("r#ref", &self.r#ref);
        debug_struct.field("repo_type", &self.repo_type);
        debug_struct.field("source", &self.source);
        debug_struct.field("enterprise_config", &self.enterprise_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GitRepoSource].
pub mod git_repo_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the SCM repo.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The connected repository resource name, in the format
        /// `projects/*/locations/*/connections/*/repositories/*`. Either `uri` or
        /// `repository` can be specified and is required.
        Repository(std::string::String),
    }

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        GithubEnterpriseConfig(std::string::String),
    }
}

/// GitFileSource describes a file within a (possibly remote) code repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitFileSource {
    /// The path of the file, with the repo root as the root of the path.
    pub path: std::string::String,

    /// The URI of the repo.
    /// Either uri or repository can be specified.
    /// If unspecified, the repo from which the trigger invocation originated is
    /// assumed to be the repo from which to read the specified path.
    pub uri: std::string::String,

    /// See RepoType above.
    pub repo_type: crate::model::git_file_source::RepoType,

    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when
    /// resolving the filename (optional).
    /// This field respects the same syntax/resolution as described here:
    /// <https://git-scm.com/docs/gitrevisions>
    /// If unspecified, the revision from which the trigger invocation originated
    /// is assumed to be the revision from which to read the specified path.
    pub revision: std::string::String,

    /// The source of the SCM repo.
    pub source: std::option::Option<crate::model::git_file_source::Source>,

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    pub enterprise_config: std::option::Option<crate::model::git_file_source::EnterpriseConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitFileSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::GitFileSource::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::GitFileSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [repo_type][crate::model::GitFileSource::repo_type].
    pub fn set_repo_type<T: std::convert::Into<crate::model::git_file_source::RepoType>>(
        mut self,
        v: T,
    ) -> Self {
        self.repo_type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::GitFileSource::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [source][crate::model::GitFileSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::git_file_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GitFileSource::source]
    /// if it holds a `Repository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repository(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::git_file_source::Source::Repository(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GitFileSource::source]
    /// to hold a `Repository`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::git_file_source::Source::Repository(v.into()));
        self
    }

    /// Sets the value of [enterprise_config][crate::model::GitFileSource::enterprise_config].
    ///
    /// Note that all the setters affecting `enterprise_config` are mutually
    /// exclusive.
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::git_file_source::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// The value of [enterprise_config][crate::model::GitFileSource::enterprise_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_enterprise_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.enterprise_config.as_ref().and_then(|v| match v {
            crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [enterprise_config][crate::model::GitFileSource::enterprise_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `enterprise_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = std::option::Option::Some(
            crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GitFileSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitFileSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitFileSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __uri,
            __repository,
            __repo_type,
            __revision,
            __github_enterprise_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitFileSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "uri" => Ok(__FieldTag::__uri),
                            "repository" => Ok(__FieldTag::__repository),
                            "repoType" => Ok(__FieldTag::__repo_type),
                            "repo_type" => Ok(__FieldTag::__repo_type),
                            "revision" => Ok(__FieldTag::__revision),
                            "githubEnterpriseConfig" => Ok(__FieldTag::__github_enterprise_config),
                            "github_enterprise_config" => {
                                Ok(__FieldTag::__github_enterprise_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitFileSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitFileSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.GitFileSource.repository, latest field was repository",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::git_file_source::Source::Repository(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repo_type => {
                            if !fields.insert(__FieldTag::__repo_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_type",
                                ));
                            }
                            result.repo_type = map.next_value::<std::option::Option<crate::model::git_file_source::RepoType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__github_enterprise_config => {
                            if !fields.insert(__FieldTag::__github_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_enterprise_config",
                                ));
                            }
                            if result.enterprise_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enterprise_config`, a oneof with full ID .google.devtools.cloudbuild.v1.GitFileSource.github_enterprise_config, latest field was githubEnterpriseConfig",
                                ));
                            }
                            result.enterprise_config = std::option::Option::Some(
                                crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitFileSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if let Some(value) = self.repository() {
            state.serialize_entry("repository", value)?;
        }
        if !wkt::internal::is_default(&self.repo_type) {
            state.serialize_entry("repoType", &self.repo_type)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if let Some(value) = self.github_enterprise_config() {
            state.serialize_entry("githubEnterpriseConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitFileSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitFileSource");
        debug_struct.field("path", &self.path);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("repo_type", &self.repo_type);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("source", &self.source);
        debug_struct.field("enterprise_config", &self.enterprise_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GitFileSource].
pub mod git_file_source {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the repo, since it may not be explicit from the `repo` field
    /// (e.g from a URL).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RepoType {
        /// The default, unknown repo type. Don't use it, instead use one of
        /// the other repo types.
        Unknown,
        /// A Google Cloud Source Repositories-hosted repo.
        CloudSourceRepositories,
        /// A GitHub-hosted repo not necessarily on "github.com" (i.e. GitHub
        /// Enterprise).
        Github,
        /// A Bitbucket Server-hosted repo.
        BitbucketServer,
        /// A GitLab-hosted repo.
        Gitlab,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RepoType::value] or
        /// [RepoType::name].
        UnknownValue(repo_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod repo_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RepoType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::CloudSourceRepositories => std::option::Option::Some(1),
                Self::Github => std::option::Option::Some(2),
                Self::BitbucketServer => std::option::Option::Some(3),
                Self::Gitlab => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::CloudSourceRepositories => {
                    std::option::Option::Some("CLOUD_SOURCE_REPOSITORIES")
                }
                Self::Github => std::option::Option::Some("GITHUB"),
                Self::BitbucketServer => std::option::Option::Some("BITBUCKET_SERVER"),
                Self::Gitlab => std::option::Option::Some("GITLAB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RepoType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RepoType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RepoType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::CloudSourceRepositories,
                2 => Self::Github,
                3 => Self::BitbucketServer,
                4 => Self::Gitlab,
                _ => Self::UnknownValue(repo_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RepoType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "CLOUD_SOURCE_REPOSITORIES" => Self::CloudSourceRepositories,
                "GITHUB" => Self::Github,
                "BITBUCKET_SERVER" => Self::BitbucketServer,
                "GITLAB" => Self::Gitlab,
                _ => Self::UnknownValue(repo_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RepoType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::CloudSourceRepositories => serializer.serialize_i32(1),
                Self::Github => serializer.serialize_i32(2),
                Self::BitbucketServer => serializer.serialize_i32(3),
                Self::Gitlab => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RepoType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepoType>::new(
                ".google.devtools.cloudbuild.v1.GitFileSource.RepoType",
            ))
        }
    }

    /// The source of the SCM repo.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The fully qualified resource name of the Repos API repository.
        /// Either URI or repository can be specified.
        /// If unspecified, the repo from which the trigger invocation originated is
        /// assumed to be the repo from which to read the specified path.
        Repository(std::string::String),
    }

    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        GithubEnterpriseConfig(std::string::String),
    }
}

/// Configuration for an automated build in response to source repository
/// changes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildTrigger {
    /// The `Trigger` name with format:
    /// `projects/{project}/locations/{location}/triggers/{trigger}`, where
    /// {trigger} is a unique identifier generated by the service.
    pub resource_name: std::string::String,

    /// Output only. Unique identifier of the trigger.
    pub id: std::string::String,

    /// Human-readable description of this trigger.
    pub description: std::string::String,

    /// User-assigned name of the trigger. Must be unique within the project.
    /// Trigger names must meet the following requirements:
    ///
    /// + They must contain only alphanumeric characters and dashes.
    /// + They can be 1-64 characters long.
    /// + They must begin and end with an alphanumeric character.
    pub name: std::string::String,

    /// Tags for annotation of a `BuildTrigger`
    pub tags: std::vec::Vec<std::string::String>,

    /// Template describing the types of source changes to trigger a build.
    ///
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular expression
    /// will trigger a build.
    ///
    /// Mutually exclusive with `github`.
    pub trigger_template: std::option::Option<crate::model::RepoSource>,

    /// GitHubEventsConfig describes the configuration of a trigger that creates
    /// a build whenever a GitHub event is received.
    ///
    /// Mutually exclusive with `trigger_template`.
    pub github: std::option::Option<crate::model::GitHubEventsConfig>,

    /// PubsubConfig describes the configuration of a trigger that
    /// creates a build whenever a Pub/Sub message is published.
    pub pubsub_config: std::option::Option<crate::model::PubsubConfig>,

    /// WebhookConfig describes the configuration of a trigger that
    /// creates a build whenever a webhook is sent to a trigger's webhook URL.
    pub webhook_config: std::option::Option<crate::model::WebhookConfig>,

    /// Output only. Time when the trigger was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// If true, the trigger will never automatically execute a build.
    pub disabled: bool,

    /// Substitutions for Build resource. The keys must match the following
    /// regular expression: `^_[A-Z0-9_]+$`.
    pub substitutions: std::collections::HashMap<std::string::String, std::string::String>,

    /// ignored_files and included_files are file glob matches using
    /// <https://golang.org/pkg/path/filepath/#Match> extended with support for "**".
    ///
    /// If ignored_files and changed files are both empty, then they are
    /// not used to determine whether or not to trigger a build.
    ///
    /// If ignored_files is not empty, then we ignore any files that match
    /// any of the ignored_file globs. If the change has no files that are
    /// outside of the ignored_files globs, then we do not trigger a build.
    pub ignored_files: std::vec::Vec<std::string::String>,

    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is empty, then as far as this filter is
    /// concerned, we should trigger the build.
    ///
    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is not empty, then we make sure that at
    /// least one of those files matches a included_files glob. If not,
    /// then we do not trigger a build.
    pub included_files: std::vec::Vec<std::string::String>,

    /// Optional. A Common Expression Language string.
    pub filter: std::string::String,

    /// The repo and ref of the repository from which to build. This field
    /// is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit
    /// caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron
    /// triggers.
    pub source_to_build: std::option::Option<crate::model::GitRepoSource>,

    /// The service account used for all user-controlled operations including
    /// UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild.
    /// If no service account is set and the legacy Cloud Build service account
    /// (`[PROJECT_NUM]@cloudbuild.gserviceaccount.com`) is the default for the
    /// project then it will be used instead.
    /// Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`
    pub service_account: std::string::String,

    /// The configuration of a trigger that creates a build whenever an event from
    /// Repo API is received.
    pub repository_event_config: std::option::Option<crate::model::RepositoryEventConfig>,

    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    pub build_template: std::option::Option<crate::model::build_trigger::BuildTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildTrigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_name][crate::model::BuildTrigger::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BuildTrigger::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BuildTrigger::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [name][crate::model::BuildTrigger::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::BuildTrigger::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trigger_template][crate::model::BuildTrigger::trigger_template].
    pub fn set_trigger_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.trigger_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger_template][crate::model::BuildTrigger::trigger_template].
    pub fn set_or_clear_trigger_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepoSource>,
    {
        self.trigger_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [github][crate::model::BuildTrigger::github].
    pub fn set_github<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEventsConfig>,
    {
        self.github = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [github][crate::model::BuildTrigger::github].
    pub fn set_or_clear_github<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEventsConfig>,
    {
        self.github = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pubsub_config][crate::model::BuildTrigger::pubsub_config].
    pub fn set_pubsub_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PubsubConfig>,
    {
        self.pubsub_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pubsub_config][crate::model::BuildTrigger::pubsub_config].
    pub fn set_or_clear_pubsub_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PubsubConfig>,
    {
        self.pubsub_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_config][crate::model::BuildTrigger::webhook_config].
    pub fn set_webhook_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WebhookConfig>,
    {
        self.webhook_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook_config][crate::model::BuildTrigger::webhook_config].
    pub fn set_or_clear_webhook_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WebhookConfig>,
    {
        self.webhook_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::BuildTrigger::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BuildTrigger::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::BuildTrigger::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [substitutions][crate::model::BuildTrigger::substitutions].
    pub fn set_substitutions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substitutions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [ignored_files][crate::model::BuildTrigger::ignored_files].
    pub fn set_ignored_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ignored_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_files][crate::model::BuildTrigger::included_files].
    pub fn set_included_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.included_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::BuildTrigger::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [source_to_build][crate::model::BuildTrigger::source_to_build].
    pub fn set_source_to_build<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitRepoSource>,
    {
        self.source_to_build = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_to_build][crate::model::BuildTrigger::source_to_build].
    pub fn set_or_clear_source_to_build<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitRepoSource>,
    {
        self.source_to_build = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::BuildTrigger::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [repository_event_config][crate::model::BuildTrigger::repository_event_config].
    pub fn set_repository_event_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepositoryEventConfig>,
    {
        self.repository_event_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository_event_config][crate::model::BuildTrigger::repository_event_config].
    pub fn set_or_clear_repository_event_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepositoryEventConfig>,
    {
        self.repository_event_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template].
    ///
    /// Note that all the setters affecting `build_template` are mutually
    /// exclusive.
    pub fn set_build_template<
        T: std::convert::Into<std::option::Option<crate::model::build_trigger::BuildTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_template = v.into();
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Autodetect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn autodetect(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Autodetect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Autodetect`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_autodetect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::Autodetect(v.into()),
        );
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Build`, `None` if the field is not set or
    /// holds a different branch.
    pub fn build(&self) -> std::option::Option<&std::boxed::Box<crate::model::Build>> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Build(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Build`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_build<T: std::convert::Into<std::boxed::Box<crate::model::Build>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_template =
            std::option::Option::Some(crate::model::build_trigger::BuildTemplate::Build(v.into()));
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `Filename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filename(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::Filename(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `Filename`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_filename<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::Filename(v.into()),
        );
        self
    }

    /// The value of [build_template][crate::model::BuildTrigger::build_template]
    /// if it holds a `GitFileSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_file_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitFileSource>> {
        #[allow(unreachable_patterns)]
        self.build_template.as_ref().and_then(|v| match v {
            crate::model::build_trigger::BuildTemplate::GitFileSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_template][crate::model::BuildTrigger::build_template]
    /// to hold a `GitFileSource`.
    ///
    /// Note that all the setters affecting `build_template` are
    /// mutually exclusive.
    pub fn set_git_file_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GitFileSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_template = std::option::Option::Some(
            crate::model::build_trigger::BuildTemplate::GitFileSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BuildTrigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildTrigger"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildTrigger {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_name,
            __id,
            __description,
            __name,
            __tags,
            __trigger_template,
            __github,
            __pubsub_config,
            __webhook_config,
            __autodetect,
            __build,
            __filename,
            __git_file_source,
            __create_time,
            __disabled,
            __substitutions,
            __ignored_files,
            __included_files,
            __filter,
            __source_to_build,
            __service_account,
            __repository_event_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildTrigger")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceName" => Ok(__FieldTag::__resource_name),
                            "resource_name" => Ok(__FieldTag::__resource_name),
                            "id" => Ok(__FieldTag::__id),
                            "description" => Ok(__FieldTag::__description),
                            "name" => Ok(__FieldTag::__name),
                            "tags" => Ok(__FieldTag::__tags),
                            "triggerTemplate" => Ok(__FieldTag::__trigger_template),
                            "trigger_template" => Ok(__FieldTag::__trigger_template),
                            "github" => Ok(__FieldTag::__github),
                            "pubsubConfig" => Ok(__FieldTag::__pubsub_config),
                            "pubsub_config" => Ok(__FieldTag::__pubsub_config),
                            "webhookConfig" => Ok(__FieldTag::__webhook_config),
                            "webhook_config" => Ok(__FieldTag::__webhook_config),
                            "autodetect" => Ok(__FieldTag::__autodetect),
                            "build" => Ok(__FieldTag::__build),
                            "filename" => Ok(__FieldTag::__filename),
                            "gitFileSource" => Ok(__FieldTag::__git_file_source),
                            "git_file_source" => Ok(__FieldTag::__git_file_source),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "disabled" => Ok(__FieldTag::__disabled),
                            "substitutions" => Ok(__FieldTag::__substitutions),
                            "ignoredFiles" => Ok(__FieldTag::__ignored_files),
                            "ignored_files" => Ok(__FieldTag::__ignored_files),
                            "includedFiles" => Ok(__FieldTag::__included_files),
                            "included_files" => Ok(__FieldTag::__included_files),
                            "filter" => Ok(__FieldTag::__filter),
                            "sourceToBuild" => Ok(__FieldTag::__source_to_build),
                            "source_to_build" => Ok(__FieldTag::__source_to_build),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "repositoryEventConfig" => Ok(__FieldTag::__repository_event_config),
                            "repository_event_config" => Ok(__FieldTag::__repository_event_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildTrigger;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildTrigger")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_name => {
                            if !fields.insert(__FieldTag::__resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_name",
                                ));
                            }
                            result.resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__trigger_template => {
                            if !fields.insert(__FieldTag::__trigger_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_template",
                                ));
                            }
                            result.trigger_template =
                                map.next_value::<std::option::Option<crate::model::RepoSource>>()?;
                        }
                        __FieldTag::__github => {
                            if !fields.insert(__FieldTag::__github) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github",
                                ));
                            }
                            result.github = map.next_value::<std::option::Option<crate::model::GitHubEventsConfig>>()?
                                ;
                        }
                        __FieldTag::__pubsub_config => {
                            if !fields.insert(__FieldTag::__pubsub_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_config",
                                ));
                            }
                            result.pubsub_config = map
                                .next_value::<std::option::Option<crate::model::PubsubConfig>>()?;
                        }
                        __FieldTag::__webhook_config => {
                            if !fields.insert(__FieldTag::__webhook_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_config",
                                ));
                            }
                            result.webhook_config = map
                                .next_value::<std::option::Option<crate::model::WebhookConfig>>()?;
                        }
                        __FieldTag::__autodetect => {
                            if !fields.insert(__FieldTag::__autodetect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.autodetect, latest field was autodetect",
                                ));
                            }
                            result.build_template = std::option::Option::Some(
                                crate::model::build_trigger::BuildTemplate::Autodetect(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.build, latest field was build",
                                ));
                            }
                            result.build_template =
                                std::option::Option::Some(
                                    crate::model::build_trigger::BuildTemplate::Build(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Build>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__filename => {
                            if !fields.insert(__FieldTag::__filename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filename",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.filename, latest field was filename",
                                ));
                            }
                            result.build_template = std::option::Option::Some(
                                crate::model::build_trigger::BuildTemplate::Filename(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git_file_source => {
                            if !fields.insert(__FieldTag::__git_file_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_file_source",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.git_file_source, latest field was gitFileSource",
                                ));
                            }
                            result.build_template = std::option::Option::Some(
                                crate::model::build_trigger::BuildTemplate::GitFileSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitFileSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substitutions => {
                            if !fields.insert(__FieldTag::__substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitutions",
                                ));
                            }
                            result.substitutions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignored_files => {
                            if !fields.insert(__FieldTag::__ignored_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignored_files",
                                ));
                            }
                            result.ignored_files = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__included_files => {
                            if !fields.insert(__FieldTag::__included_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_files",
                                ));
                            }
                            result.included_files = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_to_build => {
                            if !fields.insert(__FieldTag::__source_to_build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_to_build",
                                ));
                            }
                            result.source_to_build = map
                                .next_value::<std::option::Option<crate::model::GitRepoSource>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_event_config => {
                            if !fields.insert(__FieldTag::__repository_event_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_event_config",
                                ));
                            }
                            result.repository_event_config = map.next_value::<std::option::Option<crate::model::RepositoryEventConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildTrigger {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_name.is_empty() {
            state.serialize_entry("resourceName", &self.resource_name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.trigger_template.is_some() {
            state.serialize_entry("triggerTemplate", &self.trigger_template)?;
        }
        if self.github.is_some() {
            state.serialize_entry("github", &self.github)?;
        }
        if self.pubsub_config.is_some() {
            state.serialize_entry("pubsubConfig", &self.pubsub_config)?;
        }
        if self.webhook_config.is_some() {
            state.serialize_entry("webhookConfig", &self.webhook_config)?;
        }
        if let Some(value) = self.autodetect() {
            state.serialize_entry("autodetect", value)?;
        }
        if let Some(value) = self.build() {
            state.serialize_entry("build", value)?;
        }
        if let Some(value) = self.filename() {
            state.serialize_entry("filename", value)?;
        }
        if let Some(value) = self.git_file_source() {
            state.serialize_entry("gitFileSource", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self.substitutions.is_empty() {
            state.serialize_entry("substitutions", &self.substitutions)?;
        }
        if !self.ignored_files.is_empty() {
            state.serialize_entry("ignoredFiles", &self.ignored_files)?;
        }
        if !self.included_files.is_empty() {
            state.serialize_entry("includedFiles", &self.included_files)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.source_to_build.is_some() {
            state.serialize_entry("sourceToBuild", &self.source_to_build)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.repository_event_config.is_some() {
            state.serialize_entry("repositoryEventConfig", &self.repository_event_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuildTrigger {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildTrigger");
        debug_struct.field("resource_name", &self.resource_name);
        debug_struct.field("id", &self.id);
        debug_struct.field("description", &self.description);
        debug_struct.field("name", &self.name);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("trigger_template", &self.trigger_template);
        debug_struct.field("github", &self.github);
        debug_struct.field("pubsub_config", &self.pubsub_config);
        debug_struct.field("webhook_config", &self.webhook_config);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("substitutions", &self.substitutions);
        debug_struct.field("ignored_files", &self.ignored_files);
        debug_struct.field("included_files", &self.included_files);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("source_to_build", &self.source_to_build);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("repository_event_config", &self.repository_event_config);
        debug_struct.field("build_template", &self.build_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BuildTrigger].
pub mod build_trigger {
    #[allow(unused_imports)]
    use super::*;

    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BuildTemplate {
        /// Autodetect build configuration.  The following precedence is used (case
        /// insensitive):
        ///
        /// 1. cloudbuild.yaml
        /// 1. cloudbuild.yml
        /// 1. cloudbuild.json
        /// 1. Dockerfile
        ///
        /// Currently only available for GitHub App Triggers.
        Autodetect(bool),
        /// Contents of the build template.
        Build(std::boxed::Box<crate::model::Build>),
        /// Path, from the source root, to the build configuration file
        /// (i.e. cloudbuild.yaml).
        Filename(std::string::String),
        /// The file source describing the local or remote Build template.
        GitFileSource(std::boxed::Box<crate::model::GitFileSource>),
    }
}

/// The configuration of a trigger that creates a build whenever an event from
/// Repo API is received.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepositoryEventConfig {
    /// The resource name of the Repo API resource.
    pub repository: std::string::String,

    /// Output only. The type of the SCM vendor the repository points to.
    pub repository_type: crate::model::repository_event_config::RepositoryType,

    /// The types of filter to trigger a build.
    pub filter: std::option::Option<crate::model::repository_event_config::Filter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepositoryEventConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::RepositoryEventConfig::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [repository_type][crate::model::RepositoryEventConfig::repository_type].
    pub fn set_repository_type<
        T: std::convert::Into<crate::model::repository_event_config::RepositoryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repository_type = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::repository_event_config::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::RepositoryEventConfig::filter]
    /// if it holds a `PullRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pull_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PullRequestFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::repository_event_config::Filter::PullRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter]
    /// to hold a `PullRequest`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_pull_request<
        T: std::convert::Into<std::boxed::Box<crate::model::PullRequestFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::repository_event_config::Filter::PullRequest(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::RepositoryEventConfig::filter]
    /// if it holds a `Push`, `None` if the field is not set or
    /// holds a different branch.
    pub fn push(&self) -> std::option::Option<&std::boxed::Box<crate::model::PushFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::repository_event_config::Filter::Push(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::RepositoryEventConfig::filter]
    /// to hold a `Push`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_push<T: std::convert::Into<std::boxed::Box<crate::model::PushFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::repository_event_config::Filter::Push(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RepositoryEventConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.RepositoryEventConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepositoryEventConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __repository_type,
            __pull_request,
            __push,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepositoryEventConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "repositoryType" => Ok(__FieldTag::__repository_type),
                            "repository_type" => Ok(__FieldTag::__repository_type),
                            "pullRequest" => Ok(__FieldTag::__pull_request),
                            "pull_request" => Ok(__FieldTag::__pull_request),
                            "push" => Ok(__FieldTag::__push),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepositoryEventConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepositoryEventConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_type => {
                            if !fields.insert(__FieldTag::__repository_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_type",
                                ));
                            }
                            result.repository_type = map
                                .next_value::<std::option::Option<
                                    crate::model::repository_event_config::RepositoryType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pull_request => {
                            if !fields.insert(__FieldTag::__pull_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_request",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.devtools.cloudbuild.v1.RepositoryEventConfig.pull_request, latest field was pullRequest",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::repository_event_config::Filter::PullRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PullRequestFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__push => {
                            if !fields.insert(__FieldTag::__push) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.devtools.cloudbuild.v1.RepositoryEventConfig.push, latest field was push",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::repository_event_config::Filter::Push(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PushFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepositoryEventConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.repository.is_empty() {
            state.serialize_entry("repository", &self.repository)?;
        }
        if !wkt::internal::is_default(&self.repository_type) {
            state.serialize_entry("repositoryType", &self.repository_type)?;
        }
        if let Some(value) = self.pull_request() {
            state.serialize_entry("pullRequest", value)?;
        }
        if let Some(value) = self.push() {
            state.serialize_entry("push", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepositoryEventConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepositoryEventConfig");
        debug_struct.field("repository", &self.repository);
        debug_struct.field("repository_type", &self.repository_type);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RepositoryEventConfig].
pub mod repository_event_config {
    #[allow(unused_imports)]
    use super::*;

    /// All possible SCM repo types from Repo API.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RepositoryType {
        /// If unspecified, RepositoryType defaults to GITHUB.
        Unspecified,
        /// The SCM repo is GITHUB.
        Github,
        /// The SCM repo is GITHUB Enterprise.
        GithubEnterprise,
        /// The SCM repo is GITLAB Enterprise.
        GitlabEnterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RepositoryType::value] or
        /// [RepositoryType::name].
        UnknownValue(repository_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod repository_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RepositoryType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Github => std::option::Option::Some(1),
                Self::GithubEnterprise => std::option::Option::Some(2),
                Self::GitlabEnterprise => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPOSITORY_TYPE_UNSPECIFIED"),
                Self::Github => std::option::Option::Some("GITHUB"),
                Self::GithubEnterprise => std::option::Option::Some("GITHUB_ENTERPRISE"),
                Self::GitlabEnterprise => std::option::Option::Some("GITLAB_ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RepositoryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RepositoryType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RepositoryType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Github,
                2 => Self::GithubEnterprise,
                3 => Self::GitlabEnterprise,
                _ => Self::UnknownValue(repository_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RepositoryType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPOSITORY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GITHUB" => Self::Github,
                "GITHUB_ENTERPRISE" => Self::GithubEnterprise,
                "GITLAB_ENTERPRISE" => Self::GitlabEnterprise,
                _ => Self::UnknownValue(repository_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RepositoryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Github => serializer.serialize_i32(1),
                Self::GithubEnterprise => serializer.serialize_i32(2),
                Self::GitlabEnterprise => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RepositoryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepositoryType>::new(
                ".google.devtools.cloudbuild.v1.RepositoryEventConfig.RepositoryType",
            ))
        }
    }

    /// The types of filter to trigger a build.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// Filter to match changes in pull requests.
        PullRequest(std::boxed::Box<crate::model::PullRequestFilter>),
        /// Filter to match changes in refs like branches, tags.
        Push(std::boxed::Box<crate::model::PushFilter>),
    }
}

/// GitHubEventsConfig describes the configuration of a trigger that creates a
/// build whenever a GitHub event is received.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitHubEventsConfig {
    /// The installationID that emits the GitHub event.
    #[deprecated]
    pub installation_id: i64,

    /// Owner of the repository. For example: The owner for
    /// <https://github.com/googlecloudplatform/cloud-builders> is
    /// "googlecloudplatform".
    pub owner: std::string::String,

    /// Name of the repository. For example: The name for
    /// <https://github.com/googlecloudplatform/cloud-builders> is "cloud-builders".
    pub name: std::string::String,

    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    pub event: std::option::Option<crate::model::git_hub_events_config::Event>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEventsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [installation_id][crate::model::GitHubEventsConfig::installation_id].
    #[deprecated]
    pub fn set_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.installation_id = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::GitHubEventsConfig::owner].
    pub fn set_owner<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GitHubEventsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event].
    ///
    /// Note that all the setters affecting `event` are mutually
    /// exclusive.
    pub fn set_event<
        T: std::convert::Into<std::option::Option<crate::model::git_hub_events_config::Event>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }

    /// The value of [event][crate::model::GitHubEventsConfig::event]
    /// if it holds a `PullRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pull_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PullRequestFilter>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::git_hub_events_config::Event::PullRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event]
    /// to hold a `PullRequest`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_pull_request<
        T: std::convert::Into<std::boxed::Box<crate::model::PullRequestFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = std::option::Option::Some(
            crate::model::git_hub_events_config::Event::PullRequest(v.into()),
        );
        self
    }

    /// The value of [event][crate::model::GitHubEventsConfig::event]
    /// if it holds a `Push`, `None` if the field is not set or
    /// holds a different branch.
    pub fn push(&self) -> std::option::Option<&std::boxed::Box<crate::model::PushFilter>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::git_hub_events_config::Event::Push(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::GitHubEventsConfig::event]
    /// to hold a `Push`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_push<T: std::convert::Into<std::boxed::Box<crate::model::PushFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event =
            std::option::Option::Some(crate::model::git_hub_events_config::Event::Push(v.into()));
        self
    }
}

impl wkt::message::Message for GitHubEventsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEventsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitHubEventsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __installation_id,
            __owner,
            __name,
            __pull_request,
            __push,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEventsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "installationId" => Ok(__FieldTag::__installation_id),
                            "installation_id" => Ok(__FieldTag::__installation_id),
                            "owner" => Ok(__FieldTag::__owner),
                            "name" => Ok(__FieldTag::__name),
                            "pullRequest" => Ok(__FieldTag::__pull_request),
                            "pull_request" => Ok(__FieldTag::__pull_request),
                            "push" => Ok(__FieldTag::__push),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitHubEventsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEventsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__installation_id => {
                            if !fields.insert(__FieldTag::__installation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installation_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.installation_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner",
                                ));
                            }
                            result.owner = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pull_request => {
                            if !fields.insert(__FieldTag::__pull_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_request",
                                ));
                            }
                            if result.event.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `event`, a oneof with full ID .google.devtools.cloudbuild.v1.GitHubEventsConfig.pull_request, latest field was pullRequest",
                                ));
                            }
                            result.event = std::option::Option::Some(
                                crate::model::git_hub_events_config::Event::PullRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PullRequestFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__push => {
                            if !fields.insert(__FieldTag::__push) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push",
                                ));
                            }
                            if result.event.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `event`, a oneof with full ID .google.devtools.cloudbuild.v1.GitHubEventsConfig.push, latest field was push",
                                ));
                            }
                            result.event = std::option::Option::Some(
                                crate::model::git_hub_events_config::Event::Push(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PushFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitHubEventsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.installation_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("installationId", &__With(&self.installation_id))?;
        }
        if !self.owner.is_empty() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.pull_request() {
            state.serialize_entry("pullRequest", value)?;
        }
        if let Some(value) = self.push() {
            state.serialize_entry("push", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitHubEventsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEventsConfig");
        debug_struct.field("installation_id", &self.installation_id);
        debug_struct.field("owner", &self.owner);
        debug_struct.field("name", &self.name);
        debug_struct.field("event", &self.event);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GitHubEventsConfig].
pub mod git_hub_events_config {
    #[allow(unused_imports)]
    use super::*;

    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Event {
        /// filter to match changes in pull requests.
        PullRequest(std::boxed::Box<crate::model::PullRequestFilter>),
        /// filter to match changes in refs like branches, tags.
        Push(std::boxed::Box<crate::model::PushFilter>),
    }
}

/// PubsubConfig describes the configuration of a trigger that
/// creates a build whenever a Pub/Sub message is published.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PubsubConfig {
    /// Output only. Name of the subscription. Format is
    /// `projects/{project}/subscriptions/{subscription}`.
    pub subscription: std::string::String,

    /// The name of the topic from which this subscription is receiving messages.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    /// Service account that will make the push request.
    pub service_account_email: std::string::String,

    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    pub state: crate::model::pubsub_config::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PubsubConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::PubsubConfig::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::PubsubConfig::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::PubsubConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PubsubConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::pubsub_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for PubsubConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PubsubConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PubsubConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            __topic,
            __service_account_email,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PubsubConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            "topic" => Ok(__FieldTag::__topic),
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PubsubConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PubsubConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::pubsub_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PubsubConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PubsubConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PubsubConfig");
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("topic", &self.topic);
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PubsubConfig].
pub mod pubsub_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates potential issues with the underlying Pub/Sub subscription
    /// configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The subscription configuration has not been checked.
        Unspecified,
        /// The Pub/Sub subscription is properly configured.
        Ok,
        /// The subscription has been deleted.
        SubscriptionDeleted,
        /// The topic has been deleted.
        TopicDeleted,
        /// Some of the subscription's field are misconfigured.
        SubscriptionMisconfigured,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::SubscriptionDeleted => std::option::Option::Some(2),
                Self::TopicDeleted => std::option::Option::Some(3),
                Self::SubscriptionMisconfigured => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::SubscriptionDeleted => std::option::Option::Some("SUBSCRIPTION_DELETED"),
                Self::TopicDeleted => std::option::Option::Some("TOPIC_DELETED"),
                Self::SubscriptionMisconfigured => {
                    std::option::Option::Some("SUBSCRIPTION_MISCONFIGURED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::SubscriptionDeleted,
                3 => Self::TopicDeleted,
                4 => Self::SubscriptionMisconfigured,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "SUBSCRIPTION_DELETED" => Self::SubscriptionDeleted,
                "TOPIC_DELETED" => Self::TopicDeleted,
                "SUBSCRIPTION_MISCONFIGURED" => Self::SubscriptionMisconfigured,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::SubscriptionDeleted => serializer.serialize_i32(2),
                Self::TopicDeleted => serializer.serialize_i32(3),
                Self::SubscriptionMisconfigured => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.PubsubConfig.State",
            ))
        }
    }
}

/// WebhookConfig describes the configuration of a trigger that
/// creates a build whenever a webhook is sent to a trigger's webhook URL.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WebhookConfig {
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    pub state: crate::model::webhook_config::State,

    /// Auth method specifies how the webhook authenticates with GCP.
    pub auth_method: std::option::Option<crate::model::webhook_config::AuthMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebhookConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::WebhookConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::webhook_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [auth_method][crate::model::WebhookConfig::auth_method].
    ///
    /// Note that all the setters affecting `auth_method` are mutually
    /// exclusive.
    pub fn set_auth_method<
        T: std::convert::Into<std::option::Option<crate::model::webhook_config::AuthMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_method = v.into();
        self
    }

    /// The value of [auth_method][crate::model::WebhookConfig::auth_method]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.auth_method.as_ref().and_then(|v| match v {
            crate::model::webhook_config::AuthMethod::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [auth_method][crate::model::WebhookConfig::auth_method]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `auth_method` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.auth_method =
            std::option::Option::Some(crate::model::webhook_config::AuthMethod::Secret(v.into()));
        self
    }
}

impl wkt::message::Message for WebhookConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.WebhookConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebhookConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secret" => Ok(__FieldTag::__secret),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebhookConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.auth_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `auth_method`, a oneof with full ID .google.devtools.cloudbuild.v1.WebhookConfig.secret, latest field was secret",
                                ));
                            }
                            result.auth_method = std::option::Option::Some(
                                crate::model::webhook_config::AuthMethod::Secret(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::webhook_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WebhookConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.secret() {
            state.serialize_entry("secret", value)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WebhookConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebhookConfig");
        debug_struct.field("state", &self.state);
        debug_struct.field("auth_method", &self.auth_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WebhookConfig].
pub mod webhook_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates potential issues with the Secret Manager secret provided by the
    /// user.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The webhook auth configuration not been checked.
        Unspecified,
        /// The auth configuration is properly setup.
        Ok,
        /// The secret provided in auth_method has been deleted.
        SecretDeleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::SecretDeleted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::SecretDeleted => std::option::Option::Some("SECRET_DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::SecretDeleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "SECRET_DELETED" => Self::SecretDeleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::SecretDeleted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.WebhookConfig.State",
            ))
        }
    }

    /// Auth method specifies how the webhook authenticates with GCP.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthMethod {
        /// Required. Resource name for the secret required as a URL parameter.
        Secret(std::string::String),
    }
}

/// PullRequestFilter contains filter properties for matching GitHub Pull
/// Requests.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PullRequestFilter {
    /// If CommentControl is enabled, depending on the setting, builds may not
    /// fire until a repository writer comments `/gcbrun` on a pull
    /// request or `/gcbrun` is in the pull request description.
    /// Only PR comments that contain `/gcbrun` will trigger builds.
    ///
    /// If CommentControl is set to disabled, comments with `/gcbrun` from a user
    /// with repository write permission or above will
    /// still trigger builds to run.
    pub comment_control: crate::model::pull_request_filter::CommentControl,

    /// If true, branches that do NOT match the git_ref will trigger a build.
    pub invert_regex: bool,

    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    pub git_ref: std::option::Option<crate::model::pull_request_filter::GitRef>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PullRequestFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [comment_control][crate::model::PullRequestFilter::comment_control].
    pub fn set_comment_control<
        T: std::convert::Into<crate::model::pull_request_filter::CommentControl>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.comment_control = v.into();
        self
    }

    /// Sets the value of [invert_regex][crate::model::PullRequestFilter::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [git_ref][crate::model::PullRequestFilter::git_ref].
    ///
    /// Note that all the setters affecting `git_ref` are mutually
    /// exclusive.
    pub fn set_git_ref<
        T: std::convert::Into<std::option::Option<crate::model::pull_request_filter::GitRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.git_ref = v.into();
        self
    }

    /// The value of [git_ref][crate::model::PullRequestFilter::git_ref]
    /// if it holds a `Branch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::pull_request_filter::GitRef::Branch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PullRequestFilter::git_ref]
    /// to hold a `Branch`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref =
            std::option::Option::Some(crate::model::pull_request_filter::GitRef::Branch(v.into()));
        self
    }
}

impl wkt::message::Message for PullRequestFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PullRequestFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PullRequestFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __branch,
            __comment_control,
            __invert_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PullRequestFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "branch" => Ok(__FieldTag::__branch),
                            "commentControl" => Ok(__FieldTag::__comment_control),
                            "comment_control" => Ok(__FieldTag::__comment_control),
                            "invertRegex" => Ok(__FieldTag::__invert_regex),
                            "invert_regex" => Ok(__FieldTag::__invert_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PullRequestFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PullRequestFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__branch => {
                            if !fields.insert(__FieldTag::__branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch",
                                ));
                            }
                            if result.git_ref.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `git_ref`, a oneof with full ID .google.devtools.cloudbuild.v1.PullRequestFilter.branch, latest field was branch",
                                ));
                            }
                            result.git_ref = std::option::Option::Some(
                                crate::model::pull_request_filter::GitRef::Branch(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__comment_control => {
                            if !fields.insert(__FieldTag::__comment_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment_control",
                                ));
                            }
                            result.comment_control = map
                                .next_value::<std::option::Option<
                                    crate::model::pull_request_filter::CommentControl,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invert_regex => {
                            if !fields.insert(__FieldTag::__invert_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invert_regex",
                                ));
                            }
                            result.invert_regex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PullRequestFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.branch() {
            state.serialize_entry("branch", value)?;
        }
        if !wkt::internal::is_default(&self.comment_control) {
            state.serialize_entry("commentControl", &self.comment_control)?;
        }
        if !wkt::internal::is_default(&self.invert_regex) {
            state.serialize_entry("invertRegex", &self.invert_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PullRequestFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PullRequestFilter");
        debug_struct.field("comment_control", &self.comment_control);
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("git_ref", &self.git_ref);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PullRequestFilter].
pub mod pull_request_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Controls whether or not a `/gcbrun` comment is required from a user with
    /// repository write permission or above in order to
    /// trigger Build runs for pull requests. Pull Request update events differ
    /// between repo types.
    /// Check repo specific guides
    /// ([GitHub](https://cloud.google.com/build/docs/automating-builds/github/build-repos-from-github-enterprise#creating_a_github_enterprise_trigger),
    /// [Bitbucket](https://cloud.google.com/build/docs/automating-builds/bitbucket/build-repos-from-bitbucket-server#creating_a_bitbucket_server_trigger),
    /// [GitLab](https://cloud.google.com/build/docs/automating-builds/gitlab/build-repos-from-gitlab#creating_a_gitlab_trigger)
    /// for details.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommentControl {
        /// Do not require `/gcbrun` comments from a user with repository write
        /// permission or above on pull requests before builds are triggered.
        /// Comments that contain `/gcbrun` will still fire builds so this should
        /// be thought of as comments not required.
        CommentsDisabled,
        /// Builds will only fire in response to pull requests if:
        ///
        /// 1. The pull request author has repository write permission or above and
        ///    `/gcbrun` is in the PR description.
        /// 1. A user with repository writer permissions or above comments `/gcbrun`
        ///    on a pull request authored by any user.
        CommentsEnabled,
        /// Builds will only fire in response to pull requests if:
        ///
        /// 1. The pull request author is a repository writer or above.
        /// 1. If the author does not have write permissions, a user with write
        ///    permissions or above must comment `/gcbrun` in order to fire a build.
        CommentsEnabledForExternalContributorsOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommentControl::value] or
        /// [CommentControl::name].
        UnknownValue(comment_control::UnknownValue),
    }

    #[doc(hidden)]
    pub mod comment_control {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommentControl {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::CommentsDisabled => std::option::Option::Some(0),
                Self::CommentsEnabled => std::option::Option::Some(1),
                Self::CommentsEnabledForExternalContributorsOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::CommentsDisabled => std::option::Option::Some("COMMENTS_DISABLED"),
                Self::CommentsEnabled => std::option::Option::Some("COMMENTS_ENABLED"),
                Self::CommentsEnabledForExternalContributorsOnly => {
                    std::option::Option::Some("COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommentControl {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommentControl {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommentControl {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::CommentsDisabled,
                1 => Self::CommentsEnabled,
                2 => Self::CommentsEnabledForExternalContributorsOnly,
                _ => Self::UnknownValue(comment_control::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommentControl {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMENTS_DISABLED" => Self::CommentsDisabled,
                "COMMENTS_ENABLED" => Self::CommentsEnabled,
                "COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY" => {
                    Self::CommentsEnabledForExternalContributorsOnly
                }
                _ => Self::UnknownValue(comment_control::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommentControl {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::CommentsDisabled => serializer.serialize_i32(0),
                Self::CommentsEnabled => serializer.serialize_i32(1),
                Self::CommentsEnabledForExternalContributorsOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommentControl {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommentControl>::new(
                ".google.devtools.cloudbuild.v1.PullRequestFilter.CommentControl",
            ))
        }
    }

    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GitRef {
        /// Regex of branches to match.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Branch(std::string::String),
    }
}

/// Push contains filter properties for matching GitHub git pushes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PushFilter {
    /// When true, only trigger a build if the revision regex does NOT match the
    /// git_ref regex.
    pub invert_regex: bool,

    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    pub git_ref: std::option::Option<crate::model::push_filter::GitRef>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PushFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [invert_regex][crate::model::PushFilter::invert_regex].
    pub fn set_invert_regex<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invert_regex = v.into();
        self
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref].
    ///
    /// Note that all the setters affecting `git_ref` are mutually
    /// exclusive.
    pub fn set_git_ref<
        T: std::convert::Into<std::option::Option<crate::model::push_filter::GitRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.git_ref = v.into();
        self
    }

    /// The value of [git_ref][crate::model::PushFilter::git_ref]
    /// if it holds a `Branch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn branch(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::push_filter::GitRef::Branch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref]
    /// to hold a `Branch`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref =
            std::option::Option::Some(crate::model::push_filter::GitRef::Branch(v.into()));
        self
    }

    /// The value of [git_ref][crate::model::PushFilter::git_ref]
    /// if it holds a `Tag`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tag(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.git_ref.as_ref().and_then(|v| match v {
            crate::model::push_filter::GitRef::Tag(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [git_ref][crate::model::PushFilter::git_ref]
    /// to hold a `Tag`.
    ///
    /// Note that all the setters affecting `git_ref` are
    /// mutually exclusive.
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_ref = std::option::Option::Some(crate::model::push_filter::GitRef::Tag(v.into()));
        self
    }
}

impl wkt::message::Message for PushFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PushFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PushFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __branch,
            __tag,
            __invert_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PushFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "branch" => Ok(__FieldTag::__branch),
                            "tag" => Ok(__FieldTag::__tag),
                            "invertRegex" => Ok(__FieldTag::__invert_regex),
                            "invert_regex" => Ok(__FieldTag::__invert_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PushFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PushFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__branch => {
                            if !fields.insert(__FieldTag::__branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch",
                                ));
                            }
                            if result.git_ref.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `git_ref`, a oneof with full ID .google.devtools.cloudbuild.v1.PushFilter.branch, latest field was branch",
                                ));
                            }
                            result.git_ref = std::option::Option::Some(
                                crate::model::push_filter::GitRef::Branch(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            if result.git_ref.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `git_ref`, a oneof with full ID .google.devtools.cloudbuild.v1.PushFilter.tag, latest field was tag",
                                ));
                            }
                            result.git_ref =
                                std::option::Option::Some(crate::model::push_filter::GitRef::Tag(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__invert_regex => {
                            if !fields.insert(__FieldTag::__invert_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invert_regex",
                                ));
                            }
                            result.invert_regex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PushFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.branch() {
            state.serialize_entry("branch", value)?;
        }
        if let Some(value) = self.tag() {
            state.serialize_entry("tag", value)?;
        }
        if !wkt::internal::is_default(&self.invert_regex) {
            state.serialize_entry("invertRegex", &self.invert_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PushFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PushFilter");
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("git_ref", &self.git_ref);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PushFilter].
pub mod push_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GitRef {
        /// Regexes matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Branch(std::string::String),
        /// Regexes matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        Tag(std::string::String),
    }
}

/// Request to create a new `BuildTrigger`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBuildTriggerRequest {
    /// The parent resource where this trigger will be created.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. ID of the project for which to configure automatic builds.
    pub project_id: std::string::String,

    /// Required. `BuildTrigger` to create.
    pub trigger: std::option::Option<crate::model::BuildTrigger>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBuildTriggerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::CreateBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::CreateBuildTriggerRequest::trigger].
    pub fn set_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger][crate::model::CreateBuildTriggerRequest::trigger].
    pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateBuildTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __trigger,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "trigger" => Ok(__FieldTag::__trigger),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<crate::model::BuildTrigger>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBuildTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.trigger.is_some() {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBuildTriggerRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger", &self.trigger);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Returns the `BuildTrigger` with the specified ID.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBuildTriggerRequest {
    /// The name of the `Trigger` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    pub name: std::string::String,

    /// Required. ID of the project that owns the trigger.
    pub project_id: std::string::String,

    /// Required. Identifier (`id` or `name`) of the `BuildTrigger` to get.
    pub trigger_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::GetBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for GetBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetBuildTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __trigger_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBuildTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBuildTriggerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list existing `BuildTriggers`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBuildTriggersRequest {
    /// The parent of the collection of `Triggers`.
    /// Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. ID of the project for which to list BuildTriggers.
    pub project_id: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Token to provide to skip to a particular spot in the list.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildTriggersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBuildTriggersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ListBuildTriggersRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBuildTriggersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBuildTriggersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildTriggersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildTriggersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBuildTriggersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildTriggersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBuildTriggersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildTriggersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBuildTriggersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBuildTriggersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildTriggersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response containing existing `BuildTriggers`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBuildTriggersResponse {
    /// `BuildTriggers` for the project, sorted by `create_time` descending.
    pub triggers: std::vec::Vec<crate::model::BuildTrigger>,

    /// Token to receive the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBuildTriggersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [triggers][crate::model::ListBuildTriggersResponse::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildTrigger>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBuildTriggersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBuildTriggersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListBuildTriggersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBuildTriggersResponse {
    type PageItem = crate::model::BuildTrigger;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.triggers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBuildTriggersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __triggers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildTriggersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "triggers" => Ok(__FieldTag::__triggers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBuildTriggersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildTriggersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__triggers => {
                            if !fields.insert(__FieldTag::__triggers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggers",
                                ));
                            }
                            result.triggers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuildTrigger>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBuildTriggersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.triggers.is_empty() {
            state.serialize_entry("triggers", &self.triggers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBuildTriggersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildTriggersResponse");
        debug_struct.field("triggers", &self.triggers);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a `BuildTrigger`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBuildTriggerRequest {
    /// The name of the `Trigger` to delete.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    pub name: std::string::String,

    /// Required. ID of the project that owns the trigger.
    pub project_id: std::string::String,

    /// Required. ID of the `BuildTrigger` to delete.
    pub trigger_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBuildTriggerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DeleteBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::DeleteBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteBuildTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __trigger_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBuildTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBuildTriggerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to update an existing `BuildTrigger`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBuildTriggerRequest {
    /// Required. ID of the project that owns the trigger.
    pub project_id: std::string::String,

    /// Required. ID of the `BuildTrigger` to update.
    pub trigger_id: std::string::String,

    /// Required. `BuildTrigger` to update.
    pub trigger: std::option::Option<crate::model::BuildTrigger>,

    /// Update mask for the resource. If this is set,
    /// the server will only update the fields specified in the field mask.
    /// Otherwise, a full update of the mutable resource fields will be performed.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBuildTriggerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateBuildTriggerRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger_id][crate::model::UpdateBuildTriggerRequest::trigger_id].
    pub fn set_trigger_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::UpdateBuildTriggerRequest::trigger].
    pub fn set_trigger<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger][crate::model::UpdateBuildTriggerRequest::trigger].
    pub fn set_or_clear_trigger<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildTrigger>,
    {
        self.trigger = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBuildTriggerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBuildTriggerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBuildTriggerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateBuildTriggerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __trigger_id,
            __trigger,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<crate::model::BuildTrigger>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBuildTriggerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.trigger_id.is_empty() {
            state.serialize_entry("triggerId", &self.trigger_id)?;
        }
        if self.trigger.is_some() {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBuildTriggerRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        debug_struct.field("trigger", &self.trigger);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Optional arguments to enable specific features of builds.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildOptions {
    /// Requested hash for SourceProvenance.
    pub source_provenance_hash: std::vec::Vec<crate::model::hash::HashType>,

    /// Requested verifiability options.
    pub requested_verify_option: crate::model::build_options::VerifyOption,

    /// Compute Engine machine type on which to run the build.
    pub machine_type: crate::model::build_options::MachineType,

    /// Requested disk size for the VM that runs the build. Note that this is *NOT*
    /// "disk free"; some of the space will be used by the operating system and
    /// build utilities. Also note that this is the minimum disk size that will be
    /// allocated for the build -- the build may run with a larger disk than
    /// requested. At present, the maximum disk size is 4000GB; builds that request
    /// more than the maximum are rejected with an error.
    pub disk_size_gb: i64,

    /// Option to specify behavior when there is an error in the substitution
    /// checks.
    ///
    /// NOTE: this is always set to ALLOW_LOOSE for triggered builds and cannot
    /// be overridden in the build configuration file.
    pub substitution_option: crate::model::build_options::SubstitutionOption,

    /// Option to specify whether or not to apply bash style string
    /// operations to the substitutions.
    ///
    /// NOTE: this is always enabled for triggered builds and cannot be
    /// overridden in the build configuration file.
    pub dynamic_substitutions: bool,

    /// Option to include built-in and custom substitutions as env variables
    /// for all build steps.
    pub automap_substitutions: bool,

    /// Option to define build log streaming behavior to Cloud
    /// Storage.
    pub log_streaming_option: crate::model::build_options::LogStreamingOption,

    /// This field deprecated; please use `pool.name` instead.
    #[deprecated]
    pub worker_pool: std::string::String,

    /// Optional. Specification for execution on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool)
    /// for more information.
    pub pool: std::option::Option<crate::model::build_options::PoolOption>,

    /// Option to specify the logging mode, which determines if and where build
    /// logs are stored.
    pub logging: crate::model::build_options::LoggingMode,

    /// A list of global environment variable definitions that will exist for all
    /// build steps in this build. If a variable is defined in both globally and in
    /// a build step, the variable will use the build step value.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    pub env: std::vec::Vec<std::string::String>,

    /// A list of global environment variables, which are encrypted using a Cloud
    /// Key Management Service crypto key. These values must be specified in the
    /// build's `Secret`. These variables will be available to all build steps
    /// in this build.
    pub secret_env: std::vec::Vec<std::string::String>,

    /// Global list of volumes to mount for ALL build steps
    ///
    /// Each volume is created as an empty volume prior to starting the build
    /// process. Upon completion of the build, volumes and their contents are
    /// discarded. Global volume names and paths cannot conflict with the volumes
    /// defined a build step.
    ///
    /// Using a global volume in a build with only one step is not valid as
    /// it is indicative of a build request with an incorrect configuration.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. Option to specify how default logs buckets are setup.
    pub default_logs_bucket_behavior: crate::model::build_options::DefaultLogsBucketBehavior,

    /// Optional. Option to specify whether structured logging is enabled.
    ///
    /// If true, JSON-formatted logs are parsed as structured logs.
    pub enable_structured_logging: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_provenance_hash][crate::model::BuildOptions::source_provenance_hash].
    pub fn set_source_provenance_hash<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::hash::HashType>,
    {
        use std::iter::Iterator;
        self.source_provenance_hash = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [requested_verify_option][crate::model::BuildOptions::requested_verify_option].
    pub fn set_requested_verify_option<
        T: std::convert::Into<crate::model::build_options::VerifyOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_verify_option = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::BuildOptions::machine_type].
    pub fn set_machine_type<T: std::convert::Into<crate::model::build_options::MachineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::BuildOptions::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [substitution_option][crate::model::BuildOptions::substitution_option].
    pub fn set_substitution_option<
        T: std::convert::Into<crate::model::build_options::SubstitutionOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.substitution_option = v.into();
        self
    }

    /// Sets the value of [dynamic_substitutions][crate::model::BuildOptions::dynamic_substitutions].
    pub fn set_dynamic_substitutions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dynamic_substitutions = v.into();
        self
    }

    /// Sets the value of [automap_substitutions][crate::model::BuildOptions::automap_substitutions].
    pub fn set_automap_substitutions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.automap_substitutions = v.into();
        self
    }

    /// Sets the value of [log_streaming_option][crate::model::BuildOptions::log_streaming_option].
    pub fn set_log_streaming_option<
        T: std::convert::Into<crate::model::build_options::LogStreamingOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_streaming_option = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::BuildOptions::worker_pool].
    #[deprecated]
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [pool][crate::model::BuildOptions::pool].
    pub fn set_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::build_options::PoolOption>,
    {
        self.pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pool][crate::model::BuildOptions::pool].
    pub fn set_or_clear_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::build_options::PoolOption>,
    {
        self.pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging][crate::model::BuildOptions::logging].
    pub fn set_logging<T: std::convert::Into<crate::model::build_options::LoggingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.logging = v.into();
        self
    }

    /// Sets the value of [env][crate::model::BuildOptions::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secret_env][crate::model::BuildOptions::secret_env].
    pub fn set_secret_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::BuildOptions::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_logs_bucket_behavior][crate::model::BuildOptions::default_logs_bucket_behavior].
    pub fn set_default_logs_bucket_behavior<
        T: std::convert::Into<crate::model::build_options::DefaultLogsBucketBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_logs_bucket_behavior = v.into();
        self
    }

    /// Sets the value of [enable_structured_logging][crate::model::BuildOptions::enable_structured_logging].
    pub fn set_enable_structured_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_structured_logging = v.into();
        self
    }
}

impl wkt::message::Message for BuildOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_provenance_hash,
            __requested_verify_option,
            __machine_type,
            __disk_size_gb,
            __substitution_option,
            __dynamic_substitutions,
            __automap_substitutions,
            __log_streaming_option,
            __worker_pool,
            __pool,
            __logging,
            __env,
            __secret_env,
            __volumes,
            __default_logs_bucket_behavior,
            __enable_structured_logging,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceProvenanceHash" => Ok(__FieldTag::__source_provenance_hash),
                            "source_provenance_hash" => Ok(__FieldTag::__source_provenance_hash),
                            "requestedVerifyOption" => Ok(__FieldTag::__requested_verify_option),
                            "requested_verify_option" => Ok(__FieldTag::__requested_verify_option),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "substitutionOption" => Ok(__FieldTag::__substitution_option),
                            "substitution_option" => Ok(__FieldTag::__substitution_option),
                            "dynamicSubstitutions" => Ok(__FieldTag::__dynamic_substitutions),
                            "dynamic_substitutions" => Ok(__FieldTag::__dynamic_substitutions),
                            "automapSubstitutions" => Ok(__FieldTag::__automap_substitutions),
                            "automap_substitutions" => Ok(__FieldTag::__automap_substitutions),
                            "logStreamingOption" => Ok(__FieldTag::__log_streaming_option),
                            "log_streaming_option" => Ok(__FieldTag::__log_streaming_option),
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "pool" => Ok(__FieldTag::__pool),
                            "logging" => Ok(__FieldTag::__logging),
                            "env" => Ok(__FieldTag::__env),
                            "secretEnv" => Ok(__FieldTag::__secret_env),
                            "secret_env" => Ok(__FieldTag::__secret_env),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "defaultLogsBucketBehavior" => {
                                Ok(__FieldTag::__default_logs_bucket_behavior)
                            }
                            "default_logs_bucket_behavior" => {
                                Ok(__FieldTag::__default_logs_bucket_behavior)
                            }
                            "enableStructuredLogging" => {
                                Ok(__FieldTag::__enable_structured_logging)
                            }
                            "enable_structured_logging" => {
                                Ok(__FieldTag::__enable_structured_logging)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_provenance_hash => {
                            if !fields.insert(__FieldTag::__source_provenance_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_provenance_hash",
                                ));
                            }
                            result.source_provenance_hash =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::hash::HashType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_verify_option => {
                            if !fields.insert(__FieldTag::__requested_verify_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_verify_option",
                                ));
                            }
                            result.requested_verify_option = map.next_value::<std::option::Option<crate::model::build_options::VerifyOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map.next_value::<std::option::Option<crate::model::build_options::MachineType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__substitution_option => {
                            if !fields.insert(__FieldTag::__substitution_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitution_option",
                                ));
                            }
                            result.substitution_option = map
                                .next_value::<std::option::Option<
                                    crate::model::build_options::SubstitutionOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dynamic_substitutions => {
                            if !fields.insert(__FieldTag::__dynamic_substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dynamic_substitutions",
                                ));
                            }
                            result.dynamic_substitutions = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automap_substitutions => {
                            if !fields.insert(__FieldTag::__automap_substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automap_substitutions",
                                ));
                            }
                            result.automap_substitutions = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_streaming_option => {
                            if !fields.insert(__FieldTag::__log_streaming_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_streaming_option",
                                ));
                            }
                            result.log_streaming_option = map
                                .next_value::<std::option::Option<
                                    crate::model::build_options::LogStreamingOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pool => {
                            if !fields.insert(__FieldTag::__pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pool",
                                ));
                            }
                            result.pool = map.next_value::<std::option::Option<crate::model::build_options::PoolOption>>()?
                                ;
                        }
                        __FieldTag::__logging => {
                            if !fields.insert(__FieldTag::__logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging",
                                ));
                            }
                            result.logging = map.next_value::<std::option::Option<crate::model::build_options::LoggingMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__secret_env => {
                            if !fields.insert(__FieldTag::__secret_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_env",
                                ));
                            }
                            result.secret_env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_logs_bucket_behavior => {
                            if !fields.insert(__FieldTag::__default_logs_bucket_behavior) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_logs_bucket_behavior",
                                ));
                            }
                            result.default_logs_bucket_behavior = map
                                .next_value::<std::option::Option<
                                    crate::model::build_options::DefaultLogsBucketBehavior,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_structured_logging => {
                            if !fields.insert(__FieldTag::__enable_structured_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_structured_logging",
                                ));
                            }
                            result.enable_structured_logging = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_provenance_hash.is_empty() {
            state.serialize_entry("sourceProvenanceHash", &self.source_provenance_hash)?;
        }
        if !wkt::internal::is_default(&self.requested_verify_option) {
            state.serialize_entry("requestedVerifyOption", &self.requested_verify_option)?;
        }
        if !wkt::internal::is_default(&self.machine_type) {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !wkt::internal::is_default(&self.substitution_option) {
            state.serialize_entry("substitutionOption", &self.substitution_option)?;
        }
        if !wkt::internal::is_default(&self.dynamic_substitutions) {
            state.serialize_entry("dynamicSubstitutions", &self.dynamic_substitutions)?;
        }
        if !wkt::internal::is_default(&self.automap_substitutions) {
            state.serialize_entry("automapSubstitutions", &self.automap_substitutions)?;
        }
        if !wkt::internal::is_default(&self.log_streaming_option) {
            state.serialize_entry("logStreamingOption", &self.log_streaming_option)?;
        }
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if self.pool.is_some() {
            state.serialize_entry("pool", &self.pool)?;
        }
        if !wkt::internal::is_default(&self.logging) {
            state.serialize_entry("logging", &self.logging)?;
        }
        if !self.env.is_empty() {
            state.serialize_entry("env", &self.env)?;
        }
        if !self.secret_env.is_empty() {
            state.serialize_entry("secretEnv", &self.secret_env)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !wkt::internal::is_default(&self.default_logs_bucket_behavior) {
            state.serialize_entry(
                "defaultLogsBucketBehavior",
                &self.default_logs_bucket_behavior,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_structured_logging) {
            state.serialize_entry("enableStructuredLogging", &self.enable_structured_logging)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuildOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildOptions");
        debug_struct.field("source_provenance_hash", &self.source_provenance_hash);
        debug_struct.field("requested_verify_option", &self.requested_verify_option);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("substitution_option", &self.substitution_option);
        debug_struct.field("dynamic_substitutions", &self.dynamic_substitutions);
        debug_struct.field("automap_substitutions", &self.automap_substitutions);
        debug_struct.field("log_streaming_option", &self.log_streaming_option);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("pool", &self.pool);
        debug_struct.field("logging", &self.logging);
        debug_struct.field("env", &self.env);
        debug_struct.field("secret_env", &self.secret_env);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field(
            "default_logs_bucket_behavior",
            &self.default_logs_bucket_behavior,
        );
        debug_struct.field("enable_structured_logging", &self.enable_structured_logging);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BuildOptions].
pub mod build_options {
    #[allow(unused_imports)]
    use super::*;

    /// Details about how a build should be executed on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool)
    /// for more information.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PoolOption {
        /// The `WorkerPool` resource to execute the build on.
        /// You must have `cloudbuild.workerpools.use` on the project hosting the
        /// WorkerPool.
        ///
        /// Format projects/{project}/locations/{location}/workerPools/{workerPoolId}
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PoolOption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::build_options::PoolOption::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for PoolOption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.BuildOptions.PoolOption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PoolOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PoolOption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PoolOption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PoolOption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PoolOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PoolOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PoolOption");
            debug_struct.field("name", &self.name);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Specifies the manner in which the build should be verified, if at all.
    ///
    /// If a verified build is requested, and any part of the process to generate
    /// and upload provenance fails, the build will also fail.
    ///
    /// If the build does not request verification then that process may occur, but
    /// is not guaranteed to. If it does occur and fails, the build will not fail.
    ///
    /// For more information, see [Viewing Build
    /// Provenance](https://cloud.google.com/build/docs/securing-builds/view-build-provenance).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VerifyOption {
        /// Not a verifiable build (the default).
        NotVerified,
        /// Build must be verified.
        Verified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VerifyOption::value] or
        /// [VerifyOption::name].
        UnknownValue(verify_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod verify_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VerifyOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NotVerified => std::option::Option::Some(0),
                Self::Verified => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NotVerified => std::option::Option::Some("NOT_VERIFIED"),
                Self::Verified => std::option::Option::Some("VERIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VerifyOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VerifyOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VerifyOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NotVerified,
                1 => Self::Verified,
                _ => Self::UnknownValue(verify_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VerifyOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NOT_VERIFIED" => Self::NotVerified,
                "VERIFIED" => Self::Verified,
                _ => Self::UnknownValue(verify_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VerifyOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NotVerified => serializer.serialize_i32(0),
                Self::Verified => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VerifyOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VerifyOption>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.VerifyOption",
            ))
        }
    }

    /// Supported Compute Engine machine types.
    /// For more information, see [Machine
    /// types](https://cloud.google.com/compute/docs/machine-types).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MachineType {
        /// Standard machine type.
        Unspecified,
        /// Highcpu machine with 8 CPUs.
        N1Highcpu8,
        /// Highcpu machine with 32 CPUs.
        N1Highcpu32,
        /// Highcpu e2 machine with 8 CPUs.
        E2Highcpu8,
        /// Highcpu e2 machine with 32 CPUs.
        E2Highcpu32,
        /// E2 machine with 1 CPU.
        E2Medium,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MachineType::value] or
        /// [MachineType::name].
        UnknownValue(machine_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod machine_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MachineType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::N1Highcpu8 => std::option::Option::Some(1),
                Self::N1Highcpu32 => std::option::Option::Some(2),
                Self::E2Highcpu8 => std::option::Option::Some(5),
                Self::E2Highcpu32 => std::option::Option::Some(6),
                Self::E2Medium => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::N1Highcpu8 => std::option::Option::Some("N1_HIGHCPU_8"),
                Self::N1Highcpu32 => std::option::Option::Some("N1_HIGHCPU_32"),
                Self::E2Highcpu8 => std::option::Option::Some("E2_HIGHCPU_8"),
                Self::E2Highcpu32 => std::option::Option::Some("E2_HIGHCPU_32"),
                Self::E2Medium => std::option::Option::Some("E2_MEDIUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MachineType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MachineType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MachineType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::N1Highcpu8,
                2 => Self::N1Highcpu32,
                5 => Self::E2Highcpu8,
                6 => Self::E2Highcpu32,
                7 => Self::E2Medium,
                _ => Self::UnknownValue(machine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MachineType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "N1_HIGHCPU_8" => Self::N1Highcpu8,
                "N1_HIGHCPU_32" => Self::N1Highcpu32,
                "E2_HIGHCPU_8" => Self::E2Highcpu8,
                "E2_HIGHCPU_32" => Self::E2Highcpu32,
                "E2_MEDIUM" => Self::E2Medium,
                _ => Self::UnknownValue(machine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MachineType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::N1Highcpu8 => serializer.serialize_i32(1),
                Self::N1Highcpu32 => serializer.serialize_i32(2),
                Self::E2Highcpu8 => serializer.serialize_i32(5),
                Self::E2Highcpu32 => serializer.serialize_i32(6),
                Self::E2Medium => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MachineType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MachineType>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.MachineType",
            ))
        }
    }

    /// Specifies the behavior when there is an error in the substitution checks.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SubstitutionOption {
        /// Fails the build if error in substitutions checks, like missing
        /// a substitution in the template or in the map.
        MustMatch,
        /// Do not fail the build if error in substitutions checks.
        AllowLoose,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SubstitutionOption::value] or
        /// [SubstitutionOption::name].
        UnknownValue(substitution_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod substitution_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SubstitutionOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::MustMatch => std::option::Option::Some(0),
                Self::AllowLoose => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::MustMatch => std::option::Option::Some("MUST_MATCH"),
                Self::AllowLoose => std::option::Option::Some("ALLOW_LOOSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SubstitutionOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SubstitutionOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SubstitutionOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::MustMatch,
                1 => Self::AllowLoose,
                _ => Self::UnknownValue(substitution_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SubstitutionOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MUST_MATCH" => Self::MustMatch,
                "ALLOW_LOOSE" => Self::AllowLoose,
                _ => Self::UnknownValue(substitution_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SubstitutionOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::MustMatch => serializer.serialize_i32(0),
                Self::AllowLoose => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SubstitutionOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SubstitutionOption>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.SubstitutionOption",
            ))
        }
    }

    /// Specifies the behavior when writing build logs to Cloud Storage.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogStreamingOption {
        /// Service may automatically determine build log streaming behavior.
        StreamDefault,
        /// Build logs should be streamed to Cloud Storage.
        StreamOn,
        /// Build logs should not be streamed to Cloud Storage; they will be
        /// written when the build is completed.
        StreamOff,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogStreamingOption::value] or
        /// [LogStreamingOption::name].
        UnknownValue(log_streaming_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod log_streaming_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LogStreamingOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::StreamDefault => std::option::Option::Some(0),
                Self::StreamOn => std::option::Option::Some(1),
                Self::StreamOff => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::StreamDefault => std::option::Option::Some("STREAM_DEFAULT"),
                Self::StreamOn => std::option::Option::Some("STREAM_ON"),
                Self::StreamOff => std::option::Option::Some("STREAM_OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LogStreamingOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LogStreamingOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LogStreamingOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::StreamDefault,
                1 => Self::StreamOn,
                2 => Self::StreamOff,
                _ => Self::UnknownValue(log_streaming_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LogStreamingOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STREAM_DEFAULT" => Self::StreamDefault,
                "STREAM_ON" => Self::StreamOn,
                "STREAM_OFF" => Self::StreamOff,
                _ => Self::UnknownValue(log_streaming_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LogStreamingOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::StreamDefault => serializer.serialize_i32(0),
                Self::StreamOn => serializer.serialize_i32(1),
                Self::StreamOff => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LogStreamingOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogStreamingOption>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.LogStreamingOption",
            ))
        }
    }

    /// Specifies the logging mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoggingMode {
        /// The service determines the logging mode. The default is `LEGACY`. Do not
        /// rely on the default logging behavior as it may change in the future.
        LoggingUnspecified,
        /// Build logs are stored in Cloud Logging and Cloud Storage.
        Legacy,
        /// Build logs are stored in Cloud Storage.
        GcsOnly,
        /// This option is the same as CLOUD_LOGGING_ONLY.
        #[deprecated]
        StackdriverOnly,
        /// Build logs are stored in Cloud Logging. Selecting this option will not
        /// allow [logs
        /// streaming](https://cloud.google.com/sdk/gcloud/reference/builds/log).
        CloudLoggingOnly,
        /// Turn off all logging. No build logs will be captured.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoggingMode::value] or
        /// [LoggingMode::name].
        UnknownValue(logging_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod logging_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoggingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::LoggingUnspecified => std::option::Option::Some(0),
                Self::Legacy => std::option::Option::Some(1),
                Self::GcsOnly => std::option::Option::Some(2),
                Self::StackdriverOnly => std::option::Option::Some(3),
                Self::CloudLoggingOnly => std::option::Option::Some(5),
                Self::None => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::LoggingUnspecified => std::option::Option::Some("LOGGING_UNSPECIFIED"),
                Self::Legacy => std::option::Option::Some("LEGACY"),
                Self::GcsOnly => std::option::Option::Some("GCS_ONLY"),
                Self::StackdriverOnly => std::option::Option::Some("STACKDRIVER_ONLY"),
                Self::CloudLoggingOnly => std::option::Option::Some("CLOUD_LOGGING_ONLY"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoggingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoggingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoggingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::LoggingUnspecified,
                1 => Self::Legacy,
                2 => Self::GcsOnly,
                3 => Self::StackdriverOnly,
                4 => Self::None,
                5 => Self::CloudLoggingOnly,
                _ => Self::UnknownValue(logging_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoggingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOGGING_UNSPECIFIED" => Self::LoggingUnspecified,
                "LEGACY" => Self::Legacy,
                "GCS_ONLY" => Self::GcsOnly,
                "STACKDRIVER_ONLY" => Self::StackdriverOnly,
                "CLOUD_LOGGING_ONLY" => Self::CloudLoggingOnly,
                "NONE" => Self::None,
                _ => Self::UnknownValue(logging_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoggingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::LoggingUnspecified => serializer.serialize_i32(0),
                Self::Legacy => serializer.serialize_i32(1),
                Self::GcsOnly => serializer.serialize_i32(2),
                Self::StackdriverOnly => serializer.serialize_i32(3),
                Self::CloudLoggingOnly => serializer.serialize_i32(5),
                Self::None => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoggingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoggingMode>::new(
                ".google.devtools.cloudbuild.v1.BuildOptions.LoggingMode",
            ))
        }
    }

    /// Default Cloud Storage log bucket behavior options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefaultLogsBucketBehavior {
        /// Unspecified.
        Unspecified,
        /// Bucket is located in user-owned project in the same region as the
        /// build. The builder service account must have access to create and write
        /// to Cloud Storage buckets in the build project.
        RegionalUserOwnedBucket,
        /// Bucket is located in a Google-owned project and is not regionalized.
        LegacyBucket,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DefaultLogsBucketBehavior::value] or
        /// [DefaultLogsBucketBehavior::name].
        UnknownValue(default_logs_bucket_behavior::UnknownValue),
    }

    #[doc(hidden)]
    pub mod default_logs_bucket_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DefaultLogsBucketBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RegionalUserOwnedBucket => std::option::Option::Some(1),
                Self::LegacyBucket => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED")
                }
                Self::RegionalUserOwnedBucket => {
                    std::option::Option::Some("REGIONAL_USER_OWNED_BUCKET")
                }
                Self::LegacyBucket => std::option::Option::Some("LEGACY_BUCKET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DefaultLogsBucketBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DefaultLogsBucketBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DefaultLogsBucketBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RegionalUserOwnedBucket,
                2 => Self::LegacyBucket,
                _ => Self::UnknownValue(default_logs_bucket_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DefaultLogsBucketBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "REGIONAL_USER_OWNED_BUCKET" => Self::RegionalUserOwnedBucket,
                "LEGACY_BUCKET" => Self::LegacyBucket,
                _ => Self::UnknownValue(default_logs_bucket_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DefaultLogsBucketBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RegionalUserOwnedBucket => serializer.serialize_i32(1),
                Self::LegacyBucket => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DefaultLogsBucketBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<DefaultLogsBucketBehavior>::new(
                    ".google.devtools.cloudbuild.v1.BuildOptions.DefaultLogsBucketBehavior",
                ),
            )
        }
    }
}

/// ReceiveTriggerWebhookRequest [Experimental] is the request object accepted by
/// the ReceiveTriggerWebhook method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReceiveTriggerWebhookRequest {
    /// The name of the `ReceiveTriggerWebhook` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    pub name: std::string::String,

    /// HTTP request body.
    pub body: std::option::Option<api::model::HttpBody>,

    /// Project in which the specified trigger lives
    pub project_id: std::string::String,

    /// Name of the trigger to run the payload against
    pub trigger: std::string::String,

    /// Secret token used for authorization if an OAuth token isn't provided.
    pub secret: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReceiveTriggerWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReceiveTriggerWebhookRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [body][crate::model::ReceiveTriggerWebhookRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::HttpBody>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::ReceiveTriggerWebhookRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::HttpBody>,
    {
        self.body = v.map(|x| x.into());
        self
    }

    /// Sets the value of [project_id][crate::model::ReceiveTriggerWebhookRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::ReceiveTriggerWebhookRequest::trigger].
    pub fn set_trigger<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::ReceiveTriggerWebhookRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }
}

impl wkt::message::Message for ReceiveTriggerWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ReceiveTriggerWebhookRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReceiveTriggerWebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __body,
            __project_id,
            __trigger,
            __secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReceiveTriggerWebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "body" => Ok(__FieldTag::__body),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "secret" => Ok(__FieldTag::__secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReceiveTriggerWebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReceiveTriggerWebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<api::model::HttpBody>>()?;
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReceiveTriggerWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.trigger.is_empty() {
            state.serialize_entry("trigger", &self.trigger)?;
        }
        if !self.secret.is_empty() {
            state.serialize_entry("secret", &self.secret)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReceiveTriggerWebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReceiveTriggerWebhookRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("body", &self.body);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger", &self.trigger);
        debug_struct.field("secret", &self.secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReceiveTriggerWebhookResponse [Experimental] is the response object for the
/// ReceiveTriggerWebhook method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReceiveTriggerWebhookResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReceiveTriggerWebhookResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReceiveTriggerWebhookResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ReceiveTriggerWebhookResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReceiveTriggerWebhookResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReceiveTriggerWebhookResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReceiveTriggerWebhookResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReceiveTriggerWebhookResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReceiveTriggerWebhookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReceiveTriggerWebhookResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReceiveTriggerWebhookResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GitHubEnterpriseConfig represents a configuration for a GitHub Enterprise
/// server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitHubEnterpriseConfig {
    /// Optional. The full resource name for the GitHubEnterpriseConfig
    /// For example:
    /// "projects/{$project_id}/locations/{$location_id}/githubEnterpriseConfigs/{$config_id}"
    pub name: std::string::String,

    /// The URL of the github enterprise host the configuration is for.
    pub host_url: std::string::String,

    /// Required. The GitHub app id of the Cloud Build app on the GitHub Enterprise
    /// server.
    pub app_id: i64,

    /// Output only. Time when the installation was associated with the project.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The key that should be attached to webhook calls to the ReceiveWebhook
    /// endpoint.
    pub webhook_key: std::string::String,

    /// Optional. The network to be used when reaching out to the GitHub
    /// Enterprise server. The VPC network must be enabled for private
    /// service connection. This should be set if the GitHub Enterprise server is
    /// hosted on-premises and not reachable by public internet.
    /// If this field is left empty, no network peering will occur and calls to
    /// the GitHub Enterprise server will be made over the public internet.
    /// Must be in the format
    /// `projects/{project}/global/networks/{network}`, where {project}
    /// is a project number or id and {network} is the name of a
    /// VPC network in the project.
    pub peered_network: std::string::String,

    /// Names of secrets in Secret Manager.
    pub secrets: std::option::Option<crate::model::GitHubEnterpriseSecrets>,

    /// Name to display for this config.
    pub display_name: std::string::String,

    /// Optional. SSL certificate to use for requests to GitHub Enterprise.
    pub ssl_ca: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GitHubEnterpriseConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [host_url][crate::model::GitHubEnterpriseConfig::host_url].
    pub fn set_host_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_url = v.into();
        self
    }

    /// Sets the value of [app_id][crate::model::GitHubEnterpriseConfig::app_id].
    pub fn set_app_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GitHubEnterpriseConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GitHubEnterpriseConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_key][crate::model::GitHubEnterpriseConfig::webhook_key].
    pub fn set_webhook_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_key = v.into();
        self
    }

    /// Sets the value of [peered_network][crate::model::GitHubEnterpriseConfig::peered_network].
    pub fn set_peered_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peered_network = v.into();
        self
    }

    /// Sets the value of [secrets][crate::model::GitHubEnterpriseConfig::secrets].
    pub fn set_secrets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEnterpriseSecrets>,
    {
        self.secrets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secrets][crate::model::GitHubEnterpriseConfig::secrets].
    pub fn set_or_clear_secrets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitHubEnterpriseSecrets>,
    {
        self.secrets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::GitHubEnterpriseConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [ssl_ca][crate::model::GitHubEnterpriseConfig::ssl_ca].
    pub fn set_ssl_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_ca = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEnterpriseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitHubEnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __host_url,
            __app_id,
            __create_time,
            __webhook_key,
            __peered_network,
            __secrets,
            __display_name,
            __ssl_ca,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "hostUrl" => Ok(__FieldTag::__host_url),
                            "host_url" => Ok(__FieldTag::__host_url),
                            "appId" => Ok(__FieldTag::__app_id),
                            "app_id" => Ok(__FieldTag::__app_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "webhookKey" => Ok(__FieldTag::__webhook_key),
                            "webhook_key" => Ok(__FieldTag::__webhook_key),
                            "peeredNetwork" => Ok(__FieldTag::__peered_network),
                            "peered_network" => Ok(__FieldTag::__peered_network),
                            "secrets" => Ok(__FieldTag::__secrets),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sslCa" => Ok(__FieldTag::__ssl_ca),
                            "ssl_ca" => Ok(__FieldTag::__ssl_ca),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitHubEnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_url => {
                            if !fields.insert(__FieldTag::__host_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_url",
                                ));
                            }
                            result.host_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_id => {
                            if !fields.insert(__FieldTag::__app_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.app_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__webhook_key => {
                            if !fields.insert(__FieldTag::__webhook_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_key",
                                ));
                            }
                            result.webhook_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peered_network => {
                            if !fields.insert(__FieldTag::__peered_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peered_network",
                                ));
                            }
                            result.peered_network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secrets => {
                            if !fields.insert(__FieldTag::__secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secrets",
                                ));
                            }
                            result.secrets = map.next_value::<std::option::Option<crate::model::GitHubEnterpriseSecrets>>()?
                                ;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_ca => {
                            if !fields.insert(__FieldTag::__ssl_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_ca",
                                ));
                            }
                            result.ssl_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitHubEnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.host_url.is_empty() {
            state.serialize_entry("hostUrl", &self.host_url)?;
        }
        if !wkt::internal::is_default(&self.app_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("appId", &__With(&self.app_id))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.webhook_key.is_empty() {
            state.serialize_entry("webhookKey", &self.webhook_key)?;
        }
        if !self.peered_network.is_empty() {
            state.serialize_entry("peeredNetwork", &self.peered_network)?;
        }
        if self.secrets.is_some() {
            state.serialize_entry("secrets", &self.secrets)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.ssl_ca.is_empty() {
            state.serialize_entry("sslCa", &self.ssl_ca)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitHubEnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEnterpriseConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("host_url", &self.host_url);
        debug_struct.field("app_id", &self.app_id);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("webhook_key", &self.webhook_key);
        debug_struct.field("peered_network", &self.peered_network);
        debug_struct.field("secrets", &self.secrets);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("ssl_ca", &self.ssl_ca);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GitHubEnterpriseSecrets represents the names of all necessary secrets in
/// Secret Manager for a GitHub Enterprise server.
/// Format is: projects/\<project number\>/secrets/\<secret name\>.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GitHubEnterpriseSecrets {
    /// The resource name for the private key secret version.
    pub private_key_version_name: std::string::String,

    /// The resource name for the webhook secret secret version in Secret Manager.
    pub webhook_secret_version_name: std::string::String,

    /// The resource name for the OAuth secret secret version in Secret Manager.
    pub oauth_secret_version_name: std::string::String,

    /// The resource name for the OAuth client ID secret version in Secret Manager.
    pub oauth_client_id_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseSecrets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key_version_name][crate::model::GitHubEnterpriseSecrets::private_key_version_name].
    pub fn set_private_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_key_version_name = v.into();
        self
    }

    /// Sets the value of [webhook_secret_version_name][crate::model::GitHubEnterpriseSecrets::webhook_secret_version_name].
    pub fn set_webhook_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_version_name = v.into();
        self
    }

    /// Sets the value of [oauth_secret_version_name][crate::model::GitHubEnterpriseSecrets::oauth_secret_version_name].
    pub fn set_oauth_secret_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_secret_version_name = v.into();
        self
    }

    /// Sets the value of [oauth_client_id_version_name][crate::model::GitHubEnterpriseSecrets::oauth_client_id_version_name].
    pub fn set_oauth_client_id_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_client_id_version_name = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseSecrets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GitHubEnterpriseSecrets"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitHubEnterpriseSecrets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_key_version_name,
            __webhook_secret_version_name,
            __oauth_secret_version_name,
            __oauth_client_id_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEnterpriseSecrets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateKeyVersionName" => Ok(__FieldTag::__private_key_version_name),
                            "private_key_version_name" => {
                                Ok(__FieldTag::__private_key_version_name)
                            }
                            "webhookSecretVersionName" => {
                                Ok(__FieldTag::__webhook_secret_version_name)
                            }
                            "webhook_secret_version_name" => {
                                Ok(__FieldTag::__webhook_secret_version_name)
                            }
                            "oauthSecretVersionName" => Ok(__FieldTag::__oauth_secret_version_name),
                            "oauth_secret_version_name" => {
                                Ok(__FieldTag::__oauth_secret_version_name)
                            }
                            "oauthClientIdVersionName" => {
                                Ok(__FieldTag::__oauth_client_id_version_name)
                            }
                            "oauth_client_id_version_name" => {
                                Ok(__FieldTag::__oauth_client_id_version_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitHubEnterpriseSecrets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEnterpriseSecrets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_key_version_name => {
                            if !fields.insert(__FieldTag::__private_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key_version_name",
                                ));
                            }
                            result.private_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_secret_version_name => {
                            if !fields.insert(__FieldTag::__webhook_secret_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_version_name",
                                ));
                            }
                            result.webhook_secret_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oauth_secret_version_name => {
                            if !fields.insert(__FieldTag::__oauth_secret_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_secret_version_name",
                                ));
                            }
                            result.oauth_secret_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oauth_client_id_version_name => {
                            if !fields.insert(__FieldTag::__oauth_client_id_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_client_id_version_name",
                                ));
                            }
                            result.oauth_client_id_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitHubEnterpriseSecrets {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_key_version_name.is_empty() {
            state.serialize_entry("privateKeyVersionName", &self.private_key_version_name)?;
        }
        if !self.webhook_secret_version_name.is_empty() {
            state.serialize_entry(
                "webhookSecretVersionName",
                &self.webhook_secret_version_name,
            )?;
        }
        if !self.oauth_secret_version_name.is_empty() {
            state.serialize_entry("oauthSecretVersionName", &self.oauth_secret_version_name)?;
        }
        if !self.oauth_client_id_version_name.is_empty() {
            state.serialize_entry(
                "oauthClientIdVersionName",
                &self.oauth_client_id_version_name,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GitHubEnterpriseSecrets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEnterpriseSecrets");
        debug_struct.field("private_key_version_name", &self.private_key_version_name);
        debug_struct.field(
            "webhook_secret_version_name",
            &self.webhook_secret_version_name,
        );
        debug_struct.field("oauth_secret_version_name", &self.oauth_secret_version_name);
        debug_struct.field(
            "oauth_client_id_version_name",
            &self.oauth_client_id_version_name,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for a `WorkerPool`.
///
/// Cloud Build owns and maintains a pool of workers for general use and have no
/// access to a project's private network. By default, builds submitted to
/// Cloud Build will use a worker from this pool.
///
/// If your build needs access to resources on a private network,
/// create and use a `WorkerPool` to run your builds. Private `WorkerPool`s give
/// your builds access to any single VPC network that you
/// administer, including any on-prem resources connected to that VPC
/// network. For an overview of private pools, see
/// [Private pools
/// overview](https://cloud.google.com/build/docs/private-pools/private-pools-overview).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkerPool {
    /// Output only. The resource name of the `WorkerPool`, with format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// The value of `{worker_pool}` is provided by `worker_pool_id` in
    /// `CreateWorkerPool` request and the value of `{location}` is determined by
    /// the endpoint accessed.
    pub name: std::string::String,

    /// A user-specified, human-readable name for the `WorkerPool`. If provided,
    /// this value must be 1-63 characters.
    pub display_name: std::string::String,

    /// Output only. A unique identifier for the `WorkerPool`.
    pub uid: std::string::String,

    /// User specified annotations. See <https://google.aip.dev/128#annotations>
    /// for more details such as format and size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the request to create the `WorkerPool` was
    /// received.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the request to update the `WorkerPool` was
    /// received.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the request to delete the `WorkerPool` was
    /// received.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `WorkerPool` state.
    pub state: crate::model::worker_pool::State,

    /// Output only. Checksum computed by the server. May be sent on update and
    /// delete requests to ensure that the client has an up-to-date value before
    /// proceeding.
    pub etag: std::string::String,

    /// Configuration for the `WorkerPool`.
    pub config: std::option::Option<crate::model::worker_pool::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkerPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkerPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkerPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkerPool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkerPool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkerPool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::WorkerPool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::WorkerPool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::WorkerPool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkerPool::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::WorkerPool::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::WorkerPool::state].
    pub fn set_state<T: std::convert::Into<crate::model::worker_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::WorkerPool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [config][crate::model::WorkerPool::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::worker_pool::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::WorkerPool::config]
    /// if it holds a `PrivatePoolV1Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_pool_v1_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivatePoolV1Config>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::worker_pool::Config::PrivatePoolV1Config(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::WorkerPool::config]
    /// to hold a `PrivatePoolV1Config`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_private_pool_v1_config<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivatePoolV1Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::worker_pool::Config::PrivatePoolV1Config(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkerPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.WorkerPool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkerPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __annotations,
            __create_time,
            __update_time,
            __delete_time,
            __state,
            __private_pool_v1_config,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkerPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "state" => Ok(__FieldTag::__state),
                            "privatePoolV1Config" => Ok(__FieldTag::__private_pool_v1_config),
                            "private_pool_v1_config" => Ok(__FieldTag::__private_pool_v1_config),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkerPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkerPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::worker_pool::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__private_pool_v1_config => {
                            if !fields.insert(__FieldTag::__private_pool_v1_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_pool_v1_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.devtools.cloudbuild.v1.WorkerPool.private_pool_v1_config, latest field was privatePoolV1Config",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::worker_pool::Config::PrivatePoolV1Config(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrivatePoolV1Config>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkerPool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.private_pool_v1_config() {
            state.serialize_entry("privatePoolV1Config", value)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WorkerPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerPool");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WorkerPool].
pub mod worker_pool {
    #[allow(unused_imports)]
    use super::*;

    /// State of the `WorkerPool`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State of the `WorkerPool` is unknown.
        Unspecified,
        /// `WorkerPool` is being created.
        Creating,
        /// `WorkerPool` is running.
        Running,
        /// `WorkerPool` is being deleted: cancelling builds and draining workers.
        Deleting,
        /// `WorkerPool` is deleted.
        Deleted,
        /// `WorkerPool` is being updated; new builds cannot be run.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Running,
                3 => Self::Deleting,
                4 => Self::Deleted,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "RUNNING" => Self::Running,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.devtools.cloudbuild.v1.WorkerPool.State",
            ))
        }
    }

    /// Configuration for the `WorkerPool`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Legacy Private Pool configuration.
        PrivatePoolV1Config(std::boxed::Box<crate::model::PrivatePoolV1Config>),
    }
}

/// Configuration for a V1 `PrivatePool`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivatePoolV1Config {
    /// Machine configuration for the workers in the pool.
    pub worker_config: std::option::Option<crate::model::private_pool_v_1_config::WorkerConfig>,

    /// Network configuration for the pool.
    pub network_config: std::option::Option<crate::model::private_pool_v_1_config::NetworkConfig>,

    /// Immutable. Private Service Connect(PSC) Network configuration for the pool.
    pub private_service_connect:
        std::option::Option<crate::model::private_pool_v_1_config::PrivateServiceConnect>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePoolV1Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_config][crate::model::PrivatePoolV1Config::worker_config].
    pub fn set_worker_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::WorkerConfig>,
    {
        self.worker_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_config][crate::model::PrivatePoolV1Config::worker_config].
    pub fn set_or_clear_worker_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::WorkerConfig>,
    {
        self.worker_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_config][crate::model::PrivatePoolV1Config::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::PrivatePoolV1Config::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_service_connect][crate::model::PrivatePoolV1Config::private_service_connect].
    pub fn set_private_service_connect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::PrivateServiceConnect>,
    {
        self.private_service_connect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_service_connect][crate::model::PrivatePoolV1Config::private_service_connect].
    pub fn set_or_clear_private_service_connect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::private_pool_v_1_config::PrivateServiceConnect>,
    {
        self.private_service_connect = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrivatePoolV1Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivatePoolV1Config {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_config,
            __network_config,
            __private_service_connect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivatePoolV1Config")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerConfig" => Ok(__FieldTag::__worker_config),
                            "worker_config" => Ok(__FieldTag::__worker_config),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "privateServiceConnect" => Ok(__FieldTag::__private_service_connect),
                            "private_service_connect" => Ok(__FieldTag::__private_service_connect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivatePoolV1Config;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivatePoolV1Config")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_config => {
                            if !fields.insert(__FieldTag::__worker_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_config",
                                ));
                            }
                            result.worker_config = map.next_value::<std::option::Option<
                                crate::model::private_pool_v_1_config::WorkerConfig,
                            >>()?;
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map.next_value::<std::option::Option<
                                crate::model::private_pool_v_1_config::NetworkConfig,
                            >>()?;
                        }
                        __FieldTag::__private_service_connect => {
                            if !fields.insert(__FieldTag::__private_service_connect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_service_connect",
                                ));
                            }
                            result.private_service_connect = map.next_value::<std::option::Option<
                                crate::model::private_pool_v_1_config::PrivateServiceConnect,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivatePoolV1Config {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.worker_config.is_some() {
            state.serialize_entry("workerConfig", &self.worker_config)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if self.private_service_connect.is_some() {
            state.serialize_entry("privateServiceConnect", &self.private_service_connect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivatePoolV1Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivatePoolV1Config");
        debug_struct.field("worker_config", &self.worker_config);
        debug_struct.field("network_config", &self.network_config);
        debug_struct.field("private_service_connect", &self.private_service_connect);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PrivatePoolV1Config].
pub mod private_pool_v_1_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the configuration to be used for creating workers in
    /// the pool.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WorkerConfig {
        /// Machine type of a worker, such as `e2-medium`.
        /// See [Worker pool config
        /// file](https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema).
        /// If left blank, Cloud Build will use a sensible default.
        pub machine_type: std::string::String,

        /// Size of the disk attached to the worker, in GB.
        /// See [Worker pool config
        /// file](https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema).
        /// Specify a value of up to 2000. If `0` is specified, Cloud Build will use
        /// a standard disk size.
        pub disk_size_gb: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WorkerConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::private_pool_v_1_config::WorkerConfig::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [disk_size_gb][crate::model::private_pool_v_1_config::WorkerConfig::disk_size_gb].
        pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.disk_size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for WorkerConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.WorkerConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WorkerConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __machine_type,
                __disk_size_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WorkerConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "machineType" => Ok(__FieldTag::__machine_type),
                                "machine_type" => Ok(__FieldTag::__machine_type),
                                "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                                "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WorkerConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WorkerConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__machine_type => {
                                if !fields.insert(__FieldTag::__machine_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_type",
                                    ));
                                }
                                result.machine_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__disk_size_gb => {
                                if !fields.insert(__FieldTag::__disk_size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disk_size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.disk_size_gb =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WorkerConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.machine_type.is_empty() {
                state.serialize_entry("machineType", &self.machine_type)?;
            }
            if !wkt::internal::is_default(&self.disk_size_gb) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WorkerConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WorkerConfig");
            debug_struct.field("machine_type", &self.machine_type);
            debug_struct.field("disk_size_gb", &self.disk_size_gb);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines the network configuration for the pool.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// Required. Immutable. The network definition that the workers are peered
        /// to. If this section is left empty, the workers will be peered to
        /// `WorkerPool.project_id` on the service producer network. Must be in the
        /// format `projects/{project}/global/networks/{network}`, where `{project}`
        /// is a project number, such as `12345`, and `{network}` is the name of a
        /// VPC network in the project. See
        /// [Understanding network configuration
        /// options](https://cloud.google.com/build/docs/private-pools/set-up-private-pool-environment)
        pub peered_network: std::string::String,

        /// Option to configure network egress for the workers.
        pub egress_option: crate::model::private_pool_v_1_config::network_config::EgressOption,

        /// Immutable. Subnet IP range within the peered network. This is specified
        /// in CIDR notation with a slash and the subnet prefix size. You can
        /// optionally specify an IP address before the subnet prefix value. e.g.
        /// `192.168.0.0/29` would specify an IP range starting at 192.168.0.0 with a
        /// prefix size of 29 bits.
        /// `/16` would specify a prefix size of 16 bits, with an automatically
        /// determined IP within the peered VPC.
        /// If unspecified, a value of `/24` will be used.
        pub peered_network_ip_range: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peered_network][crate::model::private_pool_v_1_config::NetworkConfig::peered_network].
        pub fn set_peered_network<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network = v.into();
            self
        }

        /// Sets the value of [egress_option][crate::model::private_pool_v_1_config::NetworkConfig::egress_option].
        pub fn set_egress_option<
            T: std::convert::Into<crate::model::private_pool_v_1_config::network_config::EgressOption>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.egress_option = v.into();
            self
        }

        /// Sets the value of [peered_network_ip_range][crate::model::private_pool_v_1_config::NetworkConfig::peered_network_ip_range].
        pub fn set_peered_network_ip_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network_ip_range = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.NetworkConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __peered_network,
                __egress_option,
                __peered_network_ip_range,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NetworkConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "peeredNetwork" => Ok(__FieldTag::__peered_network),
                                "peered_network" => Ok(__FieldTag::__peered_network),
                                "egressOption" => Ok(__FieldTag::__egress_option),
                                "egress_option" => Ok(__FieldTag::__egress_option),
                                "peeredNetworkIpRange" => Ok(__FieldTag::__peered_network_ip_range),
                                "peered_network_ip_range" => {
                                    Ok(__FieldTag::__peered_network_ip_range)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NetworkConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NetworkConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__peered_network => {
                                if !fields.insert(__FieldTag::__peered_network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for peered_network",
                                    ));
                                }
                                result.peered_network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__egress_option => {
                                if !fields.insert(__FieldTag::__egress_option) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for egress_option",
                                    ));
                                }
                                result.egress_option = map.next_value::<std::option::Option<crate::model::private_pool_v_1_config::network_config::EgressOption>>()?.unwrap_or_default();
                            }
                            __FieldTag::__peered_network_ip_range => {
                                if !fields.insert(__FieldTag::__peered_network_ip_range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for peered_network_ip_range",
                                    ));
                                }
                                result.peered_network_ip_range = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NetworkConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.peered_network.is_empty() {
                state.serialize_entry("peeredNetwork", &self.peered_network)?;
            }
            if !wkt::internal::is_default(&self.egress_option) {
                state.serialize_entry("egressOption", &self.egress_option)?;
            }
            if !self.peered_network_ip_range.is_empty() {
                state.serialize_entry("peeredNetworkIpRange", &self.peered_network_ip_range)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NetworkConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NetworkConfig");
            debug_struct.field("peered_network", &self.peered_network);
            debug_struct.field("egress_option", &self.egress_option);
            debug_struct.field("peered_network_ip_range", &self.peered_network_ip_range);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [NetworkConfig].
    pub mod network_config {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the egress option for the pool.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EgressOption {
            /// If set, defaults to PUBLIC_EGRESS.
            Unspecified,
            /// If set, workers are created without any public address, which prevents
            /// network egress to public IPs unless a network proxy is configured.
            NoPublicEgress,
            /// If set, workers are created with a public address which allows for
            /// public internet egress.
            PublicEgress,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EgressOption::value] or
            /// [EgressOption::name].
            UnknownValue(egress_option::UnknownValue),
        }

        #[doc(hidden)]
        pub mod egress_option {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EgressOption {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::NoPublicEgress => std::option::Option::Some(1),
                    Self::PublicEgress => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("EGRESS_OPTION_UNSPECIFIED"),
                    Self::NoPublicEgress => std::option::Option::Some("NO_PUBLIC_EGRESS"),
                    Self::PublicEgress => std::option::Option::Some("PUBLIC_EGRESS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EgressOption {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EgressOption {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EgressOption {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::NoPublicEgress,
                    2 => Self::PublicEgress,
                    _ => Self::UnknownValue(egress_option::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EgressOption {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "EGRESS_OPTION_UNSPECIFIED" => Self::Unspecified,
                    "NO_PUBLIC_EGRESS" => Self::NoPublicEgress,
                    "PUBLIC_EGRESS" => Self::PublicEgress,
                    _ => Self::UnknownValue(egress_option::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EgressOption {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::NoPublicEgress => serializer.serialize_i32(1),
                    Self::PublicEgress => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EgressOption {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EgressOption>::new(
                    ".google.devtools.cloudbuild.v1.PrivatePoolV1Config.NetworkConfig.EgressOption",
                ))
            }
        }
    }

    /// Defines the Private Service Connect network configuration for the pool.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrivateServiceConnect {
        /// Required. Immutable. The network attachment that the worker network
        /// interface is peered to. Must be in the format
        /// `projects/{project}/regions/{region}/networkAttachments/{networkAttachment}`.
        /// The region of network attachment must be the same as the worker pool.
        /// See [Network
        /// Attachments](https://cloud.google.com/vpc/docs/about-network-attachments)
        pub network_attachment: std::string::String,

        /// Required. Immutable. Disable public IP on the primary network interface.
        ///
        /// If true, workers are created without any public address, which prevents
        /// network egress to public IPs unless a network proxy is configured.
        /// If false, workers are created with a public address which allows for
        /// public internet egress. The public address only applies to traffic
        /// through the primary network interface.
        /// If `route_all_traffic` is set to true, all traffic will go through the
        /// non-primary network interface, this boolean has no effect.
        pub public_ip_address_disabled: bool,

        /// Immutable. Route all traffic through PSC interface. Enable this if you
        /// want full control of traffic in the private pool. Configure Cloud NAT for
        /// the subnet of network attachment if you need to access public Internet.
        ///
        /// If false, Only route RFC 1918 (10.0.0.0/8, 172.16.0.0/12, and
        /// 192.168.0.0/16) and RFC 6598 (100.64.0.0/10) through PSC interface.
        pub route_all_traffic: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrivateServiceConnect {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_attachment][crate::model::private_pool_v_1_config::PrivateServiceConnect::network_attachment].
        pub fn set_network_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_attachment = v.into();
            self
        }

        /// Sets the value of [public_ip_address_disabled][crate::model::private_pool_v_1_config::PrivateServiceConnect::public_ip_address_disabled].
        pub fn set_public_ip_address_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.public_ip_address_disabled = v.into();
            self
        }

        /// Sets the value of [route_all_traffic][crate::model::private_pool_v_1_config::PrivateServiceConnect::route_all_traffic].
        pub fn set_route_all_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.route_all_traffic = v.into();
            self
        }
    }

    impl wkt::message::Message for PrivateServiceConnect {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.cloudbuild.v1.PrivatePoolV1Config.PrivateServiceConnect"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PrivateServiceConnect {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_attachment,
                __public_ip_address_disabled,
                __route_all_traffic,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PrivateServiceConnect")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkAttachment" => Ok(__FieldTag::__network_attachment),
                                "network_attachment" => Ok(__FieldTag::__network_attachment),
                                "publicIpAddressDisabled" => {
                                    Ok(__FieldTag::__public_ip_address_disabled)
                                }
                                "public_ip_address_disabled" => {
                                    Ok(__FieldTag::__public_ip_address_disabled)
                                }
                                "routeAllTraffic" => Ok(__FieldTag::__route_all_traffic),
                                "route_all_traffic" => Ok(__FieldTag::__route_all_traffic),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PrivateServiceConnect;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PrivateServiceConnect")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_attachment => {
                                if !fields.insert(__FieldTag::__network_attachment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_attachment",
                                    ));
                                }
                                result.network_attachment = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__public_ip_address_disabled => {
                                if !fields.insert(__FieldTag::__public_ip_address_disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for public_ip_address_disabled",
                                    ));
                                }
                                result.public_ip_address_disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__route_all_traffic => {
                                if !fields.insert(__FieldTag::__route_all_traffic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for route_all_traffic",
                                    ));
                                }
                                result.route_all_traffic = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PrivateServiceConnect {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network_attachment.is_empty() {
                state.serialize_entry("networkAttachment", &self.network_attachment)?;
            }
            if !wkt::internal::is_default(&self.public_ip_address_disabled) {
                state
                    .serialize_entry("publicIpAddressDisabled", &self.public_ip_address_disabled)?;
            }
            if !wkt::internal::is_default(&self.route_all_traffic) {
                state.serialize_entry("routeAllTraffic", &self.route_all_traffic)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PrivateServiceConnect {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PrivateServiceConnect");
            debug_struct.field("network_attachment", &self.network_attachment);
            debug_struct.field(
                "public_ip_address_disabled",
                &self.public_ip_address_disabled,
            );
            debug_struct.field("route_all_traffic", &self.route_all_traffic);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Request to create a new `WorkerPool`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkerPoolRequest {
    /// Required. The parent resource where this worker pool will be created.
    /// Format: `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. `WorkerPool` resource to create.
    pub worker_pool: std::option::Option<crate::model::WorkerPool>,

    /// Required. Immutable. The ID to use for the `WorkerPool`, which will become
    /// the final component of the resource name.
    ///
    /// This value should be 1-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    pub worker_pool_id: std::string::String,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkerPoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::CreateWorkerPoolRequest::worker_pool].
    pub fn set_worker_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_pool][crate::model::CreateWorkerPoolRequest::worker_pool].
    pub fn set_or_clear_worker_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [worker_pool_id][crate::model::CreateWorkerPoolRequest::worker_pool_id].
    pub fn set_worker_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateWorkerPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __worker_pool,
            __worker_pool_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "workerPoolId" => Ok(__FieldTag::__worker_pool_id),
                            "worker_pool_id" => Ok(__FieldTag::__worker_pool_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool =
                                map.next_value::<std::option::Option<crate::model::WorkerPool>>()?;
                        }
                        __FieldTag::__worker_pool_id => {
                            if !fields.insert(__FieldTag::__worker_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool_id",
                                ));
                            }
                            result.worker_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkerPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.worker_pool.is_some() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if !self.worker_pool_id.is_empty() {
            state.serialize_entry("workerPoolId", &self.worker_pool_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWorkerPoolRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("worker_pool_id", &self.worker_pool_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get a `WorkerPool` with the specified name.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to retrieve.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkerPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.GetWorkerPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkerPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetWorkerPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a `WorkerPool`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    pub name: std::string::String,

    /// Optional. If provided, it must match the server's etag on the workerpool
    /// for the request to be processed.
    pub etag: std::string::String,

    /// If set to true, and the `WorkerPool` is not found, the request will succeed
    /// but no action will be taken on the server.
    pub allow_missing: bool,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkerPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkerPoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteWorkerPoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteWorkerPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkerPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWorkerPoolRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to update a `WorkerPool`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkerPoolRequest {
    /// Required. The `WorkerPool` to update.
    ///
    /// The `name` field is used to identify the `WorkerPool` to update.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    pub worker_pool: std::option::Option<crate::model::WorkerPool>,

    /// A mask specifying which fields in `worker_pool` to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkerPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::UpdateWorkerPoolRequest::worker_pool].
    pub fn set_worker_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_pool][crate::model::UpdateWorkerPoolRequest::worker_pool].
    pub fn set_or_clear_worker_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkerPool>,
    {
        self.worker_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkerPoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWorkerPoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkerPoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkerPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateWorkerPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool =
                                map.next_value::<std::option::Option<crate::model::WorkerPool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkerPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.worker_pool.is_some() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWorkerPoolRequest");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list `WorkerPool`s.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkerPoolsRequest {
    /// Required. The parent of the collection of `WorkerPools`.
    /// Format: `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of `WorkerPool`s to return. The service may return
    /// fewer than this value. If omitted, the server will use a sensible default.
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkerPools` call. Provide this
    /// to retrieve the subsequent page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkerPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkerPoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkerPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkerPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkerPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListWorkerPoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkerPoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkerPoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkerPoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkerPoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkerPoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListWorkerPoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkerPoolsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response containing existing `WorkerPools`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkerPoolsResponse {
    /// `WorkerPools` for the specified project.
    pub worker_pools: std::vec::Vec<crate::model::WorkerPool>,

    /// Continuation token used to page through large result sets. Provide this
    /// value in a subsequent ListWorkerPoolsRequest to return the next page of
    /// results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkerPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pools][crate::model::ListWorkerPoolsResponse::worker_pools].
    pub fn set_worker_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkerPool>,
    {
        use std::iter::Iterator;
        self.worker_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkerPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkerPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.ListWorkerPoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkerPoolsResponse {
    type PageItem = crate::model::WorkerPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.worker_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkerPoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkerPoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPools" => Ok(__FieldTag::__worker_pools),
                            "worker_pools" => Ok(__FieldTag::__worker_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkerPoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkerPoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pools => {
                            if !fields.insert(__FieldTag::__worker_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pools",
                                ));
                            }
                            result.worker_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WorkerPool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkerPoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.worker_pools.is_empty() {
            state.serialize_entry("workerPools", &self.worker_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListWorkerPoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkerPoolsResponse");
        debug_struct.field("worker_pools", &self.worker_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for the `CreateWorkerPool` operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` to create.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::CreateWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateWorkerPoolOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::CreateWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::CreateWorkerPoolOperationMetadata::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.CreateWorkerPoolOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkerPoolOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __create_time,
            __complete_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkerPoolOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkerPoolOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkerPoolOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkerPoolOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateWorkerPoolOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWorkerPoolOperationMetadata");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("complete_time", &self.complete_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for the `UpdateWorkerPool` operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being updated.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::UpdateWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UpdateWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UpdateWorkerPoolOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::UpdateWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::UpdateWorkerPoolOperationMetadata::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.UpdateWorkerPoolOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkerPoolOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __create_time,
            __complete_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkerPoolOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkerPoolOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkerPoolOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkerPoolOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateWorkerPoolOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWorkerPoolOperationMetadata");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("complete_time", &self.complete_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for the `DeleteWorkerPool` operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    pub worker_pool: std::string::String,

    /// Time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time the operation was completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkerPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::DeleteWorkerPoolOperationMetadata::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteWorkerPoolOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteWorkerPoolOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::DeleteWorkerPoolOperationMetadata::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::DeleteWorkerPoolOperationMetadata::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteWorkerPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v1.DeleteWorkerPoolOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkerPoolOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __create_time,
            __complete_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkerPoolOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkerPoolOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkerPoolOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkerPoolOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteWorkerPoolOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWorkerPoolOperationMetadata");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("complete_time", &self.complete_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
