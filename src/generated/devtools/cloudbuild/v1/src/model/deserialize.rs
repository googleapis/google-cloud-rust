// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::RetryBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::RetryBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::RunBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __trigger_id,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::RunBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::RepoSource>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::StorageSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __source_fetcher,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "sourceFetcher" => Ok(__FieldTag::__source_fetcher),
                            "source_fetcher" => Ok(__FieldTag::__source_fetcher),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::StorageSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_fetcher => {
                            if !fields.insert(__FieldTag::__source_fetcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_fetcher",
                                ));
                            }
                            result.source_fetcher =
                                map.next_value::<std::option::Option<
                                    crate::model::storage_source::SourceFetcher,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __dir,
            __revision,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "dir" => Ok(__FieldTag::__dir),
                            "revision" => Ok(__FieldTag::__revision),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::RepoSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __repo_name,
            __branch_name,
            __tag_name,
            __commit_sha,
            __dir,
            __invert_regex,
            __substitutions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepoSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "repoName" => Ok(__FieldTag::__repo_name),
                            "repo_name" => Ok(__FieldTag::__repo_name),
                            "branchName" => Ok(__FieldTag::__branch_name),
                            "branch_name" => Ok(__FieldTag::__branch_name),
                            "tagName" => Ok(__FieldTag::__tag_name),
                            "tag_name" => Ok(__FieldTag::__tag_name),
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            "dir" => Ok(__FieldTag::__dir),
                            "invertRegex" => Ok(__FieldTag::__invert_regex),
                            "invert_regex" => Ok(__FieldTag::__invert_regex),
                            "substitutions" => Ok(__FieldTag::__substitutions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::RepoSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepoSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repo_name => {
                            if !fields.insert(__FieldTag::__repo_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_name",
                                ));
                            }
                            result.repo_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__branch_name => {
                            if !fields.insert(__FieldTag::__branch_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch_name",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .google.devtools.cloudbuild.v1.RepoSource.branch_name, latest field was branchName",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::repo_source::Revision::BranchName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__tag_name => {
                            if !fields.insert(__FieldTag::__tag_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_name",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .google.devtools.cloudbuild.v1.RepoSource.tag_name, latest field was tagName",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::repo_source::Revision::TagName(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            if result.revision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `revision`, a oneof with full ID .google.devtools.cloudbuild.v1.RepoSource.commit_sha, latest field was commitSha",
                                ));
                            }
                            result.revision = std::option::Option::Some(
                                crate::model::repo_source::Revision::CommitSha(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invert_regex => {
                            if !fields.insert(__FieldTag::__invert_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invert_regex",
                                ));
                            }
                            result.invert_regex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substitutions => {
                            if !fields.insert(__FieldTag::__substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitutions",
                                ));
                            }
                            result.substitutions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::StorageSourceManifest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageSourceManifest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::StorageSourceManifest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageSourceManifest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_source,
            __repo_source,
            __git_source,
            __storage_source_manifest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageSource" => Ok(__FieldTag::__storage_source),
                            "storage_source" => Ok(__FieldTag::__storage_source),
                            "repoSource" => Ok(__FieldTag::__repo_source),
                            "repo_source" => Ok(__FieldTag::__repo_source),
                            "gitSource" => Ok(__FieldTag::__git_source),
                            "git_source" => Ok(__FieldTag::__git_source),
                            "storageSourceManifest" => Ok(__FieldTag::__storage_source_manifest),
                            "storage_source_manifest" => Ok(__FieldTag::__storage_source_manifest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_source => {
                            if !fields.insert(__FieldTag::__storage_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.storage_source, latest field was storageSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source::Source::StorageSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repo_source => {
                            if !fields.insert(__FieldTag::__repo_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.repo_source, latest field was repoSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source::Source::RepoSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RepoSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git_source => {
                            if !fields.insert(__FieldTag::__git_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.git_source, latest field was gitSource",
                                ));
                            }
                            result.source =
                                std::option::Option::Some(crate::model::source::Source::GitSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__storage_source_manifest => {
                            if !fields.insert(__FieldTag::__storage_source_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_source_manifest",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.Source.storage_source_manifest, latest field was storageSourceManifest",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source::Source::StorageSourceManifest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageSourceManifest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::BuiltImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __digest,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuiltImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "digest" => Ok(__FieldTag::__digest),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::BuiltImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuiltImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UploadedPythonPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedPythonPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UploadedPythonPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedPythonPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UploadedMavenArtifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedMavenArtifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UploadedMavenArtifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedMavenArtifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UploadedGoModule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedGoModule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UploadedGoModule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedGoModule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UploadedNpmPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __file_hashes,
            __push_timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadedNpmPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            "pushTiming" => Ok(__FieldTag::__push_timing),
                            "push_timing" => Ok(__FieldTag::__push_timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UploadedNpmPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadedNpmPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes =
                                map.next_value::<std::option::Option<crate::model::FileHashes>>()?;
                        }
                        __FieldTag::__push_timing => {
                            if !fields.insert(__FieldTag::__push_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_timing",
                                ));
                            }
                            result.push_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::BuildStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __env,
            __args,
            __dir,
            __id,
            __wait_for,
            __entrypoint,
            __secret_env,
            __volumes,
            __timing,
            __pull_timing,
            __timeout,
            __status,
            __allow_failure,
            __exit_code,
            __allow_exit_codes,
            __script,
            __automap_substitutions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "env" => Ok(__FieldTag::__env),
                            "args" => Ok(__FieldTag::__args),
                            "dir" => Ok(__FieldTag::__dir),
                            "id" => Ok(__FieldTag::__id),
                            "waitFor" => Ok(__FieldTag::__wait_for),
                            "wait_for" => Ok(__FieldTag::__wait_for),
                            "entrypoint" => Ok(__FieldTag::__entrypoint),
                            "secretEnv" => Ok(__FieldTag::__secret_env),
                            "secret_env" => Ok(__FieldTag::__secret_env),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "timing" => Ok(__FieldTag::__timing),
                            "pullTiming" => Ok(__FieldTag::__pull_timing),
                            "pull_timing" => Ok(__FieldTag::__pull_timing),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "status" => Ok(__FieldTag::__status),
                            "allowFailure" => Ok(__FieldTag::__allow_failure),
                            "allow_failure" => Ok(__FieldTag::__allow_failure),
                            "exitCode" => Ok(__FieldTag::__exit_code),
                            "exit_code" => Ok(__FieldTag::__exit_code),
                            "allowExitCodes" => Ok(__FieldTag::__allow_exit_codes),
                            "allow_exit_codes" => Ok(__FieldTag::__allow_exit_codes),
                            "script" => Ok(__FieldTag::__script),
                            "automapSubstitutions" => Ok(__FieldTag::__automap_substitutions),
                            "automap_substitutions" => Ok(__FieldTag::__automap_substitutions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::BuildStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dir => {
                            if !fields.insert(__FieldTag::__dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dir",
                                ));
                            }
                            result.dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait_for => {
                            if !fields.insert(__FieldTag::__wait_for) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_for",
                                ));
                            }
                            result.wait_for = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entrypoint => {
                            if !fields.insert(__FieldTag::__entrypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entrypoint",
                                ));
                            }
                            result.entrypoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_env => {
                            if !fields.insert(__FieldTag::__secret_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_env",
                                ));
                            }
                            result.secret_env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__timing => {
                            if !fields.insert(__FieldTag::__timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timing",
                                ));
                            }
                            result.timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::__pull_timing => {
                            if !fields.insert(__FieldTag::__pull_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_timing",
                                ));
                            }
                            result.pull_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::build::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_failure => {
                            if !fields.insert(__FieldTag::__allow_failure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_failure",
                                ));
                            }
                            result.allow_failure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exit_code => {
                            if !fields.insert(__FieldTag::__exit_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exit_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exit_code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allow_exit_codes => {
                            if !fields.insert(__FieldTag::__allow_exit_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_exit_codes",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allow_exit_codes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            result.script = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automap_substitutions => {
                            if !fields.insert(__FieldTag::__automap_substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automap_substitutions",
                                ));
                            }
                            result.automap_substitutions =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Volume {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Volume")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Volume;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Volume")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Results {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __images,
            __build_step_images,
            __artifact_manifest,
            __num_artifacts,
            __build_step_outputs,
            __artifact_timing,
            __python_packages,
            __maven_artifacts,
            __go_modules,
            __npm_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Results")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "images" => Ok(__FieldTag::__images),
                            "buildStepImages" => Ok(__FieldTag::__build_step_images),
                            "build_step_images" => Ok(__FieldTag::__build_step_images),
                            "artifactManifest" => Ok(__FieldTag::__artifact_manifest),
                            "artifact_manifest" => Ok(__FieldTag::__artifact_manifest),
                            "numArtifacts" => Ok(__FieldTag::__num_artifacts),
                            "num_artifacts" => Ok(__FieldTag::__num_artifacts),
                            "buildStepOutputs" => Ok(__FieldTag::__build_step_outputs),
                            "build_step_outputs" => Ok(__FieldTag::__build_step_outputs),
                            "artifactTiming" => Ok(__FieldTag::__artifact_timing),
                            "artifact_timing" => Ok(__FieldTag::__artifact_timing),
                            "pythonPackages" => Ok(__FieldTag::__python_packages),
                            "python_packages" => Ok(__FieldTag::__python_packages),
                            "mavenArtifacts" => Ok(__FieldTag::__maven_artifacts),
                            "maven_artifacts" => Ok(__FieldTag::__maven_artifacts),
                            "goModules" => Ok(__FieldTag::__go_modules),
                            "go_modules" => Ok(__FieldTag::__go_modules),
                            "npmPackages" => Ok(__FieldTag::__npm_packages),
                            "npm_packages" => Ok(__FieldTag::__npm_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Results;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Results")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuiltImage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__build_step_images => {
                            if !fields.insert(__FieldTag::__build_step_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_step_images",
                                ));
                            }
                            result.build_step_images = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__artifact_manifest => {
                            if !fields.insert(__FieldTag::__artifact_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_manifest",
                                ));
                            }
                            result.artifact_manifest = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_artifacts => {
                            if !fields.insert(__FieldTag::__num_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_artifacts",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_artifacts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__build_step_outputs => {
                            if !fields.insert(__FieldTag::__build_step_outputs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_step_outputs",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.build_step_outputs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__artifact_timing => {
                            if !fields.insert(__FieldTag::__artifact_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_timing",
                                ));
                            }
                            result.artifact_timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::__python_packages => {
                            if !fields.insert(__FieldTag::__python_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_packages",
                                ));
                            }
                            result.python_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedPythonPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maven_artifacts => {
                            if !fields.insert(__FieldTag::__maven_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maven_artifacts",
                                ));
                            }
                            result.maven_artifacts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedMavenArtifact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__go_modules => {
                            if !fields.insert(__FieldTag::__go_modules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for go_modules",
                                ));
                            }
                            result.go_modules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedGoModule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__npm_packages => {
                            if !fields.insert(__FieldTag::__npm_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for npm_packages",
                                ));
                            }
                            result.npm_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UploadedNpmPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ArtifactResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __file_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArtifactResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "fileHash" => Ok(__FieldTag::__file_hash),
                            "file_hash" => Ok(__FieldTag::__file_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ArtifactResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArtifactResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_hash => {
                            if !fields.insert(__FieldTag::__file_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hash",
                                ));
                            }
                            result.file_hash = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FileHashes>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Build {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __project_id,
            __status,
            __status_detail,
            __source,
            __steps,
            __results,
            __create_time,
            __start_time,
            __finish_time,
            __timeout,
            __images,
            __queue_ttl,
            __artifacts,
            __logs_bucket,
            __source_provenance,
            __build_trigger_id,
            __options,
            __log_url,
            __substitutions,
            __tags,
            __secrets,
            __timing,
            __approval,
            __service_account,
            __available_secrets,
            __warnings,
            __git_config,
            __failure_info,
            __dependencies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Build")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "status" => Ok(__FieldTag::__status),
                            "statusDetail" => Ok(__FieldTag::__status_detail),
                            "status_detail" => Ok(__FieldTag::__status_detail),
                            "source" => Ok(__FieldTag::__source),
                            "steps" => Ok(__FieldTag::__steps),
                            "results" => Ok(__FieldTag::__results),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "images" => Ok(__FieldTag::__images),
                            "queueTtl" => Ok(__FieldTag::__queue_ttl),
                            "queue_ttl" => Ok(__FieldTag::__queue_ttl),
                            "artifacts" => Ok(__FieldTag::__artifacts),
                            "logsBucket" => Ok(__FieldTag::__logs_bucket),
                            "logs_bucket" => Ok(__FieldTag::__logs_bucket),
                            "sourceProvenance" => Ok(__FieldTag::__source_provenance),
                            "source_provenance" => Ok(__FieldTag::__source_provenance),
                            "buildTriggerId" => Ok(__FieldTag::__build_trigger_id),
                            "build_trigger_id" => Ok(__FieldTag::__build_trigger_id),
                            "options" => Ok(__FieldTag::__options),
                            "logUrl" => Ok(__FieldTag::__log_url),
                            "log_url" => Ok(__FieldTag::__log_url),
                            "substitutions" => Ok(__FieldTag::__substitutions),
                            "tags" => Ok(__FieldTag::__tags),
                            "secrets" => Ok(__FieldTag::__secrets),
                            "timing" => Ok(__FieldTag::__timing),
                            "approval" => Ok(__FieldTag::__approval),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "availableSecrets" => Ok(__FieldTag::__available_secrets),
                            "available_secrets" => Ok(__FieldTag::__available_secrets),
                            "warnings" => Ok(__FieldTag::__warnings),
                            "gitConfig" => Ok(__FieldTag::__git_config),
                            "git_config" => Ok(__FieldTag::__git_config),
                            "failureInfo" => Ok(__FieldTag::__failure_info),
                            "failure_info" => Ok(__FieldTag::__failure_info),
                            "dependencies" => Ok(__FieldTag::__dependencies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Build;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Build")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::build::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_detail => {
                            if !fields.insert(__FieldTag::__status_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_detail",
                                ));
                            }
                            result.status_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuildStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results =
                                map.next_value::<std::option::Option<crate::model::Results>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__queue_ttl => {
                            if !fields.insert(__FieldTag::__queue_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queue_ttl",
                                ));
                            }
                            result.queue_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__artifacts => {
                            if !fields.insert(__FieldTag::__artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifacts",
                                ));
                            }
                            result.artifacts =
                                map.next_value::<std::option::Option<crate::model::Artifacts>>()?;
                        }
                        __FieldTag::__logs_bucket => {
                            if !fields.insert(__FieldTag::__logs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logs_bucket",
                                ));
                            }
                            result.logs_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_provenance => {
                            if !fields.insert(__FieldTag::__source_provenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_provenance",
                                ));
                            }
                            result.source_provenance = map
                                .next_value::<std::option::Option<crate::model::SourceProvenance>>(
                                )?;
                        }
                        __FieldTag::__build_trigger_id => {
                            if !fields.insert(__FieldTag::__build_trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_trigger_id",
                                ));
                            }
                            result.build_trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map
                                .next_value::<std::option::Option<crate::model::BuildOptions>>()?;
                        }
                        __FieldTag::__log_url => {
                            if !fields.insert(__FieldTag::__log_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_url",
                                ));
                            }
                            result.log_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substitutions => {
                            if !fields.insert(__FieldTag::__substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitutions",
                                ));
                            }
                            result.substitutions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__secrets => {
                            if !fields.insert(__FieldTag::__secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secrets",
                                ));
                            }
                            result.secrets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Secret>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__timing => {
                            if !fields.insert(__FieldTag::__timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timing",
                                ));
                            }
                            result.timing = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TimeSpan,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval => {
                            if !fields.insert(__FieldTag::__approval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval",
                                ));
                            }
                            result.approval = map
                                .next_value::<std::option::Option<crate::model::BuildApproval>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_secrets => {
                            if !fields.insert(__FieldTag::__available_secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_secrets",
                                ));
                            }
                            result.available_secrets =
                                map.next_value::<std::option::Option<crate::model::Secrets>>()?;
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::build::Warning>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_config => {
                            if !fields.insert(__FieldTag::__git_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_config",
                                ));
                            }
                            result.git_config =
                                map.next_value::<std::option::Option<crate::model::GitConfig>>()?;
                        }
                        __FieldTag::__failure_info => {
                            if !fields.insert(__FieldTag::__failure_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_info",
                                ));
                            }
                            result.failure_info = map.next_value::<std::option::Option<crate::model::build::FailureInfo>>()?
                                ;
                        }
                        __FieldTag::__dependencies => {
                            if !fields.insert(__FieldTag::__dependencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependencies",
                                ));
                            }
                            result.dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dependency>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::build::Warning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __priority,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Warning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "priority" => Ok(__FieldTag::__priority),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::build::Warning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Warning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            result.priority = map.next_value::<std::option::Option<crate::model::build::warning::Priority>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::build::FailureInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailureInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "detail" => Ok(__FieldTag::__detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::build::FailureInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailureInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::build::failure_info::FailureType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Dependency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __empty,
            __git_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dependency")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "empty" => Ok(__FieldTag::__empty),
                            "gitSource" => Ok(__FieldTag::__git_source),
                            "git_source" => Ok(__FieldTag::__git_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Dependency;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dependency")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__empty => {
                            if !fields.insert(__FieldTag::__empty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for empty",
                                ));
                            }
                            if result.dep.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dep`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.empty, latest field was empty",
                                ));
                            }
                            result.dep =
                                std::option::Option::Some(crate::model::dependency::Dep::Empty(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__git_source => {
                            if !fields.insert(__FieldTag::__git_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_source",
                                ));
                            }
                            if result.dep.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dep`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.git_source, latest field was gitSource",
                                ));
                            }
                            result.dep = std::option::Option::Some(
                                crate::model::dependency::Dep::GitSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::dependency::GitSourceDependency,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::dependency::GitSourceDependency {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __revision,
            __recurse_submodules,
            __depth,
            __dest_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitSourceDependency")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "revision" => Ok(__FieldTag::__revision),
                            "recurseSubmodules" => Ok(__FieldTag::__recurse_submodules),
                            "recurse_submodules" => Ok(__FieldTag::__recurse_submodules),
                            "depth" => Ok(__FieldTag::__depth),
                            "destPath" => Ok(__FieldTag::__dest_path),
                            "dest_path" => Ok(__FieldTag::__dest_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::dependency::GitSourceDependency;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitSourceDependency")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map.next_value::<std::option::Option<
                                crate::model::dependency::GitSourceRepository,
                            >>()?;
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recurse_submodules => {
                            if !fields.insert(__FieldTag::__recurse_submodules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurse_submodules",
                                ));
                            }
                            result.recurse_submodules = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__depth => {
                            if !fields.insert(__FieldTag::__depth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for depth",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.depth = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__dest_path => {
                            if !fields.insert(__FieldTag::__dest_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dest_path",
                                ));
                            }
                            result.dest_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::dependency::GitSourceRepository {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __developer_connect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitSourceRepository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "developerConnect" => Ok(__FieldTag::__developer_connect),
                            "developer_connect" => Ok(__FieldTag::__developer_connect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::dependency::GitSourceRepository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitSourceRepository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            if result.repotype.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repotype`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.GitSourceRepository.url, latest field was url",
                                ));
                            }
                            result.repotype = std::option::Option::Some(
                                crate::model::dependency::git_source_repository::Repotype::Url(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__developer_connect => {
                            if !fields.insert(__FieldTag::__developer_connect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for developer_connect",
                                ));
                            }
                            if result.repotype.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repotype`, a oneof with full ID .google.devtools.cloudbuild.v1.Dependency.GitSourceRepository.developer_connect, latest field was developerConnect",
                                ));
                            }
                            result.repotype = std::option::Option::Some(
                                crate::model::dependency::git_source_repository::Repotype::DeveloperConnect(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "http" => Ok(__FieldTag::__http),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http => {
                            if !fields.insert(__FieldTag::__http) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http",
                                ));
                            }
                            result.http = map.next_value::<std::option::Option<crate::model::git_config::HttpConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::git_config::HttpConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __proxy_secret_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "proxySecretVersionName" => Ok(__FieldTag::__proxy_secret_version_name),
                            "proxy_secret_version_name" => {
                                Ok(__FieldTag::__proxy_secret_version_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::git_config::HttpConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__proxy_secret_version_name => {
                            if !fields.insert(__FieldTag::__proxy_secret_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_secret_version_name",
                                ));
                            }
                            result.proxy_secret_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Artifacts {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __images,
            __objects,
            __maven_artifacts,
            __go_modules,
            __python_packages,
            __npm_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Artifacts")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "images" => Ok(__FieldTag::__images),
                            "objects" => Ok(__FieldTag::__objects),
                            "mavenArtifacts" => Ok(__FieldTag::__maven_artifacts),
                            "maven_artifacts" => Ok(__FieldTag::__maven_artifacts),
                            "goModules" => Ok(__FieldTag::__go_modules),
                            "go_modules" => Ok(__FieldTag::__go_modules),
                            "pythonPackages" => Ok(__FieldTag::__python_packages),
                            "python_packages" => Ok(__FieldTag::__python_packages),
                            "npmPackages" => Ok(__FieldTag::__npm_packages),
                            "npm_packages" => Ok(__FieldTag::__npm_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Artifacts;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Artifacts")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__objects => {
                            if !fields.insert(__FieldTag::__objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects",
                                ));
                            }
                            result.objects = map.next_value::<std::option::Option<crate::model::artifacts::ArtifactObjects>>()?
                                ;
                        }
                        __FieldTag::__maven_artifacts => {
                            if !fields.insert(__FieldTag::__maven_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maven_artifacts",
                                ));
                            }
                            result.maven_artifacts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::MavenArtifact>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__go_modules => {
                            if !fields.insert(__FieldTag::__go_modules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for go_modules",
                                ));
                            }
                            result.go_modules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::GoModule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__python_packages => {
                            if !fields.insert(__FieldTag::__python_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_packages",
                                ));
                            }
                            result.python_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::PythonPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__npm_packages => {
                            if !fields.insert(__FieldTag::__npm_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for npm_packages",
                                ));
                            }
                            result.npm_packages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::artifacts::NpmPackage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::artifacts::ArtifactObjects {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __paths,
            __timing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArtifactObjects")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "paths" => Ok(__FieldTag::__paths),
                            "timing" => Ok(__FieldTag::__timing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::artifacts::ArtifactObjects;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArtifactObjects")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__timing => {
                            if !fields.insert(__FieldTag::__timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timing",
                                ));
                            }
                            result.timing =
                                map.next_value::<std::option::Option<crate::model::TimeSpan>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::artifacts::MavenArtifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __path,
            __artifact_id,
            __group_id,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MavenArtifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "path" => Ok(__FieldTag::__path),
                            "artifactId" => Ok(__FieldTag::__artifact_id),
                            "artifact_id" => Ok(__FieldTag::__artifact_id),
                            "groupId" => Ok(__FieldTag::__group_id),
                            "group_id" => Ok(__FieldTag::__group_id),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::artifacts::MavenArtifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MavenArtifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__artifact_id => {
                            if !fields.insert(__FieldTag::__artifact_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_id",
                                ));
                            }
                            result.artifact_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_id => {
                            if !fields.insert(__FieldTag::__group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id",
                                ));
                            }
                            result.group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::artifacts::GoModule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository_name,
            __repository_location,
            __repository_project_id,
            __source_path,
            __module_path,
            __module_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoModule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repositoryName" => Ok(__FieldTag::__repository_name),
                            "repository_name" => Ok(__FieldTag::__repository_name),
                            "repositoryLocation" => Ok(__FieldTag::__repository_location),
                            "repository_location" => Ok(__FieldTag::__repository_location),
                            "repositoryProjectId" => Ok(__FieldTag::__repository_project_id),
                            "repository_project_id" => Ok(__FieldTag::__repository_project_id),
                            "sourcePath" => Ok(__FieldTag::__source_path),
                            "source_path" => Ok(__FieldTag::__source_path),
                            "modulePath" => Ok(__FieldTag::__module_path),
                            "module_path" => Ok(__FieldTag::__module_path),
                            "moduleVersion" => Ok(__FieldTag::__module_version),
                            "module_version" => Ok(__FieldTag::__module_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::artifacts::GoModule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoModule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository_name => {
                            if !fields.insert(__FieldTag::__repository_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_name",
                                ));
                            }
                            result.repository_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_location => {
                            if !fields.insert(__FieldTag::__repository_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_location",
                                ));
                            }
                            result.repository_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_project_id => {
                            if !fields.insert(__FieldTag::__repository_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_project_id",
                                ));
                            }
                            result.repository_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_path => {
                            if !fields.insert(__FieldTag::__source_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_path",
                                ));
                            }
                            result.source_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__module_path => {
                            if !fields.insert(__FieldTag::__module_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for module_path",
                                ));
                            }
                            result.module_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__module_version => {
                            if !fields.insert(__FieldTag::__module_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for module_version",
                                ));
                            }
                            result.module_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::artifacts::PythonPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __paths,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PythonPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "paths" => Ok(__FieldTag::__paths),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::artifacts::PythonPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PythonPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::artifacts::NpmPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __package_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NpmPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "packagePath" => Ok(__FieldTag::__package_path),
                            "package_path" => Ok(__FieldTag::__package_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::artifacts::NpmPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NpmPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_path => {
                            if !fields.insert(__FieldTag::__package_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_path",
                                ));
                            }
                            result.package_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::TimeSpan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSpan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::TimeSpan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSpan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::BuildOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "build" => Ok(__FieldTag::__build),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::BuildOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build =
                                map.next_value::<std::option::Option<crate::model::Build>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::SourceProvenance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resolved_storage_source,
            __resolved_repo_source,
            __resolved_storage_source_manifest,
            __file_hashes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceProvenance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resolvedStorageSource" => Ok(__FieldTag::__resolved_storage_source),
                            "resolved_storage_source" => Ok(__FieldTag::__resolved_storage_source),
                            "resolvedRepoSource" => Ok(__FieldTag::__resolved_repo_source),
                            "resolved_repo_source" => Ok(__FieldTag::__resolved_repo_source),
                            "resolvedStorageSourceManifest" => {
                                Ok(__FieldTag::__resolved_storage_source_manifest)
                            }
                            "resolved_storage_source_manifest" => {
                                Ok(__FieldTag::__resolved_storage_source_manifest)
                            }
                            "fileHashes" => Ok(__FieldTag::__file_hashes),
                            "file_hashes" => Ok(__FieldTag::__file_hashes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::SourceProvenance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceProvenance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resolved_storage_source => {
                            if !fields.insert(__FieldTag::__resolved_storage_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_storage_source",
                                ));
                            }
                            result.resolved_storage_source = map
                                .next_value::<std::option::Option<crate::model::StorageSource>>()?;
                        }
                        __FieldTag::__resolved_repo_source => {
                            if !fields.insert(__FieldTag::__resolved_repo_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_repo_source",
                                ));
                            }
                            result.resolved_repo_source =
                                map.next_value::<std::option::Option<crate::model::RepoSource>>()?;
                        }
                        __FieldTag::__resolved_storage_source_manifest => {
                            if !fields.insert(__FieldTag::__resolved_storage_source_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_storage_source_manifest",
                                ));
                            }
                            result.resolved_storage_source_manifest = map.next_value::<std::option::Option<crate::model::StorageSourceManifest>>()?
                                ;
                        }
                        __FieldTag::__file_hashes => {
                            if !fields.insert(__FieldTag::__file_hashes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hashes",
                                ));
                            }
                            result.file_hashes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::FileHashes,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::FileHashes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileHashes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileHash" => Ok(__FieldTag::__file_hash),
                            "file_hash" => Ok(__FieldTag::__file_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::FileHashes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileHashes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_hash => {
                            if !fields.insert(__FieldTag::__file_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_hash",
                                ));
                            }
                            result.file_hash = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Hash>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Hash {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Hash")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Hash;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Hash")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::hash::HashType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Secrets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_manager,
            __inline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secrets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretManager" => Ok(__FieldTag::__secret_manager),
                            "secret_manager" => Ok(__FieldTag::__secret_manager),
                            "inline" => Ok(__FieldTag::__inline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Secrets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secrets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_manager => {
                            if !fields.insert(__FieldTag::__secret_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager",
                                ));
                            }
                            result.secret_manager = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecretManagerSecret>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inline => {
                            if !fields.insert(__FieldTag::__inline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline",
                                ));
                            }
                            result.inline = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InlineSecret>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::InlineSecret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            __env_map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineSecret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "envMap" => Ok(__FieldTag::__env_map),
                            "env_map" => Ok(__FieldTag::__env_map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::InlineSecret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineSecret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env_map => {
                            if !fields.insert(__FieldTag::__env_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env_map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, ::bytes::Bytes>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.env_map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::SecretManagerSecret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version_name,
            __env,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretManagerSecret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versionName" => Ok(__FieldTag::__version_name),
                            "version_name" => Ok(__FieldTag::__version_name),
                            "env" => Ok(__FieldTag::__env),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::SecretManagerSecret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretManagerSecret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version_name => {
                            if !fields.insert(__FieldTag::__version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_name",
                                ));
                            }
                            result.version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::Secret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            __secret_env,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "secretEnv" => Ok(__FieldTag::__secret_env),
                            "secret_env" => Ok(__FieldTag::__secret_env),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::Secret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_env => {
                            if !fields.insert(__FieldTag::__secret_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_env",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, ::bytes::Bytes>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.secret_env = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::CreateBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __build,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "build" => Ok(__FieldTag::__build),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::CreateBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build =
                                map.next_value::<std::option::Option<crate::model::Build>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GetBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GetBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ListBuildsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ListBuildsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ListBuildsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __builds,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "builds" => Ok(__FieldTag::__builds),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ListBuildsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__builds => {
                            if !fields.insert(__FieldTag::__builds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builds",
                                ));
                            }
                            result.builds = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Build>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::CancelBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::CancelBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ApproveBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __approval_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "approvalResult" => Ok(__FieldTag::__approval_result),
                            "approval_result" => Ok(__FieldTag::__approval_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ApproveBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval_result => {
                            if !fields.insert(__FieldTag::__approval_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_result",
                                ));
                            }
                            result.approval_result = map
                                .next_value::<std::option::Option<crate::model::ApprovalResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::BuildApproval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __config,
            __result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildApproval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "config" => Ok(__FieldTag::__config),
                            "result" => Ok(__FieldTag::__result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::BuildApproval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildApproval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::build_approval::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::ApprovalConfig>>(
                                )?;
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<crate::model::ApprovalResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ApprovalConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approval_required,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApprovalConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approvalRequired" => Ok(__FieldTag::__approval_required),
                            "approval_required" => Ok(__FieldTag::__approval_required),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ApprovalConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApprovalConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approval_required => {
                            if !fields.insert(__FieldTag::__approval_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_required",
                                ));
                            }
                            result.approval_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ApprovalResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approver_account,
            __approval_time,
            __decision,
            __comment,
            __url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApprovalResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approverAccount" => Ok(__FieldTag::__approver_account),
                            "approver_account" => Ok(__FieldTag::__approver_account),
                            "approvalTime" => Ok(__FieldTag::__approval_time),
                            "approval_time" => Ok(__FieldTag::__approval_time),
                            "decision" => Ok(__FieldTag::__decision),
                            "comment" => Ok(__FieldTag::__comment),
                            "url" => Ok(__FieldTag::__url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ApprovalResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApprovalResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approver_account => {
                            if !fields.insert(__FieldTag::__approver_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approver_account",
                                ));
                            }
                            result.approver_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval_time => {
                            if !fields.insert(__FieldTag::__approval_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_time",
                                ));
                            }
                            result.approval_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__decision => {
                            if !fields.insert(__FieldTag::__decision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decision",
                                ));
                            }
                            result.decision = map.next_value::<std::option::Option<crate::model::approval_result::Decision>>()?.unwrap_or_default();
                        }
                        __FieldTag::__comment => {
                            if !fields.insert(__FieldTag::__comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment",
                                ));
                            }
                            result.comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitRepoSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __repository,
            __ref,
            __repo_type,
            __github_enterprise_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitRepoSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "repository" => Ok(__FieldTag::__repository),
                            "ref" => Ok(__FieldTag::__ref),
                            "repoType" => Ok(__FieldTag::__repo_type),
                            "repo_type" => Ok(__FieldTag::__repo_type),
                            "githubEnterpriseConfig" => Ok(__FieldTag::__github_enterprise_config),
                            "github_enterprise_config" => {
                                Ok(__FieldTag::__github_enterprise_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitRepoSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitRepoSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.GitRepoSource.repository, latest field was repository",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::git_repo_source::Source::Repository(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ref => {
                            if !fields.insert(__FieldTag::__ref) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ref",
                                ));
                            }
                            result.r#ref = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repo_type => {
                            if !fields.insert(__FieldTag::__repo_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_type",
                                ));
                            }
                            result.repo_type = map.next_value::<std::option::Option<crate::model::git_file_source::RepoType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__github_enterprise_config => {
                            if !fields.insert(__FieldTag::__github_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_enterprise_config",
                                ));
                            }
                            if result.enterprise_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enterprise_config`, a oneof with full ID .google.devtools.cloudbuild.v1.GitRepoSource.github_enterprise_config, latest field was githubEnterpriseConfig",
                                ));
                            }
                            result.enterprise_config = std::option::Option::Some(
                                crate::model::git_repo_source::EnterpriseConfig::GithubEnterpriseConfig(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitFileSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __uri,
            __repository,
            __repo_type,
            __revision,
            __github_enterprise_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitFileSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "uri" => Ok(__FieldTag::__uri),
                            "repository" => Ok(__FieldTag::__repository),
                            "repoType" => Ok(__FieldTag::__repo_type),
                            "repo_type" => Ok(__FieldTag::__repo_type),
                            "revision" => Ok(__FieldTag::__revision),
                            "githubEnterpriseConfig" => Ok(__FieldTag::__github_enterprise_config),
                            "github_enterprise_config" => {
                                Ok(__FieldTag::__github_enterprise_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitFileSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitFileSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.devtools.cloudbuild.v1.GitFileSource.repository, latest field was repository",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::git_file_source::Source::Repository(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repo_type => {
                            if !fields.insert(__FieldTag::__repo_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repo_type",
                                ));
                            }
                            result.repo_type = map.next_value::<std::option::Option<crate::model::git_file_source::RepoType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__github_enterprise_config => {
                            if !fields.insert(__FieldTag::__github_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_enterprise_config",
                                ));
                            }
                            if result.enterprise_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `enterprise_config`, a oneof with full ID .google.devtools.cloudbuild.v1.GitFileSource.github_enterprise_config, latest field was githubEnterpriseConfig",
                                ));
                            }
                            result.enterprise_config = std::option::Option::Some(
                                crate::model::git_file_source::EnterpriseConfig::GithubEnterpriseConfig(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::BuildTrigger {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_name,
            __id,
            __description,
            __name,
            __tags,
            __trigger_template,
            __github,
            __pubsub_config,
            __webhook_config,
            __autodetect,
            __build,
            __filename,
            __git_file_source,
            __create_time,
            __disabled,
            __substitutions,
            __ignored_files,
            __included_files,
            __filter,
            __source_to_build,
            __service_account,
            __repository_event_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildTrigger")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceName" => Ok(__FieldTag::__resource_name),
                            "resource_name" => Ok(__FieldTag::__resource_name),
                            "id" => Ok(__FieldTag::__id),
                            "description" => Ok(__FieldTag::__description),
                            "name" => Ok(__FieldTag::__name),
                            "tags" => Ok(__FieldTag::__tags),
                            "triggerTemplate" => Ok(__FieldTag::__trigger_template),
                            "trigger_template" => Ok(__FieldTag::__trigger_template),
                            "github" => Ok(__FieldTag::__github),
                            "pubsubConfig" => Ok(__FieldTag::__pubsub_config),
                            "pubsub_config" => Ok(__FieldTag::__pubsub_config),
                            "webhookConfig" => Ok(__FieldTag::__webhook_config),
                            "webhook_config" => Ok(__FieldTag::__webhook_config),
                            "autodetect" => Ok(__FieldTag::__autodetect),
                            "build" => Ok(__FieldTag::__build),
                            "filename" => Ok(__FieldTag::__filename),
                            "gitFileSource" => Ok(__FieldTag::__git_file_source),
                            "git_file_source" => Ok(__FieldTag::__git_file_source),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "disabled" => Ok(__FieldTag::__disabled),
                            "substitutions" => Ok(__FieldTag::__substitutions),
                            "ignoredFiles" => Ok(__FieldTag::__ignored_files),
                            "ignored_files" => Ok(__FieldTag::__ignored_files),
                            "includedFiles" => Ok(__FieldTag::__included_files),
                            "included_files" => Ok(__FieldTag::__included_files),
                            "filter" => Ok(__FieldTag::__filter),
                            "sourceToBuild" => Ok(__FieldTag::__source_to_build),
                            "source_to_build" => Ok(__FieldTag::__source_to_build),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "repositoryEventConfig" => Ok(__FieldTag::__repository_event_config),
                            "repository_event_config" => Ok(__FieldTag::__repository_event_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::BuildTrigger;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildTrigger")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_name => {
                            if !fields.insert(__FieldTag::__resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_name",
                                ));
                            }
                            result.resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__trigger_template => {
                            if !fields.insert(__FieldTag::__trigger_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_template",
                                ));
                            }
                            result.trigger_template =
                                map.next_value::<std::option::Option<crate::model::RepoSource>>()?;
                        }
                        __FieldTag::__github => {
                            if !fields.insert(__FieldTag::__github) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github",
                                ));
                            }
                            result.github = map.next_value::<std::option::Option<crate::model::GitHubEventsConfig>>()?
                                ;
                        }
                        __FieldTag::__pubsub_config => {
                            if !fields.insert(__FieldTag::__pubsub_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_config",
                                ));
                            }
                            result.pubsub_config = map
                                .next_value::<std::option::Option<crate::model::PubsubConfig>>()?;
                        }
                        __FieldTag::__webhook_config => {
                            if !fields.insert(__FieldTag::__webhook_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_config",
                                ));
                            }
                            result.webhook_config = map
                                .next_value::<std::option::Option<crate::model::WebhookConfig>>()?;
                        }
                        __FieldTag::__autodetect => {
                            if !fields.insert(__FieldTag::__autodetect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.autodetect, latest field was autodetect",
                                ));
                            }
                            result.build_template = std::option::Option::Some(
                                crate::model::build_trigger::BuildTemplate::Autodetect(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.build, latest field was build",
                                ));
                            }
                            result.build_template =
                                std::option::Option::Some(
                                    crate::model::build_trigger::BuildTemplate::Build(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Build>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__filename => {
                            if !fields.insert(__FieldTag::__filename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filename",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.filename, latest field was filename",
                                ));
                            }
                            result.build_template = std::option::Option::Some(
                                crate::model::build_trigger::BuildTemplate::Filename(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git_file_source => {
                            if !fields.insert(__FieldTag::__git_file_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_file_source",
                                ));
                            }
                            if result.build_template.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_template`, a oneof with full ID .google.devtools.cloudbuild.v1.BuildTrigger.git_file_source, latest field was gitFileSource",
                                ));
                            }
                            result.build_template = std::option::Option::Some(
                                crate::model::build_trigger::BuildTemplate::GitFileSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitFileSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substitutions => {
                            if !fields.insert(__FieldTag::__substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitutions",
                                ));
                            }
                            result.substitutions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignored_files => {
                            if !fields.insert(__FieldTag::__ignored_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignored_files",
                                ));
                            }
                            result.ignored_files = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__included_files => {
                            if !fields.insert(__FieldTag::__included_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_files",
                                ));
                            }
                            result.included_files = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_to_build => {
                            if !fields.insert(__FieldTag::__source_to_build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_to_build",
                                ));
                            }
                            result.source_to_build = map
                                .next_value::<std::option::Option<crate::model::GitRepoSource>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_event_config => {
                            if !fields.insert(__FieldTag::__repository_event_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_event_config",
                                ));
                            }
                            result.repository_event_config = map.next_value::<std::option::Option<crate::model::RepositoryEventConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::RepositoryEventConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __repository_type,
            __pull_request,
            __push,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepositoryEventConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "repositoryType" => Ok(__FieldTag::__repository_type),
                            "repository_type" => Ok(__FieldTag::__repository_type),
                            "pullRequest" => Ok(__FieldTag::__pull_request),
                            "pull_request" => Ok(__FieldTag::__pull_request),
                            "push" => Ok(__FieldTag::__push),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::RepositoryEventConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepositoryEventConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_type => {
                            if !fields.insert(__FieldTag::__repository_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_type",
                                ));
                            }
                            result.repository_type = map
                                .next_value::<std::option::Option<
                                    crate::model::repository_event_config::RepositoryType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pull_request => {
                            if !fields.insert(__FieldTag::__pull_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_request",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.devtools.cloudbuild.v1.RepositoryEventConfig.pull_request, latest field was pullRequest",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::repository_event_config::Filter::PullRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PullRequestFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__push => {
                            if !fields.insert(__FieldTag::__push) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.devtools.cloudbuild.v1.RepositoryEventConfig.push, latest field was push",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::repository_event_config::Filter::Push(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PushFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitHubEventsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __installation_id,
            __owner,
            __name,
            __pull_request,
            __push,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEventsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "installationId" => Ok(__FieldTag::__installation_id),
                            "installation_id" => Ok(__FieldTag::__installation_id),
                            "owner" => Ok(__FieldTag::__owner),
                            "name" => Ok(__FieldTag::__name),
                            "pullRequest" => Ok(__FieldTag::__pull_request),
                            "pull_request" => Ok(__FieldTag::__pull_request),
                            "push" => Ok(__FieldTag::__push),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitHubEventsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEventsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__installation_id => {
                            if !fields.insert(__FieldTag::__installation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installation_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.installation_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner",
                                ));
                            }
                            result.owner = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pull_request => {
                            if !fields.insert(__FieldTag::__pull_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_request",
                                ));
                            }
                            if result.event.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `event`, a oneof with full ID .google.devtools.cloudbuild.v1.GitHubEventsConfig.pull_request, latest field was pullRequest",
                                ));
                            }
                            result.event = std::option::Option::Some(
                                crate::model::git_hub_events_config::Event::PullRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PullRequestFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__push => {
                            if !fields.insert(__FieldTag::__push) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push",
                                ));
                            }
                            if result.event.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `event`, a oneof with full ID .google.devtools.cloudbuild.v1.GitHubEventsConfig.push, latest field was push",
                                ));
                            }
                            result.event = std::option::Option::Some(
                                crate::model::git_hub_events_config::Event::Push(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PushFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::PubsubConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            __topic,
            __service_account_email,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PubsubConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            "topic" => Ok(__FieldTag::__topic),
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::PubsubConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PubsubConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::pubsub_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::WebhookConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secret" => Ok(__FieldTag::__secret),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::WebhookConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.auth_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `auth_method`, a oneof with full ID .google.devtools.cloudbuild.v1.WebhookConfig.secret, latest field was secret",
                                ));
                            }
                            result.auth_method = std::option::Option::Some(
                                crate::model::webhook_config::AuthMethod::Secret(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::webhook_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::PullRequestFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __branch,
            __comment_control,
            __invert_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PullRequestFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "branch" => Ok(__FieldTag::__branch),
                            "commentControl" => Ok(__FieldTag::__comment_control),
                            "comment_control" => Ok(__FieldTag::__comment_control),
                            "invertRegex" => Ok(__FieldTag::__invert_regex),
                            "invert_regex" => Ok(__FieldTag::__invert_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::PullRequestFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PullRequestFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__branch => {
                            if !fields.insert(__FieldTag::__branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch",
                                ));
                            }
                            if result.git_ref.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `git_ref`, a oneof with full ID .google.devtools.cloudbuild.v1.PullRequestFilter.branch, latest field was branch",
                                ));
                            }
                            result.git_ref = std::option::Option::Some(
                                crate::model::pull_request_filter::GitRef::Branch(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__comment_control => {
                            if !fields.insert(__FieldTag::__comment_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment_control",
                                ));
                            }
                            result.comment_control = map
                                .next_value::<std::option::Option<
                                    crate::model::pull_request_filter::CommentControl,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invert_regex => {
                            if !fields.insert(__FieldTag::__invert_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invert_regex",
                                ));
                            }
                            result.invert_regex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::PushFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __branch,
            __tag,
            __invert_regex,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PushFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "branch" => Ok(__FieldTag::__branch),
                            "tag" => Ok(__FieldTag::__tag),
                            "invertRegex" => Ok(__FieldTag::__invert_regex),
                            "invert_regex" => Ok(__FieldTag::__invert_regex),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::PushFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PushFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__branch => {
                            if !fields.insert(__FieldTag::__branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch",
                                ));
                            }
                            if result.git_ref.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `git_ref`, a oneof with full ID .google.devtools.cloudbuild.v1.PushFilter.branch, latest field was branch",
                                ));
                            }
                            result.git_ref = std::option::Option::Some(
                                crate::model::push_filter::GitRef::Branch(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            if result.git_ref.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `git_ref`, a oneof with full ID .google.devtools.cloudbuild.v1.PushFilter.tag, latest field was tag",
                                ));
                            }
                            result.git_ref =
                                std::option::Option::Some(crate::model::push_filter::GitRef::Tag(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__invert_regex => {
                            if !fields.insert(__FieldTag::__invert_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invert_regex",
                                ));
                            }
                            result.invert_regex = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::CreateBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __trigger,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "trigger" => Ok(__FieldTag::__trigger),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::CreateBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<crate::model::BuildTrigger>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GetBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __trigger_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GetBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ListBuildTriggersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_id,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildTriggersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ListBuildTriggersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildTriggersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ListBuildTriggersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __triggers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBuildTriggersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "triggers" => Ok(__FieldTag::__triggers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ListBuildTriggersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBuildTriggersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__triggers => {
                            if !fields.insert(__FieldTag::__triggers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggers",
                                ));
                            }
                            result.triggers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuildTrigger>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::DeleteBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __trigger_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::DeleteBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UpdateBuildTriggerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __trigger_id,
            __trigger,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBuildTriggerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "triggerId" => Ok(__FieldTag::__trigger_id),
                            "trigger_id" => Ok(__FieldTag::__trigger_id),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UpdateBuildTriggerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBuildTriggerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_id => {
                            if !fields.insert(__FieldTag::__trigger_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_id",
                                ));
                            }
                            result.trigger_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<crate::model::BuildTrigger>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::BuildOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_provenance_hash,
            __requested_verify_option,
            __machine_type,
            __disk_size_gb,
            __substitution_option,
            __dynamic_substitutions,
            __automap_substitutions,
            __log_streaming_option,
            __worker_pool,
            __pool,
            __logging,
            __env,
            __secret_env,
            __volumes,
            __default_logs_bucket_behavior,
            __enable_structured_logging,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceProvenanceHash" => Ok(__FieldTag::__source_provenance_hash),
                            "source_provenance_hash" => Ok(__FieldTag::__source_provenance_hash),
                            "requestedVerifyOption" => Ok(__FieldTag::__requested_verify_option),
                            "requested_verify_option" => Ok(__FieldTag::__requested_verify_option),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "substitutionOption" => Ok(__FieldTag::__substitution_option),
                            "substitution_option" => Ok(__FieldTag::__substitution_option),
                            "dynamicSubstitutions" => Ok(__FieldTag::__dynamic_substitutions),
                            "dynamic_substitutions" => Ok(__FieldTag::__dynamic_substitutions),
                            "automapSubstitutions" => Ok(__FieldTag::__automap_substitutions),
                            "automap_substitutions" => Ok(__FieldTag::__automap_substitutions),
                            "logStreamingOption" => Ok(__FieldTag::__log_streaming_option),
                            "log_streaming_option" => Ok(__FieldTag::__log_streaming_option),
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "pool" => Ok(__FieldTag::__pool),
                            "logging" => Ok(__FieldTag::__logging),
                            "env" => Ok(__FieldTag::__env),
                            "secretEnv" => Ok(__FieldTag::__secret_env),
                            "secret_env" => Ok(__FieldTag::__secret_env),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "defaultLogsBucketBehavior" => {
                                Ok(__FieldTag::__default_logs_bucket_behavior)
                            }
                            "default_logs_bucket_behavior" => {
                                Ok(__FieldTag::__default_logs_bucket_behavior)
                            }
                            "enableStructuredLogging" => {
                                Ok(__FieldTag::__enable_structured_logging)
                            }
                            "enable_structured_logging" => {
                                Ok(__FieldTag::__enable_structured_logging)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::BuildOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_provenance_hash => {
                            if !fields.insert(__FieldTag::__source_provenance_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_provenance_hash",
                                ));
                            }
                            result.source_provenance_hash =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::hash::HashType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_verify_option => {
                            if !fields.insert(__FieldTag::__requested_verify_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_verify_option",
                                ));
                            }
                            result.requested_verify_option = map.next_value::<std::option::Option<crate::model::build_options::VerifyOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map.next_value::<std::option::Option<crate::model::build_options::MachineType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__substitution_option => {
                            if !fields.insert(__FieldTag::__substitution_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitution_option",
                                ));
                            }
                            result.substitution_option = map
                                .next_value::<std::option::Option<
                                    crate::model::build_options::SubstitutionOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dynamic_substitutions => {
                            if !fields.insert(__FieldTag::__dynamic_substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dynamic_substitutions",
                                ));
                            }
                            result.dynamic_substitutions = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automap_substitutions => {
                            if !fields.insert(__FieldTag::__automap_substitutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automap_substitutions",
                                ));
                            }
                            result.automap_substitutions = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_streaming_option => {
                            if !fields.insert(__FieldTag::__log_streaming_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_streaming_option",
                                ));
                            }
                            result.log_streaming_option = map
                                .next_value::<std::option::Option<
                                    crate::model::build_options::LogStreamingOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pool => {
                            if !fields.insert(__FieldTag::__pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pool",
                                ));
                            }
                            result.pool = map.next_value::<std::option::Option<crate::model::build_options::PoolOption>>()?
                                ;
                        }
                        __FieldTag::__logging => {
                            if !fields.insert(__FieldTag::__logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging",
                                ));
                            }
                            result.logging = map.next_value::<std::option::Option<crate::model::build_options::LoggingMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__secret_env => {
                            if !fields.insert(__FieldTag::__secret_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_env",
                                ));
                            }
                            result.secret_env = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_logs_bucket_behavior => {
                            if !fields.insert(__FieldTag::__default_logs_bucket_behavior) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_logs_bucket_behavior",
                                ));
                            }
                            result.default_logs_bucket_behavior = map
                                .next_value::<std::option::Option<
                                    crate::model::build_options::DefaultLogsBucketBehavior,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_structured_logging => {
                            if !fields.insert(__FieldTag::__enable_structured_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_structured_logging",
                                ));
                            }
                            result.enable_structured_logging = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::build_options::PoolOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PoolOption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::build_options::PoolOption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PoolOption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ReceiveTriggerWebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __body,
            __project_id,
            __trigger,
            __secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReceiveTriggerWebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "body" => Ok(__FieldTag::__body),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "trigger" => Ok(__FieldTag::__trigger),
                            "secret" => Ok(__FieldTag::__secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ReceiveTriggerWebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReceiveTriggerWebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<api::model::HttpBody>>()?;
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger => {
                            if !fields.insert(__FieldTag::__trigger) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger",
                                ));
                            }
                            result.trigger = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ReceiveTriggerWebhookResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReceiveTriggerWebhookResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ReceiveTriggerWebhookResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReceiveTriggerWebhookResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitHubEnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __host_url,
            __app_id,
            __create_time,
            __webhook_key,
            __peered_network,
            __secrets,
            __display_name,
            __ssl_ca,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "hostUrl" => Ok(__FieldTag::__host_url),
                            "host_url" => Ok(__FieldTag::__host_url),
                            "appId" => Ok(__FieldTag::__app_id),
                            "app_id" => Ok(__FieldTag::__app_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "webhookKey" => Ok(__FieldTag::__webhook_key),
                            "webhook_key" => Ok(__FieldTag::__webhook_key),
                            "peeredNetwork" => Ok(__FieldTag::__peered_network),
                            "peered_network" => Ok(__FieldTag::__peered_network),
                            "secrets" => Ok(__FieldTag::__secrets),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sslCa" => Ok(__FieldTag::__ssl_ca),
                            "ssl_ca" => Ok(__FieldTag::__ssl_ca),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitHubEnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host_url => {
                            if !fields.insert(__FieldTag::__host_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_url",
                                ));
                            }
                            result.host_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_id => {
                            if !fields.insert(__FieldTag::__app_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.app_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__webhook_key => {
                            if !fields.insert(__FieldTag::__webhook_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_key",
                                ));
                            }
                            result.webhook_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peered_network => {
                            if !fields.insert(__FieldTag::__peered_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peered_network",
                                ));
                            }
                            result.peered_network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secrets => {
                            if !fields.insert(__FieldTag::__secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secrets",
                                ));
                            }
                            result.secrets = map.next_value::<std::option::Option<crate::model::GitHubEnterpriseSecrets>>()?
                                ;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_ca => {
                            if !fields.insert(__FieldTag::__ssl_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_ca",
                                ));
                            }
                            result.ssl_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GitHubEnterpriseSecrets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_key_version_name,
            __webhook_secret_version_name,
            __oauth_secret_version_name,
            __oauth_client_id_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEnterpriseSecrets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateKeyVersionName" => Ok(__FieldTag::__private_key_version_name),
                            "private_key_version_name" => {
                                Ok(__FieldTag::__private_key_version_name)
                            }
                            "webhookSecretVersionName" => {
                                Ok(__FieldTag::__webhook_secret_version_name)
                            }
                            "webhook_secret_version_name" => {
                                Ok(__FieldTag::__webhook_secret_version_name)
                            }
                            "oauthSecretVersionName" => Ok(__FieldTag::__oauth_secret_version_name),
                            "oauth_secret_version_name" => {
                                Ok(__FieldTag::__oauth_secret_version_name)
                            }
                            "oauthClientIdVersionName" => {
                                Ok(__FieldTag::__oauth_client_id_version_name)
                            }
                            "oauth_client_id_version_name" => {
                                Ok(__FieldTag::__oauth_client_id_version_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GitHubEnterpriseSecrets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEnterpriseSecrets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_key_version_name => {
                            if !fields.insert(__FieldTag::__private_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key_version_name",
                                ));
                            }
                            result.private_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_secret_version_name => {
                            if !fields.insert(__FieldTag::__webhook_secret_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_version_name",
                                ));
                            }
                            result.webhook_secret_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oauth_secret_version_name => {
                            if !fields.insert(__FieldTag::__oauth_secret_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_secret_version_name",
                                ));
                            }
                            result.oauth_secret_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oauth_client_id_version_name => {
                            if !fields.insert(__FieldTag::__oauth_client_id_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_client_id_version_name",
                                ));
                            }
                            result.oauth_client_id_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::WorkerPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __annotations,
            __create_time,
            __update_time,
            __delete_time,
            __state,
            __private_pool_v1_config,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkerPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "state" => Ok(__FieldTag::__state),
                            "privatePoolV1Config" => Ok(__FieldTag::__private_pool_v1_config),
                            "private_pool_v1_config" => Ok(__FieldTag::__private_pool_v1_config),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::WorkerPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkerPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::worker_pool::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__private_pool_v1_config => {
                            if !fields.insert(__FieldTag::__private_pool_v1_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_pool_v1_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.devtools.cloudbuild.v1.WorkerPool.private_pool_v1_config, latest field was privatePoolV1Config",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::worker_pool::Config::PrivatePoolV1Config(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrivatePoolV1Config>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::PrivatePoolV1Config {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_config,
            __network_config,
            __private_service_connect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivatePoolV1Config")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerConfig" => Ok(__FieldTag::__worker_config),
                            "worker_config" => Ok(__FieldTag::__worker_config),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "privateServiceConnect" => Ok(__FieldTag::__private_service_connect),
                            "private_service_connect" => Ok(__FieldTag::__private_service_connect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::PrivatePoolV1Config;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivatePoolV1Config")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_config => {
                            if !fields.insert(__FieldTag::__worker_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_config",
                                ));
                            }
                            result.worker_config = map.next_value::<std::option::Option<
                                crate::model::private_pool_v_1_config::WorkerConfig,
                            >>()?;
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map.next_value::<std::option::Option<
                                crate::model::private_pool_v_1_config::NetworkConfig,
                            >>()?;
                        }
                        __FieldTag::__private_service_connect => {
                            if !fields.insert(__FieldTag::__private_service_connect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_service_connect",
                                ));
                            }
                            result.private_service_connect = map.next_value::<std::option::Option<
                                crate::model::private_pool_v_1_config::PrivateServiceConnect,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::private_pool_v_1_config::WorkerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            __disk_size_gb,
            __enable_nested_virtualization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "enableNestedVirtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "enable_nested_virtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::private_pool_v_1_config::WorkerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_nested_virtualization => {
                            if !fields.insert(__FieldTag::__enable_nested_virtualization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_nested_virtualization",
                                ));
                            }
                            result.enable_nested_virtualization =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::private_pool_v_1_config::NetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __peered_network,
            __egress_option,
            __peered_network_ip_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "peeredNetwork" => Ok(__FieldTag::__peered_network),
                            "peered_network" => Ok(__FieldTag::__peered_network),
                            "egressOption" => Ok(__FieldTag::__egress_option),
                            "egress_option" => Ok(__FieldTag::__egress_option),
                            "peeredNetworkIpRange" => Ok(__FieldTag::__peered_network_ip_range),
                            "peered_network_ip_range" => Ok(__FieldTag::__peered_network_ip_range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::private_pool_v_1_config::NetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__peered_network => {
                            if !fields.insert(__FieldTag::__peered_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peered_network",
                                ));
                            }
                            result.peered_network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__egress_option => {
                            if !fields.insert(__FieldTag::__egress_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for egress_option",
                                ));
                            }
                            result.egress_option = map.next_value::<std::option::Option<crate::model::private_pool_v_1_config::network_config::EgressOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__peered_network_ip_range => {
                            if !fields.insert(__FieldTag::__peered_network_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peered_network_ip_range",
                                ));
                            }
                            result.peered_network_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for crate::model::private_pool_v_1_config::PrivateServiceConnect
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_attachment,
            __public_ip_address_disabled,
            __route_all_traffic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateServiceConnect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkAttachment" => Ok(__FieldTag::__network_attachment),
                            "network_attachment" => Ok(__FieldTag::__network_attachment),
                            "publicIpAddressDisabled" => {
                                Ok(__FieldTag::__public_ip_address_disabled)
                            }
                            "public_ip_address_disabled" => {
                                Ok(__FieldTag::__public_ip_address_disabled)
                            }
                            "routeAllTraffic" => Ok(__FieldTag::__route_all_traffic),
                            "route_all_traffic" => Ok(__FieldTag::__route_all_traffic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::private_pool_v_1_config::PrivateServiceConnect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateServiceConnect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_attachment => {
                            if !fields.insert(__FieldTag::__network_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_attachment",
                                ));
                            }
                            result.network_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip_address_disabled => {
                            if !fields.insert(__FieldTag::__public_ip_address_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip_address_disabled",
                                ));
                            }
                            result.public_ip_address_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__route_all_traffic => {
                            if !fields.insert(__FieldTag::__route_all_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_all_traffic",
                                ));
                            }
                            result.route_all_traffic = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::CreateWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __worker_pool,
            __worker_pool_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "workerPoolId" => Ok(__FieldTag::__worker_pool_id),
                            "worker_pool_id" => Ok(__FieldTag::__worker_pool_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::CreateWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool =
                                map.next_value::<std::option::Option<crate::model::WorkerPool>>()?;
                        }
                        __FieldTag::__worker_pool_id => {
                            if !fields.insert(__FieldTag::__worker_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool_id",
                                ));
                            }
                            result.worker_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::GetWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::GetWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::DeleteWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::DeleteWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UpdateWorkerPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkerPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UpdateWorkerPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkerPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool =
                                map.next_value::<std::option::Option<crate::model::WorkerPool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ListWorkerPoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkerPoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ListWorkerPoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkerPoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::ListWorkerPoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkerPoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPools" => Ok(__FieldTag::__worker_pools),
                            "worker_pools" => Ok(__FieldTag::__worker_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::ListWorkerPoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkerPoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pools => {
                            if !fields.insert(__FieldTag::__worker_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pools",
                                ));
                            }
                            result.worker_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WorkerPool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::CreateWorkerPoolOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __create_time,
            __complete_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkerPoolOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::CreateWorkerPoolOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkerPoolOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::UpdateWorkerPoolOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __create_time,
            __complete_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkerPoolOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::UpdateWorkerPoolOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkerPoolOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for crate::model::DeleteWorkerPoolOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __create_time,
            __complete_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkerPoolOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = crate::model::DeleteWorkerPoolOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkerPoolOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
