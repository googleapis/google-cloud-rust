// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::RetryBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RunBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunBuildTriggerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StorageSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageSource");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("source_fetcher", &self.source_fetcher);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitSource");
        debug_struct.field("url", &self.url);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RepoSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepoSource");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("repo_name", &self.repo_name);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("substitutions", &self.substitutions);
        debug_struct.field("revision", &self.revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StorageSourceManifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageSourceManifest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuiltImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuiltImage");
        debug_struct.field("name", &self.name);
        debug_struct.field("digest", &self.digest);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UploadedPythonPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedPythonPackage");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UploadedMavenArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedMavenArtifact");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UploadedGoModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedGoModule");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UploadedNpmPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadedNpmPackage");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("file_hashes", &self.file_hashes);
        debug_struct.field("push_timing", &self.push_timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildStep");
        debug_struct.field("name", &self.name);
        debug_struct.field("env", &self.env);
        debug_struct.field("args", &self.args);
        debug_struct.field("dir", &self.dir);
        debug_struct.field("id", &self.id);
        debug_struct.field("wait_for", &self.wait_for);
        debug_struct.field("entrypoint", &self.entrypoint);
        debug_struct.field("secret_env", &self.secret_env);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("timing", &self.timing);
        debug_struct.field("pull_timing", &self.pull_timing);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("status", &self.status);
        debug_struct.field("allow_failure", &self.allow_failure);
        debug_struct.field("exit_code", &self.exit_code);
        debug_struct.field("allow_exit_codes", &self.allow_exit_codes);
        debug_struct.field("script", &self.script);
        debug_struct.field("automap_substitutions", &self.automap_substitutions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Volume");
        debug_struct.field("name", &self.name);
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Results {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Results");
        debug_struct.field("images", &self.images);
        debug_struct.field("build_step_images", &self.build_step_images);
        debug_struct.field("artifact_manifest", &self.artifact_manifest);
        debug_struct.field("num_artifacts", &self.num_artifacts);
        debug_struct.field("build_step_outputs", &self.build_step_outputs);
        debug_struct.field("artifact_timing", &self.artifact_timing);
        debug_struct.field("python_packages", &self.python_packages);
        debug_struct.field("maven_artifacts", &self.maven_artifacts);
        debug_struct.field("go_modules", &self.go_modules);
        debug_struct.field("npm_packages", &self.npm_packages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ArtifactResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArtifactResult");
        debug_struct.field("location", &self.location);
        debug_struct.field("file_hash", &self.file_hash);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Build {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Build");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_detail", &self.status_detail);
        debug_struct.field("source", &self.source);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("results", &self.results);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("finish_time", &self.finish_time);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("images", &self.images);
        debug_struct.field("queue_ttl", &self.queue_ttl);
        debug_struct.field("artifacts", &self.artifacts);
        debug_struct.field("logs_bucket", &self.logs_bucket);
        debug_struct.field("source_provenance", &self.source_provenance);
        debug_struct.field("build_trigger_id", &self.build_trigger_id);
        debug_struct.field("options", &self.options);
        debug_struct.field("log_url", &self.log_url);
        debug_struct.field("substitutions", &self.substitutions);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("secrets", &self.secrets);
        debug_struct.field("timing", &self.timing);
        debug_struct.field("approval", &self.approval);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("available_secrets", &self.available_secrets);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("git_config", &self.git_config);
        debug_struct.field("failure_info", &self.failure_info);
        debug_struct.field("dependencies", &self.dependencies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::build::Warning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Warning");
        debug_struct.field("text", &self.text);
        debug_struct.field("priority", &self.priority);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::build::FailureInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FailureInfo");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("detail", &self.detail);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Dependency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dependency");
        debug_struct.field("dep", &self.dep);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::dependency::GitSourceDependency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitSourceDependency");
        debug_struct.field("repository", &self.repository);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("recurse_submodules", &self.recurse_submodules);
        debug_struct.field("depth", &self.depth);
        debug_struct.field("dest_path", &self.dest_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::dependency::GitSourceRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitSourceRepository");
        debug_struct.field("repotype", &self.repotype);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitConfig");
        debug_struct.field("http", &self.http);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::git_config::HttpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpConfig");
        debug_struct.field("proxy_secret_version_name", &self.proxy_secret_version_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Artifacts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Artifacts");
        debug_struct.field("images", &self.images);
        debug_struct.field("objects", &self.objects);
        debug_struct.field("maven_artifacts", &self.maven_artifacts);
        debug_struct.field("go_modules", &self.go_modules);
        debug_struct.field("python_packages", &self.python_packages);
        debug_struct.field("npm_packages", &self.npm_packages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::artifacts::ArtifactObjects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArtifactObjects");
        debug_struct.field("location", &self.location);
        debug_struct.field("paths", &self.paths);
        debug_struct.field("timing", &self.timing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::artifacts::MavenArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MavenArtifact");
        debug_struct.field("repository", &self.repository);
        debug_struct.field("path", &self.path);
        debug_struct.field("artifact_id", &self.artifact_id);
        debug_struct.field("group_id", &self.group_id);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::artifacts::GoModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoModule");
        debug_struct.field("repository_name", &self.repository_name);
        debug_struct.field("repository_location", &self.repository_location);
        debug_struct.field("repository_project_id", &self.repository_project_id);
        debug_struct.field("source_path", &self.source_path);
        debug_struct.field("module_path", &self.module_path);
        debug_struct.field("module_version", &self.module_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::artifacts::PythonPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PythonPackage");
        debug_struct.field("repository", &self.repository);
        debug_struct.field("paths", &self.paths);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::artifacts::NpmPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NpmPackage");
        debug_struct.field("repository", &self.repository);
        debug_struct.field("package_path", &self.package_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TimeSpan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeSpan");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildOperationMetadata");
        debug_struct.field("build", &self.build);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceProvenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceProvenance");
        debug_struct.field("resolved_storage_source", &self.resolved_storage_source);
        debug_struct.field("resolved_repo_source", &self.resolved_repo_source);
        debug_struct.field(
            "resolved_storage_source_manifest",
            &self.resolved_storage_source_manifest,
        );
        debug_struct.field("file_hashes", &self.file_hashes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FileHashes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FileHashes");
        debug_struct.field("file_hash", &self.file_hash);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Hash");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Secrets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secrets");
        debug_struct.field("secret_manager", &self.secret_manager);
        debug_struct.field("inline", &self.inline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InlineSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InlineSecret");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("env_map", &self.env_map);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretManagerSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretManagerSecret");
        debug_struct.field("version_name", &self.version_name);
        debug_struct.field("env", &self.env);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Secret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Secret");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("secret_env", &self.secret_env);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBuildRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("build", &self.build);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBuildsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBuildsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildsResponse");
        debug_struct.field("builds", &self.builds);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CancelBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ApproveBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApproveBuildRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("approval_result", &self.approval_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildApproval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildApproval");
        debug_struct.field("state", &self.state);
        debug_struct.field("config", &self.config);
        debug_struct.field("result", &self.result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ApprovalConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApprovalConfig");
        debug_struct.field("approval_required", &self.approval_required);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ApprovalResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApprovalResult");
        debug_struct.field("approver_account", &self.approver_account);
        debug_struct.field("approval_time", &self.approval_time);
        debug_struct.field("decision", &self.decision);
        debug_struct.field("comment", &self.comment);
        debug_struct.field("url", &self.url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitRepoSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitRepoSource");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("r#ref", &self.r#ref);
        debug_struct.field("repo_type", &self.repo_type);
        debug_struct.field("source", &self.source);
        debug_struct.field("enterprise_config", &self.enterprise_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitFileSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitFileSource");
        debug_struct.field("path", &self.path);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("repo_type", &self.repo_type);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("source", &self.source);
        debug_struct.field("enterprise_config", &self.enterprise_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildTrigger {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildTrigger");
        debug_struct.field("resource_name", &self.resource_name);
        debug_struct.field("id", &self.id);
        debug_struct.field("description", &self.description);
        debug_struct.field("name", &self.name);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("trigger_template", &self.trigger_template);
        debug_struct.field("github", &self.github);
        debug_struct.field("pubsub_config", &self.pubsub_config);
        debug_struct.field("webhook_config", &self.webhook_config);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("substitutions", &self.substitutions);
        debug_struct.field("ignored_files", &self.ignored_files);
        debug_struct.field("included_files", &self.included_files);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("source_to_build", &self.source_to_build);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("repository_event_config", &self.repository_event_config);
        debug_struct.field("build_template", &self.build_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RepositoryEventConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepositoryEventConfig");
        debug_struct.field("repository", &self.repository);
        debug_struct.field("repository_type", &self.repository_type);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitHubEventsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEventsConfig");
        debug_struct.field("installation_id", &self.installation_id);
        debug_struct.field("owner", &self.owner);
        debug_struct.field("name", &self.name);
        debug_struct.field("event", &self.event);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PubsubConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PubsubConfig");
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("topic", &self.topic);
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WebhookConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebhookConfig");
        debug_struct.field("state", &self.state);
        debug_struct.field("auth_method", &self.auth_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PullRequestFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PullRequestFilter");
        debug_struct.field("comment_control", &self.comment_control);
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("git_ref", &self.git_ref);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PushFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PushFilter");
        debug_struct.field("invert_regex", &self.invert_regex);
        debug_struct.field("git_ref", &self.git_ref);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBuildTriggerRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger", &self.trigger);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBuildTriggerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBuildTriggersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildTriggersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBuildTriggersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBuildTriggersResponse");
        debug_struct.field("triggers", &self.triggers);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBuildTriggerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBuildTriggerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBuildTriggerRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger_id", &self.trigger_id);
        debug_struct.field("trigger", &self.trigger);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildOptions");
        debug_struct.field("source_provenance_hash", &self.source_provenance_hash);
        debug_struct.field("requested_verify_option", &self.requested_verify_option);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("substitution_option", &self.substitution_option);
        debug_struct.field("dynamic_substitutions", &self.dynamic_substitutions);
        debug_struct.field("automap_substitutions", &self.automap_substitutions);
        debug_struct.field("log_streaming_option", &self.log_streaming_option);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("pool", &self.pool);
        debug_struct.field("logging", &self.logging);
        debug_struct.field("env", &self.env);
        debug_struct.field("secret_env", &self.secret_env);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field(
            "default_logs_bucket_behavior",
            &self.default_logs_bucket_behavior,
        );
        debug_struct.field("enable_structured_logging", &self.enable_structured_logging);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::build_options::PoolOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PoolOption");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReceiveTriggerWebhookRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReceiveTriggerWebhookRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("body", &self.body);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("trigger", &self.trigger);
        debug_struct.field("secret", &self.secret);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReceiveTriggerWebhookResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReceiveTriggerWebhookResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitHubEnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEnterpriseConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("host_url", &self.host_url);
        debug_struct.field("app_id", &self.app_id);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("webhook_key", &self.webhook_key);
        debug_struct.field("peered_network", &self.peered_network);
        debug_struct.field("secrets", &self.secrets);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("ssl_ca", &self.ssl_ca);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitHubEnterpriseSecrets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEnterpriseSecrets");
        debug_struct.field("private_key_version_name", &self.private_key_version_name);
        debug_struct.field(
            "webhook_secret_version_name",
            &self.webhook_secret_version_name,
        );
        debug_struct.field("oauth_secret_version_name", &self.oauth_secret_version_name);
        debug_struct.field(
            "oauth_client_id_version_name",
            &self.oauth_client_id_version_name,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkerPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerPool");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivatePoolV1Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivatePoolV1Config");
        debug_struct.field("worker_config", &self.worker_config);
        debug_struct.field("network_config", &self.network_config);
        debug_struct.field("private_service_connect", &self.private_service_connect);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::private_pool_v_1_config::WorkerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerConfig");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field(
            "enable_nested_virtualization",
            &self.enable_nested_virtualization,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::private_pool_v_1_config::NetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkConfig");
        debug_struct.field("peered_network", &self.peered_network);
        debug_struct.field("egress_option", &self.egress_option);
        debug_struct.field("peered_network_ip_range", &self.peered_network_ip_range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::private_pool_v_1_config::PrivateServiceConnect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateServiceConnect");
        debug_struct.field("network_attachment", &self.network_attachment);
        debug_struct.field(
            "public_ip_address_disabled",
            &self.public_ip_address_disabled,
        );
        debug_struct.field("route_all_traffic", &self.route_all_traffic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWorkerPoolRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("worker_pool_id", &self.worker_pool_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetWorkerPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWorkerPoolRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWorkerPoolRequest");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkerPoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkerPoolsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkerPoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkerPoolsResponse");
        debug_struct.field("worker_pools", &self.worker_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateWorkerPoolOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWorkerPoolOperationMetadata");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("complete_time", &self.complete_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateWorkerPoolOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWorkerPoolOperationMetadata");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("complete_time", &self.complete_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteWorkerPoolOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWorkerPoolOperationMetadata");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("complete_time", &self.complete_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
