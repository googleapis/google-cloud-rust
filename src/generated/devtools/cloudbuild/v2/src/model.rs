// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.OperationMetadata"
    }
}

/// Represents the custom metadata of the RunWorkflow long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunWorkflowCustomOperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. ID of the pipeline run created by RunWorkflow.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pipeline_run_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunWorkflowCustomOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::RunWorkflowCustomOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::RunWorkflowCustomOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::RunWorkflowCustomOperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::RunWorkflowCustomOperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::RunWorkflowCustomOperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [target][crate::model::RunWorkflowCustomOperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [pipeline_run_id][crate::model::RunWorkflowCustomOperationMetadata::pipeline_run_id].
    pub fn set_pipeline_run_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_run_id = v.into();
        self
    }
}

impl wkt::message::Message for RunWorkflowCustomOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.RunWorkflowCustomOperationMetadata"
    }
}

/// A connection to a SCM like GitHub, GitHub Enterprise, Bitbucket Data Center,
/// Bitbucket Cloud or GitLab.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// Immutable. The resource name of the connection, in the format
    /// `projects/{project}/locations/{location}/connections/{connection_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned timestamp for when the connection was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server assigned timestamp for when the connection was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Installation state of the Connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub installation_state: std::option::Option<crate::model::InstallationState>,

    /// If disabled is set to true, functionality is disabled for this connection.
    /// Repository based API methods and webhooks processing for repositories in
    /// this connection will be disabled.
    pub disabled: bool,

    /// Output only. Set to true when the connection is being set up or updated in
    /// the background.
    pub reconciling: bool,

    /// Allows clients to store small amounts of arbitrary data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Configuration for the connection depending on the type of provider.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connection_config: std::option::Option<crate::model::connection::ConnectionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connection::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Connection::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [installation_state][crate::model::Connection::installation_state].
    pub fn set_installation_state<
        T: std::convert::Into<std::option::Option<crate::model::InstallationState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.installation_state = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::Connection::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Connection::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Connection::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Connection::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config].
    ///
    /// Note that all the setters affecting `connection_config` are mutually
    /// exclusive.
    pub fn set_connection_config<
        T: std::convert::Into<std::option::Option<crate::model::connection::ConnectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = v.into();
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GithubConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_github_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitHubConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GithubConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_github_enterprise_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitHubEnterpriseConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GitlabConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gitlab_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitLabConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GitlabConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `BitbucketDataCenterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bitbucket_data_center_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BitbucketDataCenterConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::BitbucketDataCenterConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `BitbucketCloudConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bitbucket_cloud_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BitbucketCloudConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::BitbucketCloudConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GithubConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_github_config<T: std::convert::Into<std::boxed::Box<crate::model::GitHubConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GithubConfig(v.into()),
        );
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GitHubEnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GitlabConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_gitlab_config<T: std::convert::Into<std::boxed::Box<crate::model::GitLabConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GitlabConfig(v.into()),
        );
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `BitbucketDataCenterConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_bitbucket_data_center_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BitbucketDataCenterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::BitbucketDataCenterConfig(v.into()),
        );
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `BitbucketCloudConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_bitbucket_cloud_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BitbucketCloudConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::BitbucketCloudConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.Connection"
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the connection depending on the type of provider.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConnectionConfig {
        /// Configuration for connections to github.com.
        GithubConfig(std::boxed::Box<crate::model::GitHubConfig>),
        /// Configuration for connections to an instance of GitHub Enterprise.
        GithubEnterpriseConfig(std::boxed::Box<crate::model::GitHubEnterpriseConfig>),
        /// Configuration for connections to gitlab.com or an instance of GitLab
        /// Enterprise.
        GitlabConfig(std::boxed::Box<crate::model::GitLabConfig>),
        /// Configuration for connections to Bitbucket Data Center.
        BitbucketDataCenterConfig(std::boxed::Box<crate::model::BitbucketDataCenterConfig>),
        /// Configuration for connections to Bitbucket Cloud.
        BitbucketCloudConfig(std::boxed::Box<crate::model::BitbucketCloudConfig>),
    }
}

/// Describes stage and necessary actions to be taken by the
/// user to complete the installation. Used for GitHub and GitHub Enterprise
/// based connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstallationState {
    /// Output only. Current step of the installation process.
    pub stage: crate::model::installation_state::Stage,

    /// Output only. Message of what the user should do next to continue the
    /// installation. Empty string if the installation is already complete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Output only. Link to follow for next action. Empty string if the
    /// installation is already complete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstallationState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stage][crate::model::InstallationState::stage].
    pub fn set_stage<T: std::convert::Into<crate::model::installation_state::Stage>>(
        mut self,
        v: T,
    ) -> Self {
        self.stage = v.into();
        self
    }

    /// Sets the value of [message][crate::model::InstallationState::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [action_uri][crate::model::InstallationState::action_uri].
    pub fn set_action_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_uri = v.into();
        self
    }
}

impl wkt::message::Message for InstallationState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.InstallationState"
    }
}

/// Defines additional types related to [InstallationState].
pub mod installation_state {
    #[allow(unused_imports)]
    use super::*;

    /// Stage of the installation process.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Stage(i32);

    impl Stage {
        /// No stage specified.
        pub const STAGE_UNSPECIFIED: Stage = Stage::new(0);

        /// Only for GitHub Enterprise. An App creation has been requested.
        /// The user needs to confirm the creation in their GitHub enterprise host.
        pub const PENDING_CREATE_APP: Stage = Stage::new(1);

        /// User needs to authorize the GitHub (or Enterprise) App via OAuth.
        pub const PENDING_USER_OAUTH: Stage = Stage::new(2);

        /// User needs to follow the link to install the GitHub (or Enterprise) App.
        pub const PENDING_INSTALL_APP: Stage = Stage::new(3);

        /// Installation process has been completed.
        pub const COMPLETE: Stage = Stage::new(10);

        /// Creates a new Stage instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STAGE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING_CREATE_APP"),
                2 => std::borrow::Cow::Borrowed("PENDING_USER_OAUTH"),
                3 => std::borrow::Cow::Borrowed("PENDING_INSTALL_APP"),
                10 => std::borrow::Cow::Borrowed("COMPLETE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STAGE_UNSPECIFIED" => std::option::Option::Some(Self::STAGE_UNSPECIFIED),
                "PENDING_CREATE_APP" => std::option::Option::Some(Self::PENDING_CREATE_APP),
                "PENDING_USER_OAUTH" => std::option::Option::Some(Self::PENDING_USER_OAUTH),
                "PENDING_INSTALL_APP" => std::option::Option::Some(Self::PENDING_INSTALL_APP),
                "COMPLETE" => std::option::Option::Some(Self::COMPLETE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Stage {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Stage {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for FetchLinkableRepositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchLinkableRepositoriesRequest {
    /// Required. The name of the Connection.
    /// Format: `projects/*/locations/*/connections/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection: std::string::String,

    /// Number of results to return in the list. Default to 20.
    pub page_size: i32,

    /// Page start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchLinkableRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::FetchLinkableRepositoriesRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchLinkableRepositoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchLinkableRepositoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchLinkableRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchLinkableRepositoriesRequest"
    }
}

/// Response message for FetchLinkableRepositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchLinkableRepositoriesResponse {
    /// repositories ready to be created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub repositories: std::vec::Vec<crate::model::Repository>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchLinkableRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::FetchLinkableRepositoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [repositories][crate::model::FetchLinkableRepositoriesResponse::repositories].
    pub fn set_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Repository>,
    {
        use std::iter::Iterator;
        self.repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchLinkableRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchLinkableRepositoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchLinkableRepositoriesResponse {
    type PageItem = crate::model::Repository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.repositories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Configuration for connections to github.com.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubConfig {
    /// OAuth credential of the account that authorized the Cloud Build GitHub App.
    /// It is recommended to use a robot account instead of a human user account.
    /// The OAuth token must be tied to the Cloud Build GitHub App.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::OAuthCredential>,

    /// GitHub App installation id.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub app_installation_id: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authorizer_credential][crate::model::GitHubConfig::authorizer_credential].
    pub fn set_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::OAuthCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorizer_credential = v.into();
        self
    }

    /// Sets the value of [app_installation_id][crate::model::GitHubConfig::app_installation_id].
    pub fn set_app_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_installation_id = v.into();
        self
    }
}

impl wkt::message::Message for GitHubConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.GitHubConfig"
    }
}

/// Configuration for connections to an instance of GitHub Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEnterpriseConfig {
    /// Required. The URI of the GitHub Enterprise host this connection is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_uri: std::string::String,

    /// Required. API Key used for authentication of webhook events.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_key: std::string::String,

    /// Id of the GitHub App created from the manifest.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub app_id: i64,

    /// The URL-friendly name of the GitHub App.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_slug: std::string::String,

    /// SecretManager resource containing the private key of the GitHub App,
    /// formatted as `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_key_secret_version: std::string::String,

    /// SecretManager resource containing the webhook secret of the GitHub App,
    /// formatted as `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// ID of the installation of the GitHub App.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub app_installation_id: i64,

    /// Configuration for using Service Directory to privately connect to a GitHub
    /// Enterprise server. This should only be set if the GitHub Enterprise server
    /// is hosted on-premises and not reachable by public internet. If this field
    /// is left empty, calls to the GitHub Enterprise server will be made over the
    /// public internet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// SSL certificate to use for requests to GitHub Enterprise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_ca: std::string::String,

    /// Output only. GitHub Enterprise version installed at the host_uri.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GitHubEnterpriseConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [api_key][crate::model::GitHubEnterpriseConfig::api_key].
    pub fn set_api_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_key = v.into();
        self
    }

    /// Sets the value of [app_id][crate::model::GitHubEnterpriseConfig::app_id].
    pub fn set_app_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_id = v.into();
        self
    }

    /// Sets the value of [app_slug][crate::model::GitHubEnterpriseConfig::app_slug].
    pub fn set_app_slug<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_slug = v.into();
        self
    }

    /// Sets the value of [private_key_secret_version][crate::model::GitHubEnterpriseConfig::private_key_secret_version].
    pub fn set_private_key_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_key_secret_version = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitHubEnterpriseConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [app_installation_id][crate::model::GitHubEnterpriseConfig::app_installation_id].
    pub fn set_app_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_installation_id = v.into();
        self
    }

    /// Sets the value of [service_directory_config][crate::model::GitHubEnterpriseConfig::service_directory_config].
    pub fn set_service_directory_config<
        T: std::convert::Into<std::option::Option<crate::model::ServiceDirectoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory_config = v.into();
        self
    }

    /// Sets the value of [ssl_ca][crate::model::GitHubEnterpriseConfig::ssl_ca].
    pub fn set_ssl_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_ca = v.into();
        self
    }

    /// Sets the value of [server_version][crate::model::GitHubEnterpriseConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.GitHubEnterpriseConfig"
    }
}

/// Configuration for connections to gitlab.com or an instance of GitLab
/// Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitLabConfig {
    /// The URI of the GitLab Enterprise host this connection is for.
    /// If not specified, the default value is <https://gitlab.com>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_uri: std::string::String,

    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// of a GitLab Enterprise project, formatted as
    /// `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// Required. A GitLab personal access token with the minimum `read_api` scope
    /// access.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. A GitLab personal access token with the `api` scope access.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Configuration for using Service Directory to privately connect to a GitLab
    /// Enterprise server. This should only be set if the GitLab Enterprise server
    /// is hosted on-premises and not reachable by public internet. If this field
    /// is left empty, calls to the GitLab Enterprise server will be made over the
    /// public internet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// SSL certificate to use for requests to GitLab Enterprise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_ca: std::string::String,

    /// Output only. Version of the GitLab Enterprise server running on the
    /// `host_uri`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitLabConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GitLabConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitLabConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::GitLabConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_authorizer_credential = v.into();
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitLabConfig::authorizer_credential].
    pub fn set_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorizer_credential = v.into();
        self
    }

    /// Sets the value of [service_directory_config][crate::model::GitLabConfig::service_directory_config].
    pub fn set_service_directory_config<
        T: std::convert::Into<std::option::Option<crate::model::ServiceDirectoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory_config = v.into();
        self
    }

    /// Sets the value of [ssl_ca][crate::model::GitLabConfig::ssl_ca].
    pub fn set_ssl_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_ca = v.into();
        self
    }

    /// Sets the value of [server_version][crate::model::GitLabConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }
}

impl wkt::message::Message for GitLabConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.GitLabConfig"
    }
}

/// Configuration for connections to Bitbucket Data Center.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BitbucketDataCenterConfig {
    /// Required. The URI of the Bitbucket Data Center instance or cluster this
    /// connection is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_uri: std::string::String,

    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// used to verify webhook events, formatted as
    /// `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// Required. A http access token with the `REPO_READ` access.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. A http access token with the `REPO_ADMIN` scope access.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Optional. Configuration for using Service Directory to privately connect to
    /// a Bitbucket Data Center. This should only be set if the Bitbucket Data
    /// Center is hosted on-premises and not reachable by public internet. If this
    /// field is left empty, calls to the Bitbucket Data Center will be made over
    /// the public internet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// Optional. SSL certificate to use for requests to the Bitbucket Data Center.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_ca: std::string::String,

    /// Output only. Version of the Bitbucket Data Center running on the
    /// `host_uri`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BitbucketDataCenterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::BitbucketDataCenterConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::BitbucketDataCenterConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::BitbucketDataCenterConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_authorizer_credential = v.into();
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::BitbucketDataCenterConfig::authorizer_credential].
    pub fn set_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorizer_credential = v.into();
        self
    }

    /// Sets the value of [service_directory_config][crate::model::BitbucketDataCenterConfig::service_directory_config].
    pub fn set_service_directory_config<
        T: std::convert::Into<std::option::Option<crate::model::ServiceDirectoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_directory_config = v.into();
        self
    }

    /// Sets the value of [ssl_ca][crate::model::BitbucketDataCenterConfig::ssl_ca].
    pub fn set_ssl_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_ca = v.into();
        self
    }

    /// Sets the value of [server_version][crate::model::BitbucketDataCenterConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }
}

impl wkt::message::Message for BitbucketDataCenterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.BitbucketDataCenterConfig"
    }
}

/// Configuration for connections to Bitbucket Cloud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BitbucketCloudConfig {
    /// Required. The Bitbucket Cloud Workspace ID to be connected to Google Cloud
    /// Platform.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workspace: std::string::String,

    /// Required. SecretManager resource containing the webhook secret used to
    /// verify webhook events, formatted as `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// Required. An access token with the `repository` access. It can be either a
    /// workspace, project or repository access token. It's recommended to use a
    /// system account to generate the credentials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. An access token with the `webhook`, `repository`,
    /// `repository:admin` and `pullrequest` scope access. It can be either a
    /// workspace, project or repository access token. It's recommended to use a
    /// system account to generate these credentials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BitbucketCloudConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::BitbucketCloudConfig::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::BitbucketCloudConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::BitbucketCloudConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_authorizer_credential = v.into();
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::BitbucketCloudConfig::authorizer_credential].
    pub fn set_authorizer_credential<
        T: std::convert::Into<std::option::Option<crate::model::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorizer_credential = v.into();
        self
    }
}

impl wkt::message::Message for BitbucketCloudConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.BitbucketCloudConfig"
    }
}

/// ServiceDirectoryConfig represents Service Directory configuration for a
/// connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceDirectoryConfig {
    /// Required. The Service Directory service name.
    /// Format:
    /// projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceDirectoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::ServiceDirectoryConfig::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for ServiceDirectoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.ServiceDirectoryConfig"
    }
}

/// A repository associated to a parent connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Repository {
    /// Immutable. Resource name of the repository, in the format
    /// `projects/*/locations/*/connections/*/repositories/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Git Clone HTTPS URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remote_uri: std::string::String,

    /// Output only. Server assigned timestamp for when the connection was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server assigned timestamp for when the connection was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to store small amounts of arbitrary data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. External ID of the webhook created for the repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Repository {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Repository::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [remote_uri][crate::model::Repository::remote_uri].
    pub fn set_remote_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Repository::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Repository::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Repository::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [webhook_id][crate::model::Repository::webhook_id].
    pub fn set_webhook_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Repository::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Repository {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.Repository"
    }
}

/// Represents an OAuth token of the account that authorized the Connection,
/// and associated metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OAuthCredential {
    /// A SecretManager resource containing the OAuth token that authorizes
    /// the Cloud Build connection. Format: `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oauth_token_secret_version: std::string::String,

    /// Output only. The username associated to this token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuthCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oauth_token_secret_version][crate::model::OAuthCredential::oauth_token_secret_version].
    pub fn set_oauth_token_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_token_secret_version = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OAuthCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for OAuthCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.OAuthCredential"
    }
}

/// Represents a personal access token that authorized the Connection,
/// and associated metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserCredential {
    /// Required. A SecretManager resource containing the user token that
    /// authorizes the Cloud Build connection. Format:
    /// `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_token_secret_version: std::string::String,

    /// Output only. The username associated to this token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_token_secret_version][crate::model::UserCredential::user_token_secret_version].
    pub fn set_user_token_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_token_secret_version = v.into();
        self
    }

    /// Sets the value of [username][crate::model::UserCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for UserCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.UserCredential"
    }
}

/// Message for creating a Connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Project and location where the connection will be created.
    /// Format: `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Connection to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Required. The ID to use for the Connection, which will become the final
    /// component of the Connection's resource name. Names must be unique
    /// per-project per-location. Allows alphanumeric characters and any of
    /// -._~%!$&'()*+,;=@.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.CreateConnectionRequest"
    }
}

/// Message for getting the details of a Connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. The name of the Connection to retrieve.
    /// Format: `projects/*/locations/*/connections/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.GetConnectionRequest"
    }
}

/// Message for requesting list of Connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. The parent, which owns this collection of Connections.
    /// Format: `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Page start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.ListConnectionsRequest"
    }
}

/// Message for response to listing Connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// The list of Connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for updating a Connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. The Connection to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the connection is not found a new connection
    /// will be created. In this situation `update_mask` is ignored.
    /// The creation will succeed only if the input connection has all the
    /// necessary information (e.g a github_config with both  user_oauth_token and
    /// installation_id properties).
    pub allow_missing: bool,

    /// The current etag of the connection.
    /// If an etag is provided and does not match the current etag of the
    /// connection, update will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateConnectionRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UpdateConnectionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.UpdateConnectionRequest"
    }
}

/// Message for deleting a Connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. The name of the Connection to delete.
    /// Format: `projects/*/locations/*/connections/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current etag of the connection.
    /// If an etag is provided and does not match the current etag of the
    /// connection, deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteConnectionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.DeleteConnectionRequest"
    }
}

/// Message for creating a Repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRepositoryRequest {
    /// Required. The connection to contain the repository. If the request is part
    /// of a BatchCreateRepositoriesRequest, this field should be empty or match
    /// the parent specified there.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The repository to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repository: std::option::Option<crate::model::Repository>,

    /// Required. The ID to use for the repository, which will become the final
    /// component of the repository's resource name. This ID should be unique in
    /// the connection. Allows alphanumeric characters and any of
    /// -._~%!$&'()*+,;=@.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRepositoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::CreateRepositoryRequest::repository].
    pub fn set_repository<T: std::convert::Into<std::option::Option<crate::model::Repository>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [repository_id][crate::model::CreateRepositoryRequest::repository_id].
    pub fn set_repository_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.CreateRepositoryRequest"
    }
}

/// Message for creating repositoritories in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateRepositoriesRequest {
    /// Required. The connection to contain all the repositories being created.
    /// Format: projects/*/locations/*/connections/*
    /// The parent field in the CreateRepositoryRequest messages
    /// must either be empty or match this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request messages specifying the repositories to create.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateRepositoryRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateRepositoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateRepositoriesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateRepositoryRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.BatchCreateRepositoriesRequest"
    }
}

/// Message for response of creating repositories in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateRepositoriesResponse {
    /// Repository resources created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub repositories: std::vec::Vec<crate::model::Repository>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repositories][crate::model::BatchCreateRepositoriesResponse::repositories].
    pub fn set_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Repository>,
    {
        use std::iter::Iterator;
        self.repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.BatchCreateRepositoriesResponse"
    }
}

/// Message for getting the details of a Repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRepositoryRequest {
    /// Required. The name of the Repository to retrieve.
    /// Format: `projects/*/locations/*/connections/*/repositories/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRepositoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.GetRepositoryRequest"
    }
}

/// Message for requesting list of Repositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRepositoriesRequest {
    /// Required. The parent, which owns this collection of Repositories.
    /// Format: `projects/*/locations/*/connections/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of results to return in the list.
    pub page_size: i32,

    /// Page start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters resources listed in the response.
    /// Expressions must follow API improvement proposal
    /// [AIP-160](https://google.aip.dev/160). e.g.
    /// `remote_uri:"<https://github.com>*"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRepositoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRepositoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRepositoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRepositoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.ListRepositoriesRequest"
    }
}

/// Message for response to listing Repositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRepositoriesResponse {
    /// The list of Repositories.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub repositories: std::vec::Vec<crate::model::Repository>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRepositoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [repositories][crate::model::ListRepositoriesResponse::repositories].
    pub fn set_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Repository>,
    {
        use std::iter::Iterator;
        self.repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.ListRepositoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRepositoriesResponse {
    type PageItem = crate::model::Repository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.repositories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for deleting a Repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRepositoryRequest {
    /// Required. The name of the Repository to delete.
    /// Format: `projects/*/locations/*/connections/*/repositories/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current etag of the repository.
    /// If an etag is provided and does not match the current etag of the
    /// repository, deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRepositoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRepositoryRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteRepositoryRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.DeleteRepositoryRequest"
    }
}

/// Message for fetching SCM read/write token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadWriteTokenRequest {
    /// Required. The resource name of the repository in the format
    /// `projects/*/locations/*/connections/*/repositories/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadWriteTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::FetchReadWriteTokenRequest::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadWriteTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchReadWriteTokenRequest"
    }
}

/// Message for fetching SCM read token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadTokenRequest {
    /// Required. The resource name of the repository in the format
    /// `projects/*/locations/*/connections/*/repositories/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::FetchReadTokenRequest::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchReadTokenRequest"
    }
}

/// Message for responding to get read token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadTokenResponse {
    /// The token content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchReadTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchReadTokenResponse::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchReadTokenResponse"
    }
}

/// Message for responding to get read/write token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadWriteTokenResponse {
    /// The token content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadWriteTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchReadWriteTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchReadWriteTokenResponse::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadWriteTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchReadWriteTokenResponse"
    }
}

/// RPC request object accepted by the ProcessWebhook RPC method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProcessWebhookRequest {
    /// Required. Project and location where the webhook will be received.
    /// Format: `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// HTTP request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<api::model::HttpBody>,

    /// Arbitrary additional key to find the maching repository for a webhook event
    /// if needed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ProcessWebhookRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [body][crate::model::ProcessWebhookRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<api::model::HttpBody>>>(
        mut self,
        v: T,
    ) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [webhook_key][crate::model::ProcessWebhookRequest::webhook_key].
    pub fn set_webhook_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_key = v.into();
        self
    }
}

impl wkt::message::Message for ProcessWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.ProcessWebhookRequest"
    }
}

/// Request for fetching git refs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchGitRefsRequest {
    /// Required. The resource name of the repository in the format
    /// `projects/*/locations/*/connections/*/repositories/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Type of refs to fetch
    pub ref_type: crate::model::fetch_git_refs_request::RefType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitRefsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::FetchGitRefsRequest::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [ref_type][crate::model::FetchGitRefsRequest::ref_type].
    pub fn set_ref_type<T: std::convert::Into<crate::model::fetch_git_refs_request::RefType>>(
        mut self,
        v: T,
    ) -> Self {
        self.ref_type = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitRefsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchGitRefsRequest"
    }
}

/// Defines additional types related to [FetchGitRefsRequest].
pub mod fetch_git_refs_request {
    #[allow(unused_imports)]
    use super::*;

    /// Type of refs
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RefType(i32);

    impl RefType {
        /// No type specified.
        pub const REF_TYPE_UNSPECIFIED: RefType = RefType::new(0);

        /// To fetch tags.
        pub const TAG: RefType = RefType::new(1);

        /// To fetch branches.
        pub const BRANCH: RefType = RefType::new(2);

        /// Creates a new RefType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("REF_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TAG"),
                2 => std::borrow::Cow::Borrowed("BRANCH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "REF_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::REF_TYPE_UNSPECIFIED),
                "TAG" => std::option::Option::Some(Self::TAG),
                "BRANCH" => std::option::Option::Some(Self::BRANCH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RefType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RefType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Response for fetching git refs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchGitRefsResponse {
    /// Name of the refs fetched.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ref_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitRefsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ref_names][crate::model::FetchGitRefsResponse::ref_names].
    pub fn set_ref_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ref_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchGitRefsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.cloudbuild.v2.FetchGitRefsResponse"
    }
}
