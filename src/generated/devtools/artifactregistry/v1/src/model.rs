// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A detailed representation of an Apt artifact. Information in the record
/// is derived from the archive's control file.
/// See <https://www.debian.org/doc/debian-policy/ch-controlfields.html>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AptArtifact {
    /// Output only. The Artifact Registry resource name of the artifact.
    pub name: std::string::String,

    /// Output only. The Apt package name of the artifact.
    pub package_name: std::string::String,

    /// Output only. An artifact is a binary or source package.
    pub package_type: crate::model::apt_artifact::PackageType,

    /// Output only. Operating system architecture of the artifact.
    pub architecture: std::string::String,

    /// Output only. Repository component of the artifact.
    pub component: std::string::String,

    /// Output only. Contents of the artifact's control metadata file.
    pub control_file: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AptArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AptArtifact::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// let x = AptArtifact::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::AptArtifact::package_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// let x = AptArtifact::new().set_package_name("example");
    /// ```
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [package_type][crate::model::AptArtifact::package_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// use google_cloud_artifactregistry_v1::model::apt_artifact::PackageType;
    /// let x0 = AptArtifact::new().set_package_type(PackageType::Binary);
    /// let x1 = AptArtifact::new().set_package_type(PackageType::Source);
    /// ```
    pub fn set_package_type<T: std::convert::Into<crate::model::apt_artifact::PackageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::AptArtifact::architecture].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// let x = AptArtifact::new().set_architecture("example");
    /// ```
    pub fn set_architecture<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [component][crate::model::AptArtifact::component].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// let x = AptArtifact::new().set_component("example");
    /// ```
    pub fn set_component<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.component = v.into();
        self
    }

    /// Sets the value of [control_file][crate::model::AptArtifact::control_file].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// let x = AptArtifact::new().set_control_file(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_control_file<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.control_file = v.into();
        self
    }
}

impl wkt::message::Message for AptArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.AptArtifact"
    }
}

/// Defines additional types related to [AptArtifact].
pub mod apt_artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Package type is either binary or source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PackageType {
        /// Package type is not specified.
        Unspecified,
        /// Binary package.
        Binary,
        /// Source package.
        Source,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PackageType::value] or
        /// [PackageType::name].
        UnknownValue(package_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod package_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PackageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Binary => std::option::Option::Some(1),
                Self::Source => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PACKAGE_TYPE_UNSPECIFIED"),
                Self::Binary => std::option::Option::Some("BINARY"),
                Self::Source => std::option::Option::Some("SOURCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PackageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PackageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PackageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Binary,
                2 => Self::Source,
                _ => Self::UnknownValue(package_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PackageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PACKAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BINARY" => Self::Binary,
                "SOURCE" => Self::Source,
                _ => Self::UnknownValue(package_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PackageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Binary => serializer.serialize_i32(1),
                Self::Source => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PackageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PackageType>::new(
                ".google.devtools.artifactregistry.v1.AptArtifact.PackageType",
            ))
        }
    }
}

/// Google Cloud Storage location where the artifacts currently reside.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAptArtifactsGcsSource {
    /// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
    pub uris: std::vec::Vec<std::string::String>,

    /// Supports URI wildcards for matching multiple objects from a single URI.
    pub use_wildcards: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAptArtifactsGcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uris][crate::model::ImportAptArtifactsGcsSource::uris].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsGcsSource;
    /// let x = ImportAptArtifactsGcsSource::new().set_uris(["a", "b", "c"]);
    /// ```
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [use_wildcards][crate::model::ImportAptArtifactsGcsSource::use_wildcards].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsGcsSource;
    /// let x = ImportAptArtifactsGcsSource::new().set_use_wildcards(true);
    /// ```
    pub fn set_use_wildcards<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_wildcards = v.into();
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsGcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsGcsSource"
    }
}

/// The request to import new apt artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAptArtifactsRequest {
    /// The name of the parent resource where the artifacts will be imported.
    pub parent: std::string::String,

    /// The source location of the package binaries.
    pub source: std::option::Option<crate::model::import_apt_artifacts_request::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAptArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportAptArtifactsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsRequest;
    /// let x = ImportAptArtifactsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportAptArtifactsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsRequest;
    /// use google_cloud_artifactregistry_v1::model::ImportAptArtifactsGcsSource;
    /// let x = ImportAptArtifactsRequest::new().set_source(Some(
    ///     google_cloud_artifactregistry_v1::model::import_apt_artifacts_request::Source::GcsSource(ImportAptArtifactsGcsSource::default().into())));
    /// ```
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_apt_artifacts_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportAptArtifactsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_apt_artifacts_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAptArtifactsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsRequest;
    /// use google_cloud_artifactregistry_v1::model::ImportAptArtifactsGcsSource;
    /// let x = ImportAptArtifactsRequest::new().set_gcs_source(ImportAptArtifactsGcsSource::default()/* use setters */);
    /// assert!(x.gcs_source().is_some());
    /// ```
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_apt_artifacts_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsRequest"
    }
}

/// Defines additional types related to [ImportAptArtifactsRequest].
pub mod import_apt_artifacts_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source location of the package binaries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location where input content is located.
        GcsSource(std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>),
    }
}

/// Error information explaining why a package was not imported.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAptArtifactsErrorInfo {
    /// The detailed error status.
    pub error: std::option::Option<rpc::model::Status>,

    /// The source that was not imported.
    pub source: std::option::Option<crate::model::import_apt_artifacts_error_info::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAptArtifactsErrorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::ImportAptArtifactsErrorInfo::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsErrorInfo;
    /// use rpc::model::Status;
    /// let x = ImportAptArtifactsErrorInfo::new().set_error(Status::default()/* use setters */);
    /// ```
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ImportAptArtifactsErrorInfo::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsErrorInfo;
    /// use rpc::model::Status;
    /// let x = ImportAptArtifactsErrorInfo::new().set_or_clear_error(Some(Status::default()/* use setters */));
    /// let x = ImportAptArtifactsErrorInfo::new().set_or_clear_error(None::<Status>);
    /// ```
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ImportAptArtifactsErrorInfo::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsErrorInfo;
    /// use google_cloud_artifactregistry_v1::model::ImportAptArtifactsGcsSource;
    /// let x = ImportAptArtifactsErrorInfo::new().set_source(Some(
    ///     google_cloud_artifactregistry_v1::model::import_apt_artifacts_error_info::Source::GcsSource(ImportAptArtifactsGcsSource::default().into())));
    /// ```
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_apt_artifacts_error_info::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportAptArtifactsErrorInfo::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_apt_artifacts_error_info::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAptArtifactsErrorInfo::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsErrorInfo;
    /// use google_cloud_artifactregistry_v1::model::ImportAptArtifactsGcsSource;
    /// let x = ImportAptArtifactsErrorInfo::new().set_gcs_source(ImportAptArtifactsGcsSource::default()/* use setters */);
    /// assert!(x.gcs_source().is_some());
    /// ```
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_apt_artifacts_error_info::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsErrorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsErrorInfo"
    }
}

/// Defines additional types related to [ImportAptArtifactsErrorInfo].
pub mod import_apt_artifacts_error_info {
    #[allow(unused_imports)]
    use super::*;

    /// The source that was not imported.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location requested.
        GcsSource(std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>),
    }
}

/// The response message from importing APT artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAptArtifactsResponse {
    /// The Apt artifacts imported.
    pub apt_artifacts: std::vec::Vec<crate::model::AptArtifact>,

    /// Detailed error info for packages that were not imported.
    pub errors: std::vec::Vec<crate::model::ImportAptArtifactsErrorInfo>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAptArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [apt_artifacts][crate::model::ImportAptArtifactsResponse::apt_artifacts].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsResponse;
    /// use google_cloud_artifactregistry_v1::model::AptArtifact;
    /// let x = ImportAptArtifactsResponse::new()
    ///     .set_apt_artifacts([
    ///         AptArtifact::default()/* use setters */,
    ///         AptArtifact::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_apt_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AptArtifact>,
    {
        use std::iter::Iterator;
        self.apt_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::ImportAptArtifactsResponse::errors].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportAptArtifactsResponse;
    /// use google_cloud_artifactregistry_v1::model::ImportAptArtifactsErrorInfo;
    /// let x = ImportAptArtifactsResponse::new()
    ///     .set_errors([
    ///         ImportAptArtifactsErrorInfo::default()/* use setters */,
    ///         ImportAptArtifactsErrorInfo::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportAptArtifactsErrorInfo>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsResponse"
    }
}

/// The operation metadata for importing artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAptArtifactsMetadata {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAptArtifactsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ImportAptArtifactsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsMetadata"
    }
}

/// DockerImage represents a docker artifact.
/// The following fields are returned as untyped metadata in the Version
/// resource, using camelcase keys (i.e. metadata.imageSizeBytes):
///
/// * imageSizeBytes
/// * mediaType
/// * buildTime
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DockerImage {
    /// Required. registry_location, project_id, repository_name and image id forms
    /// a unique image
    /// name:`projects/<project_id>/locations/<location>/repository/<repository_name>/dockerImages/<docker_image>`.
    /// For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/dockerImages/
    /// nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// "nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf"
    /// is the image's digest.
    pub name: std::string::String,

    /// Required. URL to access the image.
    /// Example:
    /// us-west4-docker.pkg.dev/test-project/test-repo/nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf
    pub uri: std::string::String,

    /// Tags attached to this image.
    pub tags: std::vec::Vec<std::string::String>,

    /// Calculated size of the image.
    /// This field is returned as the 'metadata.imageSizeBytes' field in the
    /// Version resource.
    pub image_size_bytes: i64,

    /// Time the image was uploaded.
    pub upload_time: std::option::Option<wkt::Timestamp>,

    /// Media type of this image, e.g.
    /// "application/vnd.docker.distribution.manifest.v2+json".
    /// This field is returned as the 'metadata.mediaType' field in the
    /// Version resource.
    pub media_type: std::string::String,

    /// The time this image was built.
    /// This field is returned as the 'metadata.buildTime' field in the
    /// Version resource.
    /// The build time is returned to the client as an RFC 3339 string, which can
    /// be easily used with the JavaScript Date constructor.
    pub build_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the docker image was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DockerImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DockerImage::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// let x = DockerImage::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::DockerImage::uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// let x = DockerImage::new().set_uri("example");
    /// ```
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::DockerImage::tags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// let x = DockerImage::new().set_tags(["a", "b", "c"]);
    /// ```
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_size_bytes][crate::model::DockerImage::image_size_bytes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// let x = DockerImage::new().set_image_size_bytes(42);
    /// ```
    pub fn set_image_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.image_size_bytes = v.into();
        self
    }

    /// Sets the value of [upload_time][crate::model::DockerImage::upload_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// use wkt::Timestamp;
    /// let x = DockerImage::new().set_upload_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_upload_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.upload_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upload_time][crate::model::DockerImage::upload_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// use wkt::Timestamp;
    /// let x = DockerImage::new().set_or_clear_upload_time(Some(Timestamp::default()/* use setters */));
    /// let x = DockerImage::new().set_or_clear_upload_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_upload_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.upload_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [media_type][crate::model::DockerImage::media_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// let x = DockerImage::new().set_media_type("example");
    /// ```
    pub fn set_media_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.media_type = v.into();
        self
    }

    /// Sets the value of [build_time][crate::model::DockerImage::build_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// use wkt::Timestamp;
    /// let x = DockerImage::new().set_build_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_build_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_time][crate::model::DockerImage::build_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// use wkt::Timestamp;
    /// let x = DockerImage::new().set_or_clear_build_time(Some(Timestamp::default()/* use setters */));
    /// let x = DockerImage::new().set_or_clear_build_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_build_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.build_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DockerImage::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// use wkt::Timestamp;
    /// let x = DockerImage::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DockerImage::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DockerImage;
    /// use wkt::Timestamp;
    /// let x = DockerImage::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = DockerImage::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DockerImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DockerImage"
    }
}

/// The request to list docker images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDockerImagesRequest {
    /// Required. The name of the parent resource whose docker images will be
    /// listed.
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    /// The field to order the results by.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDockerImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDockerImagesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListDockerImagesRequest;
    /// let x = ListDockerImagesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDockerImagesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListDockerImagesRequest;
    /// let x = ListDockerImagesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDockerImagesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListDockerImagesRequest;
    /// let x = ListDockerImagesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDockerImagesRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListDockerImagesRequest;
    /// let x = ListDockerImagesRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDockerImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListDockerImagesRequest"
    }
}

/// The response from listing docker images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDockerImagesResponse {
    /// The docker images returned.
    pub docker_images: std::vec::Vec<crate::model::DockerImage>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDockerImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [docker_images][crate::model::ListDockerImagesResponse::docker_images].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListDockerImagesResponse;
    /// use google_cloud_artifactregistry_v1::model::DockerImage;
    /// let x = ListDockerImagesResponse::new()
    ///     .set_docker_images([
    ///         DockerImage::default()/* use setters */,
    ///         DockerImage::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_docker_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DockerImage>,
    {
        use std::iter::Iterator;
        self.docker_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDockerImagesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListDockerImagesResponse;
    /// let x = ListDockerImagesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDockerImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListDockerImagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDockerImagesResponse {
    type PageItem = crate::model::DockerImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.docker_images
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get docker images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDockerImageRequest {
    /// Required. The name of the docker images.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDockerImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDockerImageRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetDockerImageRequest;
    /// let x = GetDockerImageRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDockerImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetDockerImageRequest"
    }
}

/// MavenArtifact represents a maven artifact.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MavenArtifact {
    /// Required. registry_location, project_id, repository_name and maven_artifact
    /// forms a unique artifact For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/mavenArtifacts/
    /// com.google.guava:guava:31.0-jre",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// "com.google.guava:guava:31.0-jre"
    /// is the maven artifact.
    pub name: std::string::String,

    /// Required. URL to access the pom file of the artifact.
    /// Example:
    /// us-west4-maven.pkg.dev/test-project/test-repo/com/google/guava/guava/31.0/guava-31.0.pom
    pub pom_uri: std::string::String,

    /// Group ID for the artifact.
    /// Example:
    /// com.google.guava
    pub group_id: std::string::String,

    /// Artifact ID for the artifact.
    pub artifact_id: std::string::String,

    /// Version of this artifact.
    pub version: std::string::String,

    /// Output only. Time the artifact was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the artifact was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MavenArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MavenArtifact::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// let x = MavenArtifact::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [pom_uri][crate::model::MavenArtifact::pom_uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// let x = MavenArtifact::new().set_pom_uri("example");
    /// ```
    pub fn set_pom_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pom_uri = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::MavenArtifact::group_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// let x = MavenArtifact::new().set_group_id("example");
    /// ```
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [artifact_id][crate::model::MavenArtifact::artifact_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// let x = MavenArtifact::new().set_artifact_id("example");
    /// ```
    pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_id = v.into();
        self
    }

    /// Sets the value of [version][crate::model::MavenArtifact::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// let x = MavenArtifact::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MavenArtifact::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// use wkt::Timestamp;
    /// let x = MavenArtifact::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MavenArtifact::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// use wkt::Timestamp;
    /// let x = MavenArtifact::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = MavenArtifact::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MavenArtifact::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// use wkt::Timestamp;
    /// let x = MavenArtifact::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MavenArtifact::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// use wkt::Timestamp;
    /// let x = MavenArtifact::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = MavenArtifact::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MavenArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.MavenArtifact"
    }
}

/// The request to list maven artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMavenArtifactsRequest {
    /// Required. The name of the parent resource whose maven artifacts will be
    /// listed.
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMavenArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMavenArtifactsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListMavenArtifactsRequest;
    /// let x = ListMavenArtifactsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMavenArtifactsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListMavenArtifactsRequest;
    /// let x = ListMavenArtifactsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMavenArtifactsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListMavenArtifactsRequest;
    /// let x = ListMavenArtifactsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMavenArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListMavenArtifactsRequest"
    }
}

/// The response from listing maven artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMavenArtifactsResponse {
    /// The maven artifacts returned.
    pub maven_artifacts: std::vec::Vec<crate::model::MavenArtifact>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMavenArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [maven_artifacts][crate::model::ListMavenArtifactsResponse::maven_artifacts].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListMavenArtifactsResponse;
    /// use google_cloud_artifactregistry_v1::model::MavenArtifact;
    /// let x = ListMavenArtifactsResponse::new()
    ///     .set_maven_artifacts([
    ///         MavenArtifact::default()/* use setters */,
    ///         MavenArtifact::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMavenArtifactsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListMavenArtifactsResponse;
    /// let x = ListMavenArtifactsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMavenArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListMavenArtifactsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMavenArtifactsResponse {
    type PageItem = crate::model::MavenArtifact;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.maven_artifacts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get maven artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMavenArtifactRequest {
    /// Required. The name of the maven artifact.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMavenArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMavenArtifactRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetMavenArtifactRequest;
    /// let x = GetMavenArtifactRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMavenArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetMavenArtifactRequest"
    }
}

/// NpmPackage represents an npm artifact.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NpmPackage {
    /// Required. registry_location, project_id, repository_name and npm_package
    /// forms a unique package For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/npmPackages/
    /// npm_test:1.0.0",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// npm_test:1.0.0" is the npm package.
    pub name: std::string::String,

    /// Package for the artifact.
    pub package_name: std::string::String,

    /// Version of this package.
    pub version: std::string::String,

    /// Tags attached to this package.
    pub tags: std::vec::Vec<std::string::String>,

    /// Output only. Time the package was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the package was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NpmPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NpmPackage::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// let x = NpmPackage::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::NpmPackage::package_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// let x = NpmPackage::new().set_package_name("example");
    /// ```
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::NpmPackage::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// let x = NpmPackage::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::NpmPackage::tags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// let x = NpmPackage::new().set_tags(["a", "b", "c"]);
    /// ```
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::NpmPackage::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// use wkt::Timestamp;
    /// let x = NpmPackage::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::NpmPackage::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// use wkt::Timestamp;
    /// let x = NpmPackage::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = NpmPackage::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::NpmPackage::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// use wkt::Timestamp;
    /// let x = NpmPackage::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::NpmPackage::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// use wkt::Timestamp;
    /// let x = NpmPackage::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = NpmPackage::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NpmPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.NpmPackage"
    }
}

/// The request to list npm packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNpmPackagesRequest {
    /// Required. The name of the parent resource whose npm packages will be
    /// listed.
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNpmPackagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNpmPackagesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListNpmPackagesRequest;
    /// let x = ListNpmPackagesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNpmPackagesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListNpmPackagesRequest;
    /// let x = ListNpmPackagesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNpmPackagesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListNpmPackagesRequest;
    /// let x = ListNpmPackagesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNpmPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListNpmPackagesRequest"
    }
}

/// The response from listing npm packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNpmPackagesResponse {
    /// The npm packages returned.
    pub npm_packages: std::vec::Vec<crate::model::NpmPackage>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNpmPackagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [npm_packages][crate::model::ListNpmPackagesResponse::npm_packages].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListNpmPackagesResponse;
    /// use google_cloud_artifactregistry_v1::model::NpmPackage;
    /// let x = ListNpmPackagesResponse::new()
    ///     .set_npm_packages([
    ///         NpmPackage::default()/* use setters */,
    ///         NpmPackage::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNpmPackagesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListNpmPackagesResponse;
    /// let x = ListNpmPackagesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNpmPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListNpmPackagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNpmPackagesResponse {
    type PageItem = crate::model::NpmPackage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.npm_packages
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get npm packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNpmPackageRequest {
    /// Required. The name of the npm package.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNpmPackageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNpmPackageRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetNpmPackageRequest;
    /// let x = GetNpmPackageRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNpmPackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetNpmPackageRequest"
    }
}

/// PythonPackage represents a python artifact.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PythonPackage {
    /// Required. registry_location, project_id, repository_name and python_package
    /// forms a unique package
    /// name:`projects/<project_id>/locations/<location>/repository/<repository_name>/pythonPackages/<python_package>`.
    /// For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/pythonPackages/
    /// python_package:1.0.0",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// python_package:1.0.0" is the python package.
    pub name: std::string::String,

    /// Required. URL to access the package.
    /// Example:
    /// us-west4-python.pkg.dev/test-project/test-repo/python_package/file-name-1.0.0.tar.gz
    pub uri: std::string::String,

    /// Package for the artifact.
    pub package_name: std::string::String,

    /// Version of this package.
    pub version: std::string::String,

    /// Output only. Time the package was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the package was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PythonPackage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PythonPackage::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// let x = PythonPackage::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::PythonPackage::uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// let x = PythonPackage::new().set_uri("example");
    /// ```
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::PythonPackage::package_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// let x = PythonPackage::new().set_package_name("example");
    /// ```
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PythonPackage::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// let x = PythonPackage::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PythonPackage::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// use wkt::Timestamp;
    /// let x = PythonPackage::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PythonPackage::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// use wkt::Timestamp;
    /// let x = PythonPackage::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = PythonPackage::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PythonPackage::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// use wkt::Timestamp;
    /// let x = PythonPackage::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PythonPackage::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// use wkt::Timestamp;
    /// let x = PythonPackage::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = PythonPackage::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PythonPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.PythonPackage"
    }
}

/// The request to list python packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPythonPackagesRequest {
    /// Required. The name of the parent resource whose python packages will be
    /// listed.
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPythonPackagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPythonPackagesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPythonPackagesRequest;
    /// let x = ListPythonPackagesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPythonPackagesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPythonPackagesRequest;
    /// let x = ListPythonPackagesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPythonPackagesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPythonPackagesRequest;
    /// let x = ListPythonPackagesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPythonPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPythonPackagesRequest"
    }
}

/// The response from listing python packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPythonPackagesResponse {
    /// The python packages returned.
    pub python_packages: std::vec::Vec<crate::model::PythonPackage>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPythonPackagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [python_packages][crate::model::ListPythonPackagesResponse::python_packages].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPythonPackagesResponse;
    /// use google_cloud_artifactregistry_v1::model::PythonPackage;
    /// let x = ListPythonPackagesResponse::new()
    ///     .set_python_packages([
    ///         PythonPackage::default()/* use setters */,
    ///         PythonPackage::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPythonPackagesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPythonPackagesResponse;
    /// let x = ListPythonPackagesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPythonPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPythonPackagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPythonPackagesResponse {
    type PageItem = crate::model::PythonPackage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.python_packages
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get python packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPythonPackageRequest {
    /// Required. The name of the python package.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPythonPackageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPythonPackageRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetPythonPackageRequest;
    /// let x = GetPythonPackageRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPythonPackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetPythonPackageRequest"
    }
}

/// An Attachment refers to additional metadata that can be attached to
/// artifacts in Artifact Registry. An attachment consists of one or more files.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Attachment {
    /// The name of the attachment. E.g.
    /// `projects/p1/locations/us/repositories/repo/attachments/sbom`.
    pub name: std::string::String,

    /// Required. The target the attachment is for, can be a Version, Package or
    /// Repository. E.g.
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/p1/versions/v1`.
    pub target: std::string::String,

    /// Type of attachment.
    /// E.g. `application/vnd.spdx+json`
    pub r#type: std::string::String,

    /// The namespace this attachment belongs to.
    /// E.g. If an attachment is created by artifact analysis, namespace is set
    /// to `artifactanalysis.googleapis.com`.
    pub attachment_namespace: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Artifact Registry. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the attachment was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the attachment was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The files that belong to this attachment.
    /// If the file ID part contains slashes, they are escaped. E.g.
    /// `projects/p1/locations/us-central1/repositories/repo1/files/sha:<sha-of-file>`.
    pub files: std::vec::Vec<std::string::String>,

    /// Output only. The name of the OCI version that this attachment created. Only
    /// populated for Docker attachments. E.g.
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/p1/versions/v1`.
    pub oci_version_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Attachment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Attachment::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::Attachment::target].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_target("example");
    /// ```
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Attachment::type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [attachment_namespace][crate::model::Attachment::attachment_namespace].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_attachment_namespace("example");
    /// ```
    pub fn set_attachment_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attachment_namespace = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Attachment::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Attachment::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// use wkt::Timestamp;
    /// let x = Attachment::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Attachment::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// use wkt::Timestamp;
    /// let x = Attachment::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Attachment::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Attachment::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// use wkt::Timestamp;
    /// let x = Attachment::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Attachment::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// use wkt::Timestamp;
    /// let x = Attachment::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Attachment::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [files][crate::model::Attachment::files].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_files(["a", "b", "c"]);
    /// ```
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [oci_version_name][crate::model::Attachment::oci_version_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = Attachment::new().set_oci_version_name("example");
    /// ```
    pub fn set_oci_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oci_version_name = v.into();
        self
    }
}

impl wkt::message::Message for Attachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Attachment"
    }
}

/// The request to list attachments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttachmentsRequest {
    /// Required. The name of the parent resource whose attachments will be listed.
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `target`
    /// * `type`
    /// * `attachment_namespace`
    pub filter: std::string::String,

    /// The maximum number of attachments to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttachmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttachmentsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListAttachmentsRequest;
    /// let x = ListAttachmentsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAttachmentsRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListAttachmentsRequest;
    /// let x = ListAttachmentsRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttachmentsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListAttachmentsRequest;
    /// let x = ListAttachmentsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttachmentsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListAttachmentsRequest;
    /// let x = ListAttachmentsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListAttachmentsRequest"
    }
}

/// The response from listing attachments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttachmentsResponse {
    /// The attachments returned.
    pub attachments: std::vec::Vec<crate::model::Attachment>,

    /// The token to retrieve the next page of attachments, or empty if there are
    /// no more attachments to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttachmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attachments][crate::model::ListAttachmentsResponse::attachments].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListAttachmentsResponse;
    /// use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = ListAttachmentsResponse::new()
    ///     .set_attachments([
    ///         Attachment::default()/* use setters */,
    ///         Attachment::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attachment>,
    {
        use std::iter::Iterator;
        self.attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAttachmentsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListAttachmentsResponse;
    /// let x = ListAttachmentsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListAttachmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAttachmentsResponse {
    type PageItem = crate::model::Attachment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attachments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve an attachment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAttachmentRequest {
    /// Required. The name of the attachment to retrieve.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttachmentRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetAttachmentRequest;
    /// let x = GetAttachmentRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetAttachmentRequest"
    }
}

/// The request to create a new attachment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAttachmentRequest {
    /// Required. The name of the parent resource where the attachment will be
    /// created.
    pub parent: std::string::String,

    /// Required. The attachment id to use for this attachment.
    pub attachment_id: std::string::String,

    /// Required. The attachment to be created.
    pub attachment: std::option::Option<crate::model::Attachment>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAttachmentRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateAttachmentRequest;
    /// let x = CreateAttachmentRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attachment_id][crate::model::CreateAttachmentRequest::attachment_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateAttachmentRequest;
    /// let x = CreateAttachmentRequest::new().set_attachment_id("example");
    /// ```
    pub fn set_attachment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attachment_id = v.into();
        self
    }

    /// Sets the value of [attachment][crate::model::CreateAttachmentRequest::attachment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateAttachmentRequest;
    /// use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = CreateAttachmentRequest::new().set_attachment(Attachment::default()/* use setters */);
    /// ```
    pub fn set_attachment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Attachment>,
    {
        self.attachment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attachment][crate::model::CreateAttachmentRequest::attachment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateAttachmentRequest;
    /// use google_cloud_artifactregistry_v1::model::Attachment;
    /// let x = CreateAttachmentRequest::new().set_or_clear_attachment(Some(Attachment::default()/* use setters */));
    /// let x = CreateAttachmentRequest::new().set_or_clear_attachment(None::<Attachment>);
    /// ```
    pub fn set_or_clear_attachment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Attachment>,
    {
        self.attachment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateAttachmentRequest"
    }
}

/// The request to delete an attachment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAttachmentRequest {
    /// Required. The name of the attachment to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAttachmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAttachmentRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteAttachmentRequest;
    /// let x = DeleteAttachmentRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteAttachmentRequest"
    }
}

/// A hash of file content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Hash {
    /// The algorithm used to compute the hash value.
    pub r#type: crate::model::hash::HashType,

    /// The hash value.
    pub value: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Hash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Hash::type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Hash;
    /// use google_cloud_artifactregistry_v1::model::hash::HashType;
    /// let x0 = Hash::new().set_type(HashType::Sha256);
    /// let x1 = Hash::new().set_type(HashType::Md5);
    /// ```
    pub fn set_type<T: std::convert::Into<crate::model::hash::HashType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Hash;
    /// let x = Hash::new().set_value(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Hash"
    }
}

/// Defines additional types related to [Hash].
pub mod hash {
    #[allow(unused_imports)]
    use super::*;

    /// The algorithm used to compute the hash.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HashType {
        /// Unspecified.
        Unspecified,
        /// SHA256 hash.
        Sha256,
        /// MD5 hash.
        Md5,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HashType::value] or
        /// [HashType::name].
        UnknownValue(hash_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod hash_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HashType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sha256 => std::option::Option::Some(1),
                Self::Md5 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HASH_TYPE_UNSPECIFIED"),
                Self::Sha256 => std::option::Option::Some("SHA256"),
                Self::Md5 => std::option::Option::Some("MD5"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HashType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HashType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HashType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sha256,
                2 => Self::Md5,
                _ => Self::UnknownValue(hash_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HashType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HASH_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SHA256" => Self::Sha256,
                "MD5" => Self::Md5,
                _ => Self::UnknownValue(hash_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HashType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sha256 => serializer.serialize_i32(1),
                Self::Md5 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HashType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HashType>::new(
                ".google.devtools.artifactregistry.v1.Hash.HashType",
            ))
        }
    }
}

/// Files store content that is potentially associated with Packages or Versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct File {
    /// The name of the file, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/files/a%2Fb%2Fc.txt`.
    /// If the file ID part contains slashes, they are escaped.
    pub name: std::string::String,

    /// The size of the File in bytes.
    pub size_bytes: i64,

    /// The hashes of the file content.
    pub hashes: std::vec::Vec<crate::model::Hash>,

    /// Output only. The time when the File was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the File was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The name of the Package or Version that owns this file, if any.
    pub owner: std::string::String,

    /// Output only. The time when the last attempt to refresh the file's data was
    /// made. Only set when the repository is remote.
    pub fetch_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Client specified annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl File {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::File::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// let x = File::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::File::size_bytes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// let x = File::new().set_size_bytes(42);
    /// ```
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [hashes][crate::model::File::hashes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use google_cloud_artifactregistry_v1::model::Hash;
    /// let x = File::new()
    ///     .set_hashes([
    ///         Hash::default()/* use setters */,
    ///         Hash::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::File::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use wkt::Timestamp;
    /// let x = File::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::File::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use wkt::Timestamp;
    /// let x = File::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = File::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::File::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use wkt::Timestamp;
    /// let x = File::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::File::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use wkt::Timestamp;
    /// let x = File::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = File::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [owner][crate::model::File::owner].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// let x = File::new().set_owner("example");
    /// ```
    pub fn set_owner<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [fetch_time][crate::model::File::fetch_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use wkt::Timestamp;
    /// let x = File::new().set_fetch_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_fetch_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.fetch_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fetch_time][crate::model::File::fetch_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// use wkt::Timestamp;
    /// let x = File::new().set_or_clear_fetch_time(Some(Timestamp::default()/* use setters */));
    /// let x = File::new().set_or_clear_fetch_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_fetch_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.fetch_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::File::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::File;
    /// let x = File::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for File {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.File"
    }
}

/// The request to list files.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFilesRequest {
    /// Required. The name of the repository whose files will be listed. For
    /// example: "projects/p1/locations/us-central1/repositories/repo1
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `owner`
    /// * `annotations`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to files with the name `my_file.txt`
    /// in project `my-project` in the `us-central` region, in repository
    /// `my-repo`, append the following filter expression to your request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/my-file.txt"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/my-*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/*file.txt"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/*file*"`
    ///
    /// To filter the results of your request to files owned by the version `1.0`
    /// in package `pkg1`, append the following filter expression to your request:
    ///
    /// * `owner="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/1.0"`
    ///
    /// To filter the results of your request to files with the annotation
    /// key-value pair [`external_link`: `external_link_value`], append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link:external_link_value"`
    ///
    /// To filter just for a specific annotation key `external_link`, append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link"`
    ///
    /// If the annotation key or value contains special characters, you can escape
    /// them by surrounding the value with backticks. For example, to filter the
    /// results of your request to files with the annotation key-value pair
    /// [`external.link`:`<https://example.com/my-file>`], append the following
    /// filter expression to your request:
    ///
    /// * `` "annotations.`external.link`:`<https://example.com/my-file>`" ``
    ///
    /// You can also filter with annotations with a wildcard to
    /// match any number of characters before or after the value:
    ///
    /// * `` "annotations.*_link:`*example.com*`" ``
    pub filter: std::string::String,

    /// The maximum number of files to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    /// The field to order the results by.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFilesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesRequest;
    /// let x = ListFilesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFilesRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesRequest;
    /// let x = ListFilesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFilesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesRequest;
    /// let x = ListFilesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFilesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesRequest;
    /// let x = ListFilesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFilesRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesRequest;
    /// let x = ListFilesRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListFilesRequest"
    }
}

/// The response from listing files.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFilesResponse {
    /// The files returned.
    pub files: std::vec::Vec<crate::model::File>,

    /// The token to retrieve the next page of files, or empty if there are no
    /// more files to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [files][crate::model::ListFilesResponse::files].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesResponse;
    /// use google_cloud_artifactregistry_v1::model::File;
    /// let x = ListFilesResponse::new()
    ///     .set_files([
    ///         File::default()/* use setters */,
    ///         File::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFilesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListFilesResponse;
    /// let x = ListFilesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListFilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFilesResponse {
    type PageItem = crate::model::File;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.files
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve a file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFileRequest {
    /// Required. The name of the file to retrieve.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFileRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetFileRequest;
    /// let x = GetFileRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetFileRequest"
    }
}

/// The request to delete a file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFileRequest {
    /// Required. The name of the file to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFileRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteFileRequest;
    /// let x = DeleteFileRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteFileRequest"
    }
}

/// The request to update a file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFileRequest {
    /// Required. The File that replaces the resource on the server.
    pub file: std::option::Option<crate::model::File>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file][crate::model::UpdateFileRequest::file].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateFileRequest;
    /// use google_cloud_artifactregistry_v1::model::File;
    /// let x = UpdateFileRequest::new().set_file(File::default()/* use setters */);
    /// ```
    pub fn set_file<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::File>,
    {
        self.file = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file][crate::model::UpdateFileRequest::file].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateFileRequest;
    /// use google_cloud_artifactregistry_v1::model::File;
    /// let x = UpdateFileRequest::new().set_or_clear_file(Some(File::default()/* use setters */));
    /// let x = UpdateFileRequest::new().set_or_clear_file(None::<File>);
    /// ```
    pub fn set_or_clear_file<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::File>,
    {
        self.file = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFileRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateFileRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateFileRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFileRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateFileRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateFileRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateFileRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateFileRequest"
    }
}

/// GenericArtifact represents a generic artifact
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenericArtifact {
    /// Resource name of the generic artifact.
    /// project, location, repository, package_id and version_id
    /// create a unique generic artifact.
    /// i.e. "projects/test-project/locations/us-west4/repositories/test-repo/
    /// genericArtifacts/package_id:version_id"
    pub name: std::string::String,

    /// The version of the generic artifact.
    pub version: std::string::String,

    /// Output only. The time when the Generic module is created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Generic module is updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenericArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenericArtifact::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GenericArtifact;
    /// let x = GenericArtifact::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenericArtifact::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GenericArtifact;
    /// let x = GenericArtifact::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GenericArtifact::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GenericArtifact;
    /// use wkt::Timestamp;
    /// let x = GenericArtifact::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GenericArtifact::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GenericArtifact;
    /// use wkt::Timestamp;
    /// let x = GenericArtifact::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = GenericArtifact::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::GenericArtifact::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GenericArtifact;
    /// use wkt::Timestamp;
    /// let x = GenericArtifact::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::GenericArtifact::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GenericArtifact;
    /// use wkt::Timestamp;
    /// let x = GenericArtifact::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = GenericArtifact::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenericArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GenericArtifact"
    }
}

/// GoModule represents a Go module.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GoModule {
    /// The resource name of a Go module.
    pub name: std::string::String,

    /// The version of the Go module. Must be a valid canonical version as defined
    /// in <https://go.dev/ref/mod#glos-canonical-version>.
    pub version: std::string::String,

    /// Output only. The time when the Go module is created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Go module is updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoModule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GoModule::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GoModule;
    /// let x = GoModule::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GoModule::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GoModule;
    /// let x = GoModule::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GoModule::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GoModule;
    /// use wkt::Timestamp;
    /// let x = GoModule::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GoModule::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GoModule;
    /// use wkt::Timestamp;
    /// let x = GoModule::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = GoModule::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::GoModule::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GoModule;
    /// use wkt::Timestamp;
    /// let x = GoModule::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::GoModule::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GoModule;
    /// use wkt::Timestamp;
    /// let x = GoModule::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = GoModule::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GoModule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GoModule"
    }
}

/// A detailed representation of a KFP artifact.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct KfpArtifact {
    /// Output only. Resource name of the KFP artifact. Since users don't directly
    /// interact with this resource, the name will be derived from the associated
    /// version. For example, when version = ".../versions/sha256:abcdef...", the
    /// name will be ".../kfpArtifacts/sha256:abcdef...".
    pub name: std::string::String,

    /// The version associated with the KFP artifact. Must follow the Semantic
    /// Versioning standard.
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KfpArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KfpArtifact::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::KfpArtifact;
    /// let x = KfpArtifact::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::KfpArtifact::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::KfpArtifact;
    /// let x = KfpArtifact::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for KfpArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.KfpArtifact"
    }
}

/// Packages are named collections of versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Package {
    /// The name of the package, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1`.
    /// If the package ID part contains slashes, the slashes are escaped.
    pub name: std::string::String,

    /// The display name of the package.
    pub display_name: std::string::String,

    /// The time when the package was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the package was last updated. This includes publishing a new
    /// version of the package.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Client specified annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Package {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Package::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// let x = Package::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Package::display_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// let x = Package::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Package::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// use wkt::Timestamp;
    /// let x = Package::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Package::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// use wkt::Timestamp;
    /// let x = Package::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Package::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Package::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// use wkt::Timestamp;
    /// let x = Package::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Package::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// use wkt::Timestamp;
    /// let x = Package::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Package::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::Package::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Package;
    /// let x = Package::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Package {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Package"
    }
}

/// The request to list packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPackagesRequest {
    /// Required. The name of the parent resource whose packages will be listed.
    pub parent: std::string::String,

    /// The maximum number of packages to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `annotations`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to packages with the name
    /// `my-package` in project `my-project` in the `us-central` region, in
    /// repository `my-repo`, append the following filter expression to your
    /// request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/*package"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/*pack*"`
    ///
    /// To filter the results of your request to packages with the annotation
    /// key-value pair [`external_link`: `external_link_value`], append the
    /// following filter expression to your request":
    ///
    /// * `"annotations.external_link:external_link_value"`
    ///
    /// To filter the results just for a specific annotation key `external_link`,
    /// append the following filter expression to your request:
    ///
    /// * `"annotations.external_link"`
    ///
    /// If the annotation key or value contains special characters, you can escape
    /// them by surrounding the value with backticks. For example, to filter the
    /// results of your request to packages with the annotation key-value pair
    /// [`external.link`:`<https://example.com/my-package>`], append the following
    /// filter expression to your request:
    ///
    /// * `` "annotations.`external.link`:`<https://example.com/my-package>`" ``
    ///
    /// You can also filter with annotations with a wildcard to
    /// match any number of characters before or after the value:
    ///
    /// * `` "annotations.*_link:`*example.com*`" ``
    pub filter: std::string::String,

    /// Optional. The field to order the results by.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPackagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPackagesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesRequest;
    /// let x = ListPackagesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPackagesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesRequest;
    /// let x = ListPackagesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPackagesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesRequest;
    /// let x = ListPackagesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPackagesRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesRequest;
    /// let x = ListPackagesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPackagesRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesRequest;
    /// let x = ListPackagesRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPackagesRequest"
    }
}

/// The response from listing packages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPackagesResponse {
    /// The packages returned.
    pub packages: std::vec::Vec<crate::model::Package>,

    /// The token to retrieve the next page of packages, or empty if there are no
    /// more packages to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPackagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [packages][crate::model::ListPackagesResponse::packages].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesResponse;
    /// use google_cloud_artifactregistry_v1::model::Package;
    /// let x = ListPackagesResponse::new()
    ///     .set_packages([
    ///         Package::default()/* use setters */,
    ///         Package::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Package>,
    {
        use std::iter::Iterator;
        self.packages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPackagesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListPackagesResponse;
    /// let x = ListPackagesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPackagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPackagesResponse {
    type PageItem = crate::model::Package;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.packages
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve a package.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPackageRequest {
    /// Required. The name of the package to retrieve.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPackageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPackageRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetPackageRequest;
    /// let x = GetPackageRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetPackageRequest"
    }
}

/// The request to delete a package.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePackageRequest {
    /// Required. The name of the package to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePackageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePackageRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeletePackageRequest;
    /// let x = DeletePackageRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeletePackageRequest"
    }
}

/// The request to update a package.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePackageRequest {
    /// The package that replaces the resource on the server.
    pub package: std::option::Option<crate::model::Package>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePackageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package][crate::model::UpdatePackageRequest::package].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdatePackageRequest;
    /// use google_cloud_artifactregistry_v1::model::Package;
    /// let x = UpdatePackageRequest::new().set_package(Package::default()/* use setters */);
    /// ```
    pub fn set_package<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Package>,
    {
        self.package = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [package][crate::model::UpdatePackageRequest::package].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdatePackageRequest;
    /// use google_cloud_artifactregistry_v1::model::Package;
    /// let x = UpdatePackageRequest::new().set_or_clear_package(Some(Package::default()/* use setters */));
    /// let x = UpdatePackageRequest::new().set_or_clear_package(None::<Package>);
    /// ```
    pub fn set_or_clear_package<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Package>,
    {
        self.package = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePackageRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdatePackageRequest;
    /// use wkt::FieldMask;
    /// let x = UpdatePackageRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePackageRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdatePackageRequest;
    /// use wkt::FieldMask;
    /// let x = UpdatePackageRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdatePackageRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdatePackageRequest"
    }
}

/// Artifact policy configuration for the repository contents.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpstreamPolicy {
    /// The user-provided ID of the upstream policy.
    pub id: std::string::String,

    /// A reference to the repository resource, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1`.
    pub repository: std::string::String,

    /// Entries with a greater priority value take precedence in the pull order.
    pub priority: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpstreamPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::UpstreamPolicy::id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpstreamPolicy;
    /// let x = UpstreamPolicy::new().set_id("example");
    /// ```
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::UpstreamPolicy::repository].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpstreamPolicy;
    /// let x = UpstreamPolicy::new().set_repository("example");
    /// ```
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::UpstreamPolicy::priority].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpstreamPolicy;
    /// let x = UpstreamPolicy::new().set_priority(42);
    /// ```
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }
}

impl wkt::message::Message for UpstreamPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpstreamPolicy"
    }
}

/// CleanupPolicyCondition is a set of conditions attached to a CleanupPolicy.
/// If multiple entries are set, all must be satisfied for the condition to be
/// satisfied.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CleanupPolicyCondition {
    /// Match versions by tag status.
    pub tag_state: std::option::Option<crate::model::cleanup_policy_condition::TagState>,

    /// Match versions by tag prefix. Applied on any prefix match.
    pub tag_prefixes: std::vec::Vec<std::string::String>,

    /// Match versions by version name prefix. Applied on any prefix match.
    pub version_name_prefixes: std::vec::Vec<std::string::String>,

    /// Match versions by package prefix. Applied on any prefix match.
    pub package_name_prefixes: std::vec::Vec<std::string::String>,

    /// Match versions older than a duration.
    pub older_than: std::option::Option<wkt::Duration>,

    /// Match versions newer than a duration.
    pub newer_than: std::option::Option<wkt::Duration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CleanupPolicyCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_state][crate::model::CleanupPolicyCondition::tag_state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// use google_cloud_artifactregistry_v1::model::cleanup_policy_condition::TagState;
    /// let x0 = CleanupPolicyCondition::new().set_tag_state(TagState::Tagged);
    /// let x1 = CleanupPolicyCondition::new().set_tag_state(TagState::Untagged);
    /// let x2 = CleanupPolicyCondition::new().set_tag_state(TagState::Any);
    /// ```
    pub fn set_tag_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cleanup_policy_condition::TagState>,
    {
        self.tag_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag_state][crate::model::CleanupPolicyCondition::tag_state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// use google_cloud_artifactregistry_v1::model::cleanup_policy_condition::TagState;
    /// let x0 = CleanupPolicyCondition::new().set_or_clear_tag_state(Some(TagState::Tagged));
    /// let x1 = CleanupPolicyCondition::new().set_or_clear_tag_state(Some(TagState::Untagged));
    /// let x2 = CleanupPolicyCondition::new().set_or_clear_tag_state(Some(TagState::Any));
    /// let x_none = CleanupPolicyCondition::new().set_or_clear_tag_state(None::<TagState>);
    /// ```
    pub fn set_or_clear_tag_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cleanup_policy_condition::TagState>,
    {
        self.tag_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tag_prefixes][crate::model::CleanupPolicyCondition::tag_prefixes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// let x = CleanupPolicyCondition::new().set_tag_prefixes(["a", "b", "c"]);
    /// ```
    pub fn set_tag_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version_name_prefixes][crate::model::CleanupPolicyCondition::version_name_prefixes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// let x = CleanupPolicyCondition::new().set_version_name_prefixes(["a", "b", "c"]);
    /// ```
    pub fn set_version_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_name_prefixes][crate::model::CleanupPolicyCondition::package_name_prefixes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// let x = CleanupPolicyCondition::new().set_package_name_prefixes(["a", "b", "c"]);
    /// ```
    pub fn set_package_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.package_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [older_than][crate::model::CleanupPolicyCondition::older_than].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// use wkt::Duration;
    /// let x = CleanupPolicyCondition::new().set_older_than(Duration::default()/* use setters */);
    /// ```
    pub fn set_older_than<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.older_than = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [older_than][crate::model::CleanupPolicyCondition::older_than].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// use wkt::Duration;
    /// let x = CleanupPolicyCondition::new().set_or_clear_older_than(Some(Duration::default()/* use setters */));
    /// let x = CleanupPolicyCondition::new().set_or_clear_older_than(None::<Duration>);
    /// ```
    pub fn set_or_clear_older_than<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.older_than = v.map(|x| x.into());
        self
    }

    /// Sets the value of [newer_than][crate::model::CleanupPolicyCondition::newer_than].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// use wkt::Duration;
    /// let x = CleanupPolicyCondition::new().set_newer_than(Duration::default()/* use setters */);
    /// ```
    pub fn set_newer_than<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.newer_than = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [newer_than][crate::model::CleanupPolicyCondition::newer_than].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// use wkt::Duration;
    /// let x = CleanupPolicyCondition::new().set_or_clear_newer_than(Some(Duration::default()/* use setters */));
    /// let x = CleanupPolicyCondition::new().set_or_clear_newer_than(None::<Duration>);
    /// ```
    pub fn set_or_clear_newer_than<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.newer_than = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CleanupPolicyCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CleanupPolicyCondition"
    }
}

/// Defines additional types related to [CleanupPolicyCondition].
pub mod cleanup_policy_condition {
    #[allow(unused_imports)]
    use super::*;

    /// Statuses applying to versions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TagState {
        /// Tag status not specified.
        Unspecified,
        /// Applies to tagged versions only.
        Tagged,
        /// Applies to untagged versions only.
        Untagged,
        /// Applies to all versions.
        Any,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TagState::value] or
        /// [TagState::name].
        UnknownValue(tag_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tag_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TagState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tagged => std::option::Option::Some(1),
                Self::Untagged => std::option::Option::Some(2),
                Self::Any => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TAG_STATE_UNSPECIFIED"),
                Self::Tagged => std::option::Option::Some("TAGGED"),
                Self::Untagged => std::option::Option::Some("UNTAGGED"),
                Self::Any => std::option::Option::Some("ANY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TagState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TagState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TagState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tagged,
                2 => Self::Untagged,
                3 => Self::Any,
                _ => Self::UnknownValue(tag_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TagState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TAG_STATE_UNSPECIFIED" => Self::Unspecified,
                "TAGGED" => Self::Tagged,
                "UNTAGGED" => Self::Untagged,
                "ANY" => Self::Any,
                _ => Self::UnknownValue(tag_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TagState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tagged => serializer.serialize_i32(1),
                Self::Untagged => serializer.serialize_i32(2),
                Self::Any => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TagState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TagState>::new(
                ".google.devtools.artifactregistry.v1.CleanupPolicyCondition.TagState",
            ))
        }
    }
}

/// CleanupPolicyMostRecentVersions is an alternate condition of a CleanupPolicy
/// for retaining a minimum number of versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CleanupPolicyMostRecentVersions {
    /// List of package name prefixes that will apply this rule.
    pub package_name_prefixes: std::vec::Vec<std::string::String>,

    /// Minimum number of versions to keep.
    pub keep_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CleanupPolicyMostRecentVersions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_name_prefixes][crate::model::CleanupPolicyMostRecentVersions::package_name_prefixes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyMostRecentVersions;
    /// let x = CleanupPolicyMostRecentVersions::new().set_package_name_prefixes(["a", "b", "c"]);
    /// ```
    pub fn set_package_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.package_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [keep_count][crate::model::CleanupPolicyMostRecentVersions::keep_count].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyMostRecentVersions;
    /// let x = CleanupPolicyMostRecentVersions::new().set_keep_count(42);
    /// ```
    pub fn set_keep_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.keep_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [keep_count][crate::model::CleanupPolicyMostRecentVersions::keep_count].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicyMostRecentVersions;
    /// let x = CleanupPolicyMostRecentVersions::new().set_or_clear_keep_count(Some(42));
    /// let x = CleanupPolicyMostRecentVersions::new().set_or_clear_keep_count(None::<i32>);
    /// ```
    pub fn set_or_clear_keep_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.keep_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CleanupPolicyMostRecentVersions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CleanupPolicyMostRecentVersions"
    }
}

/// Artifact policy configuration for repository cleanup policies.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CleanupPolicy {
    /// The user-provided ID of the cleanup policy.
    pub id: std::string::String,

    /// Policy action.
    pub action: crate::model::cleanup_policy::Action,

    pub condition_type: std::option::Option<crate::model::cleanup_policy::ConditionType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CleanupPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::CleanupPolicy::id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicy;
    /// let x = CleanupPolicy::new().set_id("example");
    /// ```
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::CleanupPolicy::action].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicy;
    /// use google_cloud_artifactregistry_v1::model::cleanup_policy::Action;
    /// let x0 = CleanupPolicy::new().set_action(Action::Delete);
    /// let x1 = CleanupPolicy::new().set_action(Action::Keep);
    /// ```
    pub fn set_action<T: std::convert::Into<crate::model::cleanup_policy::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [condition_type][crate::model::CleanupPolicy::condition_type].
    ///
    /// Note that all the setters affecting `condition_type` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicy;
    /// use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// let x = CleanupPolicy::new().set_condition_type(Some(
    ///     google_cloud_artifactregistry_v1::model::cleanup_policy::ConditionType::Condition(CleanupPolicyCondition::default().into())));
    /// ```
    pub fn set_condition_type<
        T: std::convert::Into<std::option::Option<crate::model::cleanup_policy::ConditionType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_type = v.into();
        self
    }

    /// The value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// if it holds a `Condition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn condition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CleanupPolicyCondition>> {
        #[allow(unreachable_patterns)]
        self.condition_type.as_ref().and_then(|v| match v {
            crate::model::cleanup_policy::ConditionType::Condition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// to hold a `Condition`.
    ///
    /// Note that all the setters affecting `condition_type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicy;
    /// use google_cloud_artifactregistry_v1::model::CleanupPolicyCondition;
    /// let x = CleanupPolicy::new().set_condition(CleanupPolicyCondition::default()/* use setters */);
    /// assert!(x.condition().is_some());
    /// assert!(x.most_recent_versions().is_none());
    /// ```
    pub fn set_condition<
        T: std::convert::Into<std::boxed::Box<crate::model::CleanupPolicyCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_type = std::option::Option::Some(
            crate::model::cleanup_policy::ConditionType::Condition(v.into()),
        );
        self
    }

    /// The value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// if it holds a `MostRecentVersions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn most_recent_versions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CleanupPolicyMostRecentVersions>> {
        #[allow(unreachable_patterns)]
        self.condition_type.as_ref().and_then(|v| match v {
            crate::model::cleanup_policy::ConditionType::MostRecentVersions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// to hold a `MostRecentVersions`.
    ///
    /// Note that all the setters affecting `condition_type` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CleanupPolicy;
    /// use google_cloud_artifactregistry_v1::model::CleanupPolicyMostRecentVersions;
    /// let x = CleanupPolicy::new().set_most_recent_versions(CleanupPolicyMostRecentVersions::default()/* use setters */);
    /// assert!(x.most_recent_versions().is_some());
    /// assert!(x.condition().is_none());
    /// ```
    pub fn set_most_recent_versions<
        T: std::convert::Into<std::boxed::Box<crate::model::CleanupPolicyMostRecentVersions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_type = std::option::Option::Some(
            crate::model::cleanup_policy::ConditionType::MostRecentVersions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CleanupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CleanupPolicy"
    }
}

/// Defines additional types related to [CleanupPolicy].
pub mod cleanup_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Action type for a cleanup policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Action not specified.
        Unspecified,
        /// Delete action.
        Delete,
        /// Keep action.
        Keep,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Delete => std::option::Option::Some(1),
                Self::Keep => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Keep => std::option::Option::Some("KEEP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Delete,
                2 => Self::Keep,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_UNSPECIFIED" => Self::Unspecified,
                "DELETE" => Self::Delete,
                "KEEP" => Self::Keep,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Delete => serializer.serialize_i32(1),
                Self::Keep => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.devtools.artifactregistry.v1.CleanupPolicy.Action",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConditionType {
        /// Policy condition for matching versions.
        Condition(std::boxed::Box<crate::model::CleanupPolicyCondition>),
        /// Policy condition for retaining a minimum number of versions. May only be
        /// specified with a Keep action.
        MostRecentVersions(std::boxed::Box<crate::model::CleanupPolicyMostRecentVersions>),
    }
}

/// Virtual repository configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VirtualRepositoryConfig {
    /// Policies that configure the upstream artifacts distributed by the Virtual
    /// Repository. Upstream policies cannot be set on a standard repository.
    pub upstream_policies: std::vec::Vec<crate::model::UpstreamPolicy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirtualRepositoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upstream_policies][crate::model::VirtualRepositoryConfig::upstream_policies].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::VirtualRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::UpstreamPolicy;
    /// let x = VirtualRepositoryConfig::new()
    ///     .set_upstream_policies([
    ///         UpstreamPolicy::default()/* use setters */,
    ///         UpstreamPolicy::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_upstream_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpstreamPolicy>,
    {
        use std::iter::Iterator;
        self.upstream_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VirtualRepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.VirtualRepositoryConfig"
    }
}

/// Remote repository configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoteRepositoryConfig {
    /// The description of the remote source.
    pub description: std::string::String,

    /// Optional. The credentials used to access the remote repository.
    pub upstream_credentials:
        std::option::Option<crate::model::remote_repository_config::UpstreamCredentials>,

    /// Input only. A create/update remote repo option to avoid making a HEAD/GET
    /// request to validate a remote repo and any supplied upstream credentials.
    pub disable_upstream_validation: bool,

    /// Settings specific to the remote repository.
    pub remote_source: std::option::Option<crate::model::remote_repository_config::RemoteSource>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoteRepositoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::RemoteRepositoryConfig::description].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// let x = RemoteRepositoryConfig::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [upstream_credentials][crate::model::RemoteRepositoryConfig::upstream_credentials].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::UpstreamCredentials;
    /// let x = RemoteRepositoryConfig::new().set_upstream_credentials(UpstreamCredentials::default()/* use setters */);
    /// ```
    pub fn set_upstream_credentials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::remote_repository_config::UpstreamCredentials>,
    {
        self.upstream_credentials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upstream_credentials][crate::model::RemoteRepositoryConfig::upstream_credentials].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::UpstreamCredentials;
    /// let x = RemoteRepositoryConfig::new().set_or_clear_upstream_credentials(Some(UpstreamCredentials::default()/* use setters */));
    /// let x = RemoteRepositoryConfig::new().set_or_clear_upstream_credentials(None::<UpstreamCredentials>);
    /// ```
    pub fn set_or_clear_upstream_credentials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::remote_repository_config::UpstreamCredentials>,
    {
        self.upstream_credentials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disable_upstream_validation][crate::model::RemoteRepositoryConfig::disable_upstream_validation].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// let x = RemoteRepositoryConfig::new().set_disable_upstream_validation(true);
    /// ```
    pub fn set_disable_upstream_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_upstream_validation = v.into();
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source].
    ///
    /// Note that all the setters affecting `remote_source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::DockerRepository;
    /// let x = RemoteRepositoryConfig::new().set_remote_source(Some(
    ///     google_cloud_artifactregistry_v1::model::remote_repository_config::RemoteSource::DockerRepository(DockerRepository::default().into())));
    /// ```
    pub fn set_remote_source<
        T: std::convert::Into<
                std::option::Option<crate::model::remote_repository_config::RemoteSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = v.into();
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `DockerRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn docker_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::DockerRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::DockerRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `DockerRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::DockerRepository;
    /// let x = RemoteRepositoryConfig::new().set_docker_repository(DockerRepository::default()/* use setters */);
    /// assert!(x.docker_repository().is_some());
    /// assert!(x.maven_repository().is_none());
    /// assert!(x.npm_repository().is_none());
    /// assert!(x.python_repository().is_none());
    /// assert!(x.apt_repository().is_none());
    /// assert!(x.yum_repository().is_none());
    /// assert!(x.common_repository().is_none());
    /// ```
    pub fn set_docker_repository<
        T: std::convert::Into<
                std::boxed::Box<crate::model::remote_repository_config::DockerRepository>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::DockerRepository(v.into()),
        );
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `MavenRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn maven_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::MavenRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::MavenRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `MavenRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::MavenRepository;
    /// let x = RemoteRepositoryConfig::new().set_maven_repository(MavenRepository::default()/* use setters */);
    /// assert!(x.maven_repository().is_some());
    /// assert!(x.docker_repository().is_none());
    /// assert!(x.npm_repository().is_none());
    /// assert!(x.python_repository().is_none());
    /// assert!(x.apt_repository().is_none());
    /// assert!(x.yum_repository().is_none());
    /// assert!(x.common_repository().is_none());
    /// ```
    pub fn set_maven_repository<
        T: std::convert::Into<
                std::boxed::Box<crate::model::remote_repository_config::MavenRepository>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::MavenRepository(v.into()),
        );
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `NpmRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn npm_repository(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::NpmRepository>>
    {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::NpmRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `NpmRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::NpmRepository;
    /// let x = RemoteRepositoryConfig::new().set_npm_repository(NpmRepository::default()/* use setters */);
    /// assert!(x.npm_repository().is_some());
    /// assert!(x.docker_repository().is_none());
    /// assert!(x.maven_repository().is_none());
    /// assert!(x.python_repository().is_none());
    /// assert!(x.apt_repository().is_none());
    /// assert!(x.yum_repository().is_none());
    /// assert!(x.common_repository().is_none());
    /// ```
    pub fn set_npm_repository<
        T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::NpmRepository>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::NpmRepository(v.into()),
        );
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `PythonRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn python_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::PythonRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::PythonRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `PythonRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::PythonRepository;
    /// let x = RemoteRepositoryConfig::new().set_python_repository(PythonRepository::default()/* use setters */);
    /// assert!(x.python_repository().is_some());
    /// assert!(x.docker_repository().is_none());
    /// assert!(x.maven_repository().is_none());
    /// assert!(x.npm_repository().is_none());
    /// assert!(x.apt_repository().is_none());
    /// assert!(x.yum_repository().is_none());
    /// assert!(x.common_repository().is_none());
    /// ```
    pub fn set_python_repository<
        T: std::convert::Into<
                std::boxed::Box<crate::model::remote_repository_config::PythonRepository>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::PythonRepository(v.into()),
        );
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `AptRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn apt_repository(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::AptRepository>>
    {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::AptRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `AptRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::AptRepository;
    /// let x = RemoteRepositoryConfig::new().set_apt_repository(AptRepository::default()/* use setters */);
    /// assert!(x.apt_repository().is_some());
    /// assert!(x.docker_repository().is_none());
    /// assert!(x.maven_repository().is_none());
    /// assert!(x.npm_repository().is_none());
    /// assert!(x.python_repository().is_none());
    /// assert!(x.yum_repository().is_none());
    /// assert!(x.common_repository().is_none());
    /// ```
    pub fn set_apt_repository<
        T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::AptRepository>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::AptRepository(v.into()),
        );
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `YumRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn yum_repository(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::YumRepository>>
    {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::YumRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `YumRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::YumRepository;
    /// let x = RemoteRepositoryConfig::new().set_yum_repository(YumRepository::default()/* use setters */);
    /// assert!(x.yum_repository().is_some());
    /// assert!(x.docker_repository().is_none());
    /// assert!(x.maven_repository().is_none());
    /// assert!(x.npm_repository().is_none());
    /// assert!(x.python_repository().is_none());
    /// assert!(x.apt_repository().is_none());
    /// assert!(x.common_repository().is_none());
    /// ```
    pub fn set_yum_repository<
        T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::YumRepository>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::YumRepository(v.into()),
        );
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `CommonRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn common_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::CommonRemoteRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::CommonRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `CommonRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// use google_cloud_artifactregistry_v1::model::remote_repository_config::CommonRemoteRepository;
    /// let x = RemoteRepositoryConfig::new().set_common_repository(CommonRemoteRepository::default()/* use setters */);
    /// assert!(x.common_repository().is_some());
    /// assert!(x.docker_repository().is_none());
    /// assert!(x.maven_repository().is_none());
    /// assert!(x.npm_repository().is_none());
    /// assert!(x.python_repository().is_none());
    /// assert!(x.apt_repository().is_none());
    /// assert!(x.yum_repository().is_none());
    /// ```
    pub fn set_common_repository<
        T: std::convert::Into<
                std::boxed::Box<crate::model::remote_repository_config::CommonRemoteRepository>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::CommonRepository(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RemoteRepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig"
    }
}

/// Defines additional types related to [RemoteRepositoryConfig].
pub mod remote_repository_config {
    #[allow(unused_imports)]
    use super::*;

    /// The credentials to access the remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpstreamCredentials {
        pub credentials: std::option::Option<
            crate::model::remote_repository_config::upstream_credentials::Credentials,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UpstreamCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [credentials][crate::model::remote_repository_config::UpstreamCredentials::credentials].
        ///
        /// Note that all the setters affecting `credentials` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::UpstreamCredentials;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials;
        /// let x = UpstreamCredentials::new().set_credentials(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::upstream_credentials::Credentials::UsernamePasswordCredentials(UsernamePasswordCredentials::default().into())));
        /// ```
        pub fn set_credentials<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::upstream_credentials::Credentials,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.credentials = v.into();
            self
        }

        /// The value of [credentials][crate::model::remote_repository_config::UpstreamCredentials::credentials]
        /// if it holds a `UsernamePasswordCredentials`, `None` if the field is not set or
        /// holds a different branch.
        pub fn username_password_credentials(&self) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials>>{
            #[allow(unreachable_patterns)]
            self.credentials.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::upstream_credentials::Credentials::UsernamePasswordCredentials(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [credentials][crate::model::remote_repository_config::UpstreamCredentials::credentials]
        /// to hold a `UsernamePasswordCredentials`.
        ///
        /// Note that all the setters affecting `credentials` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::UpstreamCredentials;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials;
        /// let x = UpstreamCredentials::new().set_username_password_credentials(UsernamePasswordCredentials::default()/* use setters */);
        /// assert!(x.username_password_credentials().is_some());
        /// ```
        pub fn set_username_password_credentials<T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials>>>(mut self, v: T) -> Self{
            self.credentials = std::option::Option::Some(
                crate::model::remote_repository_config::upstream_credentials::Credentials::UsernamePasswordCredentials(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for UpstreamCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.UpstreamCredentials"
        }
    }

    /// Defines additional types related to [UpstreamCredentials].
    pub mod upstream_credentials {
        #[allow(unused_imports)]
        use super::*;

        /// Username and password credentials.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct UsernamePasswordCredentials {
            /// The username to access the remote repository.
            pub username: std::string::String,

            /// The Secret Manager key version that holds the password to access the
            /// remote repository. Must be in the format of
            /// `projects/{project}/secrets/{secret}/versions/{version}`.
            pub password_secret_version: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UsernamePasswordCredentials {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [username][crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials::username].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials;
            /// let x = UsernamePasswordCredentials::new().set_username("example");
            /// ```
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password_secret_version][crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials::password_secret_version].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials;
            /// let x = UsernamePasswordCredentials::new().set_password_secret_version("example");
            /// ```
            pub fn set_password_secret_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password_secret_version = v.into();
                self
            }
        }

        impl wkt::message::Message for UsernamePasswordCredentials {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.UpstreamCredentials.UsernamePasswordCredentials"
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Credentials {
            /// Use username and password to access the remote repository.
            UsernamePasswordCredentials(std::boxed::Box<crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials>),
        }
    }

    /// Configuration for a Docker remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DockerRepository {
        /// Address of the remote repository.
        pub upstream: std::option::Option<
            crate::model::remote_repository_config::docker_repository::Upstream,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DockerRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream].
        ///
        /// Note that all the setters affecting `upstream` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::DockerRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::docker_repository::PublicRepository;
        /// let x0 = DockerRepository::new().set_upstream(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::docker_repository::Upstream::PublicRepository(PublicRepository::DockerHub)));
        /// ```
        pub fn set_upstream<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::docker_repository::Upstream,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::docker_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::docker_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::DockerRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::docker_repository::PublicRepository;
        /// let x0 = DockerRepository::new().set_public_repository(PublicRepository::DockerHub);
        /// assert!(x0.public_repository().is_some());
        /// assert!(x0.custom_repository().is_none());
        /// ```
        pub fn set_public_repository<
            T: std::convert::Into<
                    crate::model::remote_repository_config::docker_repository::PublicRepository,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::docker_repository::Upstream::PublicRepository(
                    v.into()
                )
            );
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::docker_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::docker_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::DockerRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::docker_repository::CustomRepository;
        /// let x = DockerRepository::new().set_custom_repository(CustomRepository::default()/* use setters */);
        /// assert!(x.custom_repository().is_some());
        /// assert!(x.public_repository().is_none());
        /// ```
        pub fn set_custom_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::docker_repository::CustomRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::docker_repository::Upstream::CustomRepository(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for DockerRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.DockerRepository"
        }
    }

    /// Defines additional types related to [DockerRepository].
    pub mod docker_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the custom remote repository, for ex:
            /// `https://registry-1.docker.io`.
            pub uri: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::remote_repository_config::docker_repository::CustomRepository::uri].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::docker_repository::CustomRepository;
            /// let x = CustomRepository::new().set_uri("example");
            /// ```
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.DockerRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available Docker repositories like Docker
        /// Hub.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PublicRepository {
            /// Unspecified repository.
            Unspecified,
            /// Docker Hub.
            DockerHub,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PublicRepository::value] or
            /// [PublicRepository::name].
            UnknownValue(public_repository::UnknownValue),
        }

        #[doc(hidden)]
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PublicRepository {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::DockerHub => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PUBLIC_REPOSITORY_UNSPECIFIED"),
                    Self::DockerHub => std::option::Option::Some("DOCKER_HUB"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PublicRepository {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PublicRepository {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PublicRepository {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::DockerHub,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PublicRepository {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PUBLIC_REPOSITORY_UNSPECIFIED" => Self::Unspecified,
                    "DOCKER_HUB" => Self::DockerHub,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PublicRepository {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::DockerHub => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PublicRepository {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PublicRepository>::new(
                    ".google.devtools.artifactregistry.v1.RemoteRepositoryConfig.DockerRepository.PublicRepository"))
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Docker repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::docker_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::docker_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Maven remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MavenRepository {
        /// Address of the remote repository.
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::maven_repository::Upstream>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MavenRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream].
        ///
        /// Note that all the setters affecting `upstream` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::MavenRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::maven_repository::PublicRepository;
        /// let x0 = MavenRepository::new().set_upstream(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::maven_repository::Upstream::PublicRepository(PublicRepository::MavenCentral)));
        /// ```
        pub fn set_upstream<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::maven_repository::Upstream,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::maven_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::maven_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::MavenRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::maven_repository::PublicRepository;
        /// let x0 = MavenRepository::new().set_public_repository(PublicRepository::MavenCentral);
        /// assert!(x0.public_repository().is_some());
        /// assert!(x0.custom_repository().is_none());
        /// ```
        pub fn set_public_repository<
            T: std::convert::Into<
                    crate::model::remote_repository_config::maven_repository::PublicRepository,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::maven_repository::Upstream::PublicRepository(
                    v.into()
                )
            );
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::maven_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::maven_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::MavenRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::maven_repository::CustomRepository;
        /// let x = MavenRepository::new().set_custom_repository(CustomRepository::default()/* use setters */);
        /// assert!(x.custom_repository().is_some());
        /// assert!(x.public_repository().is_none());
        /// ```
        pub fn set_custom_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::maven_repository::CustomRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::maven_repository::Upstream::CustomRepository(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for MavenRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.MavenRepository"
        }
    }

    /// Defines additional types related to [MavenRepository].
    pub mod maven_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.maven.registry/`.
            pub uri: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::remote_repository_config::maven_repository::CustomRepository::uri].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::maven_repository::CustomRepository;
            /// let x = CustomRepository::new().set_uri("example");
            /// ```
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.MavenRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available Maven repositories like Maven
        /// Central.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PublicRepository {
            /// Unspecified repository.
            Unspecified,
            /// Maven Central.
            MavenCentral,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PublicRepository::value] or
            /// [PublicRepository::name].
            UnknownValue(public_repository::UnknownValue),
        }

        #[doc(hidden)]
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PublicRepository {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::MavenCentral => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PUBLIC_REPOSITORY_UNSPECIFIED"),
                    Self::MavenCentral => std::option::Option::Some("MAVEN_CENTRAL"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PublicRepository {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PublicRepository {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PublicRepository {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::MavenCentral,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PublicRepository {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PUBLIC_REPOSITORY_UNSPECIFIED" => Self::Unspecified,
                    "MAVEN_CENTRAL" => Self::MavenCentral,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PublicRepository {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::MavenCentral => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PublicRepository {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PublicRepository>::new(
                    ".google.devtools.artifactregistry.v1.RemoteRepositoryConfig.MavenRepository.PublicRepository"))
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Maven repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::maven_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::maven_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Npm remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NpmRepository {
        /// Address of the remote repository
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::npm_repository::Upstream>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NpmRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream].
        ///
        /// Note that all the setters affecting `upstream` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::NpmRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::npm_repository::PublicRepository;
        /// let x0 = NpmRepository::new().set_upstream(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::npm_repository::Upstream::PublicRepository(PublicRepository::Npmjs)));
        /// ```
        pub fn set_upstream<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::npm_repository::Upstream,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::npm_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::npm_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::NpmRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::npm_repository::PublicRepository;
        /// let x0 = NpmRepository::new().set_public_repository(PublicRepository::Npmjs);
        /// assert!(x0.public_repository().is_some());
        /// assert!(x0.custom_repository().is_none());
        /// ```
        pub fn set_public_repository<
            T: std::convert::Into<
                    crate::model::remote_repository_config::npm_repository::PublicRepository,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::npm_repository::Upstream::PublicRepository(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::npm_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::npm_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::NpmRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::npm_repository::CustomRepository;
        /// let x = NpmRepository::new().set_custom_repository(CustomRepository::default()/* use setters */);
        /// assert!(x.custom_repository().is_some());
        /// assert!(x.public_repository().is_none());
        /// ```
        pub fn set_custom_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::npm_repository::CustomRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::npm_repository::Upstream::CustomRepository(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for NpmRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.NpmRepository"
        }
    }

    /// Defines additional types related to [NpmRepository].
    pub mod npm_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.npm.registry/`.
            pub uri: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::remote_repository_config::npm_repository::CustomRepository::uri].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::npm_repository::CustomRepository;
            /// let x = CustomRepository::new().set_uri("example");
            /// ```
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.NpmRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available NPM repositories like npmjs.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PublicRepository {
            /// Unspecified repository.
            Unspecified,
            /// npmjs.
            Npmjs,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PublicRepository::value] or
            /// [PublicRepository::name].
            UnknownValue(public_repository::UnknownValue),
        }

        #[doc(hidden)]
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PublicRepository {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Npmjs => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PUBLIC_REPOSITORY_UNSPECIFIED"),
                    Self::Npmjs => std::option::Option::Some("NPMJS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PublicRepository {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PublicRepository {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PublicRepository {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Npmjs,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PublicRepository {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PUBLIC_REPOSITORY_UNSPECIFIED" => Self::Unspecified,
                    "NPMJS" => Self::Npmjs,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PublicRepository {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Npmjs => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PublicRepository {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PublicRepository>::new(
                    ".google.devtools.artifactregistry.v1.RemoteRepositoryConfig.NpmRepository.PublicRepository"))
            }
        }

        /// Address of the remote repository
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Npm repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::npm_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::npm_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Python remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PythonRepository {
        /// Address of the remote repository.
        pub upstream: std::option::Option<
            crate::model::remote_repository_config::python_repository::Upstream,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PythonRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream].
        ///
        /// Note that all the setters affecting `upstream` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::PythonRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::python_repository::PublicRepository;
        /// let x0 = PythonRepository::new().set_upstream(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::python_repository::Upstream::PublicRepository(PublicRepository::Pypi)));
        /// ```
        pub fn set_upstream<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::python_repository::Upstream,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::python_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::python_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::PythonRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::python_repository::PublicRepository;
        /// let x0 = PythonRepository::new().set_public_repository(PublicRepository::Pypi);
        /// assert!(x0.public_repository().is_some());
        /// assert!(x0.custom_repository().is_none());
        /// ```
        pub fn set_public_repository<
            T: std::convert::Into<
                    crate::model::remote_repository_config::python_repository::PublicRepository,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::python_repository::Upstream::PublicRepository(
                    v.into()
                )
            );
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::python_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::python_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::PythonRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::python_repository::CustomRepository;
        /// let x = PythonRepository::new().set_custom_repository(CustomRepository::default()/* use setters */);
        /// assert!(x.custom_repository().is_some());
        /// assert!(x.public_repository().is_none());
        /// ```
        pub fn set_custom_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::python_repository::CustomRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::python_repository::Upstream::CustomRepository(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for PythonRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.PythonRepository"
        }
    }

    /// Defines additional types related to [PythonRepository].
    pub mod python_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.python.registry/`.
            pub uri: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::remote_repository_config::python_repository::CustomRepository::uri].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::python_repository::CustomRepository;
            /// let x = CustomRepository::new().set_uri("example");
            /// ```
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.PythonRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available Python repositories like PyPI.org.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PublicRepository {
            /// Unspecified repository.
            Unspecified,
            /// PyPI.
            Pypi,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PublicRepository::value] or
            /// [PublicRepository::name].
            UnknownValue(public_repository::UnknownValue),
        }

        #[doc(hidden)]
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PublicRepository {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Pypi => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PUBLIC_REPOSITORY_UNSPECIFIED"),
                    Self::Pypi => std::option::Option::Some("PYPI"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PublicRepository {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PublicRepository {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PublicRepository {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Pypi,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PublicRepository {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PUBLIC_REPOSITORY_UNSPECIFIED" => Self::Unspecified,
                    "PYPI" => Self::Pypi,
                    _ => Self::UnknownValue(public_repository::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PublicRepository {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Pypi => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PublicRepository {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PublicRepository>::new(
                    ".google.devtools.artifactregistry.v1.RemoteRepositoryConfig.PythonRepository.PublicRepository"))
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Python repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::python_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::python_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for an Apt remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AptRepository {
        /// Address of the remote repository.
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::apt_repository::Upstream>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AptRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::AptRepository::upstream].
        ///
        /// Note that all the setters affecting `upstream` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::AptRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::PublicRepository;
        /// let x = AptRepository::new().set_upstream(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::Upstream::PublicRepository(PublicRepository::default().into())));
        /// ```
        pub fn set_upstream<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::apt_repository::Upstream,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn public_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::apt_repository::PublicRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::apt_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::AptRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::PublicRepository;
        /// let x = AptRepository::new().set_public_repository(PublicRepository::default()/* use setters */);
        /// assert!(x.public_repository().is_some());
        /// assert!(x.custom_repository().is_none());
        /// ```
        pub fn set_public_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::apt_repository::PublicRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::apt_repository::Upstream::PublicRepository(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::apt_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::apt_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::AptRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::CustomRepository;
        /// let x = AptRepository::new().set_custom_repository(CustomRepository::default()/* use setters */);
        /// assert!(x.custom_repository().is_some());
        /// assert!(x.public_repository().is_none());
        /// ```
        pub fn set_custom_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::apt_repository::CustomRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::apt_repository::Upstream::CustomRepository(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AptRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository"
        }
    }

    /// Defines additional types related to [AptRepository].
    pub mod apt_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Publicly available Apt repositories constructed from a common repository
        /// base and a custom repository path.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PublicRepository {
        
            /// A common public repository base for Apt.
            pub repository_base: crate::model::remote_repository_config::apt_repository::public_repository::RepositoryBase,
        
            /// A custom field to define a path to a specific repository from the base.
            pub repository_path: std::string::String,
        
            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PublicRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [repository_base][crate::model::remote_repository_config::apt_repository::PublicRepository::repository_base].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::PublicRepository;
            /// use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::public_repository::RepositoryBase;
            /// let x0 = PublicRepository::new().set_repository_base(RepositoryBase::Debian);
            /// let x1 = PublicRepository::new().set_repository_base(RepositoryBase::Ubuntu);
            /// let x2 = PublicRepository::new().set_repository_base(RepositoryBase::DebianSnapshot);
            /// ```
            pub fn set_repository_base<T: std::convert::Into<crate::model::remote_repository_config::apt_repository::public_repository::RepositoryBase>>(mut self, v: T) -> Self{
                self.repository_base = v.into();
                self
            }

            /// Sets the value of [repository_path][crate::model::remote_repository_config::apt_repository::PublicRepository::repository_path].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::PublicRepository;
            /// let x = PublicRepository::new().set_repository_path("example");
            /// ```
            pub fn set_repository_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.repository_path = v.into();
                self
            }
        }

        impl wkt::message::Message for PublicRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository.PublicRepository"
            }
        }

        /// Defines additional types related to [PublicRepository].
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;

            /// Predefined list of publicly available repository bases for Apt.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum RepositoryBase {
                /// Unspecified repository base.
                Unspecified,
                /// Debian.
                Debian,
                /// Ubuntu LTS/Pro.
                Ubuntu,
                /// Archived Debian.
                DebianSnapshot,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [RepositoryBase::value] or
                /// [RepositoryBase::name].
                UnknownValue(repository_base::UnknownValue),
            }

            #[doc(hidden)]
            pub mod repository_base {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl RepositoryBase {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Debian => std::option::Option::Some(1),
                        Self::Ubuntu => std::option::Option::Some(2),
                        Self::DebianSnapshot => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("REPOSITORY_BASE_UNSPECIFIED")
                        }
                        Self::Debian => std::option::Option::Some("DEBIAN"),
                        Self::Ubuntu => std::option::Option::Some("UBUNTU"),
                        Self::DebianSnapshot => std::option::Option::Some("DEBIAN_SNAPSHOT"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for RepositoryBase {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for RepositoryBase {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for RepositoryBase {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Debian,
                        2 => Self::Ubuntu,
                        3 => Self::DebianSnapshot,
                        _ => Self::UnknownValue(repository_base::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for RepositoryBase {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "REPOSITORY_BASE_UNSPECIFIED" => Self::Unspecified,
                        "DEBIAN" => Self::Debian,
                        "UBUNTU" => Self::Ubuntu,
                        "DEBIAN_SNAPSHOT" => Self::DebianSnapshot,
                        _ => Self::UnknownValue(repository_base::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for RepositoryBase {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Debian => serializer.serialize_i32(1),
                        Self::Ubuntu => serializer.serialize_i32(2),
                        Self::DebianSnapshot => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for RepositoryBase {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepositoryBase>::new(
                        ".google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository.PublicRepository.RepositoryBase"))
                }
            }
        }

        /// Customer-specified publicly available remote repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.apt.registry/`.
            pub uri: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::remote_repository_config::apt_repository::CustomRepository::uri].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::apt_repository::CustomRepository;
            /// let x = CustomRepository::new().set_uri("example");
            /// ```
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository.CustomRepository"
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Apt repositories supported by Artifact
            /// Registry.
            PublicRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::apt_repository::PublicRepository,
                >,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::apt_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Yum remote repository.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct YumRepository {
        /// Address of the remote repository.
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::yum_repository::Upstream>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl YumRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::YumRepository::upstream].
        ///
        /// Note that all the setters affecting `upstream` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::YumRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::PublicRepository;
        /// let x = YumRepository::new().set_upstream(Some(
        ///     google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::Upstream::PublicRepository(PublicRepository::default().into())));
        /// ```
        pub fn set_upstream<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::remote_repository_config::yum_repository::Upstream,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn public_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::yum_repository::PublicRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::yum_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::YumRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::PublicRepository;
        /// let x = YumRepository::new().set_public_repository(PublicRepository::default()/* use setters */);
        /// assert!(x.public_repository().is_some());
        /// assert!(x.custom_repository().is_none());
        /// ```
        pub fn set_public_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::yum_repository::PublicRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::yum_repository::Upstream::PublicRepository(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::yum_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::yum_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::YumRepository;
        /// use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::CustomRepository;
        /// let x = YumRepository::new().set_custom_repository(CustomRepository::default()/* use setters */);
        /// assert!(x.custom_repository().is_some());
        /// assert!(x.public_repository().is_none());
        /// ```
        pub fn set_custom_repository<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::remote_repository_config::yum_repository::CustomRepository,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::yum_repository::Upstream::CustomRepository(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for YumRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository"
        }
    }

    /// Defines additional types related to [YumRepository].
    pub mod yum_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Publicly available Yum repositories constructed from a common repository
        /// base and a custom repository path.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PublicRepository {
        
            /// A common public repository base for Yum.
            pub repository_base: crate::model::remote_repository_config::yum_repository::public_repository::RepositoryBase,
        
            /// A custom field to define a path to a specific repository from the base.
            pub repository_path: std::string::String,
        
            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PublicRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [repository_base][crate::model::remote_repository_config::yum_repository::PublicRepository::repository_base].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::PublicRepository;
            /// use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::public_repository::RepositoryBase;
            /// let x0 = PublicRepository::new().set_repository_base(RepositoryBase::Centos);
            /// let x1 = PublicRepository::new().set_repository_base(RepositoryBase::CentosDebug);
            /// let x2 = PublicRepository::new().set_repository_base(RepositoryBase::CentosVault);
            /// ```
            pub fn set_repository_base<T: std::convert::Into<crate::model::remote_repository_config::yum_repository::public_repository::RepositoryBase>>(mut self, v: T) -> Self{
                self.repository_base = v.into();
                self
            }

            /// Sets the value of [repository_path][crate::model::remote_repository_config::yum_repository::PublicRepository::repository_path].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::PublicRepository;
            /// let x = PublicRepository::new().set_repository_path("example");
            /// ```
            pub fn set_repository_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.repository_path = v.into();
                self
            }
        }

        impl wkt::message::Message for PublicRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository.PublicRepository"
            }
        }

        /// Defines additional types related to [PublicRepository].
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;

            /// Predefined list of publicly available repository bases for Yum.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum RepositoryBase {
                /// Unspecified repository base.
                Unspecified,
                /// CentOS.
                Centos,
                /// CentOS Debug.
                CentosDebug,
                /// CentOS Vault.
                CentosVault,
                /// CentOS Stream.
                CentosStream,
                /// Rocky.
                Rocky,
                /// Fedora Extra Packages for Enterprise Linux (EPEL).
                Epel,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [RepositoryBase::value] or
                /// [RepositoryBase::name].
                UnknownValue(repository_base::UnknownValue),
            }

            #[doc(hidden)]
            pub mod repository_base {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl RepositoryBase {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Centos => std::option::Option::Some(1),
                        Self::CentosDebug => std::option::Option::Some(2),
                        Self::CentosVault => std::option::Option::Some(3),
                        Self::CentosStream => std::option::Option::Some(4),
                        Self::Rocky => std::option::Option::Some(5),
                        Self::Epel => std::option::Option::Some(6),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("REPOSITORY_BASE_UNSPECIFIED")
                        }
                        Self::Centos => std::option::Option::Some("CENTOS"),
                        Self::CentosDebug => std::option::Option::Some("CENTOS_DEBUG"),
                        Self::CentosVault => std::option::Option::Some("CENTOS_VAULT"),
                        Self::CentosStream => std::option::Option::Some("CENTOS_STREAM"),
                        Self::Rocky => std::option::Option::Some("ROCKY"),
                        Self::Epel => std::option::Option::Some("EPEL"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for RepositoryBase {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for RepositoryBase {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for RepositoryBase {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Centos,
                        2 => Self::CentosDebug,
                        3 => Self::CentosVault,
                        4 => Self::CentosStream,
                        5 => Self::Rocky,
                        6 => Self::Epel,
                        _ => Self::UnknownValue(repository_base::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for RepositoryBase {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "REPOSITORY_BASE_UNSPECIFIED" => Self::Unspecified,
                        "CENTOS" => Self::Centos,
                        "CENTOS_DEBUG" => Self::CentosDebug,
                        "CENTOS_VAULT" => Self::CentosVault,
                        "CENTOS_STREAM" => Self::CentosStream,
                        "ROCKY" => Self::Rocky,
                        "EPEL" => Self::Epel,
                        _ => Self::UnknownValue(repository_base::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for RepositoryBase {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Centos => serializer.serialize_i32(1),
                        Self::CentosDebug => serializer.serialize_i32(2),
                        Self::CentosVault => serializer.serialize_i32(3),
                        Self::CentosStream => serializer.serialize_i32(4),
                        Self::Rocky => serializer.serialize_i32(5),
                        Self::Epel => serializer.serialize_i32(6),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for RepositoryBase {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepositoryBase>::new(
                        ".google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository.PublicRepository.RepositoryBase"))
                }
            }
        }

        /// Customer-specified publicly available remote repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.yum.registry/`.
            pub uri: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomRepository {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uri][crate::model::remote_repository_config::yum_repository::CustomRepository::uri].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::yum_repository::CustomRepository;
            /// let x = CustomRepository::new().set_uri("example");
            /// ```
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository.CustomRepository"
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Yum repositories supported by Artifact
            /// Registry.
            PublicRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::yum_repository::PublicRepository,
                >,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::yum_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Common remote repository settings type.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CommonRemoteRepository {
        /// Required. A common public repository base for remote repository.
        pub uri: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CommonRemoteRepository {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::remote_repository_config::CommonRemoteRepository::uri].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::remote_repository_config::CommonRemoteRepository;
        /// let x = CommonRemoteRepository::new().set_uri("example");
        /// ```
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CommonRemoteRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.CommonRemoteRepository"
        }
    }

    /// Settings specific to the remote repository.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RemoteSource {
        /// Specific settings for a Docker remote repository.
        DockerRepository(std::boxed::Box<crate::model::remote_repository_config::DockerRepository>),
        /// Specific settings for a Maven remote repository.
        MavenRepository(std::boxed::Box<crate::model::remote_repository_config::MavenRepository>),
        /// Specific settings for an Npm remote repository.
        NpmRepository(std::boxed::Box<crate::model::remote_repository_config::NpmRepository>),
        /// Specific settings for a Python remote repository.
        PythonRepository(std::boxed::Box<crate::model::remote_repository_config::PythonRepository>),
        /// Specific settings for an Apt remote repository.
        AptRepository(std::boxed::Box<crate::model::remote_repository_config::AptRepository>),
        /// Specific settings for a Yum remote repository.
        YumRepository(std::boxed::Box<crate::model::remote_repository_config::YumRepository>),
        /// Common remote repository settings.
        /// Used as the remote repository upstream URL.
        CommonRepository(
            std::boxed::Box<crate::model::remote_repository_config::CommonRemoteRepository>,
        ),
    }
}

/// A Repository for storing artifacts with a specific format.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Repository {
    /// The name of the repository, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1`. For each location
    /// in a project, repository names must be unique.
    pub name: std::string::String,

    /// Optional. The format of packages that are stored in the repository.
    pub format: crate::model::repository::Format,

    /// The user-provided description of the repository.
    pub description: std::string::String,

    /// Labels with user-defined metadata.
    /// This field may contain up to 64 entries. Label keys and values may be no
    /// longer than 63 characters. Label keys must begin with a lowercase letter
    /// and may only contain lowercase letters, numeric characters, underscores,
    /// and dashes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the repository was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the repository was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The Cloud KMS resource name of the customer managed encryption key that's
    /// used to encrypt the contents of the Repository. Has the form:
    /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
    /// This value may not be changed after the Repository has been created.
    pub kms_key_name: std::string::String,

    /// Optional. The mode of the repository.
    pub mode: crate::model::repository::Mode,

    /// Optional. Cleanup policies for this repository. Cleanup policies indicate
    /// when certain package versions can be automatically deleted. Map keys are
    /// policy IDs supplied by users during policy creation. They must unique
    /// within a repository and be under 128 characters in length.
    pub cleanup_policies:
        std::collections::HashMap<std::string::String, crate::model::CleanupPolicy>,

    /// Output only. The size, in bytes, of all artifact storage in this
    /// repository. Repositories that are generally available or in public preview
    /// use this to calculate storage costs.
    pub size_bytes: i64,

    /// Output only. If set, the repository satisfies physical zone separation.
    pub satisfies_pzs: bool,

    /// Optional. If true, the cleanup pipeline is prevented from deleting versions
    /// in this repository.
    pub cleanup_policy_dry_run: bool,

    /// Optional. Config and state for vulnerability scanning of resources within
    /// this Repository.
    pub vulnerability_scanning_config:
        std::option::Option<crate::model::repository::VulnerabilityScanningConfig>,

    /// Optional. If this is true, an unspecified repo type will be treated as
    /// error rather than defaulting to standard.
    pub disallow_unspecified_mode: bool,

    /// Output only. If set, the repository satisfies physical zone isolation.
    pub satisfies_pzi: bool,

    /// Output only. The repository endpoint, for example:
    /// `us-docker.pkg.dev/my-proj/my-repo`.
    pub registry_uri: std::string::String,

    /// Repository-specific configurations.
    pub format_config: std::option::Option<crate::model::repository::FormatConfig>,

    /// Repository configuration specific to the Mode value being selected (Remote
    /// or Virtual)
    pub mode_config: std::option::Option<crate::model::repository::ModeConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Repository {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Repository::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Repository::format].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::Format;
    /// let x0 = Repository::new().set_format(Format::Docker);
    /// let x1 = Repository::new().set_format(Format::Maven);
    /// let x2 = Repository::new().set_format(Format::Npm);
    /// ```
    pub fn set_format<T: std::convert::Into<crate::model::repository::Format>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Repository::description].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Repository::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Repository::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use wkt::Timestamp;
    /// let x = Repository::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Repository::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use wkt::Timestamp;
    /// let x = Repository::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Repository::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Repository::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use wkt::Timestamp;
    /// let x = Repository::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Repository::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use wkt::Timestamp;
    /// let x = Repository::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Repository::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Repository::kms_key_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_kms_key_name("example");
    /// ```
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::Repository::mode].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::Mode;
    /// let x0 = Repository::new().set_mode(Mode::StandardRepository);
    /// let x1 = Repository::new().set_mode(Mode::VirtualRepository);
    /// let x2 = Repository::new().set_mode(Mode::RemoteRepository);
    /// ```
    pub fn set_mode<T: std::convert::Into<crate::model::repository::Mode>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [cleanup_policies][crate::model::Repository::cleanup_policies].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::CleanupPolicy;
    /// let x = Repository::new().set_cleanup_policies([
    ///     ("key0", CleanupPolicy::default()/* use setters */),
    ///     ("key1", CleanupPolicy::default()/* use (different) setters */),
    /// ]);
    /// ```
    pub fn set_cleanup_policies<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CleanupPolicy>,
    {
        use std::iter::Iterator;
        self.cleanup_policies = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Repository::size_bytes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_size_bytes(42);
    /// ```
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Repository::satisfies_pzs].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_satisfies_pzs(true);
    /// ```
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [cleanup_policy_dry_run][crate::model::Repository::cleanup_policy_dry_run].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_cleanup_policy_dry_run(true);
    /// ```
    pub fn set_cleanup_policy_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cleanup_policy_dry_run = v.into();
        self
    }

    /// Sets the value of [vulnerability_scanning_config][crate::model::Repository::vulnerability_scanning_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
    /// let x = Repository::new().set_vulnerability_scanning_config(VulnerabilityScanningConfig::default()/* use setters */);
    /// ```
    pub fn set_vulnerability_scanning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::repository::VulnerabilityScanningConfig>,
    {
        self.vulnerability_scanning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerability_scanning_config][crate::model::Repository::vulnerability_scanning_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
    /// let x = Repository::new().set_or_clear_vulnerability_scanning_config(Some(VulnerabilityScanningConfig::default()/* use setters */));
    /// let x = Repository::new().set_or_clear_vulnerability_scanning_config(None::<VulnerabilityScanningConfig>);
    /// ```
    pub fn set_or_clear_vulnerability_scanning_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::repository::VulnerabilityScanningConfig>,
    {
        self.vulnerability_scanning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disallow_unspecified_mode][crate::model::Repository::disallow_unspecified_mode].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_disallow_unspecified_mode(true);
    /// ```
    pub fn set_disallow_unspecified_mode<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disallow_unspecified_mode = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Repository::satisfies_pzi].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_satisfies_pzi(true);
    /// ```
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [registry_uri][crate::model::Repository::registry_uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = Repository::new().set_registry_uri("example");
    /// ```
    pub fn set_registry_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.registry_uri = v.into();
        self
    }

    /// Sets the value of [format_config][crate::model::Repository::format_config].
    ///
    /// Note that all the setters affecting `format_config` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::MavenRepositoryConfig;
    /// let x = Repository::new().set_format_config(Some(
    ///     google_cloud_artifactregistry_v1::model::repository::FormatConfig::MavenConfig(MavenRepositoryConfig::default().into())));
    /// ```
    pub fn set_format_config<
        T: std::convert::Into<std::option::Option<crate::model::repository::FormatConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format_config = v.into();
        self
    }

    /// The value of [format_config][crate::model::Repository::format_config]
    /// if it holds a `MavenConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn maven_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::repository::MavenRepositoryConfig>>
    {
        #[allow(unreachable_patterns)]
        self.format_config.as_ref().and_then(|v| match v {
            crate::model::repository::FormatConfig::MavenConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [format_config][crate::model::Repository::format_config]
    /// to hold a `MavenConfig`.
    ///
    /// Note that all the setters affecting `format_config` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::MavenRepositoryConfig;
    /// let x = Repository::new().set_maven_config(MavenRepositoryConfig::default()/* use setters */);
    /// assert!(x.maven_config().is_some());
    /// assert!(x.docker_config().is_none());
    /// ```
    pub fn set_maven_config<
        T: std::convert::Into<std::boxed::Box<crate::model::repository::MavenRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format_config = std::option::Option::Some(
            crate::model::repository::FormatConfig::MavenConfig(v.into()),
        );
        self
    }

    /// The value of [format_config][crate::model::Repository::format_config]
    /// if it holds a `DockerConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn docker_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::repository::DockerRepositoryConfig>>
    {
        #[allow(unreachable_patterns)]
        self.format_config.as_ref().and_then(|v| match v {
            crate::model::repository::FormatConfig::DockerConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [format_config][crate::model::Repository::format_config]
    /// to hold a `DockerConfig`.
    ///
    /// Note that all the setters affecting `format_config` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::repository::DockerRepositoryConfig;
    /// let x = Repository::new().set_docker_config(DockerRepositoryConfig::default()/* use setters */);
    /// assert!(x.docker_config().is_some());
    /// assert!(x.maven_config().is_none());
    /// ```
    pub fn set_docker_config<
        T: std::convert::Into<std::boxed::Box<crate::model::repository::DockerRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format_config = std::option::Option::Some(
            crate::model::repository::FormatConfig::DockerConfig(v.into()),
        );
        self
    }

    /// Sets the value of [mode_config][crate::model::Repository::mode_config].
    ///
    /// Note that all the setters affecting `mode_config` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::VirtualRepositoryConfig;
    /// let x = Repository::new().set_mode_config(Some(
    ///     google_cloud_artifactregistry_v1::model::repository::ModeConfig::VirtualRepositoryConfig(VirtualRepositoryConfig::default().into())));
    /// ```
    pub fn set_mode_config<
        T: std::convert::Into<std::option::Option<crate::model::repository::ModeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode_config = v.into();
        self
    }

    /// The value of [mode_config][crate::model::Repository::mode_config]
    /// if it holds a `VirtualRepositoryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn virtual_repository_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VirtualRepositoryConfig>> {
        #[allow(unreachable_patterns)]
        self.mode_config.as_ref().and_then(|v| match v {
            crate::model::repository::ModeConfig::VirtualRepositoryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode_config][crate::model::Repository::mode_config]
    /// to hold a `VirtualRepositoryConfig`.
    ///
    /// Note that all the setters affecting `mode_config` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::VirtualRepositoryConfig;
    /// let x = Repository::new().set_virtual_repository_config(VirtualRepositoryConfig::default()/* use setters */);
    /// assert!(x.virtual_repository_config().is_some());
    /// assert!(x.remote_repository_config().is_none());
    /// ```
    pub fn set_virtual_repository_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VirtualRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode_config = std::option::Option::Some(
            crate::model::repository::ModeConfig::VirtualRepositoryConfig(v.into()),
        );
        self
    }

    /// The value of [mode_config][crate::model::Repository::mode_config]
    /// if it holds a `RemoteRepositoryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn remote_repository_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RemoteRepositoryConfig>> {
        #[allow(unreachable_patterns)]
        self.mode_config.as_ref().and_then(|v| match v {
            crate::model::repository::ModeConfig::RemoteRepositoryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode_config][crate::model::Repository::mode_config]
    /// to hold a `RemoteRepositoryConfig`.
    ///
    /// Note that all the setters affecting `mode_config` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Repository;
    /// use google_cloud_artifactregistry_v1::model::RemoteRepositoryConfig;
    /// let x = Repository::new().set_remote_repository_config(RemoteRepositoryConfig::default()/* use setters */);
    /// assert!(x.remote_repository_config().is_some());
    /// assert!(x.virtual_repository_config().is_none());
    /// ```
    pub fn set_remote_repository_config<
        T: std::convert::Into<std::boxed::Box<crate::model::RemoteRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode_config = std::option::Option::Some(
            crate::model::repository::ModeConfig::RemoteRepositoryConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Repository {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Repository"
    }
}

/// Defines additional types related to [Repository].
pub mod repository {
    #[allow(unused_imports)]
    use super::*;

    /// MavenRepositoryConfig is maven related repository details.
    /// Provides additional configuration details for repositories of the maven
    /// format type.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MavenRepositoryConfig {
        /// The repository with this flag will allow publishing
        /// the same snapshot versions.
        pub allow_snapshot_overwrites: bool,

        /// Version policy defines the versions that the registry will accept.
        pub version_policy: crate::model::repository::maven_repository_config::VersionPolicy,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MavenRepositoryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allow_snapshot_overwrites][crate::model::repository::MavenRepositoryConfig::allow_snapshot_overwrites].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::MavenRepositoryConfig;
        /// let x = MavenRepositoryConfig::new().set_allow_snapshot_overwrites(true);
        /// ```
        pub fn set_allow_snapshot_overwrites<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_snapshot_overwrites = v.into();
            self
        }

        /// Sets the value of [version_policy][crate::model::repository::MavenRepositoryConfig::version_policy].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::MavenRepositoryConfig;
        /// use google_cloud_artifactregistry_v1::model::repository::maven_repository_config::VersionPolicy;
        /// let x0 = MavenRepositoryConfig::new().set_version_policy(VersionPolicy::Release);
        /// let x1 = MavenRepositoryConfig::new().set_version_policy(VersionPolicy::Snapshot);
        /// ```
        pub fn set_version_policy<
            T: std::convert::Into<crate::model::repository::maven_repository_config::VersionPolicy>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.version_policy = v.into();
            self
        }
    }

    impl wkt::message::Message for MavenRepositoryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.Repository.MavenRepositoryConfig"
        }
    }

    /// Defines additional types related to [MavenRepositoryConfig].
    pub mod maven_repository_config {
        #[allow(unused_imports)]
        use super::*;

        /// VersionPolicy is the version policy for the repository.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum VersionPolicy {
            /// VERSION_POLICY_UNSPECIFIED - the version policy is not defined.
            /// When the version policy is not defined, no validation is performed
            /// for the versions.
            Unspecified,
            /// RELEASE - repository will accept only Release versions.
            Release,
            /// SNAPSHOT - repository will accept only Snapshot versions.
            Snapshot,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [VersionPolicy::value] or
            /// [VersionPolicy::name].
            UnknownValue(version_policy::UnknownValue),
        }

        #[doc(hidden)]
        pub mod version_policy {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl VersionPolicy {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Release => std::option::Option::Some(1),
                    Self::Snapshot => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("VERSION_POLICY_UNSPECIFIED"),
                    Self::Release => std::option::Option::Some("RELEASE"),
                    Self::Snapshot => std::option::Option::Some("SNAPSHOT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for VersionPolicy {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for VersionPolicy {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for VersionPolicy {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Release,
                    2 => Self::Snapshot,
                    _ => Self::UnknownValue(version_policy::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for VersionPolicy {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "VERSION_POLICY_UNSPECIFIED" => Self::Unspecified,
                    "RELEASE" => Self::Release,
                    "SNAPSHOT" => Self::Snapshot,
                    _ => Self::UnknownValue(version_policy::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for VersionPolicy {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Release => serializer.serialize_i32(1),
                    Self::Snapshot => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for VersionPolicy {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionPolicy>::new(
                    ".google.devtools.artifactregistry.v1.Repository.MavenRepositoryConfig.VersionPolicy"))
            }
        }
    }

    /// DockerRepositoryConfig is docker related repository details.
    /// Provides additional configuration details for repositories of the docker
    /// format type.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DockerRepositoryConfig {
        /// The repository which enabled this flag prevents all tags from being
        /// modified, moved or deleted. This does not prevent tags from being
        /// created.
        pub immutable_tags: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DockerRepositoryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [immutable_tags][crate::model::repository::DockerRepositoryConfig::immutable_tags].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::DockerRepositoryConfig;
        /// let x = DockerRepositoryConfig::new().set_immutable_tags(true);
        /// ```
        pub fn set_immutable_tags<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.immutable_tags = v.into();
            self
        }
    }

    impl wkt::message::Message for DockerRepositoryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.Repository.DockerRepositoryConfig"
        }
    }

    /// Config on whether to perform vulnerability scanning for resources in this
    /// repository, as well as output fields describing current state.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VulnerabilityScanningConfig {
        /// Optional. Config for whether this repository has vulnerability scanning
        /// disabled.
        pub enablement_config:
            crate::model::repository::vulnerability_scanning_config::EnablementConfig,

        /// Output only. The last time this repository config was enabled.
        pub last_enable_time: std::option::Option<wkt::Timestamp>,

        /// Output only. State of feature enablement, combining repository enablement
        /// config and API enablement state.
        pub enablement_state:
            crate::model::repository::vulnerability_scanning_config::EnablementState,

        /// Output only. Reason for the repository state.
        pub enablement_state_reason: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VulnerabilityScanningConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enablement_config][crate::model::repository::VulnerabilityScanningConfig::enablement_config].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
        /// use google_cloud_artifactregistry_v1::model::repository::vulnerability_scanning_config::EnablementConfig;
        /// let x0 = VulnerabilityScanningConfig::new().set_enablement_config(EnablementConfig::Inherited);
        /// let x1 = VulnerabilityScanningConfig::new().set_enablement_config(EnablementConfig::Disabled);
        /// ```
        pub fn set_enablement_config<
            T: std::convert::Into<
                    crate::model::repository::vulnerability_scanning_config::EnablementConfig,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.enablement_config = v.into();
            self
        }

        /// Sets the value of [last_enable_time][crate::model::repository::VulnerabilityScanningConfig::last_enable_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
        /// use wkt::Timestamp;
        /// let x = VulnerabilityScanningConfig::new().set_last_enable_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_last_enable_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_enable_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_enable_time][crate::model::repository::VulnerabilityScanningConfig::last_enable_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
        /// use wkt::Timestamp;
        /// let x = VulnerabilityScanningConfig::new().set_or_clear_last_enable_time(Some(Timestamp::default()/* use setters */));
        /// let x = VulnerabilityScanningConfig::new().set_or_clear_last_enable_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_last_enable_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_enable_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [enablement_state][crate::model::repository::VulnerabilityScanningConfig::enablement_state].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
        /// use google_cloud_artifactregistry_v1::model::repository::vulnerability_scanning_config::EnablementState;
        /// let x0 = VulnerabilityScanningConfig::new().set_enablement_state(EnablementState::ScanningUnsupported);
        /// let x1 = VulnerabilityScanningConfig::new().set_enablement_state(EnablementState::ScanningDisabled);
        /// let x2 = VulnerabilityScanningConfig::new().set_enablement_state(EnablementState::ScanningActive);
        /// ```
        pub fn set_enablement_state<
            T: std::convert::Into<
                    crate::model::repository::vulnerability_scanning_config::EnablementState,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.enablement_state = v.into();
            self
        }

        /// Sets the value of [enablement_state_reason][crate::model::repository::VulnerabilityScanningConfig::enablement_state_reason].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_artifactregistry_v1::model::repository::VulnerabilityScanningConfig;
        /// let x = VulnerabilityScanningConfig::new().set_enablement_state_reason("example");
        /// ```
        pub fn set_enablement_state_reason<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.enablement_state_reason = v.into();
            self
        }
    }

    impl wkt::message::Message for VulnerabilityScanningConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.Repository.VulnerabilityScanningConfig"
        }
    }

    /// Defines additional types related to [VulnerabilityScanningConfig].
    pub mod vulnerability_scanning_config {
        #[allow(unused_imports)]
        use super::*;

        /// Config for vulnerability scanning of resources in this repository.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EnablementConfig {
            /// Not set. This will be treated as INHERITED.
            Unspecified,
            /// Scanning is Enabled, but dependent on API enablement.
            Inherited,
            /// No automatic vulnerability scanning will be performed for this
            /// repository.
            Disabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EnablementConfig::value] or
            /// [EnablementConfig::name].
            UnknownValue(enablement_config::UnknownValue),
        }

        #[doc(hidden)]
        pub mod enablement_config {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EnablementConfig {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Inherited => std::option::Option::Some(1),
                    Self::Disabled => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENABLEMENT_CONFIG_UNSPECIFIED"),
                    Self::Inherited => std::option::Option::Some("INHERITED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EnablementConfig {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EnablementConfig {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EnablementConfig {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Inherited,
                    2 => Self::Disabled,
                    _ => Self::UnknownValue(enablement_config::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EnablementConfig {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENABLEMENT_CONFIG_UNSPECIFIED" => Self::Unspecified,
                    "INHERITED" => Self::Inherited,
                    "DISABLED" => Self::Disabled,
                    _ => Self::UnknownValue(enablement_config::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EnablementConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Inherited => serializer.serialize_i32(1),
                    Self::Disabled => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EnablementConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EnablementConfig>::new(
                    ".google.devtools.artifactregistry.v1.Repository.VulnerabilityScanningConfig.EnablementConfig"))
            }
        }

        /// Describes the state of vulnerability scanning in this repository,
        /// including both repository enablement and API enablement.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EnablementState {
            /// Enablement state is unclear.
            Unspecified,
            /// Repository does not support vulnerability scanning.
            ScanningUnsupported,
            /// Vulnerability scanning is disabled for this repository.
            ScanningDisabled,
            /// Vulnerability scanning is active for this repository.
            ScanningActive,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EnablementState::value] or
            /// [EnablementState::name].
            UnknownValue(enablement_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod enablement_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EnablementState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ScanningUnsupported => std::option::Option::Some(1),
                    Self::ScanningDisabled => std::option::Option::Some(2),
                    Self::ScanningActive => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENABLEMENT_STATE_UNSPECIFIED"),
                    Self::ScanningUnsupported => std::option::Option::Some("SCANNING_UNSUPPORTED"),
                    Self::ScanningDisabled => std::option::Option::Some("SCANNING_DISABLED"),
                    Self::ScanningActive => std::option::Option::Some("SCANNING_ACTIVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EnablementState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EnablementState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EnablementState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ScanningUnsupported,
                    2 => Self::ScanningDisabled,
                    3 => Self::ScanningActive,
                    _ => Self::UnknownValue(enablement_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EnablementState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENABLEMENT_STATE_UNSPECIFIED" => Self::Unspecified,
                    "SCANNING_UNSUPPORTED" => Self::ScanningUnsupported,
                    "SCANNING_DISABLED" => Self::ScanningDisabled,
                    "SCANNING_ACTIVE" => Self::ScanningActive,
                    _ => Self::UnknownValue(enablement_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EnablementState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ScanningUnsupported => serializer.serialize_i32(1),
                    Self::ScanningDisabled => serializer.serialize_i32(2),
                    Self::ScanningActive => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EnablementState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EnablementState>::new(
                    ".google.devtools.artifactregistry.v1.Repository.VulnerabilityScanningConfig.EnablementState"))
            }
        }
    }

    /// A package format.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Format {
        /// Unspecified package format.
        Unspecified,
        /// Docker package format.
        Docker,
        /// Maven package format.
        Maven,
        /// NPM package format.
        Npm,
        /// APT package format.
        Apt,
        /// YUM package format.
        Yum,
        /// Python package format.
        Python,
        /// Kubeflow Pipelines package format.
        Kfp,
        /// Go package format.
        Go,
        /// Generic package format.
        Generic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Format::value] or
        /// [Format::name].
        UnknownValue(format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Format {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Docker => std::option::Option::Some(1),
                Self::Maven => std::option::Option::Some(2),
                Self::Npm => std::option::Option::Some(3),
                Self::Apt => std::option::Option::Some(5),
                Self::Yum => std::option::Option::Some(6),
                Self::Python => std::option::Option::Some(8),
                Self::Kfp => std::option::Option::Some(9),
                Self::Go => std::option::Option::Some(10),
                Self::Generic => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                Self::Docker => std::option::Option::Some("DOCKER"),
                Self::Maven => std::option::Option::Some("MAVEN"),
                Self::Npm => std::option::Option::Some("NPM"),
                Self::Apt => std::option::Option::Some("APT"),
                Self::Yum => std::option::Option::Some("YUM"),
                Self::Python => std::option::Option::Some("PYTHON"),
                Self::Kfp => std::option::Option::Some("KFP"),
                Self::Go => std::option::Option::Some("GO"),
                Self::Generic => std::option::Option::Some("GENERIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Format {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Docker,
                2 => Self::Maven,
                3 => Self::Npm,
                5 => Self::Apt,
                6 => Self::Yum,
                8 => Self::Python,
                9 => Self::Kfp,
                10 => Self::Go,
                11 => Self::Generic,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Format {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORMAT_UNSPECIFIED" => Self::Unspecified,
                "DOCKER" => Self::Docker,
                "MAVEN" => Self::Maven,
                "NPM" => Self::Npm,
                "APT" => Self::Apt,
                "YUM" => Self::Yum,
                "PYTHON" => Self::Python,
                "KFP" => Self::Kfp,
                "GO" => Self::Go,
                "GENERIC" => Self::Generic,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Format {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Docker => serializer.serialize_i32(1),
                Self::Maven => serializer.serialize_i32(2),
                Self::Npm => serializer.serialize_i32(3),
                Self::Apt => serializer.serialize_i32(5),
                Self::Yum => serializer.serialize_i32(6),
                Self::Python => serializer.serialize_i32(8),
                Self::Kfp => serializer.serialize_i32(9),
                Self::Go => serializer.serialize_i32(10),
                Self::Generic => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Format {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                ".google.devtools.artifactregistry.v1.Repository.Format",
            ))
        }
    }

    /// The mode configures the repository to serve artifacts from different
    /// sources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Unspecified mode.
        Unspecified,
        /// A standard repository storing artifacts.
        StandardRepository,
        /// A virtual repository to serve artifacts from one or more sources.
        VirtualRepository,
        /// A remote repository to serve artifacts from a remote source.
        RemoteRepository,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardRepository => std::option::Option::Some(1),
                Self::VirtualRepository => std::option::Option::Some(2),
                Self::RemoteRepository => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::StandardRepository => std::option::Option::Some("STANDARD_REPOSITORY"),
                Self::VirtualRepository => std::option::Option::Some("VIRTUAL_REPOSITORY"),
                Self::RemoteRepository => std::option::Option::Some("REMOTE_REPOSITORY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardRepository,
                2 => Self::VirtualRepository,
                3 => Self::RemoteRepository,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_REPOSITORY" => Self::StandardRepository,
                "VIRTUAL_REPOSITORY" => Self::VirtualRepository,
                "REMOTE_REPOSITORY" => Self::RemoteRepository,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardRepository => serializer.serialize_i32(1),
                Self::VirtualRepository => serializer.serialize_i32(2),
                Self::RemoteRepository => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.devtools.artifactregistry.v1.Repository.Mode",
            ))
        }
    }

    /// Repository-specific configurations.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FormatConfig {
        /// Maven repository config contains repository level configuration
        /// for the repositories of maven type.
        MavenConfig(std::boxed::Box<crate::model::repository::MavenRepositoryConfig>),
        /// Docker repository config contains repository level configuration
        /// for the repositories of docker type.
        DockerConfig(std::boxed::Box<crate::model::repository::DockerRepositoryConfig>),
    }

    /// Repository configuration specific to the Mode value being selected (Remote
    /// or Virtual)
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModeConfig {
        /// Configuration specific for a Virtual Repository.
        VirtualRepositoryConfig(std::boxed::Box<crate::model::VirtualRepositoryConfig>),
        /// Configuration specific for a Remote Repository.
        RemoteRepositoryConfig(std::boxed::Box<crate::model::RemoteRepositoryConfig>),
    }
}

/// The request to list repositories.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRepositoriesRequest {
    /// Required. The name of the parent resource whose repositories will be
    /// listed.
    pub parent: std::string::String,

    /// The maximum number of repositories to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to repositories with the name
    /// `my-repo` in project `my-project` in the `us-central` region, append the
    /// following filter expression to your request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/*repo"`
    /// * `name="projects/my-project/locations/us-central1/repositories/*repo*"`
    pub filter: std::string::String,

    /// Optional. The field to order the results by.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRepositoriesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesRequest;
    /// let x = ListRepositoriesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRepositoriesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesRequest;
    /// let x = ListRepositoriesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRepositoriesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesRequest;
    /// let x = ListRepositoriesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRepositoriesRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesRequest;
    /// let x = ListRepositoriesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRepositoriesRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesRequest;
    /// let x = ListRepositoriesRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRepositoriesRequest"
    }
}

/// The response from listing repositories.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRepositoriesResponse {
    /// The repositories returned.
    pub repositories: std::vec::Vec<crate::model::Repository>,

    /// The token to retrieve the next page of repositories, or empty if there are
    /// no more repositories to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repositories][crate::model::ListRepositoriesResponse::repositories].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesResponse;
    /// use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = ListRepositoriesResponse::new()
    ///     .set_repositories([
    ///         Repository::default()/* use setters */,
    ///         Repository::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Repository>,
    {
        use std::iter::Iterator;
        self.repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRepositoriesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRepositoriesResponse;
    /// let x = ListRepositoriesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRepositoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRepositoriesResponse {
    type PageItem = crate::model::Repository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.repositories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve a repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRepositoryRequest {
    /// Required. The name of the repository to retrieve.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRepositoryRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetRepositoryRequest;
    /// let x = GetRepositoryRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetRepositoryRequest"
    }
}

/// The request to create a new repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRepositoryRequest {
    /// Required. The name of the parent resource where the repository will be
    /// created.
    pub parent: std::string::String,

    /// Required. The repository id to use for this repository.
    pub repository_id: std::string::String,

    /// Required. The repository to be created.
    pub repository: std::option::Option<crate::model::Repository>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRepositoryRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRepositoryRequest;
    /// let x = CreateRepositoryRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [repository_id][crate::model::CreateRepositoryRequest::repository_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRepositoryRequest;
    /// let x = CreateRepositoryRequest::new().set_repository_id("example");
    /// ```
    pub fn set_repository_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository_id = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::CreateRepositoryRequest::repository].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRepositoryRequest;
    /// use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = CreateRepositoryRequest::new().set_repository(Repository::default()/* use setters */);
    /// ```
    pub fn set_repository<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository][crate::model::CreateRepositoryRequest::repository].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRepositoryRequest;
    /// use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = CreateRepositoryRequest::new().set_or_clear_repository(Some(Repository::default()/* use setters */));
    /// let x = CreateRepositoryRequest::new().set_or_clear_repository(None::<Repository>);
    /// ```
    pub fn set_or_clear_repository<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateRepositoryRequest"
    }
}

/// The request to update a repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRepositoryRequest {
    /// The repository that replaces the resource on the server.
    pub repository: std::option::Option<crate::model::Repository>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::UpdateRepositoryRequest::repository].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRepositoryRequest;
    /// use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = UpdateRepositoryRequest::new().set_repository(Repository::default()/* use setters */);
    /// ```
    pub fn set_repository<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository][crate::model::UpdateRepositoryRequest::repository].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRepositoryRequest;
    /// use google_cloud_artifactregistry_v1::model::Repository;
    /// let x = UpdateRepositoryRequest::new().set_or_clear_repository(Some(Repository::default()/* use setters */));
    /// let x = UpdateRepositoryRequest::new().set_or_clear_repository(None::<Repository>);
    /// ```
    pub fn set_or_clear_repository<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRepositoryRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRepositoryRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateRepositoryRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRepositoryRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRepositoryRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateRepositoryRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateRepositoryRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateRepositoryRequest"
    }
}

/// The request to delete a repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRepositoryRequest {
    /// Required. The name of the repository to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRepositoryRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteRepositoryRequest;
    /// let x = DeleteRepositoryRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteRepositoryRequest"
    }
}

/// A rule defines the deny or allow action of the operation it applies to and
/// the conditions required for the rule to apply. You can set one rule for an
/// entire repository and one rule for each package within.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rule {
    /// The name of the rule, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/rules/rule1`.
    pub name: std::string::String,

    /// The action this rule takes.
    pub action: crate::model::rule::Action,

    pub operation: crate::model::rule::Operation,

    /// Optional. A CEL expression for conditions that must be met in order for the
    /// rule to apply. If not provided, the rule matches all objects.
    pub condition: std::option::Option<gtype::model::Expr>,

    /// The package ID the rule applies to.
    /// If empty, this rule applies to all packages inside the repository.
    pub package_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Rule::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = Rule::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [action][crate::model::Rule::action].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Rule;
    /// use google_cloud_artifactregistry_v1::model::rule::Action;
    /// let x0 = Rule::new().set_action(Action::Allow);
    /// let x1 = Rule::new().set_action(Action::Deny);
    /// ```
    pub fn set_action<T: std::convert::Into<crate::model::rule::Action>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::Rule::operation].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Rule;
    /// use google_cloud_artifactregistry_v1::model::rule::Operation;
    /// let x0 = Rule::new().set_operation(Operation::Download);
    /// ```
    pub fn set_operation<T: std::convert::Into<crate::model::rule::Operation>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::Rule::condition].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Rule;
    /// use gtype::model::Expr;
    /// let x = Rule::new().set_condition(Expr::default()/* use setters */);
    /// ```
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Rule::condition].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Rule;
    /// use gtype::model::Expr;
    /// let x = Rule::new().set_or_clear_condition(Some(Expr::default()/* use setters */));
    /// let x = Rule::new().set_or_clear_condition(None::<Expr>);
    /// ```
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [package_id][crate::model::Rule::package_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = Rule::new().set_package_id("example");
    /// ```
    pub fn set_package_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_id = v.into();
        self
    }
}

impl wkt::message::Message for Rule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Rule"
    }
}

/// Defines additional types related to [Rule].
pub mod rule {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the action of the rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Action not specified.
        Unspecified,
        /// Allow the operation.
        Allow,
        /// Deny the operation.
        Deny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Deny => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Deny => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.devtools.artifactregistry.v1.Rule.Action",
            ))
        }
    }

    /// The operation the rule applies to.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operation {
        /// Operation not specified.
        Unspecified,
        /// Download operation.
        Download,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operation::value] or
        /// [Operation::name].
        UnknownValue(operation::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operation {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Operation {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Download => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPERATION_UNSPECIFIED"),
                Self::Download => std::option::Option::Some("DOWNLOAD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Operation {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Operation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Operation {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Download,
                _ => Self::UnknownValue(operation::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Operation {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATION_UNSPECIFIED" => Self::Unspecified,
                "DOWNLOAD" => Self::Download,
                _ => Self::UnknownValue(operation::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Operation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Download => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Operation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operation>::new(
                ".google.devtools.artifactregistry.v1.Rule.Operation",
            ))
        }
    }
}

/// The request to list rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRulesRequest {
    /// Required. The name of the parent repository whose rules will be listed.
    /// For example:
    /// `projects/p1/locations/us-central1/repositories/repo1`.
    pub parent: std::string::String,

    /// The maximum number of rules to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRulesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRulesRequest;
    /// let x = ListRulesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRulesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRulesRequest;
    /// let x = ListRulesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRulesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRulesRequest;
    /// let x = ListRulesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRulesRequest"
    }
}

/// The response from listing rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRulesResponse {
    /// The rules returned.
    pub rules: std::vec::Vec<crate::model::Rule>,

    /// The token to retrieve the next page of rules, or empty if there are no
    /// more rules to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rules][crate::model::ListRulesResponse::rules].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRulesResponse;
    /// use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = ListRulesResponse::new()
    ///     .set_rules([
    ///         Rule::default()/* use setters */,
    ///         Rule::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRulesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListRulesResponse;
    /// let x = ListRulesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRulesResponse {
    type PageItem = crate::model::Rule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve a rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRuleRequest {
    /// Required. The name of the rule to retrieve.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRuleRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetRuleRequest;
    /// let x = GetRuleRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetRuleRequest"
    }
}

/// The request to create a new rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRuleRequest {
    /// Required. The name of the parent resource where the rule will be created.
    pub parent: std::string::String,

    /// The rule id to use for this repository.
    pub rule_id: std::string::String,

    /// The rule to be created.
    pub rule: std::option::Option<crate::model::Rule>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRuleRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRuleRequest;
    /// let x = CreateRuleRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::CreateRuleRequest::rule_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRuleRequest;
    /// let x = CreateRuleRequest::new().set_rule_id("example");
    /// ```
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::CreateRuleRequest::rule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRuleRequest;
    /// use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = CreateRuleRequest::new().set_rule(Rule::default()/* use setters */);
    /// ```
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::CreateRuleRequest::rule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateRuleRequest;
    /// use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = CreateRuleRequest::new().set_or_clear_rule(Some(Rule::default()/* use setters */));
    /// let x = CreateRuleRequest::new().set_or_clear_rule(None::<Rule>);
    /// ```
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateRuleRequest"
    }
}

/// The request to update a rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRuleRequest {
    /// The rule that replaces the resource on the server.
    pub rule: std::option::Option<crate::model::Rule>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::UpdateRuleRequest::rule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRuleRequest;
    /// use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = UpdateRuleRequest::new().set_rule(Rule::default()/* use setters */);
    /// ```
    pub fn set_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rule>,
    {
        self.rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule][crate::model::UpdateRuleRequest::rule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRuleRequest;
    /// use google_cloud_artifactregistry_v1::model::Rule;
    /// let x = UpdateRuleRequest::new().set_or_clear_rule(Some(Rule::default()/* use setters */));
    /// let x = UpdateRuleRequest::new().set_or_clear_rule(None::<Rule>);
    /// ```
    pub fn set_or_clear_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rule>,
    {
        self.rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRuleRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRuleRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateRuleRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRuleRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateRuleRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateRuleRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateRuleRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateRuleRequest"
    }
}

/// The request to delete a rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRuleRequest {
    /// Required. The name of the rule to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRuleRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteRuleRequest;
    /// let x = DeleteRuleRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteRuleRequest"
    }
}

/// Metadata type for longrunning-operations, currently empty.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.OperationMetadata"
    }
}

/// The Artifact Registry settings that apply to a Project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectSettings {
    /// The name of the project's settings.
    ///
    /// Always of the form:
    /// projects/{project-id}/projectSettings
    ///
    /// In update request: never set
    /// In response: always set
    pub name: std::string::String,

    /// The redirection state of the legacy repositories in this project.
    pub legacy_redirection_state: crate::model::project_settings::RedirectionState,

    /// The percentage of pull traffic to redirect from GCR to AR when using
    /// partial redirection.
    pub pull_percent: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProjectSettings::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ProjectSettings;
    /// let x = ProjectSettings::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [legacy_redirection_state][crate::model::ProjectSettings::legacy_redirection_state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ProjectSettings;
    /// use google_cloud_artifactregistry_v1::model::project_settings::RedirectionState;
    /// let x0 = ProjectSettings::new().set_legacy_redirection_state(RedirectionState::RedirectionFromGcrIoDisabled);
    /// let x1 = ProjectSettings::new().set_legacy_redirection_state(RedirectionState::RedirectionFromGcrIoEnabled);
    /// let x2 = ProjectSettings::new().set_legacy_redirection_state(RedirectionState::RedirectionFromGcrIoEnabledAndCopying);
    /// ```
    pub fn set_legacy_redirection_state<
        T: std::convert::Into<crate::model::project_settings::RedirectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_redirection_state = v.into();
        self
    }

    /// Sets the value of [pull_percent][crate::model::ProjectSettings::pull_percent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ProjectSettings;
    /// let x = ProjectSettings::new().set_pull_percent(42);
    /// ```
    pub fn set_pull_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pull_percent = v.into();
        self
    }
}

impl wkt::message::Message for ProjectSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ProjectSettings"
    }
}

/// Defines additional types related to [ProjectSettings].
pub mod project_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The possible redirection states for legacy repositories.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RedirectionState {
        /// No redirection status has been set.
        Unspecified,
        /// Redirection is disabled.
        RedirectionFromGcrIoDisabled,
        /// Redirection is enabled.
        RedirectionFromGcrIoEnabled,
        /// Redirection is enabled, and has been finalized so cannot be reverted.
        #[deprecated]
        RedirectionFromGcrIoFinalized,
        /// Redirection is enabled and missing images are copied from GCR
        RedirectionFromGcrIoEnabledAndCopying,
        /// Redirection is partially enabled and missing images are copied from GCR
        RedirectionFromGcrIoPartialAndCopying,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RedirectionState::value] or
        /// [RedirectionState::name].
        UnknownValue(redirection_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod redirection_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RedirectionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RedirectionFromGcrIoDisabled => std::option::Option::Some(1),
                Self::RedirectionFromGcrIoEnabled => std::option::Option::Some(2),
                Self::RedirectionFromGcrIoFinalized => std::option::Option::Some(3),
                Self::RedirectionFromGcrIoEnabledAndCopying => std::option::Option::Some(5),
                Self::RedirectionFromGcrIoPartialAndCopying => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REDIRECTION_STATE_UNSPECIFIED"),
                Self::RedirectionFromGcrIoDisabled => {
                    std::option::Option::Some("REDIRECTION_FROM_GCR_IO_DISABLED")
                }
                Self::RedirectionFromGcrIoEnabled => {
                    std::option::Option::Some("REDIRECTION_FROM_GCR_IO_ENABLED")
                }
                Self::RedirectionFromGcrIoFinalized => {
                    std::option::Option::Some("REDIRECTION_FROM_GCR_IO_FINALIZED")
                }
                Self::RedirectionFromGcrIoEnabledAndCopying => {
                    std::option::Option::Some("REDIRECTION_FROM_GCR_IO_ENABLED_AND_COPYING")
                }
                Self::RedirectionFromGcrIoPartialAndCopying => {
                    std::option::Option::Some("REDIRECTION_FROM_GCR_IO_PARTIAL_AND_COPYING")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RedirectionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RedirectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RedirectionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RedirectionFromGcrIoDisabled,
                2 => Self::RedirectionFromGcrIoEnabled,
                3 => Self::RedirectionFromGcrIoFinalized,
                5 => Self::RedirectionFromGcrIoEnabledAndCopying,
                6 => Self::RedirectionFromGcrIoPartialAndCopying,
                _ => Self::UnknownValue(redirection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RedirectionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDIRECTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "REDIRECTION_FROM_GCR_IO_DISABLED" => Self::RedirectionFromGcrIoDisabled,
                "REDIRECTION_FROM_GCR_IO_ENABLED" => Self::RedirectionFromGcrIoEnabled,
                "REDIRECTION_FROM_GCR_IO_FINALIZED" => Self::RedirectionFromGcrIoFinalized,
                "REDIRECTION_FROM_GCR_IO_ENABLED_AND_COPYING" => {
                    Self::RedirectionFromGcrIoEnabledAndCopying
                }
                "REDIRECTION_FROM_GCR_IO_PARTIAL_AND_COPYING" => {
                    Self::RedirectionFromGcrIoPartialAndCopying
                }
                _ => Self::UnknownValue(redirection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RedirectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RedirectionFromGcrIoDisabled => serializer.serialize_i32(1),
                Self::RedirectionFromGcrIoEnabled => serializer.serialize_i32(2),
                Self::RedirectionFromGcrIoFinalized => serializer.serialize_i32(3),
                Self::RedirectionFromGcrIoEnabledAndCopying => serializer.serialize_i32(5),
                Self::RedirectionFromGcrIoPartialAndCopying => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RedirectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RedirectionState>::new(
                ".google.devtools.artifactregistry.v1.ProjectSettings.RedirectionState",
            ))
        }
    }
}

/// Gets the redirection status for a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProjectSettingsRequest {
    /// Required. The name of the projectSettings resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProjectSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProjectSettingsRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetProjectSettingsRequest;
    /// let x = GetProjectSettingsRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProjectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetProjectSettingsRequest"
    }
}

/// Sets the settings of the project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProjectSettingsRequest {
    /// The project settings.
    pub project_settings: std::option::Option<crate::model::ProjectSettings>,

    /// Field mask to support partial updates.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProjectSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_settings][crate::model::UpdateProjectSettingsRequest::project_settings].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateProjectSettingsRequest;
    /// use google_cloud_artifactregistry_v1::model::ProjectSettings;
    /// let x = UpdateProjectSettingsRequest::new().set_project_settings(ProjectSettings::default()/* use setters */);
    /// ```
    pub fn set_project_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProjectSettings>,
    {
        self.project_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [project_settings][crate::model::UpdateProjectSettingsRequest::project_settings].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateProjectSettingsRequest;
    /// use google_cloud_artifactregistry_v1::model::ProjectSettings;
    /// let x = UpdateProjectSettingsRequest::new().set_or_clear_project_settings(Some(ProjectSettings::default()/* use setters */));
    /// let x = UpdateProjectSettingsRequest::new().set_or_clear_project_settings(None::<ProjectSettings>);
    /// ```
    pub fn set_or_clear_project_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProjectSettings>,
    {
        self.project_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProjectSettingsRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateProjectSettingsRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateProjectSettingsRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateProjectSettingsRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateProjectSettingsRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateProjectSettingsRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateProjectSettingsRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateProjectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateProjectSettingsRequest"
    }
}

/// Tags point to a version and represent an alternative name that can be used
/// to access the version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tag {
    /// The name of the tag, for example:
    /// "projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/tags/tag1".
    /// If the package part contains slashes, the slashes are escaped.
    /// The tag part can only have characters in [a-zA-Z0-9\-._~:@], anything else
    /// must be URL encoded.
    pub name: std::string::String,

    /// The name of the version the tag refers to, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/versions/sha256:5243811`
    /// If the package or version ID parts contain slashes, the slashes are
    /// escaped.
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tag::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = Tag::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Tag::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = Tag::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Tag"
    }
}

/// The request to list tags.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTagsRequest {
    /// The name of the parent package whose tags will be listed.
    /// For example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1`.
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `version`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to tags with the name `my-tag` in
    /// package `my-package` in repository `my-repo` in project "`y-project` in
    /// the us-central region, append the following filter expression to your
    /// request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/my-tag"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/my*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/*tag"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/*tag*"`
    ///
    /// To filter the results of your request to tags applied to the version
    /// `1.0` in package `my-package`, append the following filter expression to
    /// your request:
    ///
    /// * `version="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/1.0"`
    pub filter: std::string::String,

    /// The maximum number of tags to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTagsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListTagsRequest;
    /// let x = ListTagsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTagsRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListTagsRequest;
    /// let x = ListTagsRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTagsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListTagsRequest;
    /// let x = ListTagsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTagsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListTagsRequest;
    /// let x = ListTagsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListTagsRequest"
    }
}

/// The response from listing tags.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTagsResponse {
    /// The tags returned.
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// The token to retrieve the next page of tags, or empty if there are no
    /// more tags to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::ListTagsResponse::tags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListTagsResponse;
    /// use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = ListTagsResponse::new()
    ///     .set_tags([
    ///         Tag::default()/* use setters */,
    ///         Tag::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTagsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListTagsResponse;
    /// let x = ListTagsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListTagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTagsResponse {
    type PageItem = crate::model::Tag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve a tag.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTagRequest {
    /// The name of the tag to retrieve.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTagRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetTagRequest;
    /// let x = GetTagRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetTagRequest"
    }
}

/// The request to create a new tag.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTagRequest {
    /// The name of the parent resource where the tag will be created.
    pub parent: std::string::String,

    /// The tag id to use for this repository.
    pub tag_id: std::string::String,

    /// The tag to be created.
    pub tag: std::option::Option<crate::model::Tag>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTagRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateTagRequest;
    /// let x = CreateTagRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_id][crate::model::CreateTagRequest::tag_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateTagRequest;
    /// let x = CreateTagRequest::new().set_tag_id("example");
    /// ```
    pub fn set_tag_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_id = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::CreateTagRequest::tag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateTagRequest;
    /// use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = CreateTagRequest::new().set_tag(Tag::default()/* use setters */);
    /// ```
    pub fn set_tag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag][crate::model::CreateTagRequest::tag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::CreateTagRequest;
    /// use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = CreateTagRequest::new().set_or_clear_tag(Some(Tag::default()/* use setters */));
    /// let x = CreateTagRequest::new().set_or_clear_tag(None::<Tag>);
    /// ```
    pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateTagRequest"
    }
}

/// The request to create or update a tag.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTagRequest {
    /// The tag that replaces the resource on the server.
    pub tag: std::option::Option<crate::model::Tag>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag][crate::model::UpdateTagRequest::tag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateTagRequest;
    /// use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = UpdateTagRequest::new().set_tag(Tag::default()/* use setters */);
    /// ```
    pub fn set_tag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tag][crate::model::UpdateTagRequest::tag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateTagRequest;
    /// use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = UpdateTagRequest::new().set_or_clear_tag(Some(Tag::default()/* use setters */));
    /// let x = UpdateTagRequest::new().set_or_clear_tag(None::<Tag>);
    /// ```
    pub fn set_or_clear_tag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tag>,
    {
        self.tag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateTagRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateTagRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateTagRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateTagRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateTagRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateTagRequest"
    }
}

/// The request to delete a tag.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTagRequest {
    /// The name of the tag to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTagRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTagRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteTagRequest;
    /// let x = DeleteTagRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteTagRequest"
    }
}

/// The body of a version resource. A version resource represents a
/// collection of components, such as files and other data. This may correspond
/// to a version in many package management schemes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// The name of the version, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/versions/art1`.
    /// If the package or version ID parts contain slashes, the slashes are
    /// escaped.
    pub name: std::string::String,

    /// Optional. Description of the version, as specified in its metadata.
    pub description: std::string::String,

    /// The time when the version was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the version was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A list of related tags. Will contain up to 100 tags that
    /// reference this version.
    pub related_tags: std::vec::Vec<crate::model::Tag>,

    /// Output only. Repository-specific Metadata stored against this version.
    /// The fields returned are defined by the underlying repository-specific
    /// resource. Currently, the resources could be:
    /// [DockerImage][google.devtools.artifactregistry.v1.DockerImage]
    /// [MavenArtifact][google.devtools.artifactregistry.v1.MavenArtifact]
    ///
    /// [google.devtools.artifactregistry.v1.DockerImage]: crate::model::DockerImage
    /// [google.devtools.artifactregistry.v1.MavenArtifact]: crate::model::MavenArtifact
    pub metadata: std::option::Option<wkt::Struct>,

    /// Optional. Client specified annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// let x = Version::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Version::description].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// let x = Version::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use wkt::Timestamp;
    /// let x = Version::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Version::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use wkt::Timestamp;
    /// let x = Version::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Version::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Version::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use wkt::Timestamp;
    /// let x = Version::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Version::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use wkt::Timestamp;
    /// let x = Version::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Version::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_tags][crate::model::Version::related_tags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use google_cloud_artifactregistry_v1::model::Tag;
    /// let x = Version::new()
    ///     .set_related_tags([
    ///         Tag::default()/* use setters */,
    ///         Tag::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_related_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.related_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Version::metadata].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use wkt::Struct;
    /// let x = Version::new().set_metadata(Struct::default()/* use setters */);
    /// ```
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::Version::metadata].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// use wkt::Struct;
    /// let x = Version::new().set_or_clear_metadata(Some(Struct::default()/* use setters */));
    /// let x = Version::new().set_or_clear_metadata(None::<Struct>);
    /// ```
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::Version::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::Version;
    /// let x = Version::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Version"
    }
}

/// The request to list versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// The name of the parent resource whose versions will be listed.
    pub parent: std::string::String,

    /// The maximum number of versions to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    pub page_token: std::string::String,

    /// The view that should be returned in the response.
    pub view: crate::model::VersionView,

    /// Optional. The field to order the results by.
    pub order_by: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `annotations`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to versions with the name
    /// `my-version` in project `my-project` in the `us-central` region, in
    /// repository `my-repo`, append the following filter expression to your
    /// request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/my-version"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/*version"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/my*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/*version*"`
    ///
    /// To filter the results of your request to versions with the annotation
    /// key-value pair [`external_link`: `external_link_value`], append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link:external_link_value"`
    ///
    /// To filter just for a specific annotation key `external_link`, append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link"`
    ///
    /// If the annotation key or value contains special characters, you can escape
    /// them by surrounding the value with backticks. For example, to filter the
    /// results of your request to versions with the annotation key-value pair
    /// [`external.link`:`<https://example.com/my-version>`], append the following
    /// filter expression to your request:
    ///
    /// * `` "annotations.`external.link`:`<https://example.com/my-version>`" ``
    ///
    /// You can also filter with annotations with a wildcard to
    /// match any number of characters before or after the value:
    ///
    /// * `` "annotations.*_link:`*example.com*`" ``
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsRequest;
    /// let x = ListVersionsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsRequest;
    /// let x = ListVersionsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsRequest;
    /// let x = ListVersionsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListVersionsRequest::view].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsRequest;
    /// use google_cloud_artifactregistry_v1::model::VersionView;
    /// let x0 = ListVersionsRequest::new().set_view(VersionView::Basic);
    /// let x1 = ListVersionsRequest::new().set_view(VersionView::Full);
    /// ```
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVersionsRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsRequest;
    /// let x = ListVersionsRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVersionsRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsRequest;
    /// let x = ListVersionsRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListVersionsRequest"
    }
}

/// The response from listing versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The versions returned.
    pub versions: std::vec::Vec<crate::model::Version>,

    /// The token to retrieve the next page of versions, or empty if there are no
    /// more versions to return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsResponse;
    /// use google_cloud_artifactregistry_v1::model::Version;
    /// let x = ListVersionsResponse::new()
    ///     .set_versions([
    ///         Version::default()/* use setters */,
    ///         Version::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ListVersionsResponse;
    /// let x = ListVersionsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to retrieve a version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// The name of the version to retrieve.
    pub name: std::string::String,

    /// The view that should be returned in the response.
    pub view: crate::model::VersionView,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetVersionRequest;
    /// let x = GetVersionRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetVersionRequest::view].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetVersionRequest;
    /// use google_cloud_artifactregistry_v1::model::VersionView;
    /// let x0 = GetVersionRequest::new().set_view(VersionView::Basic);
    /// let x1 = GetVersionRequest::new().set_view(VersionView::Full);
    /// ```
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetVersionRequest"
    }
}

/// The request to delete a version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// The name of the version to delete.
    pub name: std::string::String,

    /// By default, a version that is tagged may not be deleted. If force=true, the
    /// version and any tags pointing to the version are deleted.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteVersionRequest;
    /// let x = DeleteVersionRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteVersionRequest::force].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::DeleteVersionRequest;
    /// let x = DeleteVersionRequest::new().set_force(true);
    /// ```
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteVersionRequest"
    }
}

/// The request to delete multiple versions across a repository.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteVersionsRequest {
    /// The name of the repository holding all requested versions.
    pub parent: std::string::String,

    /// Required. The names of the versions to delete.
    /// The maximum number of versions deleted per batch is determined by the
    /// service and is dependent on the available resources in the region.
    pub names: std::vec::Vec<std::string::String>,

    /// If true, the request is performed without deleting data, following AIP-163.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDeleteVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteVersionsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::BatchDeleteVersionsRequest;
    /// let x = BatchDeleteVersionsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeleteVersionsRequest::names].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::BatchDeleteVersionsRequest;
    /// let x = BatchDeleteVersionsRequest::new().set_names(["a", "b", "c"]);
    /// ```
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [validate_only][crate::model::BatchDeleteVersionsRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::BatchDeleteVersionsRequest;
    /// let x = BatchDeleteVersionsRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for BatchDeleteVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.BatchDeleteVersionsRequest"
    }
}

/// The metadata of an LRO from deleting multiple versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteVersionsMetadata {
    /// The versions the operation failed to delete.
    pub failed_versions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDeleteVersionsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [failed_versions][crate::model::BatchDeleteVersionsMetadata::failed_versions].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::BatchDeleteVersionsMetadata;
    /// let x = BatchDeleteVersionsMetadata::new().set_failed_versions(["a", "b", "c"]);
    /// ```
    pub fn set_failed_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteVersionsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.BatchDeleteVersionsMetadata"
    }
}

/// The request to update a version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Required. The Version that replaces the resource on the server.
    pub version: std::option::Option<crate::model::Version>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVersionRequest;
    /// use google_cloud_artifactregistry_v1::model::Version;
    /// let x = UpdateVersionRequest::new().set_version(Version::default()/* use setters */);
    /// ```
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpdateVersionRequest::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVersionRequest;
    /// use google_cloud_artifactregistry_v1::model::Version;
    /// let x = UpdateVersionRequest::new().set_or_clear_version(Some(Version::default()/* use setters */));
    /// let x = UpdateVersionRequest::new().set_or_clear_version(None::<Version>);
    /// ```
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVersionRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateVersionRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVersionRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateVersionRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateVersionRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateVersionRequest"
    }
}

/// The Artifact Registry VPC SC config that apply to a Project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VPCSCConfig {
    /// The name of the project's VPC SC Config.
    ///
    /// Always of the form:
    /// projects/{projectID}/locations/{location}/vpcscConfig
    ///
    /// In update request: never set
    /// In response: always set
    pub name: std::string::String,

    /// The project per location VPC SC policy that defines the VPC SC behavior for
    /// the Remote Repository (Allow/Deny).
    pub vpcsc_policy: crate::model::vpcsc_config::VPCSCPolicy,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VPCSCConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VPCSCConfig::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::VPCSCConfig;
    /// let x = VPCSCConfig::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [vpcsc_policy][crate::model::VPCSCConfig::vpcsc_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::VPCSCConfig;
    /// use google_cloud_artifactregistry_v1::model::vpcsc_config::VPCSCPolicy;
    /// let x0 = VPCSCConfig::new().set_vpcsc_policy(VPCSCPolicy::Deny);
    /// let x1 = VPCSCConfig::new().set_vpcsc_policy(VPCSCPolicy::Allow);
    /// ```
    pub fn set_vpcsc_policy<T: std::convert::Into<crate::model::vpcsc_config::VPCSCPolicy>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpcsc_policy = v.into();
        self
    }
}

impl wkt::message::Message for VPCSCConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.VPCSCConfig"
    }
}

/// Defines additional types related to [VPCSCConfig].
pub mod vpcsc_config {
    #[allow(unused_imports)]
    use super::*;

    /// VPCSCPolicy is the VPC SC policy for project and location.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VPCSCPolicy {
        /// VPCSC_POLICY_UNSPECIFIED - the VPS SC policy is not defined.
        /// When VPS SC policy is not defined - the Service will use the default
        /// behavior (VPCSC_DENY).
        Unspecified,
        /// VPCSC_DENY - repository will block the requests to the Upstreams for the
        /// Remote Repositories if the resource is in the perimeter.
        Deny,
        /// VPCSC_ALLOW - repository will allow the requests to the Upstreams for the
        /// Remote Repositories if the resource is in the perimeter.
        Allow,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VPCSCPolicy::value] or
        /// [VPCSCPolicy::name].
        UnknownValue(vpcsc_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vpcsc_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VPCSCPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Deny => std::option::Option::Some(1),
                Self::Allow => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VPCSC_POLICY_UNSPECIFIED"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VPCSCPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VPCSCPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VPCSCPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Deny,
                2 => Self::Allow,
                _ => Self::UnknownValue(vpcsc_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VPCSCPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VPCSC_POLICY_UNSPECIFIED" => Self::Unspecified,
                "DENY" => Self::Deny,
                "ALLOW" => Self::Allow,
                _ => Self::UnknownValue(vpcsc_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VPCSCPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Deny => serializer.serialize_i32(1),
                Self::Allow => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VPCSCPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VPCSCPolicy>::new(
                ".google.devtools.artifactregistry.v1.VPCSCConfig.VPCSCPolicy",
            ))
        }
    }
}

/// Gets the VPC SC config for a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVPCSCConfigRequest {
    /// Required. The name of the VPCSCConfig resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVPCSCConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVPCSCConfigRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::GetVPCSCConfigRequest;
    /// let x = GetVPCSCConfigRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVPCSCConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetVPCSCConfigRequest"
    }
}

/// Sets the VPCSC config of the project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVPCSCConfigRequest {
    /// The project config.
    pub vpcsc_config: std::option::Option<crate::model::VPCSCConfig>,

    /// Field mask to support partial updates.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVPCSCConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpcsc_config][crate::model::UpdateVPCSCConfigRequest::vpcsc_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVPCSCConfigRequest;
    /// use google_cloud_artifactregistry_v1::model::VPCSCConfig;
    /// let x = UpdateVPCSCConfigRequest::new().set_vpcsc_config(VPCSCConfig::default()/* use setters */);
    /// ```
    pub fn set_vpcsc_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VPCSCConfig>,
    {
        self.vpcsc_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpcsc_config][crate::model::UpdateVPCSCConfigRequest::vpcsc_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVPCSCConfigRequest;
    /// use google_cloud_artifactregistry_v1::model::VPCSCConfig;
    /// let x = UpdateVPCSCConfigRequest::new().set_or_clear_vpcsc_config(Some(VPCSCConfig::default()/* use setters */));
    /// let x = UpdateVPCSCConfigRequest::new().set_or_clear_vpcsc_config(None::<VPCSCConfig>);
    /// ```
    pub fn set_or_clear_vpcsc_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VPCSCConfig>,
    {
        self.vpcsc_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVPCSCConfigRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVPCSCConfigRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateVPCSCConfigRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVPCSCConfigRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::UpdateVPCSCConfigRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateVPCSCConfigRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateVPCSCConfigRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVPCSCConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateVPCSCConfigRequest"
    }
}

/// A detailed representation of a Yum artifact.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct YumArtifact {
    /// Output only. The Artifact Registry resource name of the artifact.
    pub name: std::string::String,

    /// Output only. The yum package name of the artifact.
    pub package_name: std::string::String,

    /// Output only. An artifact is a binary or source package.
    pub package_type: crate::model::yum_artifact::PackageType,

    /// Output only. Operating system architecture of the artifact.
    pub architecture: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl YumArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::YumArtifact::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::YumArtifact;
    /// let x = YumArtifact::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::YumArtifact::package_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::YumArtifact;
    /// let x = YumArtifact::new().set_package_name("example");
    /// ```
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [package_type][crate::model::YumArtifact::package_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::YumArtifact;
    /// use google_cloud_artifactregistry_v1::model::yum_artifact::PackageType;
    /// let x0 = YumArtifact::new().set_package_type(PackageType::Binary);
    /// let x1 = YumArtifact::new().set_package_type(PackageType::Source);
    /// ```
    pub fn set_package_type<T: std::convert::Into<crate::model::yum_artifact::PackageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::YumArtifact::architecture].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::YumArtifact;
    /// let x = YumArtifact::new().set_architecture("example");
    /// ```
    pub fn set_architecture<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for YumArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.YumArtifact"
    }
}

/// Defines additional types related to [YumArtifact].
pub mod yum_artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Package type is either binary or source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PackageType {
        /// Package type is not specified.
        Unspecified,
        /// Binary package (.rpm).
        Binary,
        /// Source package (.srpm).
        Source,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PackageType::value] or
        /// [PackageType::name].
        UnknownValue(package_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod package_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PackageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Binary => std::option::Option::Some(1),
                Self::Source => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PACKAGE_TYPE_UNSPECIFIED"),
                Self::Binary => std::option::Option::Some("BINARY"),
                Self::Source => std::option::Option::Some("SOURCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PackageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PackageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PackageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Binary,
                2 => Self::Source,
                _ => Self::UnknownValue(package_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PackageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PACKAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BINARY" => Self::Binary,
                "SOURCE" => Self::Source,
                _ => Self::UnknownValue(package_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PackageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Binary => serializer.serialize_i32(1),
                Self::Source => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PackageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PackageType>::new(
                ".google.devtools.artifactregistry.v1.YumArtifact.PackageType",
            ))
        }
    }
}

/// Google Cloud Storage location where the artifacts currently reside.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportYumArtifactsGcsSource {
    /// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
    pub uris: std::vec::Vec<std::string::String>,

    /// Supports URI wildcards for matching multiple objects from a single URI.
    pub use_wildcards: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportYumArtifactsGcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uris][crate::model::ImportYumArtifactsGcsSource::uris].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsGcsSource;
    /// let x = ImportYumArtifactsGcsSource::new().set_uris(["a", "b", "c"]);
    /// ```
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [use_wildcards][crate::model::ImportYumArtifactsGcsSource::use_wildcards].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsGcsSource;
    /// let x = ImportYumArtifactsGcsSource::new().set_use_wildcards(true);
    /// ```
    pub fn set_use_wildcards<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_wildcards = v.into();
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsGcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsGcsSource"
    }
}

/// The request to import new yum artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportYumArtifactsRequest {
    /// The name of the parent resource where the artifacts will be imported.
    pub parent: std::string::String,

    /// The source location of the package binaries.
    pub source: std::option::Option<crate::model::import_yum_artifacts_request::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportYumArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportYumArtifactsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsRequest;
    /// let x = ImportYumArtifactsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportYumArtifactsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsRequest;
    /// use google_cloud_artifactregistry_v1::model::ImportYumArtifactsGcsSource;
    /// let x = ImportYumArtifactsRequest::new().set_source(Some(
    ///     google_cloud_artifactregistry_v1::model::import_yum_artifacts_request::Source::GcsSource(ImportYumArtifactsGcsSource::default().into())));
    /// ```
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_yum_artifacts_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportYumArtifactsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_yum_artifacts_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportYumArtifactsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsRequest;
    /// use google_cloud_artifactregistry_v1::model::ImportYumArtifactsGcsSource;
    /// let x = ImportYumArtifactsRequest::new().set_gcs_source(ImportYumArtifactsGcsSource::default()/* use setters */);
    /// assert!(x.gcs_source().is_some());
    /// ```
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_yum_artifacts_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsRequest"
    }
}

/// Defines additional types related to [ImportYumArtifactsRequest].
pub mod import_yum_artifacts_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source location of the package binaries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location where input content is located.
        GcsSource(std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>),
    }
}

/// Error information explaining why a package was not imported.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportYumArtifactsErrorInfo {
    /// The detailed error status.
    pub error: std::option::Option<rpc::model::Status>,

    /// The source that was not imported.
    pub source: std::option::Option<crate::model::import_yum_artifacts_error_info::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportYumArtifactsErrorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::ImportYumArtifactsErrorInfo::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsErrorInfo;
    /// use rpc::model::Status;
    /// let x = ImportYumArtifactsErrorInfo::new().set_error(Status::default()/* use setters */);
    /// ```
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ImportYumArtifactsErrorInfo::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsErrorInfo;
    /// use rpc::model::Status;
    /// let x = ImportYumArtifactsErrorInfo::new().set_or_clear_error(Some(Status::default()/* use setters */));
    /// let x = ImportYumArtifactsErrorInfo::new().set_or_clear_error(None::<Status>);
    /// ```
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ImportYumArtifactsErrorInfo::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsErrorInfo;
    /// use google_cloud_artifactregistry_v1::model::ImportYumArtifactsGcsSource;
    /// let x = ImportYumArtifactsErrorInfo::new().set_source(Some(
    ///     google_cloud_artifactregistry_v1::model::import_yum_artifacts_error_info::Source::GcsSource(ImportYumArtifactsGcsSource::default().into())));
    /// ```
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_yum_artifacts_error_info::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportYumArtifactsErrorInfo::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_yum_artifacts_error_info::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportYumArtifactsErrorInfo::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsErrorInfo;
    /// use google_cloud_artifactregistry_v1::model::ImportYumArtifactsGcsSource;
    /// let x = ImportYumArtifactsErrorInfo::new().set_gcs_source(ImportYumArtifactsGcsSource::default()/* use setters */);
    /// assert!(x.gcs_source().is_some());
    /// ```
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_yum_artifacts_error_info::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsErrorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsErrorInfo"
    }
}

/// Defines additional types related to [ImportYumArtifactsErrorInfo].
pub mod import_yum_artifacts_error_info {
    #[allow(unused_imports)]
    use super::*;

    /// The source that was not imported.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location requested.
        GcsSource(std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>),
    }
}

/// The response message from importing YUM artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportYumArtifactsResponse {
    /// The yum artifacts imported.
    pub yum_artifacts: std::vec::Vec<crate::model::YumArtifact>,

    /// Detailed error info for packages that were not imported.
    pub errors: std::vec::Vec<crate::model::ImportYumArtifactsErrorInfo>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportYumArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [yum_artifacts][crate::model::ImportYumArtifactsResponse::yum_artifacts].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsResponse;
    /// use google_cloud_artifactregistry_v1::model::YumArtifact;
    /// let x = ImportYumArtifactsResponse::new()
    ///     .set_yum_artifacts([
    ///         YumArtifact::default()/* use setters */,
    ///         YumArtifact::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_yum_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::YumArtifact>,
    {
        use std::iter::Iterator;
        self.yum_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::ImportYumArtifactsResponse::errors].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_artifactregistry_v1::model::ImportYumArtifactsResponse;
    /// use google_cloud_artifactregistry_v1::model::ImportYumArtifactsErrorInfo;
    /// let x = ImportYumArtifactsResponse::new()
    ///     .set_errors([
    ///         ImportYumArtifactsErrorInfo::default()/* use setters */,
    ///         ImportYumArtifactsErrorInfo::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportYumArtifactsErrorInfo>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsResponse"
    }
}

/// The operation metadata for importing artifacts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportYumArtifactsMetadata {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportYumArtifactsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ImportYumArtifactsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsMetadata"
    }
}

/// The view, which determines what version information is returned in a
/// response.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum VersionView {
    /// The default / unset value.
    /// The API will default to the BASIC view.
    Unspecified,
    /// Includes basic information about the version, but not any related tags.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [VersionView::value] or
    /// [VersionView::name].
    UnknownValue(version_view::UnknownValue),
}

#[doc(hidden)]
pub mod version_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl VersionView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VERSION_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for VersionView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for VersionView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for VersionView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for VersionView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VERSION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(version_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for VersionView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for VersionView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionView>::new(
            ".google.devtools.artifactregistry.v1.VersionView",
        ))
    }
}
