// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A detailed representation of an Apt artifact. Information in the record
/// is derived from the archive's control file.
/// See <https://www.debian.org/doc/debian-policy/ch-controlfields.html>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AptArtifact {
    /// Output only. The Artifact Registry resource name of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The Apt package name of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_name: std::string::String,

    /// Output only. An artifact is a binary or source package.
    pub package_type: crate::model::apt_artifact::PackageType,

    /// Output only. Operating system architecture of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub architecture: std::string::String,

    /// Output only. Repository component of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub component: std::string::String,

    /// Output only. Contents of the artifact's control metadata file.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub control_file: bytes::Bytes,
}

impl AptArtifact {
    /// Sets the value of [name][crate::model::AptArtifact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::AptArtifact::package_name].
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [package_type][crate::model::AptArtifact::package_type].
    pub fn set_package_type<T: std::convert::Into<crate::model::apt_artifact::PackageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::AptArtifact::architecture].
    pub fn set_architecture<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [component][crate::model::AptArtifact::component].
    pub fn set_component<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.component = v.into();
        self
    }

    /// Sets the value of [control_file][crate::model::AptArtifact::control_file].
    pub fn set_control_file<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.control_file = v.into();
        self
    }
}

impl wkt::message::Message for AptArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.AptArtifact"
    }
}

/// Defines additional types related to AptArtifact
pub mod apt_artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Package type is either binary or source.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PackageType(std::borrow::Cow<'static, str>);

    impl PackageType {
        /// Creates a new PackageType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [PackageType](PackageType)
    pub mod package_type {
        use super::PackageType;

        /// Package type is not specified.
        pub const PACKAGE_TYPE_UNSPECIFIED: PackageType =
            PackageType::new("PACKAGE_TYPE_UNSPECIFIED");

        /// Binary package.
        pub const BINARY: PackageType = PackageType::new("BINARY");

        /// Source package.
        pub const SOURCE: PackageType = PackageType::new("SOURCE");
    }

    impl std::convert::From<std::string::String> for PackageType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Google Cloud Storage location where the artifacts currently reside.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAptArtifactsGcsSource {
    /// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uris: std::vec::Vec<std::string::String>,

    /// Supports URI wildcards for matching multiple objects from a single URI.
    pub use_wildcards: bool,
}

impl ImportAptArtifactsGcsSource {
    /// Sets the value of [use_wildcards][crate::model::ImportAptArtifactsGcsSource::use_wildcards].
    pub fn set_use_wildcards<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_wildcards = v.into();
        self
    }

    /// Sets the value of [uris][crate::model::ImportAptArtifactsGcsSource::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsGcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsGcsSource"
    }
}

/// The request to import new apt artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAptArtifactsRequest {
    /// The name of the parent resource where the artifacts will be imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The source location of the package binaries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_apt_artifacts_request::Source>,
}

impl ImportAptArtifactsRequest {
    /// Sets the value of [parent][crate::model::ImportAptArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_apt_artifacts_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportAptArtifactsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_apt_artifacts_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAptArtifactsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_apt_artifacts_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsRequest"
    }
}

/// Defines additional types related to ImportAptArtifactsRequest
pub mod import_apt_artifacts_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source location of the package binaries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location where input content is located.
        GcsSource(std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>),
    }
}

/// Error information explaining why a package was not imported.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAptArtifactsErrorInfo {
    /// The detailed error status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The source that was not imported.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_apt_artifacts_error_info::Source>,
}

impl ImportAptArtifactsErrorInfo {
    /// Sets the value of [error][crate::model::ImportAptArtifactsErrorInfo::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<
            std::option::Option<crate::model::import_apt_artifacts_error_info::Source>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportAptArtifactsErrorInfo::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_apt_artifacts_error_info::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAptArtifactsErrorInfo::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_apt_artifacts_error_info::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsErrorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsErrorInfo"
    }
}

/// Defines additional types related to ImportAptArtifactsErrorInfo
pub mod import_apt_artifacts_error_info {
    #[allow(unused_imports)]
    use super::*;

    /// The source that was not imported.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location requested.
        GcsSource(std::boxed::Box<crate::model::ImportAptArtifactsGcsSource>),
    }
}

/// The response message from importing APT artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAptArtifactsResponse {
    /// The Apt artifacts imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub apt_artifacts: std::vec::Vec<crate::model::AptArtifact>,

    /// Detailed error info for packages that were not imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::ImportAptArtifactsErrorInfo>,
}

impl ImportAptArtifactsResponse {
    /// Sets the value of [apt_artifacts][crate::model::ImportAptArtifactsResponse::apt_artifacts].
    pub fn set_apt_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AptArtifact>,
    {
        use std::iter::Iterator;
        self.apt_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::ImportAptArtifactsResponse::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportAptArtifactsErrorInfo>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportAptArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsResponse"
    }
}

/// The operation metadata for importing artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAptArtifactsMetadata {}

impl ImportAptArtifactsMetadata {}

impl wkt::message::Message for ImportAptArtifactsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportAptArtifactsMetadata"
    }
}

/// DockerImage represents a docker artifact.
/// The following fields are returned as untyped metadata in the Version
/// resource, using camelcase keys (i.e. metadata.imageSizeBytes):
///
/// * imageSizeBytes
/// * mediaType
/// * buildTime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DockerImage {
    /// Required. registry_location, project_id, repository_name and image id forms
    /// a unique image
    /// name:`projects/<project_id>/locations/<location>/repository/<repository_name>/dockerImages/<docker_image>`.
    /// For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/dockerImages/
    /// nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// "nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf"
    /// is the image's digest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. URL to access the image.
    /// Example:
    /// us-west4-docker.pkg.dev/test-project/test-repo/nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Tags attached to this image.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Calculated size of the image.
    /// This field is returned as the 'metadata.imageSizeBytes' field in the
    /// Version resource.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub image_size_bytes: i64,

    /// Time the image was uploaded.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upload_time: std::option::Option<wkt::Timestamp>,

    /// Media type of this image, e.g.
    /// "application/vnd.docker.distribution.manifest.v2+json".
    /// This field is returned as the 'metadata.mediaType' field in the
    /// Version resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub media_type: std::string::String,

    /// The time this image was built.
    /// This field is returned as the 'metadata.buildTime' field in the
    /// Version resource.
    /// The build time is returned to the client as an RFC 3339 string, which can
    /// be easily used with the JavaScript Date constructor.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the docker image was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl DockerImage {
    /// Sets the value of [name][crate::model::DockerImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::DockerImage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [image_size_bytes][crate::model::DockerImage::image_size_bytes].
    pub fn set_image_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.image_size_bytes = v.into();
        self
    }

    /// Sets the value of [upload_time][crate::model::DockerImage::upload_time].
    pub fn set_upload_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.upload_time = v.into();
        self
    }

    /// Sets the value of [media_type][crate::model::DockerImage::media_type].
    pub fn set_media_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.media_type = v.into();
        self
    }

    /// Sets the value of [build_time][crate::model::DockerImage::build_time].
    pub fn set_build_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DockerImage::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::DockerImage::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DockerImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DockerImage"
    }
}

/// The request to list docker images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDockerImagesRequest {
    /// Required. The name of the parent resource whose docker images will be
    /// listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The field to order the results by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDockerImagesRequest {
    /// Sets the value of [parent][crate::model::ListDockerImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDockerImagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDockerImagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDockerImagesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDockerImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListDockerImagesRequest"
    }
}

/// The response from listing docker images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDockerImagesResponse {
    /// The docker images returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub docker_images: std::vec::Vec<crate::model::DockerImage>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDockerImagesResponse {
    /// Sets the value of [next_page_token][crate::model::ListDockerImagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [docker_images][crate::model::ListDockerImagesResponse::docker_images].
    pub fn set_docker_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DockerImage>,
    {
        use std::iter::Iterator;
        self.docker_images = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDockerImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListDockerImagesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDockerImagesResponse {
    type PageItem = crate::model::DockerImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.docker_images
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to get docker images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDockerImageRequest {
    /// Required. The name of the docker images.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDockerImageRequest {
    /// Sets the value of [name][crate::model::GetDockerImageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDockerImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetDockerImageRequest"
    }
}

/// MavenArtifact represents a maven artifact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MavenArtifact {
    /// Required. registry_location, project_id, repository_name and maven_artifact
    /// forms a unique artifact For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/mavenArtifacts/
    /// com.google.guava:guava:31.0-jre",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// "com.google.guava:guava:31.0-jre"
    /// is the maven artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. URL to access the pom file of the artifact.
    /// Example:
    /// us-west4-maven.pkg.dev/test-project/test-repo/com/google/guava/guava/31.0/guava-31.0.pom
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pom_uri: std::string::String,

    /// Group ID for the artifact.
    /// Example:
    /// com.google.guava
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group_id: std::string::String,

    /// Artifact ID for the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_id: std::string::String,

    /// Version of this artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. Time the artifact was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the artifact was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl MavenArtifact {
    /// Sets the value of [name][crate::model::MavenArtifact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [pom_uri][crate::model::MavenArtifact::pom_uri].
    pub fn set_pom_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pom_uri = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::MavenArtifact::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [artifact_id][crate::model::MavenArtifact::artifact_id].
    pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_id = v.into();
        self
    }

    /// Sets the value of [version][crate::model::MavenArtifact::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MavenArtifact::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MavenArtifact::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for MavenArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.MavenArtifact"
    }
}

/// The request to list maven artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMavenArtifactsRequest {
    /// Required. The name of the parent resource whose maven artifacts will be
    /// listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListMavenArtifactsRequest {
    /// Sets the value of [parent][crate::model::ListMavenArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMavenArtifactsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMavenArtifactsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMavenArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListMavenArtifactsRequest"
    }
}

/// The response from listing maven artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMavenArtifactsResponse {
    /// The maven artifacts returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub maven_artifacts: std::vec::Vec<crate::model::MavenArtifact>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListMavenArtifactsResponse {
    /// Sets the value of [next_page_token][crate::model::ListMavenArtifactsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [maven_artifacts][crate::model::ListMavenArtifactsResponse::maven_artifacts].
    pub fn set_maven_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MavenArtifact>,
    {
        use std::iter::Iterator;
        self.maven_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMavenArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListMavenArtifactsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMavenArtifactsResponse {
    type PageItem = crate::model::MavenArtifact;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.maven_artifacts
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to get maven artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMavenArtifactRequest {
    /// Required. The name of the maven artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMavenArtifactRequest {
    /// Sets the value of [name][crate::model::GetMavenArtifactRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMavenArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetMavenArtifactRequest"
    }
}

/// NpmPackage represents an npm artifact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NpmPackage {
    /// Required. registry_location, project_id, repository_name and npm_package
    /// forms a unique package For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/npmPackages/
    /// npm_test:1.0.0",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// npm_test:1.0.0" is the npm package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Package for the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_name: std::string::String,

    /// Version of this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Tags attached to this package.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Output only. Time the package was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the package was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl NpmPackage {
    /// Sets the value of [name][crate::model::NpmPackage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::NpmPackage::package_name].
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::NpmPackage::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NpmPackage::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NpmPackage::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::NpmPackage::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NpmPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.NpmPackage"
    }
}

/// The request to list npm packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNpmPackagesRequest {
    /// Required. The name of the parent resource whose npm packages will be
    /// listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListNpmPackagesRequest {
    /// Sets the value of [parent][crate::model::ListNpmPackagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNpmPackagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNpmPackagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNpmPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListNpmPackagesRequest"
    }
}

/// The response from listing npm packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNpmPackagesResponse {
    /// The npm packages returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub npm_packages: std::vec::Vec<crate::model::NpmPackage>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNpmPackagesResponse {
    /// Sets the value of [next_page_token][crate::model::ListNpmPackagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [npm_packages][crate::model::ListNpmPackagesResponse::npm_packages].
    pub fn set_npm_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NpmPackage>,
    {
        use std::iter::Iterator;
        self.npm_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNpmPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListNpmPackagesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNpmPackagesResponse {
    type PageItem = crate::model::NpmPackage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.npm_packages
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to get npm packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNpmPackageRequest {
    /// Required. The name of the npm package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNpmPackageRequest {
    /// Sets the value of [name][crate::model::GetNpmPackageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNpmPackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetNpmPackageRequest"
    }
}

/// PythonPackage represents a python artifact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PythonPackage {
    /// Required. registry_location, project_id, repository_name and python_package
    /// forms a unique package
    /// name:`projects/<project_id>/locations/<location>/repository/<repository_name>/pythonPackages/<python_package>`.
    /// For example,
    /// "projects/test-project/locations/us-west4/repositories/test-repo/pythonPackages/
    /// python_package:1.0.0",
    /// where "us-west4" is the registry_location, "test-project" is the
    /// project_id, "test-repo" is the repository_name and
    /// python_package:1.0.0" is the python package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. URL to access the package.
    /// Example:
    /// us-west4-python.pkg.dev/test-project/test-repo/python_package/file-name-1.0.0.tar.gz
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Package for the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_name: std::string::String,

    /// Version of this package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. Time the package was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the package was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl PythonPackage {
    /// Sets the value of [name][crate::model::PythonPackage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::PythonPackage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::PythonPackage::package_name].
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PythonPackage::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PythonPackage::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PythonPackage::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for PythonPackage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.PythonPackage"
    }
}

/// The request to list python packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPythonPackagesRequest {
    /// Required. The name of the parent resource whose python packages will be
    /// listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of artifacts to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListPythonPackagesRequest {
    /// Sets the value of [parent][crate::model::ListPythonPackagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPythonPackagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPythonPackagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPythonPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPythonPackagesRequest"
    }
}

/// The response from listing python packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPythonPackagesResponse {
    /// The python packages returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub python_packages: std::vec::Vec<crate::model::PythonPackage>,

    /// The token to retrieve the next page of artifacts, or empty if there are no
    /// more artifacts to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPythonPackagesResponse {
    /// Sets the value of [next_page_token][crate::model::ListPythonPackagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [python_packages][crate::model::ListPythonPackagesResponse::python_packages].
    pub fn set_python_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PythonPackage>,
    {
        use std::iter::Iterator;
        self.python_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPythonPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPythonPackagesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPythonPackagesResponse {
    type PageItem = crate::model::PythonPackage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.python_packages
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to get python packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPythonPackageRequest {
    /// Required. The name of the python package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPythonPackageRequest {
    /// Sets the value of [name][crate::model::GetPythonPackageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPythonPackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetPythonPackageRequest"
    }
}

/// An Attachment refers to additional metadata that can be attached to
/// artifacts in Artifact Registry. An attachment consists of one or more files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Attachment {
    /// The name of the attachment. E.g.
    /// `projects/p1/locations/us/repositories/repo/attachments/sbom`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The target the attachment is for, can be a Version, Package or
    /// Repository. E.g.
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/p1/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Type of attachment.
    /// E.g. `application/vnd.spdx+json`
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// The namespace this attachment belongs to.
    /// E.g. If an attachment is created by artifact analysis, namespace is set
    /// to `artifactanalysis.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attachment_namespace: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Artifact Registry. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the attachment was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the attachment was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The files that belong to this attachment.
    /// If the file ID part contains slashes, they are escaped. E.g.
    /// `projects/p1/locations/us-central1/repositories/repo1/files/sha:<sha-of-file>`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<std::string::String>,

    /// Output only. The name of the OCI version that this attachment created. Only
    /// populated for Docker attachments. E.g.
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/p1/versions/v1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oci_version_name: std::string::String,
}

impl Attachment {
    /// Sets the value of [name][crate::model::Attachment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::Attachment::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Attachment::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [attachment_namespace][crate::model::Attachment::attachment_namespace].
    pub fn set_attachment_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attachment_namespace = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Attachment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Attachment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [oci_version_name][crate::model::Attachment::oci_version_name].
    pub fn set_oci_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oci_version_name = v.into();
        self
    }

    /// Sets the value of [files][crate::model::Attachment::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Attachment::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Attachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Attachment"
    }
}

/// The request to list attachments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttachmentsRequest {
    /// Required. The name of the parent resource whose attachments will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `target`
    /// * `type`
    /// * `attachment_namespace`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of attachments to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAttachmentsRequest {
    /// Sets the value of [parent][crate::model::ListAttachmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAttachmentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttachmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttachmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListAttachmentsRequest"
    }
}

/// The response from listing attachments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttachmentsResponse {
    /// The attachments returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attachments: std::vec::Vec<crate::model::Attachment>,

    /// The token to retrieve the next page of attachments, or empty if there are
    /// no more attachments to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAttachmentsResponse {
    /// Sets the value of [next_page_token][crate::model::ListAttachmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [attachments][crate::model::ListAttachmentsResponse::attachments].
    pub fn set_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attachment>,
    {
        use std::iter::Iterator;
        self.attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAttachmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListAttachmentsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAttachmentsResponse {
    type PageItem = crate::model::Attachment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attachments
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve an attachment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAttachmentRequest {
    /// Required. The name of the attachment to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAttachmentRequest {
    /// Sets the value of [name][crate::model::GetAttachmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetAttachmentRequest"
    }
}

/// The request to create a new attachment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAttachmentRequest {
    /// Required. The name of the parent resource where the attachment will be
    /// created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The attachment id to use for this attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attachment_id: std::string::String,

    /// Required. The attachment to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attachment: std::option::Option<crate::model::Attachment>,
}

impl CreateAttachmentRequest {
    /// Sets the value of [parent][crate::model::CreateAttachmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attachment_id][crate::model::CreateAttachmentRequest::attachment_id].
    pub fn set_attachment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attachment_id = v.into();
        self
    }

    /// Sets the value of [attachment][crate::model::CreateAttachmentRequest::attachment].
    pub fn set_attachment<T: std::convert::Into<std::option::Option<crate::model::Attachment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.attachment = v.into();
        self
    }
}

impl wkt::message::Message for CreateAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateAttachmentRequest"
    }
}

/// The request to delete an attachment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAttachmentRequest {
    /// Required. The name of the attachment to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteAttachmentRequest {
    /// Sets the value of [name][crate::model::DeleteAttachmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAttachmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteAttachmentRequest"
    }
}

/// A hash of file content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Hash {
    /// The algorithm used to compute the hash value.
    #[serde(rename = "type")]
    pub r#type: crate::model::hash::HashType,

    /// The hash value.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub value: bytes::Bytes,
}

impl Hash {
    /// Sets the value of [r#type][crate::model::Hash::type].
    pub fn set_type<T: std::convert::Into<crate::model::hash::HashType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Hash::value].
    pub fn set_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Hash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Hash"
    }
}

/// Defines additional types related to Hash
pub mod hash {
    #[allow(unused_imports)]
    use super::*;

    /// The algorithm used to compute the hash.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HashType(std::borrow::Cow<'static, str>);

    impl HashType {
        /// Creates a new HashType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HashType](HashType)
    pub mod hash_type {
        use super::HashType;

        /// Unspecified.
        pub const HASH_TYPE_UNSPECIFIED: HashType = HashType::new("HASH_TYPE_UNSPECIFIED");

        /// SHA256 hash.
        pub const SHA256: HashType = HashType::new("SHA256");

        /// MD5 hash.
        pub const MD5: HashType = HashType::new("MD5");
    }

    impl std::convert::From<std::string::String> for HashType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Files store content that is potentially associated with Packages or Versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct File {
    /// The name of the file, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/files/a%2Fb%2Fc.txt`.
    /// If the file ID part contains slashes, they are escaped.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The size of the File in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,

    /// The hashes of the file content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hashes: std::vec::Vec<crate::model::Hash>,

    /// Output only. The time when the File was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the File was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The name of the Package or Version that owns this file, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub owner: std::string::String,

    /// Output only. The time when the last attempt to refresh the file's data was
    /// made. Only set when the repository is remote.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fetch_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Client specified annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,
}

impl File {
    /// Sets the value of [name][crate::model::File::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::File::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::File::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::File::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::File::owner].
    pub fn set_owner<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [fetch_time][crate::model::File::fetch_time].
    pub fn set_fetch_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fetch_time = v.into();
        self
    }

    /// Sets the value of [hashes][crate::model::File::hashes].
    pub fn set_hashes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Hash>,
    {
        use std::iter::Iterator;
        self.hashes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::File::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for File {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.File"
    }
}

/// The request to list files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFilesRequest {
    /// Required. The name of the repository whose files will be listed. For
    /// example: "projects/p1/locations/us-central1/repositories/repo1
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `owner`
    /// * `annotations`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to files with the name `my_file.txt`
    /// in project `my-project` in the `us-central` region, in repository
    /// `my-repo`, append the following filter expression to your request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/my-file.txt"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/my-*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/*file.txt"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/files/*file*"`
    ///
    /// To filter the results of your request to files owned by the version `1.0`
    /// in package `pkg1`, append the following filter expression to your request:
    ///
    /// * `owner="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/1.0"`
    ///
    /// To filter the results of your request to files with the annotation
    /// key-value pair [`external_link`: `external_link_value`], append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link:external_link_value"`
    ///
    /// To filter just for a specific annotation key `external_link`, append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link"`
    ///
    /// If the annotation key or value contains special characters, you can escape
    /// them by surrounding the value with backticks. For example, to filter the
    /// results of your request to files with the annotation key-value pair
    /// [`external.link`:`<https://example.com/my-file>`], append the following
    /// filter expression to your request:
    ///
    /// * `` "annotations.`external.link`:`<https://example.com/my-file>`" ``
    ///
    /// You can also filter with annotations with a wildcard to
    /// match any number of characters before or after the value:
    ///
    /// * `` "annotations.*_link:`*example.com*`" ``
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of files to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The field to order the results by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListFilesRequest {
    /// Sets the value of [parent][crate::model::ListFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListFilesRequest"
    }
}

/// The response from listing files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFilesResponse {
    /// The files returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// The token to retrieve the next page of files, or empty if there are no
    /// more files to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFilesResponse {
    /// Sets the value of [next_page_token][crate::model::ListFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [files][crate::model::ListFilesResponse::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListFilesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFilesResponse {
    type PageItem = crate::model::File;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.files
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve a file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFileRequest {
    /// Required. The name of the file to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFileRequest {
    /// Sets the value of [name][crate::model::GetFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetFileRequest"
    }
}

/// The request to delete a file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFileRequest {
    /// Required. The name of the file to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteFileRequest {
    /// Sets the value of [name][crate::model::DeleteFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteFileRequest"
    }
}

/// The request to update a file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFileRequest {
    /// Required. The File that replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file: std::option::Option<crate::model::File>,

    /// Required. The update mask applies to the resource. For the `FieldMask`
    /// definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFileRequest {
    /// Sets the value of [file][crate::model::UpdateFileRequest::file].
    pub fn set_file<T: std::convert::Into<std::option::Option<crate::model::File>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFileRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateFileRequest"
    }
}

/// GenericArtifact represents a generic artifact
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenericArtifact {
    /// Resource name of the generic artifact.
    /// project, location, repository, package_id and version_id
    /// create a unique generic artifact.
    /// i.e. "projects/test-project/locations/us-west4/repositories/test-repo/
    /// genericArtifacts/package_id:version_id"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The version of the generic artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The time when the Generic module is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Generic module is updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl GenericArtifact {
    /// Sets the value of [name][crate::model::GenericArtifact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenericArtifact::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GenericArtifact::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::GenericArtifact::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for GenericArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GenericArtifact"
    }
}

/// Packages are named collections of versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Package {
    /// The name of the package, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1`.
    /// If the package ID part contains slashes, the slashes are escaped.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The time when the package was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the package was last updated. This includes publishing a new
    /// version of the package.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Client specified annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Package {
    /// Sets the value of [name][crate::model::Package::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Package::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Package::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Package::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Package::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Package {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Package"
    }
}

/// The request to list packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPackagesRequest {
    /// Required. The name of the parent resource whose packages will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of packages to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `annotations`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to packages with the name
    /// `my-package` in project `my-project` in the `us-central` region, in
    /// repository `my-repo`, append the following filter expression to your
    /// request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/*package"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/*pack*"`
    ///
    /// To filter the results of your request to packages with the annotation
    /// key-value pair [`external_link`: `external_link_value`], append the
    /// following filter expression to your request":
    ///
    /// * `"annotations.external_link:external_link_value"`
    ///
    /// To filter the results just for a specific annotation key `external_link`,
    /// append the following filter expression to your request:
    ///
    /// * `"annotations.external_link"`
    ///
    /// If the annotation key or value contains special characters, you can escape
    /// them by surrounding the value with backticks. For example, to filter the
    /// results of your request to packages with the annotation key-value pair
    /// [`external.link`:`<https://example.com/my-package>`], append the following
    /// filter expression to your request:
    ///
    /// * `` "annotations.`external.link`:`<https://example.com/my-package>`" ``
    ///
    /// You can also filter with annotations with a wildcard to
    /// match any number of characters before or after the value:
    ///
    /// * `` "annotations.*_link:`*example.com*`" ``
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The field to order the results by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListPackagesRequest {
    /// Sets the value of [parent][crate::model::ListPackagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPackagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPackagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPackagesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPackagesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPackagesRequest"
    }
}

/// The response from listing packages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPackagesResponse {
    /// The packages returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub packages: std::vec::Vec<crate::model::Package>,

    /// The token to retrieve the next page of packages, or empty if there are no
    /// more packages to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPackagesResponse {
    /// Sets the value of [next_page_token][crate::model::ListPackagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [packages][crate::model::ListPackagesResponse::packages].
    pub fn set_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Package>,
    {
        use std::iter::Iterator;
        self.packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListPackagesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPackagesResponse {
    type PageItem = crate::model::Package;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.packages
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve a package.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPackageRequest {
    /// Required. The name of the package to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPackageRequest {
    /// Sets the value of [name][crate::model::GetPackageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetPackageRequest"
    }
}

/// The request to delete a package.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePackageRequest {
    /// Required. The name of the package to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeletePackageRequest {
    /// Sets the value of [name][crate::model::DeletePackageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeletePackageRequest"
    }
}

/// The request to update a package.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePackageRequest {
    /// The package that replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub package: std::option::Option<crate::model::Package>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdatePackageRequest {
    /// Sets the value of [package][crate::model::UpdatePackageRequest::package].
    pub fn set_package<T: std::convert::Into<std::option::Option<crate::model::Package>>>(
        mut self,
        v: T,
    ) -> Self {
        self.package = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePackageRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePackageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdatePackageRequest"
    }
}

/// Artifact policy configuration for the repository contents.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpstreamPolicy {
    /// The user-provided ID of the upstream policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// A reference to the repository resource, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Entries with a greater priority value take precedence in the pull order.
    pub priority: i32,
}

impl UpstreamPolicy {
    /// Sets the value of [id][crate::model::UpstreamPolicy::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::UpstreamPolicy::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::UpstreamPolicy::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }
}

impl wkt::message::Message for UpstreamPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpstreamPolicy"
    }
}

/// CleanupPolicyCondition is a set of conditions attached to a CleanupPolicy.
/// If multiple entries are set, all must be satisfied for the condition to be
/// satisfied.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CleanupPolicyCondition {
    /// Match versions by tag status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag_state: std::option::Option<crate::model::cleanup_policy_condition::TagState>,

    /// Match versions by tag prefix. Applied on any prefix match.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tag_prefixes: std::vec::Vec<std::string::String>,

    /// Match versions by version name prefix. Applied on any prefix match.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version_name_prefixes: std::vec::Vec<std::string::String>,

    /// Match versions by package prefix. Applied on any prefix match.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub package_name_prefixes: std::vec::Vec<std::string::String>,

    /// Match versions older than a duration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub older_than: std::option::Option<wkt::Duration>,

    /// Match versions newer than a duration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub newer_than: std::option::Option<wkt::Duration>,
}

impl CleanupPolicyCondition {
    /// Sets the value of [tag_state][crate::model::CleanupPolicyCondition::tag_state].
    pub fn set_tag_state<
        T: std::convert::Into<std::option::Option<crate::model::cleanup_policy_condition::TagState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tag_state = v.into();
        self
    }

    /// Sets the value of [older_than][crate::model::CleanupPolicyCondition::older_than].
    pub fn set_older_than<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.older_than = v.into();
        self
    }

    /// Sets the value of [newer_than][crate::model::CleanupPolicyCondition::newer_than].
    pub fn set_newer_than<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.newer_than = v.into();
        self
    }

    /// Sets the value of [tag_prefixes][crate::model::CleanupPolicyCondition::tag_prefixes].
    pub fn set_tag_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version_name_prefixes][crate::model::CleanupPolicyCondition::version_name_prefixes].
    pub fn set_version_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [package_name_prefixes][crate::model::CleanupPolicyCondition::package_name_prefixes].
    pub fn set_package_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.package_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CleanupPolicyCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CleanupPolicyCondition"
    }
}

/// Defines additional types related to CleanupPolicyCondition
pub mod cleanup_policy_condition {
    #[allow(unused_imports)]
    use super::*;

    /// Statuses applying to versions.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TagState(std::borrow::Cow<'static, str>);

    impl TagState {
        /// Creates a new TagState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [TagState](TagState)
    pub mod tag_state {
        use super::TagState;

        /// Tag status not specified.
        pub const TAG_STATE_UNSPECIFIED: TagState = TagState::new("TAG_STATE_UNSPECIFIED");

        /// Applies to tagged versions only.
        pub const TAGGED: TagState = TagState::new("TAGGED");

        /// Applies to untagged versions only.
        pub const UNTAGGED: TagState = TagState::new("UNTAGGED");

        /// Applies to all versions.
        pub const ANY: TagState = TagState::new("ANY");
    }

    impl std::convert::From<std::string::String> for TagState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// CleanupPolicyMostRecentVersions is an alternate condition of a CleanupPolicy
/// for retaining a minimum number of versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CleanupPolicyMostRecentVersions {
    /// List of package name prefixes that will apply this rule.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub package_name_prefixes: std::vec::Vec<std::string::String>,

    /// Minimum number of versions to keep.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub keep_count: std::option::Option<i32>,
}

impl CleanupPolicyMostRecentVersions {
    /// Sets the value of [keep_count][crate::model::CleanupPolicyMostRecentVersions::keep_count].
    pub fn set_keep_count<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.keep_count = v.into();
        self
    }

    /// Sets the value of [package_name_prefixes][crate::model::CleanupPolicyMostRecentVersions::package_name_prefixes].
    pub fn set_package_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.package_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CleanupPolicyMostRecentVersions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CleanupPolicyMostRecentVersions"
    }
}

/// Artifact policy configuration for repository cleanup policies.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CleanupPolicy {
    /// The user-provided ID of the cleanup policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Policy action.
    pub action: crate::model::cleanup_policy::Action,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub condition_type: std::option::Option<crate::model::cleanup_policy::ConditionType>,
}

impl CleanupPolicy {
    /// Sets the value of [id][crate::model::CleanupPolicy::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::CleanupPolicy::action].
    pub fn set_action<T: std::convert::Into<crate::model::cleanup_policy::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of `condition_type`.
    pub fn set_condition_type<
        T: std::convert::Into<std::option::Option<crate::model::cleanup_policy::ConditionType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_type = v.into();
        self
    }

    /// The value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// if it holds a `Condition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_condition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CleanupPolicyCondition>> {
        #[allow(unreachable_patterns)]
        self.condition_type.as_ref().and_then(|v| match v {
            crate::model::cleanup_policy::ConditionType::Condition(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// if it holds a `MostRecentVersions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_most_recent_versions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CleanupPolicyMostRecentVersions>> {
        #[allow(unreachable_patterns)]
        self.condition_type.as_ref().and_then(|v| match v {
            crate::model::cleanup_policy::ConditionType::MostRecentVersions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// to hold a `Condition`.
    ///
    /// Note that all the setters affecting `condition_type` are
    /// mutually exclusive.
    pub fn set_condition<
        T: std::convert::Into<std::boxed::Box<crate::model::CleanupPolicyCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_type = std::option::Option::Some(
            crate::model::cleanup_policy::ConditionType::Condition(v.into()),
        );
        self
    }

    /// Sets the value of [condition_type][crate::model::CleanupPolicy::condition_type]
    /// to hold a `MostRecentVersions`.
    ///
    /// Note that all the setters affecting `condition_type` are
    /// mutually exclusive.
    pub fn set_most_recent_versions<
        T: std::convert::Into<std::boxed::Box<crate::model::CleanupPolicyMostRecentVersions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_type = std::option::Option::Some(
            crate::model::cleanup_policy::ConditionType::MostRecentVersions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CleanupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CleanupPolicy"
    }
}

/// Defines additional types related to CleanupPolicy
pub mod cleanup_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Action type for a cleanup policy.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Action(std::borrow::Cow<'static, str>);

    impl Action {
        /// Creates a new Action instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Action](Action)
    pub mod action {
        use super::Action;

        /// Action not specified.
        pub const ACTION_UNSPECIFIED: Action = Action::new("ACTION_UNSPECIFIED");

        /// Delete action.
        pub const DELETE: Action = Action::new("DELETE");

        /// Keep action.
        pub const KEEP: Action = Action::new("KEEP");
    }

    impl std::convert::From<std::string::String> for Action {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConditionType {
        /// Policy condition for matching versions.
        Condition(std::boxed::Box<crate::model::CleanupPolicyCondition>),
        /// Policy condition for retaining a minimum number of versions. May only be
        /// specified with a Keep action.
        MostRecentVersions(std::boxed::Box<crate::model::CleanupPolicyMostRecentVersions>),
    }
}

/// Virtual repository configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirtualRepositoryConfig {
    /// Policies that configure the upstream artifacts distributed by the Virtual
    /// Repository. Upstream policies cannot be set on a standard repository.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub upstream_policies: std::vec::Vec<crate::model::UpstreamPolicy>,
}

impl VirtualRepositoryConfig {
    /// Sets the value of [upstream_policies][crate::model::VirtualRepositoryConfig::upstream_policies].
    pub fn set_upstream_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpstreamPolicy>,
    {
        use std::iter::Iterator;
        self.upstream_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VirtualRepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.VirtualRepositoryConfig"
    }
}

/// Remote repository configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoteRepositoryConfig {
    /// The description of the remote source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. The credentials used to access the remote repository.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upstream_credentials:
        std::option::Option<crate::model::remote_repository_config::UpstreamCredentials>,

    /// Input only. A create/update remote repo option to avoid making a HEAD/GET
    /// request to validate a remote repo and any supplied upstream credentials.
    pub disable_upstream_validation: bool,

    /// Settings specific to the remote repository.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub remote_source: std::option::Option<crate::model::remote_repository_config::RemoteSource>,
}

impl RemoteRepositoryConfig {
    /// Sets the value of [description][crate::model::RemoteRepositoryConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [upstream_credentials][crate::model::RemoteRepositoryConfig::upstream_credentials].
    pub fn set_upstream_credentials<
        T: std::convert::Into<
            std::option::Option<crate::model::remote_repository_config::UpstreamCredentials>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upstream_credentials = v.into();
        self
    }

    /// Sets the value of [disable_upstream_validation][crate::model::RemoteRepositoryConfig::disable_upstream_validation].
    pub fn set_disable_upstream_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_upstream_validation = v.into();
        self
    }

    /// Sets the value of `remote_source`.
    pub fn set_remote_source<
        T: std::convert::Into<
            std::option::Option<crate::model::remote_repository_config::RemoteSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = v.into();
        self
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `DockerRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_docker_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::DockerRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::DockerRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `MavenRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_maven_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::MavenRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::MavenRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `NpmRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_npm_repository(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::NpmRepository>>
    {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::NpmRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `PythonRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_python_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::PythonRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::PythonRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `AptRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_apt_repository(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::AptRepository>>
    {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::AptRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `YumRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_yum_repository(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::YumRepository>>
    {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::YumRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// if it holds a `CommonRepository`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_common_repository(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::remote_repository_config::CommonRemoteRepository>,
    > {
        #[allow(unreachable_patterns)]
        self.remote_source.as_ref().and_then(|v| match v {
            crate::model::remote_repository_config::RemoteSource::CommonRepository(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `DockerRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_docker_repository<
        T: std::convert::Into<
            std::boxed::Box<crate::model::remote_repository_config::DockerRepository>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::DockerRepository(v.into()),
        );
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `MavenRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_maven_repository<
        T: std::convert::Into<
            std::boxed::Box<crate::model::remote_repository_config::MavenRepository>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::MavenRepository(v.into()),
        );
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `NpmRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_npm_repository<
        T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::NpmRepository>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::NpmRepository(v.into()),
        );
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `PythonRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_python_repository<
        T: std::convert::Into<
            std::boxed::Box<crate::model::remote_repository_config::PythonRepository>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::PythonRepository(v.into()),
        );
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `AptRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_apt_repository<
        T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::AptRepository>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::AptRepository(v.into()),
        );
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `YumRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_yum_repository<
        T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::YumRepository>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::YumRepository(v.into()),
        );
        self
    }

    /// Sets the value of [remote_source][crate::model::RemoteRepositoryConfig::remote_source]
    /// to hold a `CommonRepository`.
    ///
    /// Note that all the setters affecting `remote_source` are
    /// mutually exclusive.
    pub fn set_common_repository<
        T: std::convert::Into<
            std::boxed::Box<crate::model::remote_repository_config::CommonRemoteRepository>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_source = std::option::Option::Some(
            crate::model::remote_repository_config::RemoteSource::CommonRepository(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RemoteRepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig"
    }
}

/// Defines additional types related to RemoteRepositoryConfig
pub mod remote_repository_config {
    #[allow(unused_imports)]
    use super::*;

    /// The credentials to access the remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UpstreamCredentials {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub credentials: std::option::Option<
            crate::model::remote_repository_config::upstream_credentials::Credentials,
        >,
    }

    impl UpstreamCredentials {
        /// Sets the value of `credentials`.
        pub fn set_credentials<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::upstream_credentials::Credentials,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.credentials = v.into();
            self
        }

        /// The value of [credentials][crate::model::remote_repository_config::UpstreamCredentials::credentials]
        /// if it holds a `UsernamePasswordCredentials`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_username_password_credentials(&self) -> std::option::Option<&std::boxed::Box<crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials>>{
            #[allow(unreachable_patterns)]
            self.credentials.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::upstream_credentials::Credentials::UsernamePasswordCredentials(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [credentials][crate::model::remote_repository_config::UpstreamCredentials::credentials]
        /// to hold a `UsernamePasswordCredentials`.
        ///
        /// Note that all the setters affecting `credentials` are
        /// mutually exclusive.
        pub fn set_username_password_credentials<T: std::convert::Into<std::boxed::Box<crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials>>>(mut self, v: T) -> Self{
            self.credentials = std::option::Option::Some(
                crate::model::remote_repository_config::upstream_credentials::Credentials::UsernamePasswordCredentials(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for UpstreamCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.UpstreamCredentials"
        }
    }

    /// Defines additional types related to UpstreamCredentials
    pub mod upstream_credentials {
        #[allow(unused_imports)]
        use super::*;

        /// Username and password credentials.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct UsernamePasswordCredentials {
            /// The username to access the remote repository.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub username: std::string::String,

            /// The Secret Manager key version that holds the password to access the
            /// remote repository. Must be in the format of
            /// `projects/{project}/secrets/{secret}/versions/{version}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub password_secret_version: std::string::String,
        }

        impl UsernamePasswordCredentials {
            /// Sets the value of [username][crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials::username].
            pub fn set_username<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.username = v.into();
                self
            }

            /// Sets the value of [password_secret_version][crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials::password_secret_version].
            pub fn set_password_secret_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.password_secret_version = v.into();
                self
            }
        }

        impl wkt::message::Message for UsernamePasswordCredentials {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.UpstreamCredentials.UsernamePasswordCredentials"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Credentials {
            /// Use username and password to access the remote repository.
            UsernamePasswordCredentials(std::boxed::Box<crate::model::remote_repository_config::upstream_credentials::UsernamePasswordCredentials>),
        }
    }

    /// Configuration for a Docker remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DockerRepository {
        /// Address of the remote repository.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub upstream: std::option::Option<
            crate::model::remote_repository_config::docker_repository::Upstream,
        >,
    }

    impl DockerRepository {
        /// Sets the value of `upstream`.
        pub fn set_upstream<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::docker_repository::Upstream,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::docker_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::docker_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::docker_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::docker_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_public_repository<
            T: std::convert::Into<
                crate::model::remote_repository_config::docker_repository::PublicRepository,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::docker_repository::Upstream::PublicRepository(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::DockerRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_custom_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::docker_repository::CustomRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::docker_repository::Upstream::CustomRepository(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for DockerRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.DockerRepository"
        }
    }

    /// Defines additional types related to DockerRepository
    pub mod docker_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the custom remote repository, for ex:
            /// `https://registry-1.docker.io`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,
        }

        impl CustomRepository {
            /// Sets the value of [uri][crate::model::remote_repository_config::docker_repository::CustomRepository::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.DockerRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available Docker repositories like Docker
        /// Hub.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PublicRepository(std::borrow::Cow<'static, str>);

        impl PublicRepository {
            /// Creates a new PublicRepository instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [PublicRepository](PublicRepository)
        pub mod public_repository {
            use super::PublicRepository;

            /// Unspecified repository.
            pub const PUBLIC_REPOSITORY_UNSPECIFIED: PublicRepository =
                PublicRepository::new("PUBLIC_REPOSITORY_UNSPECIFIED");

            /// Docker Hub.
            pub const DOCKER_HUB: PublicRepository = PublicRepository::new("DOCKER_HUB");
        }

        impl std::convert::From<std::string::String> for PublicRepository {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Docker repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::docker_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::docker_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Maven remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MavenRepository {
        /// Address of the remote repository.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::maven_repository::Upstream>,
    }

    impl MavenRepository {
        /// Sets the value of `upstream`.
        pub fn set_upstream<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::maven_repository::Upstream,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::maven_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::maven_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::maven_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::maven_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_public_repository<
            T: std::convert::Into<
                crate::model::remote_repository_config::maven_repository::PublicRepository,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::maven_repository::Upstream::PublicRepository(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::MavenRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_custom_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::maven_repository::CustomRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::maven_repository::Upstream::CustomRepository(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for MavenRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.MavenRepository"
        }
    }

    /// Defines additional types related to MavenRepository
    pub mod maven_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.maven.registry/`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,
        }

        impl CustomRepository {
            /// Sets the value of [uri][crate::model::remote_repository_config::maven_repository::CustomRepository::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.MavenRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available Maven repositories like Maven
        /// Central.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PublicRepository(std::borrow::Cow<'static, str>);

        impl PublicRepository {
            /// Creates a new PublicRepository instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [PublicRepository](PublicRepository)
        pub mod public_repository {
            use super::PublicRepository;

            /// Unspecified repository.
            pub const PUBLIC_REPOSITORY_UNSPECIFIED: PublicRepository =
                PublicRepository::new("PUBLIC_REPOSITORY_UNSPECIFIED");

            /// Maven Central.
            pub const MAVEN_CENTRAL: PublicRepository = PublicRepository::new("MAVEN_CENTRAL");
        }

        impl std::convert::From<std::string::String> for PublicRepository {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Maven repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::maven_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::maven_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Npm remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NpmRepository {
        /// Address of the remote repository
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::npm_repository::Upstream>,
    }

    impl NpmRepository {
        /// Sets the value of `upstream`.
        pub fn set_upstream<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::npm_repository::Upstream,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::npm_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::npm_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::npm_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::npm_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_public_repository<
            T: std::convert::Into<
                crate::model::remote_repository_config::npm_repository::PublicRepository,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::npm_repository::Upstream::PublicRepository(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::NpmRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_custom_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::npm_repository::CustomRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::npm_repository::Upstream::CustomRepository(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for NpmRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.NpmRepository"
        }
    }

    /// Defines additional types related to NpmRepository
    pub mod npm_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.npm.registry/`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,
        }

        impl CustomRepository {
            /// Sets the value of [uri][crate::model::remote_repository_config::npm_repository::CustomRepository::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.NpmRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available NPM repositories like npmjs.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PublicRepository(std::borrow::Cow<'static, str>);

        impl PublicRepository {
            /// Creates a new PublicRepository instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [PublicRepository](PublicRepository)
        pub mod public_repository {
            use super::PublicRepository;

            /// Unspecified repository.
            pub const PUBLIC_REPOSITORY_UNSPECIFIED: PublicRepository =
                PublicRepository::new("PUBLIC_REPOSITORY_UNSPECIFIED");

            /// npmjs.
            pub const NPMJS: PublicRepository = PublicRepository::new("NPMJS");
        }

        impl std::convert::From<std::string::String> for PublicRepository {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Address of the remote repository
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Npm repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::npm_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::npm_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Python remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PythonRepository {
        /// Address of the remote repository.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub upstream: std::option::Option<
            crate::model::remote_repository_config::python_repository::Upstream,
        >,
    }

    impl PythonRepository {
        /// Sets the value of `upstream`.
        pub fn set_upstream<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::python_repository::Upstream,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_public_repository(
            &self,
        ) -> std::option::Option<
            &crate::model::remote_repository_config::python_repository::PublicRepository,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::python_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::python_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::python_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_public_repository<
            T: std::convert::Into<
                crate::model::remote_repository_config::python_repository::PublicRepository,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::python_repository::Upstream::PublicRepository(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::PythonRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_custom_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::python_repository::CustomRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::python_repository::Upstream::CustomRepository(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for PythonRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.PythonRepository"
        }
    }

    /// Defines additional types related to PythonRepository
    pub mod python_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Customer-specified publicly available remote repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.python.registry/`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,
        }

        impl CustomRepository {
            /// Sets the value of [uri][crate::model::remote_repository_config::python_repository::CustomRepository::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.PythonRepository.CustomRepository"
            }
        }

        /// Predefined list of publicly available Python repositories like PyPI.org.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PublicRepository(std::borrow::Cow<'static, str>);

        impl PublicRepository {
            /// Creates a new PublicRepository instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [PublicRepository](PublicRepository)
        pub mod public_repository {
            use super::PublicRepository;

            /// Unspecified repository.
            pub const PUBLIC_REPOSITORY_UNSPECIFIED: PublicRepository =
                PublicRepository::new("PUBLIC_REPOSITORY_UNSPECIFIED");

            /// PyPI.
            pub const PYPI: PublicRepository = PublicRepository::new("PYPI");
        }

        impl std::convert::From<std::string::String> for PublicRepository {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Python repositories supported by Artifact
            /// Registry.
            PublicRepository(
                crate::model::remote_repository_config::python_repository::PublicRepository,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::python_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for an Apt remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AptRepository {
        /// Address of the remote repository.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::apt_repository::Upstream>,
    }

    impl AptRepository {
        /// Sets the value of `upstream`.
        pub fn set_upstream<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::apt_repository::Upstream,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_public_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::apt_repository::PublicRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::apt_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::apt_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::apt_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_public_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::apt_repository::PublicRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::apt_repository::Upstream::PublicRepository(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::AptRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_custom_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::apt_repository::CustomRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::apt_repository::Upstream::CustomRepository(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AptRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository"
        }
    }

    /// Defines additional types related to AptRepository
    pub mod apt_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Publicly available Apt repositories constructed from a common repository
        /// base and a custom repository path.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PublicRepository {

            /// A common public repository base for Apt.
            pub repository_base: crate::model::remote_repository_config::apt_repository::public_repository::RepositoryBase,

            /// A custom field to define a path to a specific repository from the base.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub repository_path: std::string::String,
        }

        impl PublicRepository {
            /// Sets the value of [repository_base][crate::model::remote_repository_config::apt_repository::PublicRepository::repository_base].
            pub fn set_repository_base<T: std::convert::Into<crate::model::remote_repository_config::apt_repository::public_repository::RepositoryBase>>(mut self, v: T) -> Self{
                self.repository_base = v.into();
                self
            }

            /// Sets the value of [repository_path][crate::model::remote_repository_config::apt_repository::PublicRepository::repository_path].
            pub fn set_repository_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.repository_path = v.into();
                self
            }
        }

        impl wkt::message::Message for PublicRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository.PublicRepository"
            }
        }

        /// Defines additional types related to PublicRepository
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;

            /// Predefined list of publicly available repository bases for Apt.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct RepositoryBase(std::borrow::Cow<'static, str>);

            impl RepositoryBase {
                /// Creates a new RepositoryBase instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [RepositoryBase](RepositoryBase)
            pub mod repository_base {
                use super::RepositoryBase;

                /// Unspecified repository base.
                pub const REPOSITORY_BASE_UNSPECIFIED: RepositoryBase =
                    RepositoryBase::new("REPOSITORY_BASE_UNSPECIFIED");

                /// Debian.
                pub const DEBIAN: RepositoryBase = RepositoryBase::new("DEBIAN");

                /// Ubuntu LTS/Pro.
                pub const UBUNTU: RepositoryBase = RepositoryBase::new("UBUNTU");

                /// Archived Debian.
                pub const DEBIAN_SNAPSHOT: RepositoryBase = RepositoryBase::new("DEBIAN_SNAPSHOT");
            }

            impl std::convert::From<std::string::String> for RepositoryBase {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// Customer-specified publicly available remote repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.apt.registry/`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,
        }

        impl CustomRepository {
            /// Sets the value of [uri][crate::model::remote_repository_config::apt_repository::CustomRepository::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.AptRepository.CustomRepository"
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Apt repositories supported by Artifact
            /// Registry.
            PublicRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::apt_repository::PublicRepository,
                >,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::apt_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Configuration for a Yum remote repository.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct YumRepository {
        /// Address of the remote repository.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub upstream:
            std::option::Option<crate::model::remote_repository_config::yum_repository::Upstream>,
    }

    impl YumRepository {
        /// Sets the value of `upstream`.
        pub fn set_upstream<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::remote_repository_config::yum_repository::Upstream,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = v.into();
            self
        }

        /// The value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// if it holds a `PublicRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_public_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::yum_repository::PublicRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::yum_repository::Upstream::PublicRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// if it holds a `CustomRepository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_custom_repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::remote_repository_config::yum_repository::CustomRepository,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.upstream.as_ref().and_then(|v| match v {
                crate::model::remote_repository_config::yum_repository::Upstream::CustomRepository(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// to hold a `PublicRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_public_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::yum_repository::PublicRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::yum_repository::Upstream::PublicRepository(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [upstream][crate::model::remote_repository_config::YumRepository::upstream]
        /// to hold a `CustomRepository`.
        ///
        /// Note that all the setters affecting `upstream` are
        /// mutually exclusive.
        pub fn set_custom_repository<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::remote_repository_config::yum_repository::CustomRepository,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upstream = std::option::Option::Some(
                crate::model::remote_repository_config::yum_repository::Upstream::CustomRepository(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for YumRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository"
        }
    }

    /// Defines additional types related to YumRepository
    pub mod yum_repository {
        #[allow(unused_imports)]
        use super::*;

        /// Publicly available Yum repositories constructed from a common repository
        /// base and a custom repository path.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PublicRepository {

            /// A common public repository base for Yum.
            pub repository_base: crate::model::remote_repository_config::yum_repository::public_repository::RepositoryBase,

            /// A custom field to define a path to a specific repository from the base.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub repository_path: std::string::String,
        }

        impl PublicRepository {
            /// Sets the value of [repository_base][crate::model::remote_repository_config::yum_repository::PublicRepository::repository_base].
            pub fn set_repository_base<T: std::convert::Into<crate::model::remote_repository_config::yum_repository::public_repository::RepositoryBase>>(mut self, v: T) -> Self{
                self.repository_base = v.into();
                self
            }

            /// Sets the value of [repository_path][crate::model::remote_repository_config::yum_repository::PublicRepository::repository_path].
            pub fn set_repository_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.repository_path = v.into();
                self
            }
        }

        impl wkt::message::Message for PublicRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository.PublicRepository"
            }
        }

        /// Defines additional types related to PublicRepository
        pub mod public_repository {
            #[allow(unused_imports)]
            use super::*;

            /// Predefined list of publicly available repository bases for Yum.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct RepositoryBase(std::borrow::Cow<'static, str>);

            impl RepositoryBase {
                /// Creates a new RepositoryBase instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [RepositoryBase](RepositoryBase)
            pub mod repository_base {
                use super::RepositoryBase;

                /// Unspecified repository base.
                pub const REPOSITORY_BASE_UNSPECIFIED: RepositoryBase =
                    RepositoryBase::new("REPOSITORY_BASE_UNSPECIFIED");

                /// CentOS.
                pub const CENTOS: RepositoryBase = RepositoryBase::new("CENTOS");

                /// CentOS Debug.
                pub const CENTOS_DEBUG: RepositoryBase = RepositoryBase::new("CENTOS_DEBUG");

                /// CentOS Vault.
                pub const CENTOS_VAULT: RepositoryBase = RepositoryBase::new("CENTOS_VAULT");

                /// CentOS Stream.
                pub const CENTOS_STREAM: RepositoryBase = RepositoryBase::new("CENTOS_STREAM");

                /// Rocky.
                pub const ROCKY: RepositoryBase = RepositoryBase::new("ROCKY");

                /// Fedora Extra Packages for Enterprise Linux (EPEL).
                pub const EPEL: RepositoryBase = RepositoryBase::new("EPEL");
            }

            impl std::convert::From<std::string::String> for RepositoryBase {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// Customer-specified publicly available remote repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CustomRepository {
            /// An http/https uri reference to the upstream remote repository, for ex:
            /// `https://my.yum.registry/`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,
        }

        impl CustomRepository {
            /// Sets the value of [uri][crate::model::remote_repository_config::yum_repository::CustomRepository::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomRepository {
            fn typename() -> &'static str {
                "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.YumRepository.CustomRepository"
            }
        }

        /// Address of the remote repository.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Upstream {
            /// One of the publicly available Yum repositories supported by Artifact
            /// Registry.
            PublicRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::yum_repository::PublicRepository,
                >,
            ),
            /// Customer-specified remote repository.
            CustomRepository(
                std::boxed::Box<
                    crate::model::remote_repository_config::yum_repository::CustomRepository,
                >,
            ),
        }
    }

    /// Common remote repository settings type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CommonRemoteRepository {
        /// Required. A common public repository base for remote repository.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,
    }

    impl CommonRemoteRepository {
        /// Sets the value of [uri][crate::model::remote_repository_config::CommonRemoteRepository::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CommonRemoteRepository {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.RemoteRepositoryConfig.CommonRemoteRepository"
        }
    }

    /// Settings specific to the remote repository.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RemoteSource {
        /// Specific settings for a Docker remote repository.
        DockerRepository(std::boxed::Box<crate::model::remote_repository_config::DockerRepository>),
        /// Specific settings for a Maven remote repository.
        MavenRepository(std::boxed::Box<crate::model::remote_repository_config::MavenRepository>),
        /// Specific settings for an Npm remote repository.
        NpmRepository(std::boxed::Box<crate::model::remote_repository_config::NpmRepository>),
        /// Specific settings for a Python remote repository.
        PythonRepository(std::boxed::Box<crate::model::remote_repository_config::PythonRepository>),
        /// Specific settings for an Apt remote repository.
        AptRepository(std::boxed::Box<crate::model::remote_repository_config::AptRepository>),
        /// Specific settings for a Yum remote repository.
        YumRepository(std::boxed::Box<crate::model::remote_repository_config::YumRepository>),
        /// Common remote repository settings.
        /// Used as the remote repository upstream URL.
        CommonRepository(
            std::boxed::Box<crate::model::remote_repository_config::CommonRemoteRepository>,
        ),
    }
}

/// A Repository for storing artifacts with a specific format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Repository {
    /// The name of the repository, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1`. For each location
    /// in a project, repository names must be unique.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The format of packages that are stored in the repository.
    pub format: crate::model::repository::Format,

    /// The user-provided description of the repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Labels with user-defined metadata.
    /// This field may contain up to 64 entries. Label keys and values may be no
    /// longer than 63 characters. Label keys must begin with a lowercase letter
    /// and may only contain lowercase letters, numeric characters, underscores,
    /// and dashes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the repository was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the repository was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The Cloud KMS resource name of the customer managed encryption key that's
    /// used to encrypt the contents of the Repository. Has the form:
    /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
    /// This value may not be changed after the Repository has been created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Optional. The mode of the repository.
    pub mode: crate::model::repository::Mode,

    /// Optional. Cleanup policies for this repository. Cleanup policies indicate
    /// when certain package versions can be automatically deleted. Map keys are
    /// policy IDs supplied by users during policy creation. They must unique
    /// within a repository and be under 128 characters in length.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub cleanup_policies:
        std::collections::HashMap<std::string::String, crate::model::CleanupPolicy>,

    /// Output only. The size, in bytes, of all artifact storage in this
    /// repository. Repositories that are generally available or in public preview
    /// use this to calculate storage costs.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,

    /// Output only. If set, the repository satisfies physical zone separation.
    pub satisfies_pzs: bool,

    /// Optional. If true, the cleanup pipeline is prevented from deleting versions
    /// in this repository.
    pub cleanup_policy_dry_run: bool,

    /// Optional. Config and state for vulnerability scanning of resources within
    /// this Repository.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerability_scanning_config:
        std::option::Option<crate::model::repository::VulnerabilityScanningConfig>,

    /// Optional. If this is true, an unspecified repo type will be treated as
    /// error rather than defaulting to standard.
    pub disallow_unspecified_mode: bool,

    /// Output only. If set, the repository satisfies physical zone isolation.
    pub satisfies_pzi: bool,

    /// Repository-specific configurations.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub format_config: std::option::Option<crate::model::repository::FormatConfig>,

    /// Repository configuration specific to the Mode value being selected (Remote
    /// or Virtual)
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode_config: std::option::Option<crate::model::repository::ModeConfig>,
}

impl Repository {
    /// Sets the value of [name][crate::model::Repository::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Repository::format].
    pub fn set_format<T: std::convert::Into<crate::model::repository::Format>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Repository::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Repository::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Repository::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Repository::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::Repository::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::repository::Mode>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Repository::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Repository::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [cleanup_policy_dry_run][crate::model::Repository::cleanup_policy_dry_run].
    pub fn set_cleanup_policy_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cleanup_policy_dry_run = v.into();
        self
    }

    /// Sets the value of [vulnerability_scanning_config][crate::model::Repository::vulnerability_scanning_config].
    pub fn set_vulnerability_scanning_config<
        T: std::convert::Into<
            std::option::Option<crate::model::repository::VulnerabilityScanningConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerability_scanning_config = v.into();
        self
    }

    /// Sets the value of [disallow_unspecified_mode][crate::model::Repository::disallow_unspecified_mode].
    pub fn set_disallow_unspecified_mode<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disallow_unspecified_mode = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Repository::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Repository::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [cleanup_policies][crate::model::Repository::cleanup_policies].
    pub fn set_cleanup_policies<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CleanupPolicy>,
    {
        use std::iter::Iterator;
        self.cleanup_policies = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `format_config`.
    pub fn set_format_config<
        T: std::convert::Into<std::option::Option<crate::model::repository::FormatConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format_config = v.into();
        self
    }

    /// The value of [format_config][crate::model::Repository::format_config]
    /// if it holds a `MavenConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_maven_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::repository::MavenRepositoryConfig>>
    {
        #[allow(unreachable_patterns)]
        self.format_config.as_ref().and_then(|v| match v {
            crate::model::repository::FormatConfig::MavenConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [format_config][crate::model::Repository::format_config]
    /// if it holds a `DockerConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_docker_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::repository::DockerRepositoryConfig>>
    {
        #[allow(unreachable_patterns)]
        self.format_config.as_ref().and_then(|v| match v {
            crate::model::repository::FormatConfig::DockerConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [format_config][crate::model::Repository::format_config]
    /// to hold a `MavenConfig`.
    ///
    /// Note that all the setters affecting `format_config` are
    /// mutually exclusive.
    pub fn set_maven_config<
        T: std::convert::Into<std::boxed::Box<crate::model::repository::MavenRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format_config = std::option::Option::Some(
            crate::model::repository::FormatConfig::MavenConfig(v.into()),
        );
        self
    }

    /// Sets the value of [format_config][crate::model::Repository::format_config]
    /// to hold a `DockerConfig`.
    ///
    /// Note that all the setters affecting `format_config` are
    /// mutually exclusive.
    pub fn set_docker_config<
        T: std::convert::Into<std::boxed::Box<crate::model::repository::DockerRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format_config = std::option::Option::Some(
            crate::model::repository::FormatConfig::DockerConfig(v.into()),
        );
        self
    }

    /// Sets the value of `mode_config`.
    pub fn set_mode_config<
        T: std::convert::Into<std::option::Option<crate::model::repository::ModeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode_config = v.into();
        self
    }

    /// The value of [mode_config][crate::model::Repository::mode_config]
    /// if it holds a `VirtualRepositoryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_virtual_repository_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VirtualRepositoryConfig>> {
        #[allow(unreachable_patterns)]
        self.mode_config.as_ref().and_then(|v| match v {
            crate::model::repository::ModeConfig::VirtualRepositoryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [mode_config][crate::model::Repository::mode_config]
    /// if it holds a `RemoteRepositoryConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_remote_repository_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RemoteRepositoryConfig>> {
        #[allow(unreachable_patterns)]
        self.mode_config.as_ref().and_then(|v| match v {
            crate::model::repository::ModeConfig::RemoteRepositoryConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode_config][crate::model::Repository::mode_config]
    /// to hold a `VirtualRepositoryConfig`.
    ///
    /// Note that all the setters affecting `mode_config` are
    /// mutually exclusive.
    pub fn set_virtual_repository_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VirtualRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode_config = std::option::Option::Some(
            crate::model::repository::ModeConfig::VirtualRepositoryConfig(v.into()),
        );
        self
    }

    /// Sets the value of [mode_config][crate::model::Repository::mode_config]
    /// to hold a `RemoteRepositoryConfig`.
    ///
    /// Note that all the setters affecting `mode_config` are
    /// mutually exclusive.
    pub fn set_remote_repository_config<
        T: std::convert::Into<std::boxed::Box<crate::model::RemoteRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode_config = std::option::Option::Some(
            crate::model::repository::ModeConfig::RemoteRepositoryConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Repository {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Repository"
    }
}

/// Defines additional types related to Repository
pub mod repository {
    #[allow(unused_imports)]
    use super::*;

    /// MavenRepositoryConfig is maven related repository details.
    /// Provides additional configuration details for repositories of the maven
    /// format type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MavenRepositoryConfig {
        /// The repository with this flag will allow publishing
        /// the same snapshot versions.
        pub allow_snapshot_overwrites: bool,

        /// Version policy defines the versions that the registry will accept.
        pub version_policy: crate::model::repository::maven_repository_config::VersionPolicy,
    }

    impl MavenRepositoryConfig {
        /// Sets the value of [allow_snapshot_overwrites][crate::model::repository::MavenRepositoryConfig::allow_snapshot_overwrites].
        pub fn set_allow_snapshot_overwrites<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_snapshot_overwrites = v.into();
            self
        }

        /// Sets the value of [version_policy][crate::model::repository::MavenRepositoryConfig::version_policy].
        pub fn set_version_policy<
            T: std::convert::Into<crate::model::repository::maven_repository_config::VersionPolicy>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.version_policy = v.into();
            self
        }
    }

    impl wkt::message::Message for MavenRepositoryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.Repository.MavenRepositoryConfig"
        }
    }

    /// Defines additional types related to MavenRepositoryConfig
    pub mod maven_repository_config {
        #[allow(unused_imports)]
        use super::*;

        /// VersionPolicy is the version policy for the repository.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct VersionPolicy(std::borrow::Cow<'static, str>);

        impl VersionPolicy {
            /// Creates a new VersionPolicy instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [VersionPolicy](VersionPolicy)
        pub mod version_policy {
            use super::VersionPolicy;

            /// VERSION_POLICY_UNSPECIFIED - the version policy is not defined.
            /// When the version policy is not defined, no validation is performed
            /// for the versions.
            pub const VERSION_POLICY_UNSPECIFIED: VersionPolicy =
                VersionPolicy::new("VERSION_POLICY_UNSPECIFIED");

            /// RELEASE - repository will accept only Release versions.
            pub const RELEASE: VersionPolicy = VersionPolicy::new("RELEASE");

            /// SNAPSHOT - repository will accept only Snapshot versions.
            pub const SNAPSHOT: VersionPolicy = VersionPolicy::new("SNAPSHOT");
        }

        impl std::convert::From<std::string::String> for VersionPolicy {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// DockerRepositoryConfig is docker related repository details.
    /// Provides additional configuration details for repositories of the docker
    /// format type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DockerRepositoryConfig {
        /// The repository which enabled this flag prevents all tags from being
        /// modified, moved or deleted. This does not prevent tags from being
        /// created.
        pub immutable_tags: bool,
    }

    impl DockerRepositoryConfig {
        /// Sets the value of [immutable_tags][crate::model::repository::DockerRepositoryConfig::immutable_tags].
        pub fn set_immutable_tags<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.immutable_tags = v.into();
            self
        }
    }

    impl wkt::message::Message for DockerRepositoryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.Repository.DockerRepositoryConfig"
        }
    }

    /// Config on whether to perform vulnerability scanning for resources in this
    /// repository, as well as output fields describing current state.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VulnerabilityScanningConfig {
        /// Optional. Config for whether this repository has vulnerability scanning
        /// disabled.
        pub enablement_config:
            crate::model::repository::vulnerability_scanning_config::EnablementConfig,

        /// Output only. The last time this repository config was enabled.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_enable_time: std::option::Option<wkt::Timestamp>,

        /// Output only. State of feature enablement, combining repository enablement
        /// config and API enablement state.
        pub enablement_state:
            crate::model::repository::vulnerability_scanning_config::EnablementState,

        /// Output only. Reason for the repository state.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub enablement_state_reason: std::string::String,
    }

    impl VulnerabilityScanningConfig {
        /// Sets the value of [enablement_config][crate::model::repository::VulnerabilityScanningConfig::enablement_config].
        pub fn set_enablement_config<
            T: std::convert::Into<
                crate::model::repository::vulnerability_scanning_config::EnablementConfig,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.enablement_config = v.into();
            self
        }

        /// Sets the value of [last_enable_time][crate::model::repository::VulnerabilityScanningConfig::last_enable_time].
        pub fn set_last_enable_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_enable_time = v.into();
            self
        }

        /// Sets the value of [enablement_state][crate::model::repository::VulnerabilityScanningConfig::enablement_state].
        pub fn set_enablement_state<
            T: std::convert::Into<
                crate::model::repository::vulnerability_scanning_config::EnablementState,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.enablement_state = v.into();
            self
        }

        /// Sets the value of [enablement_state_reason][crate::model::repository::VulnerabilityScanningConfig::enablement_state_reason].
        pub fn set_enablement_state_reason<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.enablement_state_reason = v.into();
            self
        }
    }

    impl wkt::message::Message for VulnerabilityScanningConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.devtools.artifactregistry.v1.Repository.VulnerabilityScanningConfig"
        }
    }

    /// Defines additional types related to VulnerabilityScanningConfig
    pub mod vulnerability_scanning_config {
        #[allow(unused_imports)]
        use super::*;

        /// Config for vulnerability scanning of resources in this repository.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct EnablementConfig(std::borrow::Cow<'static, str>);

        impl EnablementConfig {
            /// Creates a new EnablementConfig instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [EnablementConfig](EnablementConfig)
        pub mod enablement_config {
            use super::EnablementConfig;

            /// Not set. This will be treated as INHERITED.
            pub const ENABLEMENT_CONFIG_UNSPECIFIED: EnablementConfig =
                EnablementConfig::new("ENABLEMENT_CONFIG_UNSPECIFIED");

            /// Scanning is Enabled, but dependent on API enablement.
            pub const INHERITED: EnablementConfig = EnablementConfig::new("INHERITED");

            /// No automatic vulnerability scanning will be performed for this
            /// repository.
            pub const DISABLED: EnablementConfig = EnablementConfig::new("DISABLED");
        }

        impl std::convert::From<std::string::String> for EnablementConfig {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Describes the state of vulnerability scanning in this repository,
        /// including both repository enablement and API enablement.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct EnablementState(std::borrow::Cow<'static, str>);

        impl EnablementState {
            /// Creates a new EnablementState instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [EnablementState](EnablementState)
        pub mod enablement_state {
            use super::EnablementState;

            /// Enablement state is unclear.
            pub const ENABLEMENT_STATE_UNSPECIFIED: EnablementState =
                EnablementState::new("ENABLEMENT_STATE_UNSPECIFIED");

            /// Repository does not support vulnerability scanning.
            pub const SCANNING_UNSUPPORTED: EnablementState =
                EnablementState::new("SCANNING_UNSUPPORTED");

            /// Vulnerability scanning is disabled for this repository.
            pub const SCANNING_DISABLED: EnablementState =
                EnablementState::new("SCANNING_DISABLED");

            /// Vulnerability scanning is active for this repository.
            pub const SCANNING_ACTIVE: EnablementState = EnablementState::new("SCANNING_ACTIVE");
        }

        impl std::convert::From<std::string::String> for EnablementState {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// A package format.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Format(std::borrow::Cow<'static, str>);

    impl Format {
        /// Creates a new Format instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Format](Format)
    pub mod format {
        use super::Format;

        /// Unspecified package format.
        pub const FORMAT_UNSPECIFIED: Format = Format::new("FORMAT_UNSPECIFIED");

        /// Docker package format.
        pub const DOCKER: Format = Format::new("DOCKER");

        /// Maven package format.
        pub const MAVEN: Format = Format::new("MAVEN");

        /// NPM package format.
        pub const NPM: Format = Format::new("NPM");

        /// APT package format.
        pub const APT: Format = Format::new("APT");

        /// YUM package format.
        pub const YUM: Format = Format::new("YUM");

        /// Python package format.
        pub const PYTHON: Format = Format::new("PYTHON");

        /// Kubeflow Pipelines package format.
        pub const KFP: Format = Format::new("KFP");

        /// Go package format.
        pub const GO: Format = Format::new("GO");

        /// Generic package format.
        pub const GENERIC: Format = Format::new("GENERIC");
    }

    impl std::convert::From<std::string::String> for Format {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The mode configures the repository to serve artifacts from different
    /// sources.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Mode(std::borrow::Cow<'static, str>);

    impl Mode {
        /// Creates a new Mode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Mode](Mode)
    pub mod mode {
        use super::Mode;

        /// Unspecified mode.
        pub const MODE_UNSPECIFIED: Mode = Mode::new("MODE_UNSPECIFIED");

        /// A standard repository storing artifacts.
        pub const STANDARD_REPOSITORY: Mode = Mode::new("STANDARD_REPOSITORY");

        /// A virtual repository to serve artifacts from one or more sources.
        pub const VIRTUAL_REPOSITORY: Mode = Mode::new("VIRTUAL_REPOSITORY");

        /// A remote repository to serve artifacts from a remote source.
        pub const REMOTE_REPOSITORY: Mode = Mode::new("REMOTE_REPOSITORY");
    }

    impl std::convert::From<std::string::String> for Mode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Repository-specific configurations.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FormatConfig {
        /// Maven repository config contains repository level configuration
        /// for the repositories of maven type.
        MavenConfig(std::boxed::Box<crate::model::repository::MavenRepositoryConfig>),
        /// Docker repository config contains repository level configuration
        /// for the repositories of docker type.
        DockerConfig(std::boxed::Box<crate::model::repository::DockerRepositoryConfig>),
    }

    /// Repository configuration specific to the Mode value being selected (Remote
    /// or Virtual)
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ModeConfig {
        /// Configuration specific for a Virtual Repository.
        VirtualRepositoryConfig(std::boxed::Box<crate::model::VirtualRepositoryConfig>),
        /// Configuration specific for a Remote Repository.
        RemoteRepositoryConfig(std::boxed::Box<crate::model::RemoteRepositoryConfig>),
    }
}

/// The request to list repositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRepositoriesRequest {
    /// Required. The name of the parent resource whose repositories will be
    /// listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of repositories to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to repositories with the name
    /// `my-repo` in project `my-project` in the `us-central` region, append the
    /// following filter expression to your request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/*repo"`
    /// * `name="projects/my-project/locations/us-central1/repositories/*repo*"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The field to order the results by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListRepositoriesRequest {
    /// Sets the value of [parent][crate::model::ListRepositoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRepositoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRepositoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRepositoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRepositoriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRepositoriesRequest"
    }
}

/// The response from listing repositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRepositoriesResponse {
    /// The repositories returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub repositories: std::vec::Vec<crate::model::Repository>,

    /// The token to retrieve the next page of repositories, or empty if there are
    /// no more repositories to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListRepositoriesResponse {
    /// Sets the value of [next_page_token][crate::model::ListRepositoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [repositories][crate::model::ListRepositoriesResponse::repositories].
    pub fn set_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Repository>,
    {
        use std::iter::Iterator;
        self.repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRepositoriesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListRepositoriesResponse {
    type PageItem = crate::model::Repository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.repositories
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve a repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRepositoryRequest {
    /// Required. The name of the repository to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetRepositoryRequest {
    /// Sets the value of [name][crate::model::GetRepositoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetRepositoryRequest"
    }
}

/// The request to create a new repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRepositoryRequest {
    /// Required. The name of the parent resource where the repository will be
    /// created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The repository id to use for this repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository_id: std::string::String,

    /// Required. The repository to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repository: std::option::Option<crate::model::Repository>,
}

impl CreateRepositoryRequest {
    /// Sets the value of [parent][crate::model::CreateRepositoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [repository_id][crate::model::CreateRepositoryRequest::repository_id].
    pub fn set_repository_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository_id = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::CreateRepositoryRequest::repository].
    pub fn set_repository<T: std::convert::Into<std::option::Option<crate::model::Repository>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repository = v.into();
        self
    }
}

impl wkt::message::Message for CreateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateRepositoryRequest"
    }
}

/// The request to update a repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRepositoryRequest {
    /// The repository that replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repository: std::option::Option<crate::model::Repository>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateRepositoryRequest {
    /// Sets the value of [repository][crate::model::UpdateRepositoryRequest::repository].
    pub fn set_repository<T: std::convert::Into<std::option::Option<crate::model::Repository>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRepositoryRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateRepositoryRequest"
    }
}

/// The request to delete a repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRepositoryRequest {
    /// Required. The name of the repository to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteRepositoryRequest {
    /// Sets the value of [name][crate::model::DeleteRepositoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteRepositoryRequest"
    }
}

/// A rule defines the deny or allow action of the operation it applies to and
/// the conditions required for the rule to apply. You can set one rule for an
/// entire repository and one rule for each package within.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Rule {
    /// The name of the rule, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/rules/rule1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The action this rule takes.
    pub action: crate::model::rule::Action,

    pub operation: crate::model::rule::Operation,

    /// Optional. A CEL expression for conditions that must be met in order for the
    /// rule to apply. If not provided, the rule matches all objects.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<gtype::model::Expr>,

    /// The package ID the rule applies to.
    /// If empty, this rule applies to all packages inside the repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_id: std::string::String,
}

impl Rule {
    /// Sets the value of [name][crate::model::Rule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [action][crate::model::Rule::action].
    pub fn set_action<T: std::convert::Into<crate::model::rule::Action>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::Rule::operation].
    pub fn set_operation<T: std::convert::Into<crate::model::rule::Operation>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::Rule::condition].
    pub fn set_condition<T: std::convert::Into<std::option::Option<gtype::model::Expr>>>(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [package_id][crate::model::Rule::package_id].
    pub fn set_package_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_id = v.into();
        self
    }
}

impl wkt::message::Message for Rule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Rule"
    }
}

/// Defines additional types related to Rule
pub mod rule {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the action of the rule.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Action(std::borrow::Cow<'static, str>);

    impl Action {
        /// Creates a new Action instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Action](Action)
    pub mod action {
        use super::Action;

        /// Action not specified.
        pub const ACTION_UNSPECIFIED: Action = Action::new("ACTION_UNSPECIFIED");

        /// Allow the operation.
        pub const ALLOW: Action = Action::new("ALLOW");

        /// Deny the operation.
        pub const DENY: Action = Action::new("DENY");
    }

    impl std::convert::From<std::string::String> for Action {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The operation the rule applies to.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Operation(std::borrow::Cow<'static, str>);

    impl Operation {
        /// Creates a new Operation instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Operation](Operation)
    pub mod operation {
        use super::Operation;

        /// Operation not specified.
        pub const OPERATION_UNSPECIFIED: Operation = Operation::new("OPERATION_UNSPECIFIED");

        /// Download operation.
        pub const DOWNLOAD: Operation = Operation::new("DOWNLOAD");
    }

    impl std::convert::From<std::string::String> for Operation {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The request to list rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRulesRequest {
    /// Required. The name of the parent repository whose rules will be listed.
    /// For example:
    /// `projects/p1/locations/us-central1/repositories/repo1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of rules to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListRulesRequest {
    /// Sets the value of [parent][crate::model::ListRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRulesRequest"
    }
}

/// The response from listing rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRulesResponse {
    /// The rules returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::Rule>,

    /// The token to retrieve the next page of rules, or empty if there are no
    /// more rules to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListRulesResponse {
    /// Sets the value of [next_page_token][crate::model::ListRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [rules][crate::model::ListRulesResponse::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListRulesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListRulesResponse {
    type PageItem = crate::model::Rule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rules
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve a rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRuleRequest {
    /// Required. The name of the rule to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetRuleRequest {
    /// Sets the value of [name][crate::model::GetRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetRuleRequest"
    }
}

/// The request to create a new rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRuleRequest {
    /// Required. The name of the parent resource where the rule will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The rule id to use for this repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_id: std::string::String,

    /// The rule to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::Rule>,
}

impl CreateRuleRequest {
    /// Sets the value of [parent][crate::model::CreateRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::CreateRuleRequest::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::CreateRuleRequest::rule].
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }
}

impl wkt::message::Message for CreateRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateRuleRequest"
    }
}

/// The request to update a rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRuleRequest {
    /// The rule that replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::Rule>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateRuleRequest {
    /// Sets the value of [rule][crate::model::UpdateRuleRequest::rule].
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRuleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateRuleRequest"
    }
}

/// The request to delete a rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRuleRequest {
    /// Required. The name of the rule to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteRuleRequest {
    /// Sets the value of [name][crate::model::DeleteRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteRuleRequest"
    }
}

/// Metadata type for longrunning-operations, currently empty.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {}

impl OperationMetadata {}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.OperationMetadata"
    }
}

/// The Artifact Registry settings that apply to a Project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProjectSettings {
    /// The name of the project's settings.
    ///
    /// Always of the form:
    /// projects/{project-id}/projectSettings
    ///
    /// In update request: never set
    /// In response: always set
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The redirection state of the legacy repositories in this project.
    pub legacy_redirection_state: crate::model::project_settings::RedirectionState,

    /// The percentage of pull traffic to redirect from GCR to AR when using
    /// partial redirection.
    pub pull_percent: i32,
}

impl ProjectSettings {
    /// Sets the value of [name][crate::model::ProjectSettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [legacy_redirection_state][crate::model::ProjectSettings::legacy_redirection_state].
    pub fn set_legacy_redirection_state<
        T: std::convert::Into<crate::model::project_settings::RedirectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_redirection_state = v.into();
        self
    }

    /// Sets the value of [pull_percent][crate::model::ProjectSettings::pull_percent].
    pub fn set_pull_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pull_percent = v.into();
        self
    }
}

impl wkt::message::Message for ProjectSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ProjectSettings"
    }
}

/// Defines additional types related to ProjectSettings
pub mod project_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The possible redirection states for legacy repositories.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RedirectionState(std::borrow::Cow<'static, str>);

    impl RedirectionState {
        /// Creates a new RedirectionState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [RedirectionState](RedirectionState)
    pub mod redirection_state {
        use super::RedirectionState;

        /// No redirection status has been set.
        pub const REDIRECTION_STATE_UNSPECIFIED: RedirectionState =
            RedirectionState::new("REDIRECTION_STATE_UNSPECIFIED");

        /// Redirection is disabled.
        pub const REDIRECTION_FROM_GCR_IO_DISABLED: RedirectionState =
            RedirectionState::new("REDIRECTION_FROM_GCR_IO_DISABLED");

        /// Redirection is enabled.
        pub const REDIRECTION_FROM_GCR_IO_ENABLED: RedirectionState =
            RedirectionState::new("REDIRECTION_FROM_GCR_IO_ENABLED");

        /// Redirection is enabled, and has been finalized so cannot be reverted.
        pub const REDIRECTION_FROM_GCR_IO_FINALIZED: RedirectionState =
            RedirectionState::new("REDIRECTION_FROM_GCR_IO_FINALIZED");

        /// Redirection is enabled and missing images are copied from GCR
        pub const REDIRECTION_FROM_GCR_IO_ENABLED_AND_COPYING: RedirectionState =
            RedirectionState::new("REDIRECTION_FROM_GCR_IO_ENABLED_AND_COPYING");

        /// Redirection is partially enabled and missing images are copied from GCR
        pub const REDIRECTION_FROM_GCR_IO_PARTIAL_AND_COPYING: RedirectionState =
            RedirectionState::new("REDIRECTION_FROM_GCR_IO_PARTIAL_AND_COPYING");
    }

    impl std::convert::From<std::string::String> for RedirectionState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Gets the redirection status for a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProjectSettingsRequest {
    /// Required. The name of the projectSettings resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetProjectSettingsRequest {
    /// Sets the value of [name][crate::model::GetProjectSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProjectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetProjectSettingsRequest"
    }
}

/// Sets the settings of the project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateProjectSettingsRequest {
    /// The project settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub project_settings: std::option::Option<crate::model::ProjectSettings>,

    /// Field mask to support partial updates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateProjectSettingsRequest {
    /// Sets the value of [project_settings][crate::model::UpdateProjectSettingsRequest::project_settings].
    pub fn set_project_settings<
        T: std::convert::Into<std::option::Option<crate::model::ProjectSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.project_settings = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProjectSettingsRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProjectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateProjectSettingsRequest"
    }
}

/// Tags point to a version and represent an alternative name that can be used
/// to access the version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tag {
    /// The name of the tag, for example:
    /// "projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/tags/tag1".
    /// If the package part contains slashes, the slashes are escaped.
    /// The tag part can only have characters in [a-zA-Z0-9\-._~:@], anything else
    /// must be URL encoded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the version the tag refers to, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/versions/sha256:5243811`
    /// If the package or version ID parts contain slashes, the slashes are
    /// escaped.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl Tag {
    /// Sets the value of [name][crate::model::Tag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Tag::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Tag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Tag"
    }
}

/// The request to list tags.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTagsRequest {
    /// The name of the parent package whose tags will be listed.
    /// For example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. Filter rules are
    /// case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `version`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to tags with the name `my-tag` in
    /// package `my-package` in repository `my-repo` in project "`y-project` in
    /// the us-central region, append the following filter expression to your
    /// request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/my-tag"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/my*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/*tag"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/tags/*tag*"`
    ///
    /// To filter the results of your request to tags applied to the version
    /// `1.0` in package `my-package`, append the following filter expression to
    /// your request:
    ///
    /// * `version="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/1.0"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of tags to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTagsRequest {
    /// Sets the value of [parent][crate::model::ListTagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTagsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListTagsRequest"
    }
}

/// The response from listing tags.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTagsResponse {
    /// The tags returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<crate::model::Tag>,

    /// The token to retrieve the next page of tags, or empty if there are no
    /// more tags to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTagsResponse {
    /// Sets the value of [next_page_token][crate::model::ListTagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::ListTagsResponse::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListTagsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTagsResponse {
    type PageItem = crate::model::Tag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tags
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve a tag.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTagRequest {
    /// The name of the tag to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTagRequest {
    /// Sets the value of [name][crate::model::GetTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetTagRequest"
    }
}

/// The request to create a new tag.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTagRequest {
    /// The name of the parent resource where the tag will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The tag id to use for this repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag_id: std::string::String,

    /// The tag to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag: std::option::Option<crate::model::Tag>,
}

impl CreateTagRequest {
    /// Sets the value of [parent][crate::model::CreateTagRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tag_id][crate::model::CreateTagRequest::tag_id].
    pub fn set_tag_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_id = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::CreateTagRequest::tag].
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for CreateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.CreateTagRequest"
    }
}

/// The request to create or update a tag.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTagRequest {
    /// The tag that replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tag: std::option::Option<crate::model::Tag>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateTagRequest {
    /// Sets the value of [tag][crate::model::UpdateTagRequest::tag].
    pub fn set_tag<T: std::convert::Into<std::option::Option<crate::model::Tag>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tag = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTagRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateTagRequest"
    }
}

/// The request to delete a tag.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTagRequest {
    /// The name of the tag to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTagRequest {
    /// Sets the value of [name][crate::model::DeleteTagRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTagRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteTagRequest"
    }
}

/// The body of a version resource. A version resource represents a
/// collection of components, such as files and other data. This may correspond
/// to a version in many package management schemes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Version {
    /// The name of the version, for example:
    /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/versions/art1`.
    /// If the package or version ID parts contain slashes, the slashes are
    /// escaped.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description of the version, as specified in its metadata.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The time when the version was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the version was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A list of related tags. Will contain up to 100 tags that
    /// reference this version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_tags: std::vec::Vec<crate::model::Tag>,

    /// Output only. Repository-specific Metadata stored against this version.
    /// The fields returned are defined by the underlying repository-specific
    /// resource. Currently, the resources could be:
    /// [DockerImage][google.devtools.artifactregistry.v1.DockerImage]
    /// [MavenArtifact][google.devtools.artifactregistry.v1.MavenArtifact]
    ///
    /// [google.devtools.artifactregistry.v1.DockerImage]: crate::model::DockerImage
    /// [google.devtools.artifactregistry.v1.MavenArtifact]: crate::model::MavenArtifact
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Optional. Client specified annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Version {
    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Version::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Version::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Version::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [related_tags][crate::model::Version::related_tags].
    pub fn set_related_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tag>,
    {
        use std::iter::Iterator;
        self.related_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Version::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.Version"
    }
}

/// The request to list versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// The name of the parent resource whose versions will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of versions to return. Maximum page size is 1,000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The view that should be returned in the response.
    pub view: crate::model::VersionView,

    /// Optional. The field to order the results by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. An expression for filtering the results of the request. Filter
    /// rules are case insensitive. The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `annotations`
    ///
    /// Examples of using a filter:
    ///
    /// To filter the results of your request to versions with the name
    /// `my-version` in project `my-project` in the `us-central` region, in
    /// repository `my-repo`, append the following filter expression to your
    /// request:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/my-version"`
    ///
    /// You can also use wildcards to match any number of characters before or
    /// after the value:
    ///
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/*version"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/my*"`
    /// * `name="projects/my-project/locations/us-central1/repositories/my-repo/packages/my-package/versions/*version*"`
    ///
    /// To filter the results of your request to versions with the annotation
    /// key-value pair [`external_link`: `external_link_value`], append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link:external_link_value"`
    ///
    /// To filter just for a specific annotation key `external_link`, append the
    /// following filter expression to your request:
    ///
    /// * `"annotations.external_link"`
    ///
    /// If the annotation key or value contains special characters, you can escape
    /// them by surrounding the value with backticks. For example, to filter the
    /// results of your request to versions with the annotation key-value pair
    /// [`external.link`:`<https://example.com/my-version>`], append the following
    /// filter expression to your request:
    ///
    /// * `` "annotations.`external.link`:`<https://example.com/my-version>`" ``
    ///
    /// You can also filter with annotations with a wildcard to
    /// match any number of characters before or after the value:
    ///
    /// * `` "annotations.*_link:`*example.com*`" ``
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListVersionsRequest {
    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListVersionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListVersionsRequest"
    }
}

/// The response from listing versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The versions returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::Version>,

    /// The token to retrieve the next page of versions, or empty if there are no
    /// more versions to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListVersionsResponse {
    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ListVersionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request to retrieve a version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// The name of the version to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The view that should be returned in the response.
    pub view: crate::model::VersionView,
}

impl GetVersionRequest {
    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetVersionRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::VersionView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetVersionRequest"
    }
}

/// The request to delete a version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// The name of the version to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// By default, a version that is tagged may not be deleted. If force=true, the
    /// version and any tags pointing to the version are deleted.
    pub force: bool,
}

impl DeleteVersionRequest {
    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteVersionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.DeleteVersionRequest"
    }
}

/// The request to delete multiple versions across a repository.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeleteVersionsRequest {
    /// The name of the repository holding all requested versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The names of the versions to delete.
    /// A maximum of 10000 versions can be deleted in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    /// If true, the request is performed without deleting data, following AIP-163.
    pub validate_only: bool,
}

impl BatchDeleteVersionsRequest {
    /// Sets the value of [parent][crate::model::BatchDeleteVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::BatchDeleteVersionsRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeleteVersionsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.BatchDeleteVersionsRequest"
    }
}

/// The metadata of an LRO from deleting multiple versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeleteVersionsMetadata {
    /// The versions the operation failed to delete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub failed_versions: std::vec::Vec<std::string::String>,
}

impl BatchDeleteVersionsMetadata {
    /// Sets the value of [failed_versions][crate::model::BatchDeleteVersionsMetadata::failed_versions].
    pub fn set_failed_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteVersionsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.BatchDeleteVersionsMetadata"
    }
}

/// The request to update a version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Required. The Version that replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::Version>,

    /// The update mask applies to the resource. For the `FieldMask` definition,
    /// see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateVersionRequest {
    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::option::Option<crate::model::Version>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateVersionRequest"
    }
}

/// The Artifact Registry VPC SC config that apply to a Project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VPCSCConfig {
    /// The name of the project's VPC SC Config.
    ///
    /// Always of the form:
    /// projects/{projectID}/locations/{location}/vpcscConfig
    ///
    /// In update request: never set
    /// In response: always set
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The project per location VPC SC policy that defines the VPC SC behavior for
    /// the Remote Repository (Allow/Deny).
    pub vpcsc_policy: crate::model::vpcsc_config::VPCSCPolicy,
}

impl VPCSCConfig {
    /// Sets the value of [name][crate::model::VPCSCConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [vpcsc_policy][crate::model::VPCSCConfig::vpcsc_policy].
    pub fn set_vpcsc_policy<T: std::convert::Into<crate::model::vpcsc_config::VPCSCPolicy>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpcsc_policy = v.into();
        self
    }
}

impl wkt::message::Message for VPCSCConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.VPCSCConfig"
    }
}

/// Defines additional types related to VPCSCConfig
pub mod vpcsc_config {
    #[allow(unused_imports)]
    use super::*;

    /// VPCSCPolicy is the VPC SC policy for project and location.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VPCSCPolicy(std::borrow::Cow<'static, str>);

    impl VPCSCPolicy {
        /// Creates a new VPCSCPolicy instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [VPCSCPolicy](VPCSCPolicy)
    pub mod vpcsc_policy {
        use super::VPCSCPolicy;

        /// VPCSC_POLICY_UNSPECIFIED - the VPS SC policy is not defined.
        /// When VPS SC policy is not defined - the Service will use the default
        /// behavior (VPCSC_DENY).
        pub const VPCSC_POLICY_UNSPECIFIED: VPCSCPolicy =
            VPCSCPolicy::new("VPCSC_POLICY_UNSPECIFIED");

        /// VPCSC_DENY - repository will block the requests to the Upstreams for the
        /// Remote Repositories if the resource is in the perimeter.
        pub const DENY: VPCSCPolicy = VPCSCPolicy::new("DENY");

        /// VPCSC_ALLOW - repository will allow the requests to the Upstreams for the
        /// Remote Repositories if the resource is in the perimeter.
        pub const ALLOW: VPCSCPolicy = VPCSCPolicy::new("ALLOW");
    }

    impl std::convert::From<std::string::String> for VPCSCPolicy {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Gets the VPC SC config for a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVPCSCConfigRequest {
    /// Required. The name of the VPCSCConfig resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetVPCSCConfigRequest {
    /// Sets the value of [name][crate::model::GetVPCSCConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVPCSCConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.GetVPCSCConfigRequest"
    }
}

/// Sets the VPCSC config of the project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVPCSCConfigRequest {
    /// The project config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpcsc_config: std::option::Option<crate::model::VPCSCConfig>,

    /// Field mask to support partial updates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateVPCSCConfigRequest {
    /// Sets the value of [vpcsc_config][crate::model::UpdateVPCSCConfigRequest::vpcsc_config].
    pub fn set_vpcsc_config<
        T: std::convert::Into<std::option::Option<crate::model::VPCSCConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpcsc_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVPCSCConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVPCSCConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.UpdateVPCSCConfigRequest"
    }
}

/// A detailed representation of a Yum artifact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct YumArtifact {
    /// Output only. The Artifact Registry resource name of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The yum package name of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_name: std::string::String,

    /// Output only. An artifact is a binary or source package.
    pub package_type: crate::model::yum_artifact::PackageType,

    /// Output only. Operating system architecture of the artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub architecture: std::string::String,
}

impl YumArtifact {
    /// Sets the value of [name][crate::model::YumArtifact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [package_name][crate::model::YumArtifact::package_name].
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [package_type][crate::model::YumArtifact::package_type].
    pub fn set_package_type<T: std::convert::Into<crate::model::yum_artifact::PackageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::YumArtifact::architecture].
    pub fn set_architecture<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for YumArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.YumArtifact"
    }
}

/// Defines additional types related to YumArtifact
pub mod yum_artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Package type is either binary or source.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PackageType(std::borrow::Cow<'static, str>);

    impl PackageType {
        /// Creates a new PackageType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [PackageType](PackageType)
    pub mod package_type {
        use super::PackageType;

        /// Package type is not specified.
        pub const PACKAGE_TYPE_UNSPECIFIED: PackageType =
            PackageType::new("PACKAGE_TYPE_UNSPECIFIED");

        /// Binary package (.rpm).
        pub const BINARY: PackageType = PackageType::new("BINARY");

        /// Source package (.srpm).
        pub const SOURCE: PackageType = PackageType::new("SOURCE");
    }

    impl std::convert::From<std::string::String> for PackageType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Google Cloud Storage location where the artifacts currently reside.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportYumArtifactsGcsSource {
    /// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uris: std::vec::Vec<std::string::String>,

    /// Supports URI wildcards for matching multiple objects from a single URI.
    pub use_wildcards: bool,
}

impl ImportYumArtifactsGcsSource {
    /// Sets the value of [use_wildcards][crate::model::ImportYumArtifactsGcsSource::use_wildcards].
    pub fn set_use_wildcards<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_wildcards = v.into();
        self
    }

    /// Sets the value of [uris][crate::model::ImportYumArtifactsGcsSource::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsGcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsGcsSource"
    }
}

/// The request to import new yum artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportYumArtifactsRequest {
    /// The name of the parent resource where the artifacts will be imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The source location of the package binaries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_yum_artifacts_request::Source>,
}

impl ImportYumArtifactsRequest {
    /// Sets the value of [parent][crate::model::ImportYumArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_yum_artifacts_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportYumArtifactsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_yum_artifacts_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportYumArtifactsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_yum_artifacts_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsRequest"
    }
}

/// Defines additional types related to ImportYumArtifactsRequest
pub mod import_yum_artifacts_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source location of the package binaries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location where input content is located.
        GcsSource(std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>),
    }
}

/// Error information explaining why a package was not imported.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportYumArtifactsErrorInfo {
    /// The detailed error status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The source that was not imported.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_yum_artifacts_error_info::Source>,
}

impl ImportYumArtifactsErrorInfo {
    /// Sets the value of [error][crate::model::ImportYumArtifactsErrorInfo::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<
            std::option::Option<crate::model::import_yum_artifacts_error_info::Source>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportYumArtifactsErrorInfo::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_yum_artifacts_error_info::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportYumArtifactsErrorInfo::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_yum_artifacts_error_info::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsErrorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsErrorInfo"
    }
}

/// Defines additional types related to ImportYumArtifactsErrorInfo
pub mod import_yum_artifacts_error_info {
    #[allow(unused_imports)]
    use super::*;

    /// The source that was not imported.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location requested.
        GcsSource(std::boxed::Box<crate::model::ImportYumArtifactsGcsSource>),
    }
}

/// The response message from importing YUM artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportYumArtifactsResponse {
    /// The yum artifacts imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub yum_artifacts: std::vec::Vec<crate::model::YumArtifact>,

    /// Detailed error info for packages that were not imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::ImportYumArtifactsErrorInfo>,
}

impl ImportYumArtifactsResponse {
    /// Sets the value of [yum_artifacts][crate::model::ImportYumArtifactsResponse::yum_artifacts].
    pub fn set_yum_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::YumArtifact>,
    {
        use std::iter::Iterator;
        self.yum_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors][crate::model::ImportYumArtifactsResponse::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportYumArtifactsErrorInfo>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportYumArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsResponse"
    }
}

/// The operation metadata for importing artifacts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportYumArtifactsMetadata {}

impl ImportYumArtifactsMetadata {}

impl wkt::message::Message for ImportYumArtifactsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.devtools.artifactregistry.v1.ImportYumArtifactsMetadata"
    }
}

/// The view, which determines what version information is returned in a
/// response.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct VersionView(std::borrow::Cow<'static, str>);

impl VersionView {
    /// Creates a new VersionView instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [VersionView](VersionView)
pub mod version_view {
    use super::VersionView;

    /// The default / unset value.
    /// The API will default to the BASIC view.
    pub const VERSION_VIEW_UNSPECIFIED: VersionView = VersionView::new("VERSION_VIEW_UNSPECIFIED");

    /// Includes basic information about the version, but not any related tags.
    pub const BASIC: VersionView = VersionView::new("BASIC");

    /// Include everything.
    pub const FULL: VersionView = VersionView::new("FULL");
}

impl std::convert::From<std::string::String> for VersionView {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}
