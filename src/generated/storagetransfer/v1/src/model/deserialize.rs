// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetGoogleServiceAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGoogleServiceAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetGoogleServiceAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGoogleServiceAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferJob" => Ok(__FieldTag::__transfer_job),
                            "transfer_job" => Ok(__FieldTag::__transfer_job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_job => {
                            if !fields.insert(__FieldTag::__transfer_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_job",
                                ));
                            }
                            result.transfer_job =
                                map.next_value::<std::option::Option<crate::model::TransferJob>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            __transfer_job,
            __update_transfer_job_field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "transferJob" => Ok(__FieldTag::__transfer_job),
                            "transfer_job" => Ok(__FieldTag::__transfer_job),
                            "updateTransferJobFieldMask" => {
                                Ok(__FieldTag::__update_transfer_job_field_mask)
                            }
                            "update_transfer_job_field_mask" => {
                                Ok(__FieldTag::__update_transfer_job_field_mask)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_job => {
                            if !fields.insert(__FieldTag::__transfer_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_job",
                                ));
                            }
                            result.transfer_job =
                                map.next_value::<std::option::Option<crate::model::TransferJob>>()?;
                        }
                        __FieldTag::__update_transfer_job_field_mask => {
                            if !fields.insert(__FieldTag::__update_transfer_job_field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_transfer_job_field_mask",
                                ));
                            }
                            result.update_transfer_job_field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListTransferJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListTransferJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListTransferJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferJobs" => Ok(__FieldTag::__transfer_jobs),
                            "transfer_jobs" => Ok(__FieldTag::__transfer_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListTransferJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_jobs => {
                            if !fields.insert(__FieldTag::__transfer_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_jobs",
                                ));
                            }
                            result.transfer_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TransferJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PauseTransferOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseTransferOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PauseTransferOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseTransferOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResumeTransferOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeTransferOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResumeTransferOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeTransferOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RunTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RunTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __agent_pool,
            __agent_pool_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "agentPool" => Ok(__FieldTag::__agent_pool),
                            "agent_pool" => Ok(__FieldTag::__agent_pool),
                            "agentPoolId" => Ok(__FieldTag::__agent_pool_id),
                            "agent_pool_id" => Ok(__FieldTag::__agent_pool_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_pool => {
                            if !fields.insert(__FieldTag::__agent_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pool",
                                ));
                            }
                            result.agent_pool =
                                map.next_value::<std::option::Option<crate::model::AgentPool>>()?;
                        }
                        __FieldTag::__agent_pool_id => {
                            if !fields.insert(__FieldTag::__agent_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pool_id",
                                ));
                            }
                            result.agent_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_pool,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentPool" => Ok(__FieldTag::__agent_pool),
                            "agent_pool" => Ok(__FieldTag::__agent_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_pool => {
                            if !fields.insert(__FieldTag::__agent_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pool",
                                ));
                            }
                            result.agent_pool =
                                map.next_value::<std::option::Option<crate::model::AgentPool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAgentPoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAgentPoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAgentPoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAgentPoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAgentPoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_pools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAgentPoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentPools" => Ok(__FieldTag::__agent_pools),
                            "agent_pools" => Ok(__FieldTag::__agent_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAgentPoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAgentPoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_pools => {
                            if !fields.insert(__FieldTag::__agent_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pools",
                                ));
                            }
                            result.agent_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AgentPool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleServiceAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_email,
            __subject_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleServiceAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountEmail" => Ok(__FieldTag::__account_email),
                            "account_email" => Ok(__FieldTag::__account_email),
                            "subjectId" => Ok(__FieldTag::__subject_id),
                            "subject_id" => Ok(__FieldTag::__subject_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleServiceAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleServiceAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_email => {
                            if !fields.insert(__FieldTag::__account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_email",
                                ));
                            }
                            result.account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_id => {
                            if !fields.insert(__FieldTag::__subject_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_id",
                                ));
                            }
                            result.subject_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AwsAccessKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_key_id,
            __secret_access_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAccessKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessKeyId" => Ok(__FieldTag::__access_key_id),
                            "access_key_id" => Ok(__FieldTag::__access_key_id),
                            "secretAccessKey" => Ok(__FieldTag::__secret_access_key),
                            "secret_access_key" => Ok(__FieldTag::__secret_access_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AwsAccessKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAccessKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_key_id => {
                            if !fields.insert(__FieldTag::__access_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_key_id",
                                ));
                            }
                            result.access_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_access_key => {
                            if !fields.insert(__FieldTag::__secret_access_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_access_key",
                                ));
                            }
                            result.secret_access_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AzureCredentials {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sas_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureCredentials")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sasToken" => Ok(__FieldTag::__sas_token),
                            "sas_token" => Ok(__FieldTag::__sas_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AzureCredentials;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureCredentials")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sas_token => {
                            if !fields.insert(__FieldTag::__sas_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sas_token",
                                ));
                            }
                            result.sas_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ObjectConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_time_elapsed_since_last_modification,
            __max_time_elapsed_since_last_modification,
            __include_prefixes,
            __exclude_prefixes,
            __last_modified_since,
            __last_modified_before,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minTimeElapsedSinceLastModification" => {
                                Ok(__FieldTag::__min_time_elapsed_since_last_modification)
                            }
                            "min_time_elapsed_since_last_modification" => {
                                Ok(__FieldTag::__min_time_elapsed_since_last_modification)
                            }
                            "maxTimeElapsedSinceLastModification" => {
                                Ok(__FieldTag::__max_time_elapsed_since_last_modification)
                            }
                            "max_time_elapsed_since_last_modification" => {
                                Ok(__FieldTag::__max_time_elapsed_since_last_modification)
                            }
                            "includePrefixes" => Ok(__FieldTag::__include_prefixes),
                            "include_prefixes" => Ok(__FieldTag::__include_prefixes),
                            "excludePrefixes" => Ok(__FieldTag::__exclude_prefixes),
                            "exclude_prefixes" => Ok(__FieldTag::__exclude_prefixes),
                            "lastModifiedSince" => Ok(__FieldTag::__last_modified_since),
                            "last_modified_since" => Ok(__FieldTag::__last_modified_since),
                            "lastModifiedBefore" => Ok(__FieldTag::__last_modified_before),
                            "last_modified_before" => Ok(__FieldTag::__last_modified_before),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ObjectConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_time_elapsed_since_last_modification => {
                            if !fields
                                .insert(__FieldTag::__min_time_elapsed_since_last_modification)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_time_elapsed_since_last_modification",
                                ));
                            }
                            result.min_time_elapsed_since_last_modification =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_time_elapsed_since_last_modification => {
                            if !fields
                                .insert(__FieldTag::__max_time_elapsed_since_last_modification)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_time_elapsed_since_last_modification",
                                ));
                            }
                            result.max_time_elapsed_since_last_modification =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__include_prefixes => {
                            if !fields.insert(__FieldTag::__include_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_prefixes",
                                ));
                            }
                            result.include_prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclude_prefixes => {
                            if !fields.insert(__FieldTag::__exclude_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_prefixes",
                                ));
                            }
                            result.exclude_prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_since => {
                            if !fields.insert(__FieldTag::__last_modified_since) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_since",
                                ));
                            }
                            result.last_modified_since =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modified_before => {
                            if !fields.insert(__FieldTag::__last_modified_before) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_before",
                                ));
                            }
                            result.last_modified_before =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __path,
            __managed_folder_transfer_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "path" => Ok(__FieldTag::__path),
                            "managedFolderTransferEnabled" => {
                                Ok(__FieldTag::__managed_folder_transfer_enabled)
                            }
                            "managed_folder_transfer_enabled" => {
                                Ok(__FieldTag::__managed_folder_transfer_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__managed_folder_transfer_enabled => {
                            if !fields.insert(__FieldTag::__managed_folder_transfer_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_folder_transfer_enabled",
                                ));
                            }
                            result.managed_folder_transfer_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AwsS3Data {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __aws_access_key,
            __path,
            __role_arn,
            __cloudfront_domain,
            __credentials_secret,
            __managed_private_network,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsS3Data")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "awsAccessKey" => Ok(__FieldTag::__aws_access_key),
                            "aws_access_key" => Ok(__FieldTag::__aws_access_key),
                            "path" => Ok(__FieldTag::__path),
                            "roleArn" => Ok(__FieldTag::__role_arn),
                            "role_arn" => Ok(__FieldTag::__role_arn),
                            "cloudfrontDomain" => Ok(__FieldTag::__cloudfront_domain),
                            "cloudfront_domain" => Ok(__FieldTag::__cloudfront_domain),
                            "credentialsSecret" => Ok(__FieldTag::__credentials_secret),
                            "credentials_secret" => Ok(__FieldTag::__credentials_secret),
                            "managedPrivateNetwork" => Ok(__FieldTag::__managed_private_network),
                            "managed_private_network" => Ok(__FieldTag::__managed_private_network),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AwsS3Data;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsS3Data")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aws_access_key => {
                            if !fields.insert(__FieldTag::__aws_access_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_access_key",
                                ));
                            }
                            result.aws_access_key = map
                                .next_value::<std::option::Option<crate::model::AwsAccessKey>>()?;
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role_arn => {
                            if !fields.insert(__FieldTag::__role_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_arn",
                                ));
                            }
                            result.role_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloudfront_domain => {
                            if !fields.insert(__FieldTag::__cloudfront_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloudfront_domain",
                                ));
                            }
                            result.cloudfront_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__credentials_secret => {
                            if !fields.insert(__FieldTag::__credentials_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for credentials_secret",
                                ));
                            }
                            result.credentials_secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__managed_private_network => {
                            if !fields.insert(__FieldTag::__managed_private_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_private_network",
                                ));
                            }
                            if result.private_network.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `private_network`, a oneof with full ID .google.storagetransfer.v1.AwsS3Data.managed_private_network, latest field was managedPrivateNetwork",
                                ));
                            }
                            result.private_network = std::option::Option::Some(
                                crate::model::aws_s_3_data::PrivateNetwork::ManagedPrivateNetwork(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AzureBlobStorageData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_account,
            __azure_credentials,
            __container,
            __path,
            __credentials_secret,
            __federated_identity_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureBlobStorageData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageAccount" => Ok(__FieldTag::__storage_account),
                            "storage_account" => Ok(__FieldTag::__storage_account),
                            "azureCredentials" => Ok(__FieldTag::__azure_credentials),
                            "azure_credentials" => Ok(__FieldTag::__azure_credentials),
                            "container" => Ok(__FieldTag::__container),
                            "path" => Ok(__FieldTag::__path),
                            "credentialsSecret" => Ok(__FieldTag::__credentials_secret),
                            "credentials_secret" => Ok(__FieldTag::__credentials_secret),
                            "federatedIdentityConfig" => {
                                Ok(__FieldTag::__federated_identity_config)
                            }
                            "federated_identity_config" => {
                                Ok(__FieldTag::__federated_identity_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AzureBlobStorageData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureBlobStorageData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_account => {
                            if !fields.insert(__FieldTag::__storage_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_account",
                                ));
                            }
                            result.storage_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_credentials => {
                            if !fields.insert(__FieldTag::__azure_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_credentials",
                                ));
                            }
                            result.azure_credentials = map
                                .next_value::<std::option::Option<crate::model::AzureCredentials>>(
                                )?;
                        }
                        __FieldTag::__container => {
                            if !fields.insert(__FieldTag::__container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container",
                                ));
                            }
                            result.container = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__credentials_secret => {
                            if !fields.insert(__FieldTag::__credentials_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for credentials_secret",
                                ));
                            }
                            result.credentials_secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__federated_identity_config => {
                            if !fields.insert(__FieldTag::__federated_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for federated_identity_config",
                                ));
                            }
                            result.federated_identity_config = map
                                .next_value::<std::option::Option<
                                    crate::model::azure_blob_storage_data::FederatedIdentityConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::azure_blob_storage_data::FederatedIdentityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __client_id,
            __tenant_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FederatedIdentityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clientId" => Ok(__FieldTag::__client_id),
                            "client_id" => Ok(__FieldTag::__client_id),
                            "tenantId" => Ok(__FieldTag::__tenant_id),
                            "tenant_id" => Ok(__FieldTag::__tenant_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::azure_blob_storage_data::FederatedIdentityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FederatedIdentityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__client_id => {
                            if !fields.insert(__FieldTag::__client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_id",
                                ));
                            }
                            result.client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tenant_id => {
                            if !fields.insert(__FieldTag::__tenant_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant_id",
                                ));
                            }
                            result.tenant_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HttpData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __list_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "listUrl" => Ok(__FieldTag::__list_url),
                            "list_url" => Ok(__FieldTag::__list_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HttpData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__list_url => {
                            if !fields.insert(__FieldTag::__list_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for list_url",
                                ));
                            }
                            result.list_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PosixFilesystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __root_directory,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PosixFilesystem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rootDirectory" => Ok(__FieldTag::__root_directory),
                            "root_directory" => Ok(__FieldTag::__root_directory),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PosixFilesystem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PosixFilesystem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__root_directory => {
                            if !fields.insert(__FieldTag::__root_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_directory",
                                ));
                            }
                            result.root_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HdfsData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HdfsData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HdfsData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HdfsData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AwsS3CompatibleData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __path,
            __endpoint,
            __region,
            __s3_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsS3CompatibleData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "path" => Ok(__FieldTag::__path),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "region" => Ok(__FieldTag::__region),
                            "s3Metadata" => Ok(__FieldTag::__s3_metadata),
                            "s3_metadata" => Ok(__FieldTag::__s3_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AwsS3CompatibleData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsS3CompatibleData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__s3_metadata => {
                            if !fields.insert(__FieldTag::__s3_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for s3_metadata",
                                ));
                            }
                            if result.data_provider.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_provider`, a oneof with full ID .google.storagetransfer.v1.AwsS3CompatibleData.s3_metadata, latest field was s3Metadata",
                                ));
                            }
                            result.data_provider = std::option::Option::Some(
                                crate::model::aws_s_3_compatible_data::DataProvider::S3Metadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::S3CompatibleMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::S3CompatibleMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auth_method,
            __request_model,
            __protocol,
            __list_api,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for S3CompatibleMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authMethod" => Ok(__FieldTag::__auth_method),
                            "auth_method" => Ok(__FieldTag::__auth_method),
                            "requestModel" => Ok(__FieldTag::__request_model),
                            "request_model" => Ok(__FieldTag::__request_model),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "listApi" => Ok(__FieldTag::__list_api),
                            "list_api" => Ok(__FieldTag::__list_api),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::S3CompatibleMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct S3CompatibleMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auth_method => {
                            if !fields.insert(__FieldTag::__auth_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_method",
                                ));
                            }
                            result.auth_method = map
                                .next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::AuthMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_model => {
                            if !fields.insert(__FieldTag::__request_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_model",
                                ));
                            }
                            result.request_model = map
                                .next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::RequestModel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::NetworkProtocol,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__list_api => {
                            if !fields.insert(__FieldTag::__list_api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for list_api",
                                ));
                            }
                            result.list_api =
                                map.next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::ListApi,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AgentPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __bandwidth_limit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "bandwidthLimit" => Ok(__FieldTag::__bandwidth_limit),
                            "bandwidth_limit" => Ok(__FieldTag::__bandwidth_limit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AgentPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::agent_pool::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bandwidth_limit => {
                            if !fields.insert(__FieldTag::__bandwidth_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bandwidth_limit",
                                ));
                            }
                            result.bandwidth_limit = map.next_value::<std::option::Option<crate::model::agent_pool::BandwidthLimit>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_pool::BandwidthLimit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __limit_mbps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BandwidthLimit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "limitMbps" => Ok(__FieldTag::__limit_mbps),
                            "limit_mbps" => Ok(__FieldTag::__limit_mbps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_pool::BandwidthLimit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BandwidthLimit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__limit_mbps => {
                            if !fields.insert(__FieldTag::__limit_mbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for limit_mbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.limit_mbps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransferOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __overwrite_objects_already_existing_in_sink,
            __delete_objects_unique_in_sink,
            __delete_objects_from_source_after_transfer,
            __overwrite_when,
            __metadata_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "overwriteObjectsAlreadyExistingInSink" => {
                                Ok(__FieldTag::__overwrite_objects_already_existing_in_sink)
                            }
                            "overwrite_objects_already_existing_in_sink" => {
                                Ok(__FieldTag::__overwrite_objects_already_existing_in_sink)
                            }
                            "deleteObjectsUniqueInSink" => {
                                Ok(__FieldTag::__delete_objects_unique_in_sink)
                            }
                            "delete_objects_unique_in_sink" => {
                                Ok(__FieldTag::__delete_objects_unique_in_sink)
                            }
                            "deleteObjectsFromSourceAfterTransfer" => {
                                Ok(__FieldTag::__delete_objects_from_source_after_transfer)
                            }
                            "delete_objects_from_source_after_transfer" => {
                                Ok(__FieldTag::__delete_objects_from_source_after_transfer)
                            }
                            "overwriteWhen" => Ok(__FieldTag::__overwrite_when),
                            "overwrite_when" => Ok(__FieldTag::__overwrite_when),
                            "metadataOptions" => Ok(__FieldTag::__metadata_options),
                            "metadata_options" => Ok(__FieldTag::__metadata_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransferOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__overwrite_objects_already_existing_in_sink => {
                            if !fields
                                .insert(__FieldTag::__overwrite_objects_already_existing_in_sink)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overwrite_objects_already_existing_in_sink",
                                ));
                            }
                            result.overwrite_objects_already_existing_in_sink = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_objects_unique_in_sink => {
                            if !fields.insert(__FieldTag::__delete_objects_unique_in_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_objects_unique_in_sink",
                                ));
                            }
                            result.delete_objects_unique_in_sink = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_objects_from_source_after_transfer => {
                            if !fields
                                .insert(__FieldTag::__delete_objects_from_source_after_transfer)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_objects_from_source_after_transfer",
                                ));
                            }
                            result.delete_objects_from_source_after_transfer = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__overwrite_when => {
                            if !fields.insert(__FieldTag::__overwrite_when) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overwrite_when",
                                ));
                            }
                            result.overwrite_when =
                                map.next_value::<std::option::Option<
                                    crate::model::transfer_options::OverwriteWhen,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata_options => {
                            if !fields.insert(__FieldTag::__metadata_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_options",
                                ));
                            }
                            result.metadata_options = map
                                .next_value::<std::option::Option<crate::model::MetadataOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransferSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_data_sink,
            __posix_data_sink,
            __gcs_data_source,
            __aws_s3_data_source,
            __http_data_source,
            __posix_data_source,
            __azure_blob_storage_data_source,
            __aws_s3_compatible_data_source,
            __hdfs_data_source,
            __gcs_intermediate_data_location,
            __object_conditions,
            __transfer_options,
            __transfer_manifest,
            __source_agent_pool_name,
            __sink_agent_pool_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDataSink" => Ok(__FieldTag::__gcs_data_sink),
                            "gcs_data_sink" => Ok(__FieldTag::__gcs_data_sink),
                            "posixDataSink" => Ok(__FieldTag::__posix_data_sink),
                            "posix_data_sink" => Ok(__FieldTag::__posix_data_sink),
                            "gcsDataSource" => Ok(__FieldTag::__gcs_data_source),
                            "gcs_data_source" => Ok(__FieldTag::__gcs_data_source),
                            "awsS3DataSource" => Ok(__FieldTag::__aws_s3_data_source),
                            "aws_s3_data_source" => Ok(__FieldTag::__aws_s3_data_source),
                            "httpDataSource" => Ok(__FieldTag::__http_data_source),
                            "http_data_source" => Ok(__FieldTag::__http_data_source),
                            "posixDataSource" => Ok(__FieldTag::__posix_data_source),
                            "posix_data_source" => Ok(__FieldTag::__posix_data_source),
                            "azureBlobStorageDataSource" => {
                                Ok(__FieldTag::__azure_blob_storage_data_source)
                            }
                            "azure_blob_storage_data_source" => {
                                Ok(__FieldTag::__azure_blob_storage_data_source)
                            }
                            "awsS3CompatibleDataSource" => {
                                Ok(__FieldTag::__aws_s3_compatible_data_source)
                            }
                            "aws_s3_compatible_data_source" => {
                                Ok(__FieldTag::__aws_s3_compatible_data_source)
                            }
                            "hdfsDataSource" => Ok(__FieldTag::__hdfs_data_source),
                            "hdfs_data_source" => Ok(__FieldTag::__hdfs_data_source),
                            "gcsIntermediateDataLocation" => {
                                Ok(__FieldTag::__gcs_intermediate_data_location)
                            }
                            "gcs_intermediate_data_location" => {
                                Ok(__FieldTag::__gcs_intermediate_data_location)
                            }
                            "objectConditions" => Ok(__FieldTag::__object_conditions),
                            "object_conditions" => Ok(__FieldTag::__object_conditions),
                            "transferOptions" => Ok(__FieldTag::__transfer_options),
                            "transfer_options" => Ok(__FieldTag::__transfer_options),
                            "transferManifest" => Ok(__FieldTag::__transfer_manifest),
                            "transfer_manifest" => Ok(__FieldTag::__transfer_manifest),
                            "sourceAgentPoolName" => Ok(__FieldTag::__source_agent_pool_name),
                            "source_agent_pool_name" => Ok(__FieldTag::__source_agent_pool_name),
                            "sinkAgentPoolName" => Ok(__FieldTag::__sink_agent_pool_name),
                            "sink_agent_pool_name" => Ok(__FieldTag::__sink_agent_pool_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransferSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_data_sink => {
                            if !fields.insert(__FieldTag::__gcs_data_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_sink",
                                ));
                            }
                            if result.data_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_sink`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.gcs_data_sink, latest field was gcsDataSink",
                                ));
                            }
                            result.data_sink =
                                std::option::Option::Some(
                                    crate::model::transfer_spec::DataSink::GcsDataSink(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__posix_data_sink => {
                            if !fields.insert(__FieldTag::__posix_data_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posix_data_sink",
                                ));
                            }
                            if result.data_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_sink`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.posix_data_sink, latest field was posixDataSink",
                                ));
                            }
                            result.data_sink = std::option::Option::Some(
                                crate::model::transfer_spec::DataSink::PosixDataSink(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PosixFilesystem>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_data_source => {
                            if !fields.insert(__FieldTag::__gcs_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.gcs_data_source, latest field was gcsDataSource",
                                ));
                            }
                            result.data_source =
                                std::option::Option::Some(
                                    crate::model::transfer_spec::DataSource::GcsDataSource(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__aws_s3_data_source => {
                            if !fields.insert(__FieldTag::__aws_s3_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_s3_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.aws_s3_data_source, latest field was awsS3DataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::AwsS3DataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsS3Data>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__http_data_source => {
                            if !fields.insert(__FieldTag::__http_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.http_data_source, latest field was httpDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::HttpDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__posix_data_source => {
                            if !fields.insert(__FieldTag::__posix_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posix_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.posix_data_source, latest field was posixDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::PosixDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PosixFilesystem>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_blob_storage_data_source => {
                            if !fields.insert(__FieldTag::__azure_blob_storage_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_blob_storage_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.azure_blob_storage_data_source, latest field was azureBlobStorageDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::AzureBlobStorageDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureBlobStorageData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_s3_compatible_data_source => {
                            if !fields.insert(__FieldTag::__aws_s3_compatible_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_s3_compatible_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.aws_s3_compatible_data_source, latest field was awsS3CompatibleDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::AwsS3CompatibleDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsS3CompatibleData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__hdfs_data_source => {
                            if !fields.insert(__FieldTag::__hdfs_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hdfs_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.hdfs_data_source, latest field was hdfsDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::HdfsDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HdfsData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_intermediate_data_location => {
                            if !fields.insert(__FieldTag::__gcs_intermediate_data_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_intermediate_data_location",
                                ));
                            }
                            if result.intermediate_data_location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intermediate_data_location`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.gcs_intermediate_data_location, latest field was gcsIntermediateDataLocation",
                                ));
                            }
                            result.intermediate_data_location = std::option::Option::Some(
                                crate::model::transfer_spec::IntermediateDataLocation::GcsIntermediateDataLocation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsData>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__object_conditions => {
                            if !fields.insert(__FieldTag::__object_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_conditions",
                                ));
                            }
                            result.object_conditions = map
                                .next_value::<std::option::Option<crate::model::ObjectConditions>>(
                                )?;
                        }
                        __FieldTag::__transfer_options => {
                            if !fields.insert(__FieldTag::__transfer_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_options",
                                ));
                            }
                            result.transfer_options = map
                                .next_value::<std::option::Option<crate::model::TransferOptions>>(
                                )?;
                        }
                        __FieldTag::__transfer_manifest => {
                            if !fields.insert(__FieldTag::__transfer_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_manifest",
                                ));
                            }
                            result.transfer_manifest = map
                                .next_value::<std::option::Option<crate::model::TransferManifest>>(
                                )?;
                        }
                        __FieldTag::__source_agent_pool_name => {
                            if !fields.insert(__FieldTag::__source_agent_pool_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_agent_pool_name",
                                ));
                            }
                            result.source_agent_pool_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sink_agent_pool_name => {
                            if !fields.insert(__FieldTag::__sink_agent_pool_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink_agent_pool_name",
                                ));
                            }
                            result.sink_agent_pool_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReplicationSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_data_source,
            __gcs_data_sink,
            __object_conditions,
            __transfer_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDataSource" => Ok(__FieldTag::__gcs_data_source),
                            "gcs_data_source" => Ok(__FieldTag::__gcs_data_source),
                            "gcsDataSink" => Ok(__FieldTag::__gcs_data_sink),
                            "gcs_data_sink" => Ok(__FieldTag::__gcs_data_sink),
                            "objectConditions" => Ok(__FieldTag::__object_conditions),
                            "object_conditions" => Ok(__FieldTag::__object_conditions),
                            "transferOptions" => Ok(__FieldTag::__transfer_options),
                            "transfer_options" => Ok(__FieldTag::__transfer_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReplicationSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_data_source => {
                            if !fields.insert(__FieldTag::__gcs_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.ReplicationSpec.gcs_data_source, latest field was gcsDataSource",
                                ));
                            }
                            result.data_source =
                                std::option::Option::Some(
                                    crate::model::replication_spec::DataSource::GcsDataSource(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__gcs_data_sink => {
                            if !fields.insert(__FieldTag::__gcs_data_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_sink",
                                ));
                            }
                            if result.data_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_sink`, a oneof with full ID .google.storagetransfer.v1.ReplicationSpec.gcs_data_sink, latest field was gcsDataSink",
                                ));
                            }
                            result.data_sink =
                                std::option::Option::Some(
                                    crate::model::replication_spec::DataSink::GcsDataSink(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__object_conditions => {
                            if !fields.insert(__FieldTag::__object_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_conditions",
                                ));
                            }
                            result.object_conditions = map
                                .next_value::<std::option::Option<crate::model::ObjectConditions>>(
                                )?;
                        }
                        __FieldTag::__transfer_options => {
                            if !fields.insert(__FieldTag::__transfer_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_options",
                                ));
                            }
                            result.transfer_options = map
                                .next_value::<std::option::Option<crate::model::TransferOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MetadataOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __symlink,
            __mode,
            __gid,
            __uid,
            __acl,
            __storage_class,
            __temporary_hold,
            __kms_key,
            __time_created,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetadataOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "symlink" => Ok(__FieldTag::__symlink),
                            "mode" => Ok(__FieldTag::__mode),
                            "gid" => Ok(__FieldTag::__gid),
                            "uid" => Ok(__FieldTag::__uid),
                            "acl" => Ok(__FieldTag::__acl),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            "temporaryHold" => Ok(__FieldTag::__temporary_hold),
                            "temporary_hold" => Ok(__FieldTag::__temporary_hold),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "timeCreated" => Ok(__FieldTag::__time_created),
                            "time_created" => Ok(__FieldTag::__time_created),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MetadataOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetadataOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__symlink => {
                            if !fields.insert(__FieldTag::__symlink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for symlink",
                                ));
                            }
                            result.symlink = map.next_value::<std::option::Option<crate::model::metadata_options::Symlink>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::metadata_options::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gid => {
                            if !fields.insert(__FieldTag::__gid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gid",
                                ));
                            }
                            result.gid = map.next_value::<std::option::Option<crate::model::metadata_options::Gid>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map.next_value::<std::option::Option<crate::model::metadata_options::Uid>>()?.unwrap_or_default();
                        }
                        __FieldTag::__acl => {
                            if !fields.insert(__FieldTag::__acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acl",
                                ));
                            }
                            result.acl = map.next_value::<std::option::Option<crate::model::metadata_options::Acl>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_class",
                                ));
                            }
                            result.storage_class =
                                map.next_value::<std::option::Option<
                                    crate::model::metadata_options::StorageClass,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__temporary_hold => {
                            if !fields.insert(__FieldTag::__temporary_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for temporary_hold",
                                ));
                            }
                            result.temporary_hold =
                                map.next_value::<std::option::Option<
                                    crate::model::metadata_options::TemporaryHold,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map.next_value::<std::option::Option<crate::model::metadata_options::KmsKey>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_created => {
                            if !fields.insert(__FieldTag::__time_created) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_created",
                                ));
                            }
                            result.time_created =
                                map.next_value::<std::option::Option<
                                    crate::model::metadata_options::TimeCreated,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransferManifest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferManifest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransferManifest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferManifest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Schedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schedule_start_date,
            __schedule_end_date,
            __start_time_of_day,
            __end_time_of_day,
            __repeat_interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scheduleStartDate" => Ok(__FieldTag::__schedule_start_date),
                            "schedule_start_date" => Ok(__FieldTag::__schedule_start_date),
                            "scheduleEndDate" => Ok(__FieldTag::__schedule_end_date),
                            "schedule_end_date" => Ok(__FieldTag::__schedule_end_date),
                            "startTimeOfDay" => Ok(__FieldTag::__start_time_of_day),
                            "start_time_of_day" => Ok(__FieldTag::__start_time_of_day),
                            "endTimeOfDay" => Ok(__FieldTag::__end_time_of_day),
                            "end_time_of_day" => Ok(__FieldTag::__end_time_of_day),
                            "repeatInterval" => Ok(__FieldTag::__repeat_interval),
                            "repeat_interval" => Ok(__FieldTag::__repeat_interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Schedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schedule_start_date => {
                            if !fields.insert(__FieldTag::__schedule_start_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_start_date",
                                ));
                            }
                            result.schedule_start_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__schedule_end_date => {
                            if !fields.insert(__FieldTag::__schedule_end_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_end_date",
                                ));
                            }
                            result.schedule_end_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__start_time_of_day => {
                            if !fields.insert(__FieldTag::__start_time_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time_of_day",
                                ));
                            }
                            result.start_time_of_day =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__end_time_of_day => {
                            if !fields.insert(__FieldTag::__end_time_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time_of_day",
                                ));
                            }
                            result.end_time_of_day =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__repeat_interval => {
                            if !fields.insert(__FieldTag::__repeat_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeat_interval",
                                ));
                            }
                            result.repeat_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EventStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __event_stream_start_time,
            __event_stream_expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "eventStreamStartTime" => Ok(__FieldTag::__event_stream_start_time),
                            "event_stream_start_time" => Ok(__FieldTag::__event_stream_start_time),
                            "eventStreamExpirationTime" => {
                                Ok(__FieldTag::__event_stream_expiration_time)
                            }
                            "event_stream_expiration_time" => {
                                Ok(__FieldTag::__event_stream_expiration_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EventStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_stream_start_time => {
                            if !fields.insert(__FieldTag::__event_stream_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_stream_start_time",
                                ));
                            }
                            result.event_stream_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__event_stream_expiration_time => {
                            if !fields.insert(__FieldTag::__event_stream_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_stream_expiration_time",
                                ));
                            }
                            result.event_stream_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransferJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __project_id,
            __service_account,
            __transfer_spec,
            __replication_spec,
            __notification_config,
            __logging_config,
            __schedule,
            __event_stream,
            __status,
            __creation_time,
            __last_modification_time,
            __deletion_time,
            __latest_operation_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "transferSpec" => Ok(__FieldTag::__transfer_spec),
                            "transfer_spec" => Ok(__FieldTag::__transfer_spec),
                            "replicationSpec" => Ok(__FieldTag::__replication_spec),
                            "replication_spec" => Ok(__FieldTag::__replication_spec),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "eventStream" => Ok(__FieldTag::__event_stream),
                            "event_stream" => Ok(__FieldTag::__event_stream),
                            "status" => Ok(__FieldTag::__status),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModificationTime" => Ok(__FieldTag::__last_modification_time),
                            "last_modification_time" => Ok(__FieldTag::__last_modification_time),
                            "deletionTime" => Ok(__FieldTag::__deletion_time),
                            "deletion_time" => Ok(__FieldTag::__deletion_time),
                            "latestOperationName" => Ok(__FieldTag::__latest_operation_name),
                            "latest_operation_name" => Ok(__FieldTag::__latest_operation_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransferJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_spec => {
                            if !fields.insert(__FieldTag::__transfer_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_spec",
                                ));
                            }
                            result.transfer_spec = map
                                .next_value::<std::option::Option<crate::model::TransferSpec>>()?;
                        }
                        __FieldTag::__replication_spec => {
                            if !fields.insert(__FieldTag::__replication_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_spec",
                                ));
                            }
                            result.replication_spec = map
                                .next_value::<std::option::Option<crate::model::ReplicationSpec>>(
                                )?;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule =
                                map.next_value::<std::option::Option<crate::model::Schedule>>()?;
                        }
                        __FieldTag::__event_stream => {
                            if !fields.insert(__FieldTag::__event_stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_stream",
                                ));
                            }
                            result.event_stream =
                                map.next_value::<std::option::Option<crate::model::EventStream>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::transfer_job::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modification_time => {
                            if !fields.insert(__FieldTag::__last_modification_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modification_time",
                                ));
                            }
                            result.last_modification_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__deletion_time => {
                            if !fields.insert(__FieldTag::__deletion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_time",
                                ));
                            }
                            result.deletion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__latest_operation_name => {
                            if !fields.insert(__FieldTag::__latest_operation_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_operation_name",
                                ));
                            }
                            result.latest_operation_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ErrorLogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __error_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorLogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "errorDetails" => Ok(__FieldTag::__error_details),
                            "error_details" => Ok(__FieldTag::__error_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ErrorLogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorLogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_details => {
                            if !fields.insert(__FieldTag::__error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_details",
                                ));
                            }
                            result.error_details = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ErrorSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_code,
            __error_count,
            __error_log_entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorCode" => Ok(__FieldTag::__error_code),
                            "error_code" => Ok(__FieldTag::__error_code),
                            "errorCount" => Ok(__FieldTag::__error_count),
                            "error_count" => Ok(__FieldTag::__error_count),
                            "errorLogEntries" => Ok(__FieldTag::__error_log_entries),
                            "error_log_entries" => Ok(__FieldTag::__error_log_entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ErrorSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_code => {
                            if !fields.insert(__FieldTag::__error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_code",
                                ));
                            }
                            result.error_code = map
                                .next_value::<std::option::Option<rpc::model::Code>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_count => {
                            if !fields.insert(__FieldTag::__error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.error_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error_log_entries => {
                            if !fields.insert(__FieldTag::__error_log_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_log_entries",
                                ));
                            }
                            result.error_log_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorLogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransferCounters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __objects_found_from_source,
            __bytes_found_from_source,
            __objects_found_only_from_sink,
            __bytes_found_only_from_sink,
            __objects_from_source_skipped_by_sync,
            __bytes_from_source_skipped_by_sync,
            __objects_copied_to_sink,
            __bytes_copied_to_sink,
            __objects_deleted_from_source,
            __bytes_deleted_from_source,
            __objects_deleted_from_sink,
            __bytes_deleted_from_sink,
            __objects_from_source_failed,
            __bytes_from_source_failed,
            __objects_failed_to_delete_from_sink,
            __bytes_failed_to_delete_from_sink,
            __directories_found_from_source,
            __directories_failed_to_list_from_source,
            __directories_successfully_listed_from_source,
            __intermediate_objects_cleaned_up,
            __intermediate_objects_failed_cleaned_up,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferCounters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectsFoundFromSource" => Ok(__FieldTag::__objects_found_from_source),
                            "objects_found_from_source" => {
                                Ok(__FieldTag::__objects_found_from_source)
                            }
                            "bytesFoundFromSource" => Ok(__FieldTag::__bytes_found_from_source),
                            "bytes_found_from_source" => Ok(__FieldTag::__bytes_found_from_source),
                            "objectsFoundOnlyFromSink" => {
                                Ok(__FieldTag::__objects_found_only_from_sink)
                            }
                            "objects_found_only_from_sink" => {
                                Ok(__FieldTag::__objects_found_only_from_sink)
                            }
                            "bytesFoundOnlyFromSink" => {
                                Ok(__FieldTag::__bytes_found_only_from_sink)
                            }
                            "bytes_found_only_from_sink" => {
                                Ok(__FieldTag::__bytes_found_only_from_sink)
                            }
                            "objectsFromSourceSkippedBySync" => {
                                Ok(__FieldTag::__objects_from_source_skipped_by_sync)
                            }
                            "objects_from_source_skipped_by_sync" => {
                                Ok(__FieldTag::__objects_from_source_skipped_by_sync)
                            }
                            "bytesFromSourceSkippedBySync" => {
                                Ok(__FieldTag::__bytes_from_source_skipped_by_sync)
                            }
                            "bytes_from_source_skipped_by_sync" => {
                                Ok(__FieldTag::__bytes_from_source_skipped_by_sync)
                            }
                            "objectsCopiedToSink" => Ok(__FieldTag::__objects_copied_to_sink),
                            "objects_copied_to_sink" => Ok(__FieldTag::__objects_copied_to_sink),
                            "bytesCopiedToSink" => Ok(__FieldTag::__bytes_copied_to_sink),
                            "bytes_copied_to_sink" => Ok(__FieldTag::__bytes_copied_to_sink),
                            "objectsDeletedFromSource" => {
                                Ok(__FieldTag::__objects_deleted_from_source)
                            }
                            "objects_deleted_from_source" => {
                                Ok(__FieldTag::__objects_deleted_from_source)
                            }
                            "bytesDeletedFromSource" => Ok(__FieldTag::__bytes_deleted_from_source),
                            "bytes_deleted_from_source" => {
                                Ok(__FieldTag::__bytes_deleted_from_source)
                            }
                            "objectsDeletedFromSink" => Ok(__FieldTag::__objects_deleted_from_sink),
                            "objects_deleted_from_sink" => {
                                Ok(__FieldTag::__objects_deleted_from_sink)
                            }
                            "bytesDeletedFromSink" => Ok(__FieldTag::__bytes_deleted_from_sink),
                            "bytes_deleted_from_sink" => Ok(__FieldTag::__bytes_deleted_from_sink),
                            "objectsFromSourceFailed" => {
                                Ok(__FieldTag::__objects_from_source_failed)
                            }
                            "objects_from_source_failed" => {
                                Ok(__FieldTag::__objects_from_source_failed)
                            }
                            "bytesFromSourceFailed" => Ok(__FieldTag::__bytes_from_source_failed),
                            "bytes_from_source_failed" => {
                                Ok(__FieldTag::__bytes_from_source_failed)
                            }
                            "objectsFailedToDeleteFromSink" => {
                                Ok(__FieldTag::__objects_failed_to_delete_from_sink)
                            }
                            "objects_failed_to_delete_from_sink" => {
                                Ok(__FieldTag::__objects_failed_to_delete_from_sink)
                            }
                            "bytesFailedToDeleteFromSink" => {
                                Ok(__FieldTag::__bytes_failed_to_delete_from_sink)
                            }
                            "bytes_failed_to_delete_from_sink" => {
                                Ok(__FieldTag::__bytes_failed_to_delete_from_sink)
                            }
                            "directoriesFoundFromSource" => {
                                Ok(__FieldTag::__directories_found_from_source)
                            }
                            "directories_found_from_source" => {
                                Ok(__FieldTag::__directories_found_from_source)
                            }
                            "directoriesFailedToListFromSource" => {
                                Ok(__FieldTag::__directories_failed_to_list_from_source)
                            }
                            "directories_failed_to_list_from_source" => {
                                Ok(__FieldTag::__directories_failed_to_list_from_source)
                            }
                            "directoriesSuccessfullyListedFromSource" => {
                                Ok(__FieldTag::__directories_successfully_listed_from_source)
                            }
                            "directories_successfully_listed_from_source" => {
                                Ok(__FieldTag::__directories_successfully_listed_from_source)
                            }
                            "intermediateObjectsCleanedUp" => {
                                Ok(__FieldTag::__intermediate_objects_cleaned_up)
                            }
                            "intermediate_objects_cleaned_up" => {
                                Ok(__FieldTag::__intermediate_objects_cleaned_up)
                            }
                            "intermediateObjectsFailedCleanedUp" => {
                                Ok(__FieldTag::__intermediate_objects_failed_cleaned_up)
                            }
                            "intermediate_objects_failed_cleaned_up" => {
                                Ok(__FieldTag::__intermediate_objects_failed_cleaned_up)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransferCounters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferCounters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__objects_found_from_source => {
                            if !fields.insert(__FieldTag::__objects_found_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_found_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_found_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_found_from_source => {
                            if !fields.insert(__FieldTag::__bytes_found_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_found_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_found_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_found_only_from_sink => {
                            if !fields.insert(__FieldTag::__objects_found_only_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_found_only_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_found_only_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_found_only_from_sink => {
                            if !fields.insert(__FieldTag::__bytes_found_only_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_found_only_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_found_only_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_from_source_skipped_by_sync => {
                            if !fields.insert(__FieldTag::__objects_from_source_skipped_by_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_from_source_skipped_by_sync",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_from_source_skipped_by_sync =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_from_source_skipped_by_sync => {
                            if !fields.insert(__FieldTag::__bytes_from_source_skipped_by_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_from_source_skipped_by_sync",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_from_source_skipped_by_sync =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_copied_to_sink => {
                            if !fields.insert(__FieldTag::__objects_copied_to_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_copied_to_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_copied_to_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_copied_to_sink => {
                            if !fields.insert(__FieldTag::__bytes_copied_to_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_copied_to_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_copied_to_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_deleted_from_source => {
                            if !fields.insert(__FieldTag::__objects_deleted_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_deleted_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_deleted_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_deleted_from_source => {
                            if !fields.insert(__FieldTag::__bytes_deleted_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_deleted_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_deleted_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_deleted_from_sink => {
                            if !fields.insert(__FieldTag::__objects_deleted_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_deleted_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_deleted_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_deleted_from_sink => {
                            if !fields.insert(__FieldTag::__bytes_deleted_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_deleted_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_deleted_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_from_source_failed => {
                            if !fields.insert(__FieldTag::__objects_from_source_failed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_from_source_failed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_from_source_failed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_from_source_failed => {
                            if !fields.insert(__FieldTag::__bytes_from_source_failed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_from_source_failed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_from_source_failed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_failed_to_delete_from_sink => {
                            if !fields.insert(__FieldTag::__objects_failed_to_delete_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_failed_to_delete_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_failed_to_delete_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_failed_to_delete_from_sink => {
                            if !fields.insert(__FieldTag::__bytes_failed_to_delete_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_failed_to_delete_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_failed_to_delete_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__directories_found_from_source => {
                            if !fields.insert(__FieldTag::__directories_found_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directories_found_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.directories_found_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__directories_failed_to_list_from_source => {
                            if !fields.insert(__FieldTag::__directories_failed_to_list_from_source)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directories_failed_to_list_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.directories_failed_to_list_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__directories_successfully_listed_from_source => {
                            if !fields
                                .insert(__FieldTag::__directories_successfully_listed_from_source)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directories_successfully_listed_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.directories_successfully_listed_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__intermediate_objects_cleaned_up => {
                            if !fields.insert(__FieldTag::__intermediate_objects_cleaned_up) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intermediate_objects_cleaned_up",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intermediate_objects_cleaned_up =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__intermediate_objects_failed_cleaned_up => {
                            if !fields.insert(__FieldTag::__intermediate_objects_failed_cleaned_up)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intermediate_objects_failed_cleaned_up",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intermediate_objects_failed_cleaned_up =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub_topic,
            __event_types,
            __payload_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsubTopic" => Ok(__FieldTag::__pubsub_topic),
                            "pubsub_topic" => Ok(__FieldTag::__pubsub_topic),
                            "eventTypes" => Ok(__FieldTag::__event_types),
                            "event_types" => Ok(__FieldTag::__event_types),
                            "payloadFormat" => Ok(__FieldTag::__payload_format),
                            "payload_format" => Ok(__FieldTag::__payload_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub_topic => {
                            if !fields.insert(__FieldTag::__pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_topic",
                                ));
                            }
                            result.pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_types => {
                            if !fields.insert(__FieldTag::__event_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_types",
                                ));
                            }
                            result.event_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::notification_config::EventType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload_format => {
                            if !fields.insert(__FieldTag::__payload_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_format",
                                ));
                            }
                            result.payload_format = map
                                .next_value::<std::option::Option<
                                    crate::model::notification_config::PayloadFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_actions,
            __log_action_states,
            __enable_onprem_gcs_transfer_logs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logActions" => Ok(__FieldTag::__log_actions),
                            "log_actions" => Ok(__FieldTag::__log_actions),
                            "logActionStates" => Ok(__FieldTag::__log_action_states),
                            "log_action_states" => Ok(__FieldTag::__log_action_states),
                            "enableOnpremGcsTransferLogs" => {
                                Ok(__FieldTag::__enable_onprem_gcs_transfer_logs)
                            }
                            "enable_onprem_gcs_transfer_logs" => {
                                Ok(__FieldTag::__enable_onprem_gcs_transfer_logs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_actions => {
                            if !fields.insert(__FieldTag::__log_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_actions",
                                ));
                            }
                            result.log_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::logging_config::LoggableAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_action_states => {
                            if !fields.insert(__FieldTag::__log_action_states) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_action_states",
                                ));
                            }
                            result.log_action_states = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::logging_config::LoggableActionState,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_onprem_gcs_transfer_logs => {
                            if !fields.insert(__FieldTag::__enable_onprem_gcs_transfer_logs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_onprem_gcs_transfer_logs",
                                ));
                            }
                            result.enable_onprem_gcs_transfer_logs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransferOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __transfer_spec,
            __notification_config,
            __logging_config,
            __start_time,
            __end_time,
            __status,
            __counters,
            __error_breakdowns,
            __transfer_job_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "transferSpec" => Ok(__FieldTag::__transfer_spec),
                            "transfer_spec" => Ok(__FieldTag::__transfer_spec),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "status" => Ok(__FieldTag::__status),
                            "counters" => Ok(__FieldTag::__counters),
                            "errorBreakdowns" => Ok(__FieldTag::__error_breakdowns),
                            "error_breakdowns" => Ok(__FieldTag::__error_breakdowns),
                            "transferJobName" => Ok(__FieldTag::__transfer_job_name),
                            "transfer_job_name" => Ok(__FieldTag::__transfer_job_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransferOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_spec => {
                            if !fields.insert(__FieldTag::__transfer_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_spec",
                                ));
                            }
                            result.transfer_spec = map
                                .next_value::<std::option::Option<crate::model::TransferSpec>>()?;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::transfer_operation::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__counters => {
                            if !fields.insert(__FieldTag::__counters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for counters",
                                ));
                            }
                            result.counters = map
                                .next_value::<std::option::Option<crate::model::TransferCounters>>(
                                )?;
                        }
                        __FieldTag::__error_breakdowns => {
                            if !fields.insert(__FieldTag::__error_breakdowns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_breakdowns",
                                ));
                            }
                            result.error_breakdowns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorSummary>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transfer_job_name => {
                            if !fields.insert(__FieldTag::__transfer_job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_job_name",
                                ));
                            }
                            result.transfer_job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
