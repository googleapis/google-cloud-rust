// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::GetGoogleServiceAccountRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGoogleServiceAccountRequest");
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTransferJobRequest");
        debug_struct.field("transfer_job", &self.transfer_job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("transfer_job", &self.transfer_job);
        debug_struct.field(
            "update_transfer_job_field_mask",
            &self.update_transfer_job_field_mask,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListTransferJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferJobsRequest");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListTransferJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferJobsResponse");
        debug_struct.field("transfer_jobs", &self.transfer_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PauseTransferOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseTransferOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResumeTransferOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeTransferOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RunTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAgentPoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("agent_pool", &self.agent_pool);
        debug_struct.field("agent_pool_id", &self.agent_pool_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAgentPoolRequest");
        debug_struct.field("agent_pool", &self.agent_pool);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAgentPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAgentPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAgentPoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAgentPoolsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAgentPoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAgentPoolsResponse");
        debug_struct.field("agent_pools", &self.agent_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GoogleServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleServiceAccount");
        debug_struct.field("account_email", &self.account_email);
        debug_struct.field("subject_id", &self.subject_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AwsAccessKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsAccessKey");
        debug_struct.field("access_key_id", &self.access_key_id);
        debug_struct.field("secret_access_key", &self.secret_access_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AzureCredentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureCredentials");
        debug_struct.field("sas_token", &self.sas_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ObjectConditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectConditions");
        debug_struct.field(
            "min_time_elapsed_since_last_modification",
            &self.min_time_elapsed_since_last_modification,
        );
        debug_struct.field(
            "max_time_elapsed_since_last_modification",
            &self.max_time_elapsed_since_last_modification,
        );
        debug_struct.field("include_prefixes", &self.include_prefixes);
        debug_struct.field("exclude_prefixes", &self.exclude_prefixes);
        debug_struct.field("last_modified_since", &self.last_modified_since);
        debug_struct.field("last_modified_before", &self.last_modified_before);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsData");
        debug_struct.field("bucket_name", &self.bucket_name);
        debug_struct.field("path", &self.path);
        debug_struct.field(
            "managed_folder_transfer_enabled",
            &self.managed_folder_transfer_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AwsS3Data {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsS3Data");
        debug_struct.field("bucket_name", &self.bucket_name);
        debug_struct.field("aws_access_key", &self.aws_access_key);
        debug_struct.field("path", &self.path);
        debug_struct.field("role_arn", &self.role_arn);
        debug_struct.field("cloudfront_domain", &self.cloudfront_domain);
        debug_struct.field("credentials_secret", &self.credentials_secret);
        debug_struct.field("private_network", &self.private_network);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AzureBlobStorageData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureBlobStorageData");
        debug_struct.field("storage_account", &self.storage_account);
        debug_struct.field("azure_credentials", &self.azure_credentials);
        debug_struct.field("container", &self.container);
        debug_struct.field("path", &self.path);
        debug_struct.field("credentials_secret", &self.credentials_secret);
        debug_struct.field("federated_identity_config", &self.federated_identity_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::azure_blob_storage_data::FederatedIdentityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FederatedIdentityConfig");
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("tenant_id", &self.tenant_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HttpData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpData");
        debug_struct.field("list_url", &self.list_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PosixFilesystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PosixFilesystem");
        debug_struct.field("root_directory", &self.root_directory);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HdfsData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HdfsData");
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AwsS3CompatibleData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsS3CompatibleData");
        debug_struct.field("bucket_name", &self.bucket_name);
        debug_struct.field("path", &self.path);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("region", &self.region);
        debug_struct.field("data_provider", &self.data_provider);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::S3CompatibleMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("S3CompatibleMetadata");
        debug_struct.field("auth_method", &self.auth_method);
        debug_struct.field("request_model", &self.request_model);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("list_api", &self.list_api);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AgentPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AgentPool");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("bandwidth_limit", &self.bandwidth_limit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::agent_pool::BandwidthLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BandwidthLimit");
        debug_struct.field("limit_mbps", &self.limit_mbps);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransferOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferOptions");
        debug_struct.field(
            "overwrite_objects_already_existing_in_sink",
            &self.overwrite_objects_already_existing_in_sink,
        );
        debug_struct.field(
            "delete_objects_unique_in_sink",
            &self.delete_objects_unique_in_sink,
        );
        debug_struct.field(
            "delete_objects_from_source_after_transfer",
            &self.delete_objects_from_source_after_transfer,
        );
        debug_struct.field("overwrite_when", &self.overwrite_when);
        debug_struct.field("metadata_options", &self.metadata_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransferSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferSpec");
        debug_struct.field("object_conditions", &self.object_conditions);
        debug_struct.field("transfer_options", &self.transfer_options);
        debug_struct.field("transfer_manifest", &self.transfer_manifest);
        debug_struct.field("source_agent_pool_name", &self.source_agent_pool_name);
        debug_struct.field("sink_agent_pool_name", &self.sink_agent_pool_name);
        debug_struct.field("data_sink", &self.data_sink);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field(
            "intermediate_data_location",
            &self.intermediate_data_location,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReplicationSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationSpec");
        debug_struct.field("object_conditions", &self.object_conditions);
        debug_struct.field("transfer_options", &self.transfer_options);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field("data_sink", &self.data_sink);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetadataOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetadataOptions");
        debug_struct.field("symlink", &self.symlink);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("gid", &self.gid);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("acl", &self.acl);
        debug_struct.field("storage_class", &self.storage_class);
        debug_struct.field("temporary_hold", &self.temporary_hold);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("time_created", &self.time_created);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransferManifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferManifest");
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Schedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Schedule");
        debug_struct.field("schedule_start_date", &self.schedule_start_date);
        debug_struct.field("schedule_end_date", &self.schedule_end_date);
        debug_struct.field("start_time_of_day", &self.start_time_of_day);
        debug_struct.field("end_time_of_day", &self.end_time_of_day);
        debug_struct.field("repeat_interval", &self.repeat_interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EventStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventStream");
        debug_struct.field("name", &self.name);
        debug_struct.field("event_stream_start_time", &self.event_stream_start_time);
        debug_struct.field(
            "event_stream_expiration_time",
            &self.event_stream_expiration_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransferJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("transfer_spec", &self.transfer_spec);
        debug_struct.field("replication_spec", &self.replication_spec);
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("event_stream", &self.event_stream);
        debug_struct.field("status", &self.status);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modification_time", &self.last_modification_time);
        debug_struct.field("deletion_time", &self.deletion_time);
        debug_struct.field("latest_operation_name", &self.latest_operation_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ErrorLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorLogEntry");
        debug_struct.field("url", &self.url);
        debug_struct.field("error_details", &self.error_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ErrorSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorSummary");
        debug_struct.field("error_code", &self.error_code);
        debug_struct.field("error_count", &self.error_count);
        debug_struct.field("error_log_entries", &self.error_log_entries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransferCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferCounters");
        debug_struct.field("objects_found_from_source", &self.objects_found_from_source);
        debug_struct.field("bytes_found_from_source", &self.bytes_found_from_source);
        debug_struct.field(
            "objects_found_only_from_sink",
            &self.objects_found_only_from_sink,
        );
        debug_struct.field(
            "bytes_found_only_from_sink",
            &self.bytes_found_only_from_sink,
        );
        debug_struct.field(
            "objects_from_source_skipped_by_sync",
            &self.objects_from_source_skipped_by_sync,
        );
        debug_struct.field(
            "bytes_from_source_skipped_by_sync",
            &self.bytes_from_source_skipped_by_sync,
        );
        debug_struct.field("objects_copied_to_sink", &self.objects_copied_to_sink);
        debug_struct.field("bytes_copied_to_sink", &self.bytes_copied_to_sink);
        debug_struct.field(
            "objects_deleted_from_source",
            &self.objects_deleted_from_source,
        );
        debug_struct.field("bytes_deleted_from_source", &self.bytes_deleted_from_source);
        debug_struct.field("objects_deleted_from_sink", &self.objects_deleted_from_sink);
        debug_struct.field("bytes_deleted_from_sink", &self.bytes_deleted_from_sink);
        debug_struct.field(
            "objects_from_source_failed",
            &self.objects_from_source_failed,
        );
        debug_struct.field("bytes_from_source_failed", &self.bytes_from_source_failed);
        debug_struct.field(
            "objects_failed_to_delete_from_sink",
            &self.objects_failed_to_delete_from_sink,
        );
        debug_struct.field(
            "bytes_failed_to_delete_from_sink",
            &self.bytes_failed_to_delete_from_sink,
        );
        debug_struct.field(
            "directories_found_from_source",
            &self.directories_found_from_source,
        );
        debug_struct.field(
            "directories_failed_to_list_from_source",
            &self.directories_failed_to_list_from_source,
        );
        debug_struct.field(
            "directories_successfully_listed_from_source",
            &self.directories_successfully_listed_from_source,
        );
        debug_struct.field(
            "intermediate_objects_cleaned_up",
            &self.intermediate_objects_cleaned_up,
        );
        debug_struct.field(
            "intermediate_objects_failed_cleaned_up",
            &self.intermediate_objects_failed_cleaned_up,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NotificationConfig");
        debug_struct.field("pubsub_topic", &self.pubsub_topic);
        debug_struct.field("event_types", &self.event_types);
        debug_struct.field("payload_format", &self.payload_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingConfig");
        debug_struct.field("log_actions", &self.log_actions);
        debug_struct.field("log_action_states", &self.log_action_states);
        debug_struct.field(
            "enable_onprem_gcs_transfer_logs",
            &self.enable_onprem_gcs_transfer_logs,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransferOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferOperation");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("transfer_spec", &self.transfer_spec);
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("status", &self.status);
        debug_struct.field("counters", &self.counters);
        debug_struct.field("error_breakdowns", &self.error_breakdowns);
        debug_struct.field("transfer_job_name", &self.transfer_job_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
