// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request passed to GetGoogleServiceAccount.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGoogleServiceAccountRequest {
    /// Required. The ID of the Google Cloud project that the Google service
    /// account is associated with.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGoogleServiceAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetGoogleServiceAccountRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GetGoogleServiceAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GetGoogleServiceAccountRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGoogleServiceAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGoogleServiceAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGoogleServiceAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGoogleServiceAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGoogleServiceAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGoogleServiceAccountRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGoogleServiceAccountRequest");
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to CreateTransferJob.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTransferJobRequest {
    /// Required. The job to create.
    pub transfer_job: std::option::Option<crate::model::TransferJob>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_job][crate::model::CreateTransferJobRequest::transfer_job].
    pub fn set_transfer_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_job][crate::model::CreateTransferJobRequest::transfer_job].
    pub fn set_or_clear_transfer_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.CreateTransferJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferJob" => Ok(__FieldTag::__transfer_job),
                            "transfer_job" => Ok(__FieldTag::__transfer_job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_job => {
                            if !fields.insert(__FieldTag::__transfer_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_job",
                                ));
                            }
                            result.transfer_job =
                                map.next_value::<std::option::Option<crate::model::TransferJob>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTransferJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transfer_job.is_some() {
            state.serialize_entry("transferJob", &self.transfer_job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTransferJobRequest");
        debug_struct.field("transfer_job", &self.transfer_job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to UpdateTransferJob.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTransferJobRequest {
    /// Required. The name of job to update.
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the
    /// job.
    pub project_id: std::string::String,

    /// Required. The job to update. `transferJob` is expected to specify one or
    /// more of five fields:
    /// [description][google.storagetransfer.v1.TransferJob.description],
    /// [transfer_spec][google.storagetransfer.v1.TransferJob.transfer_spec],
    /// [notification_config][google.storagetransfer.v1.TransferJob.notification_config],
    /// [logging_config][google.storagetransfer.v1.TransferJob.logging_config], and
    /// [status][google.storagetransfer.v1.TransferJob.status].  An
    /// `UpdateTransferJobRequest` that specifies other fields are rejected with
    /// the error [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. Updating a
    /// job status to
    /// [DELETED][google.storagetransfer.v1.TransferJob.Status.DELETED] requires
    /// `storagetransfer.jobs.delete` permission.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.TransferJob.Status.DELETED]: crate::model::transfer_job::Status::Deleted
    /// [google.storagetransfer.v1.TransferJob.description]: crate::model::TransferJob::description
    /// [google.storagetransfer.v1.TransferJob.logging_config]: crate::model::TransferJob::logging_config
    /// [google.storagetransfer.v1.TransferJob.notification_config]: crate::model::TransferJob::notification_config
    /// [google.storagetransfer.v1.TransferJob.status]: crate::model::TransferJob::status
    /// [google.storagetransfer.v1.TransferJob.transfer_spec]: crate::model::TransferJob::transfer_spec
    pub transfer_job: std::option::Option<crate::model::TransferJob>,

    /// The field mask of the fields in `transferJob` that are to be updated in
    /// this request.  Fields in `transferJob` that can be updated are:
    /// [description][google.storagetransfer.v1.TransferJob.description],
    /// [transfer_spec][google.storagetransfer.v1.TransferJob.transfer_spec],
    /// [notification_config][google.storagetransfer.v1.TransferJob.notification_config],
    /// [logging_config][google.storagetransfer.v1.TransferJob.logging_config], and
    /// [status][google.storagetransfer.v1.TransferJob.status].  To update the
    /// `transfer_spec` of the job, a complete transfer specification must be
    /// provided. An incomplete specification missing any required fields is
    /// rejected with the error
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.TransferJob.description]: crate::model::TransferJob::description
    /// [google.storagetransfer.v1.TransferJob.logging_config]: crate::model::TransferJob::logging_config
    /// [google.storagetransfer.v1.TransferJob.notification_config]: crate::model::TransferJob::notification_config
    /// [google.storagetransfer.v1.TransferJob.status]: crate::model::TransferJob::status
    /// [google.storagetransfer.v1.TransferJob.transfer_spec]: crate::model::TransferJob::transfer_spec
    pub update_transfer_job_field_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::UpdateTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::UpdateTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [transfer_job][crate::model::UpdateTransferJobRequest::transfer_job].
    pub fn set_transfer_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_job][crate::model::UpdateTransferJobRequest::transfer_job].
    pub fn set_or_clear_transfer_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_transfer_job_field_mask][crate::model::UpdateTransferJobRequest::update_transfer_job_field_mask].
    pub fn set_update_transfer_job_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_transfer_job_field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_transfer_job_field_mask][crate::model::UpdateTransferJobRequest::update_transfer_job_field_mask].
    pub fn set_or_clear_update_transfer_job_field_mask<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_transfer_job_field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.UpdateTransferJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            __transfer_job,
            __update_transfer_job_field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "transferJob" => Ok(__FieldTag::__transfer_job),
                            "transfer_job" => Ok(__FieldTag::__transfer_job),
                            "updateTransferJobFieldMask" => {
                                Ok(__FieldTag::__update_transfer_job_field_mask)
                            }
                            "update_transfer_job_field_mask" => {
                                Ok(__FieldTag::__update_transfer_job_field_mask)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_job => {
                            if !fields.insert(__FieldTag::__transfer_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_job",
                                ));
                            }
                            result.transfer_job =
                                map.next_value::<std::option::Option<crate::model::TransferJob>>()?;
                        }
                        __FieldTag::__update_transfer_job_field_mask => {
                            if !fields.insert(__FieldTag::__update_transfer_job_field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_transfer_job_field_mask",
                                ));
                            }
                            result.update_transfer_job_field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTransferJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_name.is_empty() {
            state.serialize_entry("jobName", &self.job_name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.transfer_job.is_some() {
            state.serialize_entry("transferJob", &self.transfer_job)?;
        }
        if self.update_transfer_job_field_mask.is_some() {
            state.serialize_entry(
                "updateTransferJobFieldMask",
                &self.update_transfer_job_field_mask,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("transfer_job", &self.transfer_job);
        debug_struct.field(
            "update_transfer_job_field_mask",
            &self.update_transfer_job_field_mask,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to GetTransferJob.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTransferJobRequest {
    /// Required. The job to get.
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the
    /// job.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::GetTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GetTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GetTransferJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTransferJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_name.is_empty() {
            state.serialize_entry("jobName", &self.job_name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to DeleteTransferJob.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTransferJobRequest {
    /// Required. The job to delete.
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the
    /// job.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::DeleteTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DeleteTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.DeleteTransferJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTransferJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_name.is_empty() {
            state.serialize_entry("jobName", &self.job_name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// `projectId`, `jobNames`, and `jobStatuses` are query parameters that can
/// be specified when listing transfer jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferJobsRequest {
    /// Required. A list of query parameters specified as JSON text in the form of:
    ///
    /// ```norust
    /// {
    ///   "projectId":"my_project_id",
    ///   "jobNames":["jobid1","jobid2",...],
    ///   "jobStatuses":["status1","status2",...],
    ///   "dataBackend":"QUERY_REPLICATION_CONFIGS",
    ///   "sourceBucket":"source-bucket-name",
    ///   "sinkBucket":"sink-bucket-name",
    /// }
    /// ```
    ///
    /// The JSON formatting in the example is for display only; provide the
    /// query parameters without spaces or line breaks.
    ///
    /// * `projectId` is required.
    /// * Since `jobNames` and `jobStatuses` support multiple values, their values
    ///   must be specified with array notation. `jobNames` and `jobStatuses` are
    ///   optional. Valid values are case-insensitive:
    ///   * [ENABLED][google.storagetransfer.v1.TransferJob.Status.ENABLED]
    ///   * [DISABLED][google.storagetransfer.v1.TransferJob.Status.DISABLED]
    ///   * [DELETED][google.storagetransfer.v1.TransferJob.Status.DELETED]
    /// * Specify `"dataBackend":"QUERY_REPLICATION_CONFIGS"` to return a list of
    ///   cross-bucket replication jobs.
    /// * Limit the results to jobs from a particular bucket with `sourceBucket`
    ///   and/or to a particular bucket with `sinkBucket`.
    ///
    /// [google.storagetransfer.v1.TransferJob.Status.DELETED]: crate::model::transfer_job::Status::Deleted
    /// [google.storagetransfer.v1.TransferJob.Status.DISABLED]: crate::model::transfer_job::Status::Disabled
    /// [google.storagetransfer.v1.TransferJob.Status.ENABLED]: crate::model::transfer_job::Status::Enabled
    pub filter: std::string::String,

    /// The list page size. The max allowed value is 256.
    pub page_size: i32,

    /// The list page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::ListTransferJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTransferJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTransferJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListTransferJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferJobsRequest");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response from ListTransferJobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferJobsResponse {
    /// A list of transfer jobs.
    pub transfer_jobs: std::vec::Vec<crate::model::TransferJob>,

    /// The list next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_jobs][crate::model::ListTransferJobsResponse::transfer_jobs].
    pub fn set_transfer_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferJob>,
    {
        use std::iter::Iterator;
        self.transfer_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTransferJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListTransferJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTransferJobsResponse {
    type PageItem = crate::model::TransferJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.transfer_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferJobs" => Ok(__FieldTag::__transfer_jobs),
                            "transfer_jobs" => Ok(__FieldTag::__transfer_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_jobs => {
                            if !fields.insert(__FieldTag::__transfer_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_jobs",
                                ));
                            }
                            result.transfer_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TransferJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transfer_jobs.is_empty() {
            state.serialize_entry("transferJobs", &self.transfer_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferJobsResponse");
        debug_struct.field("transfer_jobs", &self.transfer_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to PauseTransferOperation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseTransferOperationRequest {
    /// Required. The name of the transfer operation.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseTransferOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseTransferOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseTransferOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.PauseTransferOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseTransferOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseTransferOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseTransferOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseTransferOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseTransferOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseTransferOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseTransferOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to ResumeTransferOperation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeTransferOperationRequest {
    /// Required. The name of the transfer operation.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeTransferOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeTransferOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeTransferOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ResumeTransferOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeTransferOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeTransferOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeTransferOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeTransferOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeTransferOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeTransferOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeTransferOperationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request passed to RunTransferJob.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTransferJobRequest {
    /// Required. The name of the transfer job.
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the transfer
    /// job.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::RunTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RunTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for RunTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.RunTransferJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTransferJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_name,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTransferJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobName" => Ok(__FieldTag::__job_name),
                            "job_name" => Ok(__FieldTag::__job_name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTransferJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTransferJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_name => {
                            if !fields.insert(__FieldTag::__job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_name",
                                ));
                            }
                            result.job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunTransferJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_name.is_empty() {
            state.serialize_entry("jobName", &self.job_name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunTransferJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunTransferJobRequest");
        debug_struct.field("job_name", &self.job_name);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies the request passed to CreateAgentPool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAgentPoolRequest {
    /// Required. The ID of the Google Cloud project that owns the
    /// agent pool.
    pub project_id: std::string::String,

    /// Required. The agent pool to create.
    pub agent_pool: std::option::Option<crate::model::AgentPool>,

    /// Required. The ID of the agent pool to create.
    ///
    /// The `agent_pool_id` must meet the following requirements:
    ///
    /// * Length of 128 characters or less.
    /// * Not start with the string `goog`.
    /// * Start with a lowercase ASCII character, followed by:
    ///   * Zero or more: lowercase Latin alphabet characters, numerals,
    ///     hyphens (`-`), periods (`.`), underscores (`_`), or tildes (`~`).
    ///   * One or more numerals or lowercase ASCII characters.
    ///
    /// As expressed by the regular expression:
    /// `^(?!goog)[a-z]([a-z0-9-._~]*[a-z0-9])?$`.
    pub agent_pool_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateAgentPoolRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [agent_pool][crate::model::CreateAgentPoolRequest::agent_pool].
    pub fn set_agent_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent_pool][crate::model::CreateAgentPoolRequest::agent_pool].
    pub fn set_or_clear_agent_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [agent_pool_id][crate::model::CreateAgentPoolRequest::agent_pool_id].
    pub fn set_agent_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_pool_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.CreateAgentPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __agent_pool,
            __agent_pool_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "agentPool" => Ok(__FieldTag::__agent_pool),
                            "agent_pool" => Ok(__FieldTag::__agent_pool),
                            "agentPoolId" => Ok(__FieldTag::__agent_pool_id),
                            "agent_pool_id" => Ok(__FieldTag::__agent_pool_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_pool => {
                            if !fields.insert(__FieldTag::__agent_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pool",
                                ));
                            }
                            result.agent_pool =
                                map.next_value::<std::option::Option<crate::model::AgentPool>>()?;
                        }
                        __FieldTag::__agent_pool_id => {
                            if !fields.insert(__FieldTag::__agent_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pool_id",
                                ));
                            }
                            result.agent_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAgentPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.agent_pool.is_some() {
            state.serialize_entry("agentPool", &self.agent_pool)?;
        }
        if !self.agent_pool_id.is_empty() {
            state.serialize_entry("agentPoolId", &self.agent_pool_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAgentPoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("agent_pool", &self.agent_pool);
        debug_struct.field("agent_pool_id", &self.agent_pool_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies the request passed to UpdateAgentPool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAgentPoolRequest {
    /// Required. The agent pool to update. `agent_pool` is expected to specify
    /// following fields:
    ///
    /// * [name][google.storagetransfer.v1.AgentPool.name]
    ///
    /// * [display_name][google.storagetransfer.v1.AgentPool.display_name]
    ///
    /// * [bandwidth_limit][google.storagetransfer.v1.AgentPool.bandwidth_limit]
    ///   An `UpdateAgentPoolRequest` with any other fields is rejected
    ///   with the error [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
    ///
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.AgentPool.bandwidth_limit]: crate::model::AgentPool::bandwidth_limit
    /// [google.storagetransfer.v1.AgentPool.display_name]: crate::model::AgentPool::display_name
    /// [google.storagetransfer.v1.AgentPool.name]: crate::model::AgentPool::name
    pub agent_pool: std::option::Option<crate::model::AgentPool>,

    /// The [field mask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf>)
    /// of the fields in `agentPool` to update in this request.
    /// The following `agentPool` fields can be updated:
    ///
    /// * [display_name][google.storagetransfer.v1.AgentPool.display_name]
    ///
    /// * [bandwidth_limit][google.storagetransfer.v1.AgentPool.bandwidth_limit]
    ///
    ///
    /// [google.storagetransfer.v1.AgentPool.bandwidth_limit]: crate::model::AgentPool::bandwidth_limit
    /// [google.storagetransfer.v1.AgentPool.display_name]: crate::model::AgentPool::display_name
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent_pool][crate::model::UpdateAgentPoolRequest::agent_pool].
    pub fn set_agent_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent_pool][crate::model::UpdateAgentPoolRequest::agent_pool].
    pub fn set_or_clear_agent_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAgentPoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAgentPoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.UpdateAgentPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_pool,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentPool" => Ok(__FieldTag::__agent_pool),
                            "agent_pool" => Ok(__FieldTag::__agent_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_pool => {
                            if !fields.insert(__FieldTag::__agent_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pool",
                                ));
                            }
                            result.agent_pool =
                                map.next_value::<std::option::Option<crate::model::AgentPool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAgentPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.agent_pool.is_some() {
            state.serialize_entry("agentPool", &self.agent_pool)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAgentPoolRequest");
        debug_struct.field("agent_pool", &self.agent_pool);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies the request passed to GetAgentPool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAgentPoolRequest {
    /// Required. The name of the agent pool to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAgentPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GetAgentPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAgentPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAgentPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies the request passed to DeleteAgentPool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAgentPoolRequest {
    /// Required. The name of the agent pool to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAgentPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.DeleteAgentPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAgentPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAgentPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAgentPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAgentPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAgentPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAgentPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAgentPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request passed to ListAgentPools.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAgentPoolsRequest {
    /// Required. The ID of the Google Cloud project that owns the job.
    pub project_id: std::string::String,

    /// An optional list of query parameters specified as JSON text in the
    /// form of:
    ///
    /// `{"agentPoolNames":["agentpool1","agentpool2",...]}`
    ///
    /// Since `agentPoolNames` support multiple values, its values must be
    /// specified with array notation. When the filter is either empty or not
    /// provided, the list returns all agent pools for the project.
    pub filter: std::string::String,

    /// The list page size. The max allowed value is `256`.
    pub page_size: i32,

    /// The list page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAgentPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListAgentPoolsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAgentPoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAgentPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAgentPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAgentPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListAgentPoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAgentPoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAgentPoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAgentPoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAgentPoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAgentPoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAgentPoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAgentPoolsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response from ListAgentPools.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAgentPoolsResponse {
    /// A list of agent pools.
    pub agent_pools: std::vec::Vec<crate::model::AgentPool>,

    /// The list next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAgentPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent_pools][crate::model::ListAgentPoolsResponse::agent_pools].
    pub fn set_agent_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AgentPool>,
    {
        use std::iter::Iterator;
        self.agent_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAgentPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAgentPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListAgentPoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAgentPoolsResponse {
    type PageItem = crate::model::AgentPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.agent_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAgentPoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_pools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAgentPoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentPools" => Ok(__FieldTag::__agent_pools),
                            "agent_pools" => Ok(__FieldTag::__agent_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAgentPoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAgentPoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_pools => {
                            if !fields.insert(__FieldTag::__agent_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_pools",
                                ));
                            }
                            result.agent_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AgentPool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAgentPoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent_pools.is_empty() {
            state.serialize_entry("agentPools", &self.agent_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAgentPoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAgentPoolsResponse");
        debug_struct.field("agent_pools", &self.agent_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Google service account
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleServiceAccount {
    /// Email address of the service account.
    pub account_email: std::string::String,

    /// Unique identifier for the service account.
    pub subject_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_email][crate::model::GoogleServiceAccount::account_email].
    pub fn set_account_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_email = v.into();
        self
    }

    /// Sets the value of [subject_id][crate::model::GoogleServiceAccount::subject_id].
    pub fn set_subject_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_id = v.into();
        self
    }
}

impl wkt::message::Message for GoogleServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GoogleServiceAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleServiceAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_email,
            __subject_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleServiceAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountEmail" => Ok(__FieldTag::__account_email),
                            "account_email" => Ok(__FieldTag::__account_email),
                            "subjectId" => Ok(__FieldTag::__subject_id),
                            "subject_id" => Ok(__FieldTag::__subject_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleServiceAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleServiceAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_email => {
                            if !fields.insert(__FieldTag::__account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_email",
                                ));
                            }
                            result.account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_id => {
                            if !fields.insert(__FieldTag::__subject_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_id",
                                ));
                            }
                            result.subject_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleServiceAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.account_email.is_empty() {
            state.serialize_entry("accountEmail", &self.account_email)?;
        }
        if !self.subject_id.is_empty() {
            state.serialize_entry("subjectId", &self.subject_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GoogleServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleServiceAccount");
        debug_struct.field("account_email", &self.account_email);
        debug_struct.field("subject_id", &self.subject_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AWS access key (see
/// [AWS Security
/// Credentials](https://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html)).
///
/// For information on our data retention policy for user credentials, see
/// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsAccessKey {
    /// Required. AWS access key ID.
    pub access_key_id: std::string::String,

    /// Required. AWS secret access key. This field is not returned in RPC
    /// responses.
    pub secret_access_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccessKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_key_id][crate::model::AwsAccessKey::access_key_id].
    pub fn set_access_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_key_id = v.into();
        self
    }

    /// Sets the value of [secret_access_key][crate::model::AwsAccessKey::secret_access_key].
    pub fn set_secret_access_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_access_key = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccessKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AwsAccessKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsAccessKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_key_id,
            __secret_access_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAccessKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessKeyId" => Ok(__FieldTag::__access_key_id),
                            "access_key_id" => Ok(__FieldTag::__access_key_id),
                            "secretAccessKey" => Ok(__FieldTag::__secret_access_key),
                            "secret_access_key" => Ok(__FieldTag::__secret_access_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsAccessKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAccessKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_key_id => {
                            if !fields.insert(__FieldTag::__access_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_key_id",
                                ));
                            }
                            result.access_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_access_key => {
                            if !fields.insert(__FieldTag::__secret_access_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_access_key",
                                ));
                            }
                            result.secret_access_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsAccessKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_key_id.is_empty() {
            state.serialize_entry("accessKeyId", &self.access_key_id)?;
        }
        if !self.secret_access_key.is_empty() {
            state.serialize_entry("secretAccessKey", &self.secret_access_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsAccessKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsAccessKey");
        debug_struct.field("access_key_id", &self.access_key_id);
        debug_struct.field("secret_access_key", &self.secret_access_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Azure credentials
///
/// For information on our data retention policy for user credentials, see
/// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureCredentials {
    /// Required. Azure shared access signature (SAS).
    ///
    /// For more information about SAS, see
    /// [Grant limited access to Azure Storage resources using shared access
    /// signatures
    /// (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview).
    pub sas_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureCredentials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sas_token][crate::model::AzureCredentials::sas_token].
    pub fn set_sas_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sas_token = v.into();
        self
    }
}

impl wkt::message::Message for AzureCredentials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AzureCredentials"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureCredentials {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sas_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureCredentials")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sasToken" => Ok(__FieldTag::__sas_token),
                            "sas_token" => Ok(__FieldTag::__sas_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureCredentials;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureCredentials")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sas_token => {
                            if !fields.insert(__FieldTag::__sas_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sas_token",
                                ));
                            }
                            result.sas_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureCredentials {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sas_token.is_empty() {
            state.serialize_entry("sasToken", &self.sas_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureCredentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureCredentials");
        debug_struct.field("sas_token", &self.sas_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Conditions that determine which objects are transferred. Applies only
/// to Cloud Data Sources such as S3, Azure, and Cloud Storage.
///
/// The "last modification time" refers to the time of the
/// last change to the object's content or metadata  specifically, this is
/// the `updated` property of Cloud Storage objects, the `LastModified` field
/// of S3 objects, and the `Last-Modified` header of Azure blobs.
///
/// For S3 objects, the `LastModified` value is the time the object begins
/// uploading. If the object meets your "last modification time" criteria,
/// but has not finished uploading, the object is not transferred. See
/// [Transfer from Amazon S3 to Cloud
/// Storage](https://cloud.google.com/storage-transfer/docs/create-transfers/agentless/s3#transfer_options)
/// for more information.
///
/// Transfers with a [PosixFilesystem][google.storagetransfer.v1.PosixFilesystem]
/// source or destination don't support `ObjectConditions`.
///
/// [google.storagetransfer.v1.PosixFilesystem]: crate::model::PosixFilesystem
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectConditions {
    /// Ensures that objects are not transferred until a specific minimum time
    /// has elapsed after the "last modification time". When a
    /// [TransferOperation][google.storagetransfer.v1.TransferOperation] begins,
    /// objects with a "last modification time" are transferred only if the elapsed
    /// time between the
    /// [start_time][google.storagetransfer.v1.TransferOperation.start_time] of the
    /// `TransferOperation` and the "last modification time" of the object is equal
    /// to or greater than the value of min_time_elapsed_since_last_modification`.
    /// Objects that do not have a "last modification time" are also transferred.
    ///
    /// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
    /// [google.storagetransfer.v1.TransferOperation.start_time]: crate::model::TransferOperation::start_time
    pub min_time_elapsed_since_last_modification: std::option::Option<wkt::Duration>,

    /// Ensures that objects are not transferred if a specific maximum time
    /// has elapsed since the "last modification time".
    /// When a [TransferOperation][google.storagetransfer.v1.TransferOperation]
    /// begins, objects with a "last modification time" are transferred only if the
    /// elapsed time between the
    /// [start_time][google.storagetransfer.v1.TransferOperation.start_time] of the
    /// `TransferOperation`and the "last modification time" of the object
    /// is less than the value of max_time_elapsed_since_last_modification`.
    /// Objects that do not have a "last modification time" are also transferred.
    ///
    /// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
    /// [google.storagetransfer.v1.TransferOperation.start_time]: crate::model::TransferOperation::start_time
    pub max_time_elapsed_since_last_modification: std::option::Option<wkt::Duration>,

    /// If you specify `include_prefixes`, Storage Transfer Service uses the items
    /// in the `include_prefixes` array to determine which objects to include in a
    /// transfer. Objects must start with one of the matching `include_prefixes`
    /// for inclusion in the transfer. If
    /// [exclude_prefixes][google.storagetransfer.v1.ObjectConditions.exclude_prefixes]
    /// is specified, objects must not start with any of the `exclude_prefixes`
    /// specified for inclusion in the transfer.
    ///
    /// The following are requirements of `include_prefixes`:
    ///
    /// * Each include-prefix can contain any sequence of Unicode characters, to
    ///   a max length of 1024 bytes when UTF8-encoded, and must not contain
    ///   Carriage Return or Line Feed characters.  Wildcard matching and regular
    ///   expression matching are not supported.
    ///
    /// * Each include-prefix must omit the leading slash. For example, to
    ///   include the object `s3://my-aws-bucket/logs/y=2015/requests.gz`,
    ///   specify the include-prefix as `logs/y=2015/requests.gz`.
    ///
    /// * None of the include-prefix values can be empty, if specified.
    ///
    /// * Each include-prefix must include a distinct portion of the object
    ///   namespace. No include-prefix may be a prefix of another
    ///   include-prefix.
    ///
    ///
    /// The max size of `include_prefixes` is 1000.
    ///
    /// For more information, see [Filtering objects from
    /// transfers](/storage-transfer/docs/filtering-objects-from-transfers).
    ///
    /// [google.storagetransfer.v1.ObjectConditions.exclude_prefixes]: crate::model::ObjectConditions::exclude_prefixes
    pub include_prefixes: std::vec::Vec<std::string::String>,

    /// If you specify `exclude_prefixes`, Storage Transfer Service uses the items
    /// in the `exclude_prefixes` array to determine which objects to exclude from
    /// a transfer. Objects must not start with one of the matching
    /// `exclude_prefixes` for inclusion in a transfer.
    ///
    /// The following are requirements of `exclude_prefixes`:
    ///
    /// * Each exclude-prefix can contain any sequence of Unicode characters, to
    ///   a max length of 1024 bytes when UTF8-encoded, and must not contain
    ///   Carriage Return or Line Feed characters.  Wildcard matching and regular
    ///   expression matching are not supported.
    ///
    /// * Each exclude-prefix must omit the leading slash. For example, to
    ///   exclude the object `s3://my-aws-bucket/logs/y=2015/requests.gz`,
    ///   specify the exclude-prefix as `logs/y=2015/requests.gz`.
    ///
    /// * None of the exclude-prefix values can be empty, if specified.
    ///
    /// * Each exclude-prefix must exclude a distinct portion of the object
    ///   namespace. No exclude-prefix may be a prefix of another
    ///   exclude-prefix.
    ///
    /// * If
    ///   [include_prefixes][google.storagetransfer.v1.ObjectConditions.include_prefixes]
    ///   is specified, then each exclude-prefix must start with the value of a
    ///   path explicitly included by `include_prefixes`.
    ///
    ///
    /// The max size of `exclude_prefixes` is 1000.
    ///
    /// For more information, see [Filtering objects from
    /// transfers](/storage-transfer/docs/filtering-objects-from-transfers).
    ///
    /// [google.storagetransfer.v1.ObjectConditions.include_prefixes]: crate::model::ObjectConditions::include_prefixes
    pub exclude_prefixes: std::vec::Vec<std::string::String>,

    /// If specified, only objects with a "last modification time" on or after
    /// this timestamp and objects that don't have a "last modification time" are
    /// transferred.
    ///
    /// The `last_modified_since` and `last_modified_before` fields can be used
    /// together for chunked data processing. For example, consider a script that
    /// processes each day's worth of data at a time. For that you'd set each
    /// of the fields as follows:
    ///
    /// * `last_modified_since` to the start of the day
    ///
    /// * `last_modified_before` to the end of the day
    ///
    pub last_modified_since: std::option::Option<wkt::Timestamp>,

    /// If specified, only objects with a "last modification time" before this
    /// timestamp and objects that don't have a "last modification time" are
    /// transferred.
    pub last_modified_before: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_time_elapsed_since_last_modification][crate::model::ObjectConditions::min_time_elapsed_since_last_modification].
    pub fn set_min_time_elapsed_since_last_modification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_time_elapsed_since_last_modification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_time_elapsed_since_last_modification][crate::model::ObjectConditions::min_time_elapsed_since_last_modification].
    pub fn set_or_clear_min_time_elapsed_since_last_modification<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_time_elapsed_since_last_modification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_time_elapsed_since_last_modification][crate::model::ObjectConditions::max_time_elapsed_since_last_modification].
    pub fn set_max_time_elapsed_since_last_modification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_time_elapsed_since_last_modification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_time_elapsed_since_last_modification][crate::model::ObjectConditions::max_time_elapsed_since_last_modification].
    pub fn set_or_clear_max_time_elapsed_since_last_modification<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_time_elapsed_since_last_modification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [include_prefixes][crate::model::ObjectConditions::include_prefixes].
    pub fn set_include_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_prefixes][crate::model::ObjectConditions::exclude_prefixes].
    pub fn set_exclude_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [last_modified_since][crate::model::ObjectConditions::last_modified_since].
    pub fn set_last_modified_since<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_since = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_since][crate::model::ObjectConditions::last_modified_since].
    pub fn set_or_clear_last_modified_since<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_since = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified_before][crate::model::ObjectConditions::last_modified_before].
    pub fn set_last_modified_before<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_before = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_before][crate::model::ObjectConditions::last_modified_before].
    pub fn set_or_clear_last_modified_before<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_before = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ObjectConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ObjectConditions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectConditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_time_elapsed_since_last_modification,
            __max_time_elapsed_since_last_modification,
            __include_prefixes,
            __exclude_prefixes,
            __last_modified_since,
            __last_modified_before,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectConditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minTimeElapsedSinceLastModification" => {
                                Ok(__FieldTag::__min_time_elapsed_since_last_modification)
                            }
                            "min_time_elapsed_since_last_modification" => {
                                Ok(__FieldTag::__min_time_elapsed_since_last_modification)
                            }
                            "maxTimeElapsedSinceLastModification" => {
                                Ok(__FieldTag::__max_time_elapsed_since_last_modification)
                            }
                            "max_time_elapsed_since_last_modification" => {
                                Ok(__FieldTag::__max_time_elapsed_since_last_modification)
                            }
                            "includePrefixes" => Ok(__FieldTag::__include_prefixes),
                            "include_prefixes" => Ok(__FieldTag::__include_prefixes),
                            "excludePrefixes" => Ok(__FieldTag::__exclude_prefixes),
                            "exclude_prefixes" => Ok(__FieldTag::__exclude_prefixes),
                            "lastModifiedSince" => Ok(__FieldTag::__last_modified_since),
                            "last_modified_since" => Ok(__FieldTag::__last_modified_since),
                            "lastModifiedBefore" => Ok(__FieldTag::__last_modified_before),
                            "last_modified_before" => Ok(__FieldTag::__last_modified_before),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectConditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectConditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_time_elapsed_since_last_modification => {
                            if !fields
                                .insert(__FieldTag::__min_time_elapsed_since_last_modification)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_time_elapsed_since_last_modification",
                                ));
                            }
                            result.min_time_elapsed_since_last_modification =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_time_elapsed_since_last_modification => {
                            if !fields
                                .insert(__FieldTag::__max_time_elapsed_since_last_modification)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_time_elapsed_since_last_modification",
                                ));
                            }
                            result.max_time_elapsed_since_last_modification =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__include_prefixes => {
                            if !fields.insert(__FieldTag::__include_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_prefixes",
                                ));
                            }
                            result.include_prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclude_prefixes => {
                            if !fields.insert(__FieldTag::__exclude_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_prefixes",
                                ));
                            }
                            result.exclude_prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_since => {
                            if !fields.insert(__FieldTag::__last_modified_since) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_since",
                                ));
                            }
                            result.last_modified_since =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modified_before => {
                            if !fields.insert(__FieldTag::__last_modified_before) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_before",
                                ));
                            }
                            result.last_modified_before =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectConditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_time_elapsed_since_last_modification.is_some() {
            state.serialize_entry(
                "minTimeElapsedSinceLastModification",
                &self.min_time_elapsed_since_last_modification,
            )?;
        }
        if self.max_time_elapsed_since_last_modification.is_some() {
            state.serialize_entry(
                "maxTimeElapsedSinceLastModification",
                &self.max_time_elapsed_since_last_modification,
            )?;
        }
        if !self.include_prefixes.is_empty() {
            state.serialize_entry("includePrefixes", &self.include_prefixes)?;
        }
        if !self.exclude_prefixes.is_empty() {
            state.serialize_entry("excludePrefixes", &self.exclude_prefixes)?;
        }
        if self.last_modified_since.is_some() {
            state.serialize_entry("lastModifiedSince", &self.last_modified_since)?;
        }
        if self.last_modified_before.is_some() {
            state.serialize_entry("lastModifiedBefore", &self.last_modified_before)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ObjectConditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectConditions");
        debug_struct.field(
            "min_time_elapsed_since_last_modification",
            &self.min_time_elapsed_since_last_modification,
        );
        debug_struct.field(
            "max_time_elapsed_since_last_modification",
            &self.max_time_elapsed_since_last_modification,
        );
        debug_struct.field("include_prefixes", &self.include_prefixes);
        debug_struct.field("exclude_prefixes", &self.exclude_prefixes);
        debug_struct.field("last_modified_since", &self.last_modified_since);
        debug_struct.field("last_modified_before", &self.last_modified_before);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// In a GcsData resource, an object's name is the Cloud Storage object's
/// name and its "last modification time" refers to the object's `updated`
/// property of Cloud Storage objects, which changes when the content or the
/// metadata of the object is updated.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsData {
    /// Required. Cloud Storage bucket name. Must meet
    /// [Bucket Name Requirements](/storage/docs/naming#requirements).
    pub bucket_name: std::string::String,

    /// Root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This field
    /// is treated as an object prefix. As such, it should generally not begin with
    /// a '/'.
    ///
    /// The root path value must meet
    /// [Object Name Requirements](/storage/docs/naming#objectnames).
    pub path: std::string::String,

    /// Preview. Enables the transfer of managed folders between Cloud Storage
    /// buckets. Set this option on the gcs_data_source.
    ///
    /// If set to true:
    ///
    /// - Managed folders in the source bucket are transferred to the
    ///   destination bucket.
    /// - Managed folders in the destination bucket are overwritten. Other
    ///   OVERWRITE options are not supported.
    ///
    /// See
    /// [Transfer Cloud Storage managed
    /// folders](/storage-transfer/docs/managed-folders).
    pub managed_folder_transfer_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::GcsData::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::GcsData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [managed_folder_transfer_enabled][crate::model::GcsData::managed_folder_transfer_enabled].
    pub fn set_managed_folder_transfer_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.managed_folder_transfer_enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcsData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GcsData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __path,
            __managed_folder_transfer_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "path" => Ok(__FieldTag::__path),
                            "managedFolderTransferEnabled" => {
                                Ok(__FieldTag::__managed_folder_transfer_enabled)
                            }
                            "managed_folder_transfer_enabled" => {
                                Ok(__FieldTag::__managed_folder_transfer_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__managed_folder_transfer_enabled => {
                            if !fields.insert(__FieldTag::__managed_folder_transfer_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_folder_transfer_enabled",
                                ));
                            }
                            result.managed_folder_transfer_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.managed_folder_transfer_enabled) {
            state.serialize_entry(
                "managedFolderTransferEnabled",
                &self.managed_folder_transfer_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsData");
        debug_struct.field("bucket_name", &self.bucket_name);
        debug_struct.field("path", &self.path);
        debug_struct.field(
            "managed_folder_transfer_enabled",
            &self.managed_folder_transfer_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An AwsS3Data resource can be a data source, but not a data sink.
/// In an AwsS3Data resource, an object's name is the S3 object's key name.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsS3Data {
    /// Required. S3 Bucket name (see
    /// [Creating a
    /// bucket](https://docs.aws.amazon.com/AmazonS3/latest/dev/create-bucket-get-location-example.html)).
    pub bucket_name: std::string::String,

    /// Input only. AWS access key used to sign the API requests to the AWS S3
    /// bucket. Permissions on the bucket must be granted to the access ID of the
    /// AWS access key.
    ///
    /// For information on our data retention policy for user credentials, see
    /// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
    pub aws_access_key: std::option::Option<crate::model::AwsAccessKey>,

    /// Root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This field
    /// is treated as an object prefix. As such, it should generally not begin with
    /// a '/'.
    pub path: std::string::String,

    /// The Amazon Resource Name (ARN) of the role to support temporary
    /// credentials via `AssumeRoleWithWebIdentity`. For more information about
    /// ARNs, see [IAM
    /// ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    ///
    /// When a role ARN is provided, Transfer Service fetches temporary
    /// credentials for the session using a `AssumeRoleWithWebIdentity` call for
    /// the provided role using the
    /// [GoogleServiceAccount][google.storagetransfer.v1.GoogleServiceAccount] for
    /// this project.
    ///
    /// [google.storagetransfer.v1.GoogleServiceAccount]: crate::model::GoogleServiceAccount
    pub role_arn: std::string::String,

    /// Optional. The CloudFront distribution domain name pointing to this bucket,
    /// to use when fetching.
    ///
    /// See
    /// [Transfer from S3 via
    /// CloudFront](https://cloud.google.com/storage-transfer/docs/s3-cloudfront)
    /// for more information.
    ///
    /// Format: `https://{id}.cloudfront.net` or any valid custom domain. Must
    /// begin with `https://`.
    pub cloudfront_domain: std::string::String,

    /// Optional. The Resource name of a secret in Secret Manager.
    ///
    /// AWS credentials must be stored in Secret Manager in JSON format:
    ///
    /// {
    /// "access_key_id": "ACCESS_KEY_ID",
    /// "secret_access_key": "SECRET_ACCESS_KEY"
    /// }
    ///
    /// [GoogleServiceAccount][google.storagetransfer.v1.GoogleServiceAccount] must
    /// be granted `roles/secretmanager.secretAccessor` for the resource.
    ///
    /// See [Configure access to a source: Amazon S3]
    /// (<https://cloud.google.com/storage-transfer/docs/source-amazon-s3#secret_manager>)
    /// for more information.
    ///
    /// If `credentials_secret` is specified, do not specify
    /// [role_arn][google.storagetransfer.v1.AwsS3Data.role_arn] or
    /// [aws_access_key][google.storagetransfer.v1.AwsS3Data.aws_access_key].
    ///
    /// Format: `projects/{project_number}/secrets/{secret_name}`
    ///
    /// [google.storagetransfer.v1.AwsS3Data.aws_access_key]: crate::model::AwsS3Data::aws_access_key
    /// [google.storagetransfer.v1.AwsS3Data.role_arn]: crate::model::AwsS3Data::role_arn
    /// [google.storagetransfer.v1.GoogleServiceAccount]: crate::model::GoogleServiceAccount
    pub credentials_secret: std::string::String,

    pub private_network: std::option::Option<crate::model::aws_s_3_data::PrivateNetwork>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsS3Data {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::AwsS3Data::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [aws_access_key][crate::model::AwsS3Data::aws_access_key].
    pub fn set_aws_access_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccessKey>,
    {
        self.aws_access_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_access_key][crate::model::AwsS3Data::aws_access_key].
    pub fn set_or_clear_aws_access_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccessKey>,
    {
        self.aws_access_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::AwsS3Data::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [role_arn][crate::model::AwsS3Data::role_arn].
    pub fn set_role_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role_arn = v.into();
        self
    }

    /// Sets the value of [cloudfront_domain][crate::model::AwsS3Data::cloudfront_domain].
    pub fn set_cloudfront_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloudfront_domain = v.into();
        self
    }

    /// Sets the value of [credentials_secret][crate::model::AwsS3Data::credentials_secret].
    pub fn set_credentials_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_secret = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::AwsS3Data::private_network].
    ///
    /// Note that all the setters affecting `private_network` are mutually
    /// exclusive.
    pub fn set_private_network<
        T: std::convert::Into<std::option::Option<crate::model::aws_s_3_data::PrivateNetwork>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_network = v.into();
        self
    }

    /// The value of [private_network][crate::model::AwsS3Data::private_network]
    /// if it holds a `ManagedPrivateNetwork`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_private_network(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.private_network.as_ref().and_then(|v| match v {
            crate::model::aws_s_3_data::PrivateNetwork::ManagedPrivateNetwork(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [private_network][crate::model::AwsS3Data::private_network]
    /// to hold a `ManagedPrivateNetwork`.
    ///
    /// Note that all the setters affecting `private_network` are
    /// mutually exclusive.
    pub fn set_managed_private_network<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.private_network = std::option::Option::Some(
            crate::model::aws_s_3_data::PrivateNetwork::ManagedPrivateNetwork(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsS3Data {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AwsS3Data"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsS3Data {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __aws_access_key,
            __path,
            __role_arn,
            __cloudfront_domain,
            __credentials_secret,
            __managed_private_network,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsS3Data")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "awsAccessKey" => Ok(__FieldTag::__aws_access_key),
                            "aws_access_key" => Ok(__FieldTag::__aws_access_key),
                            "path" => Ok(__FieldTag::__path),
                            "roleArn" => Ok(__FieldTag::__role_arn),
                            "role_arn" => Ok(__FieldTag::__role_arn),
                            "cloudfrontDomain" => Ok(__FieldTag::__cloudfront_domain),
                            "cloudfront_domain" => Ok(__FieldTag::__cloudfront_domain),
                            "credentialsSecret" => Ok(__FieldTag::__credentials_secret),
                            "credentials_secret" => Ok(__FieldTag::__credentials_secret),
                            "managedPrivateNetwork" => Ok(__FieldTag::__managed_private_network),
                            "managed_private_network" => Ok(__FieldTag::__managed_private_network),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsS3Data;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsS3Data")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aws_access_key => {
                            if !fields.insert(__FieldTag::__aws_access_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_access_key",
                                ));
                            }
                            result.aws_access_key = map
                                .next_value::<std::option::Option<crate::model::AwsAccessKey>>()?;
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role_arn => {
                            if !fields.insert(__FieldTag::__role_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_arn",
                                ));
                            }
                            result.role_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloudfront_domain => {
                            if !fields.insert(__FieldTag::__cloudfront_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloudfront_domain",
                                ));
                            }
                            result.cloudfront_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__credentials_secret => {
                            if !fields.insert(__FieldTag::__credentials_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for credentials_secret",
                                ));
                            }
                            result.credentials_secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__managed_private_network => {
                            if !fields.insert(__FieldTag::__managed_private_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_private_network",
                                ));
                            }
                            if result.private_network.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `private_network`, a oneof with full ID .google.storagetransfer.v1.AwsS3Data.managed_private_network, latest field was managedPrivateNetwork",
                                ));
                            }
                            result.private_network = std::option::Option::Some(
                                crate::model::aws_s_3_data::PrivateNetwork::ManagedPrivateNetwork(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsS3Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if self.aws_access_key.is_some() {
            state.serialize_entry("awsAccessKey", &self.aws_access_key)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.role_arn.is_empty() {
            state.serialize_entry("roleArn", &self.role_arn)?;
        }
        if !self.cloudfront_domain.is_empty() {
            state.serialize_entry("cloudfrontDomain", &self.cloudfront_domain)?;
        }
        if !self.credentials_secret.is_empty() {
            state.serialize_entry("credentialsSecret", &self.credentials_secret)?;
        }
        if let Some(value) = self.managed_private_network() {
            state.serialize_entry("managedPrivateNetwork", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsS3Data {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsS3Data");
        debug_struct.field("bucket_name", &self.bucket_name);
        debug_struct.field("aws_access_key", &self.aws_access_key);
        debug_struct.field("path", &self.path);
        debug_struct.field("role_arn", &self.role_arn);
        debug_struct.field("cloudfront_domain", &self.cloudfront_domain);
        debug_struct.field("credentials_secret", &self.credentials_secret);
        debug_struct.field("private_network", &self.private_network);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsS3Data].
pub mod aws_s_3_data {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateNetwork {
        /// Egress bytes over a Google-managed private network.
        /// This network is shared between other users of Storage Transfer Service.
        ManagedPrivateNetwork(bool),
    }
}

/// An AzureBlobStorageData resource can be a data source, but not a data sink.
/// An AzureBlobStorageData resource represents one Azure container. The storage
/// account determines the [Azure
/// endpoint](https://docs.microsoft.com/en-us/azure/storage/common/storage-create-storage-account#storage-account-endpoints).
/// In an AzureBlobStorageData resource, a blobs's name is the [Azure Blob
/// Storage blob's key
/// name](https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata#blob-names).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureBlobStorageData {
    /// Required. The name of the Azure Storage account.
    pub storage_account: std::string::String,

    /// Required. Input only. Credentials used to authenticate API requests to
    /// Azure.
    ///
    /// For information on our data retention policy for user credentials, see
    /// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
    pub azure_credentials: std::option::Option<crate::model::AzureCredentials>,

    /// Required. The container to transfer from the Azure Storage account.
    pub container: std::string::String,

    /// Root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This field
    /// is treated as an object prefix. As such, it should generally not begin with
    /// a '/'.
    pub path: std::string::String,

    /// Optional. The Resource name of a secret in Secret Manager.
    ///
    /// The Azure SAS token must be stored in Secret Manager in JSON format:
    ///
    /// {
    /// "sas_token" : "SAS_TOKEN"
    /// }
    ///
    /// [GoogleServiceAccount][google.storagetransfer.v1.GoogleServiceAccount] must
    /// be granted `roles/secretmanager.secretAccessor` for the resource.
    ///
    /// See [Configure access to a source: Microsoft Azure Blob Storage]
    /// (<https://cloud.google.com/storage-transfer/docs/source-microsoft-azure#secret_manager>)
    /// for more information.
    ///
    /// If `credentials_secret` is specified, do not specify
    /// [azure_credentials][google.storagetransfer.v1.AzureBlobStorageData.azure_credentials].
    ///
    /// Format: `projects/{project_number}/secrets/{secret_name}`
    ///
    /// [google.storagetransfer.v1.AzureBlobStorageData.azure_credentials]: crate::model::AzureBlobStorageData::azure_credentials
    /// [google.storagetransfer.v1.GoogleServiceAccount]: crate::model::GoogleServiceAccount
    pub credentials_secret: std::string::String,

    /// Optional. Federated identity config of a user registered Azure application.
    ///
    /// If `federated_identity_config` is specified, do not specify
    /// [azure_credentials][google.storagetransfer.v1.AzureBlobStorageData.azure_credentials]
    /// or
    /// [credentials_secret][google.storagetransfer.v1.AzureBlobStorageData.credentials_secret].
    ///
    /// [google.storagetransfer.v1.AzureBlobStorageData.azure_credentials]: crate::model::AzureBlobStorageData::azure_credentials
    /// [google.storagetransfer.v1.AzureBlobStorageData.credentials_secret]: crate::model::AzureBlobStorageData::credentials_secret
    pub federated_identity_config:
        std::option::Option<crate::model::azure_blob_storage_data::FederatedIdentityConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureBlobStorageData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_account][crate::model::AzureBlobStorageData::storage_account].
    pub fn set_storage_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_account = v.into();
        self
    }

    /// Sets the value of [azure_credentials][crate::model::AzureBlobStorageData::azure_credentials].
    pub fn set_azure_credentials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureCredentials>,
    {
        self.azure_credentials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_credentials][crate::model::AzureBlobStorageData::azure_credentials].
    pub fn set_or_clear_azure_credentials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureCredentials>,
    {
        self.azure_credentials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container][crate::model::AzureBlobStorageData::container].
    pub fn set_container<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container = v.into();
        self
    }

    /// Sets the value of [path][crate::model::AzureBlobStorageData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [credentials_secret][crate::model::AzureBlobStorageData::credentials_secret].
    pub fn set_credentials_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_secret = v.into();
        self
    }

    /// Sets the value of [federated_identity_config][crate::model::AzureBlobStorageData::federated_identity_config].
    pub fn set_federated_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::azure_blob_storage_data::FederatedIdentityConfig>,
    {
        self.federated_identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [federated_identity_config][crate::model::AzureBlobStorageData::federated_identity_config].
    pub fn set_or_clear_federated_identity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::azure_blob_storage_data::FederatedIdentityConfig>,
    {
        self.federated_identity_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AzureBlobStorageData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AzureBlobStorageData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureBlobStorageData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_account,
            __azure_credentials,
            __container,
            __path,
            __credentials_secret,
            __federated_identity_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureBlobStorageData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storageAccount" => Ok(__FieldTag::__storage_account),
                            "storage_account" => Ok(__FieldTag::__storage_account),
                            "azureCredentials" => Ok(__FieldTag::__azure_credentials),
                            "azure_credentials" => Ok(__FieldTag::__azure_credentials),
                            "container" => Ok(__FieldTag::__container),
                            "path" => Ok(__FieldTag::__path),
                            "credentialsSecret" => Ok(__FieldTag::__credentials_secret),
                            "credentials_secret" => Ok(__FieldTag::__credentials_secret),
                            "federatedIdentityConfig" => {
                                Ok(__FieldTag::__federated_identity_config)
                            }
                            "federated_identity_config" => {
                                Ok(__FieldTag::__federated_identity_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureBlobStorageData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureBlobStorageData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_account => {
                            if !fields.insert(__FieldTag::__storage_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_account",
                                ));
                            }
                            result.storage_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_credentials => {
                            if !fields.insert(__FieldTag::__azure_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_credentials",
                                ));
                            }
                            result.azure_credentials = map
                                .next_value::<std::option::Option<crate::model::AzureCredentials>>(
                                )?;
                        }
                        __FieldTag::__container => {
                            if !fields.insert(__FieldTag::__container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container",
                                ));
                            }
                            result.container = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__credentials_secret => {
                            if !fields.insert(__FieldTag::__credentials_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for credentials_secret",
                                ));
                            }
                            result.credentials_secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__federated_identity_config => {
                            if !fields.insert(__FieldTag::__federated_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for federated_identity_config",
                                ));
                            }
                            result.federated_identity_config = map
                                .next_value::<std::option::Option<
                                    crate::model::azure_blob_storage_data::FederatedIdentityConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureBlobStorageData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.storage_account.is_empty() {
            state.serialize_entry("storageAccount", &self.storage_account)?;
        }
        if self.azure_credentials.is_some() {
            state.serialize_entry("azureCredentials", &self.azure_credentials)?;
        }
        if !self.container.is_empty() {
            state.serialize_entry("container", &self.container)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.credentials_secret.is_empty() {
            state.serialize_entry("credentialsSecret", &self.credentials_secret)?;
        }
        if self.federated_identity_config.is_some() {
            state.serialize_entry("federatedIdentityConfig", &self.federated_identity_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureBlobStorageData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureBlobStorageData");
        debug_struct.field("storage_account", &self.storage_account);
        debug_struct.field("azure_credentials", &self.azure_credentials);
        debug_struct.field("container", &self.container);
        debug_struct.field("path", &self.path);
        debug_struct.field("credentials_secret", &self.credentials_secret);
        debug_struct.field("federated_identity_config", &self.federated_identity_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AzureBlobStorageData].
pub mod azure_blob_storage_data {
    #[allow(unused_imports)]
    use super::*;

    /// The identity of an Azure application through which Storage Transfer Service
    /// can authenticate requests using Azure workload identity federation.
    ///
    /// Storage Transfer Service can issue requests to Azure Storage through
    /// registered Azure applications, eliminating the need to pass credentials to
    /// Storage Transfer Service directly.
    ///
    /// To configure federated identity, see
    /// [Configure access to Microsoft Azure
    /// Storage](https://cloud.google.com/storage-transfer/docs/source-microsoft-azure#option_3_authenticate_using_federated_identity).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FederatedIdentityConfig {
        /// Required. The client (application) ID of the application with federated
        /// credentials.
        pub client_id: std::string::String,

        /// Required. The tenant (directory) ID of the application with federated
        /// credentials.
        pub tenant_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FederatedIdentityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::azure_blob_storage_data::FederatedIdentityConfig::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [tenant_id][crate::model::azure_blob_storage_data::FederatedIdentityConfig::tenant_id].
        pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tenant_id = v.into();
            self
        }
    }

    impl wkt::message::Message for FederatedIdentityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storagetransfer.v1.AzureBlobStorageData.FederatedIdentityConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FederatedIdentityConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __client_id,
                __tenant_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FederatedIdentityConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clientId" => Ok(__FieldTag::__client_id),
                                "client_id" => Ok(__FieldTag::__client_id),
                                "tenantId" => Ok(__FieldTag::__tenant_id),
                                "tenant_id" => Ok(__FieldTag::__tenant_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FederatedIdentityConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FederatedIdentityConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__client_id => {
                                if !fields.insert(__FieldTag::__client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_id",
                                    ));
                                }
                                result.client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tenant_id => {
                                if !fields.insert(__FieldTag::__tenant_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tenant_id",
                                    ));
                                }
                                result.tenant_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FederatedIdentityConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.client_id.is_empty() {
                state.serialize_entry("clientId", &self.client_id)?;
            }
            if !self.tenant_id.is_empty() {
                state.serialize_entry("tenantId", &self.tenant_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FederatedIdentityConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FederatedIdentityConfig");
            debug_struct.field("client_id", &self.client_id);
            debug_struct.field("tenant_id", &self.tenant_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// An HttpData resource specifies a list of objects on the web to be
/// transferred over HTTP.  The information of the objects to be transferred is
/// contained in a file referenced by a URL. The first line in the file must be
/// `"TsvHttpData-1.0"`, which specifies the format of the file.  Subsequent
/// lines specify the information of the list of objects, one object per list
/// entry. Each entry has the following tab-delimited fields:
///
/// * **HTTP URL**  The location of the object.
///
/// * **Length**  The size of the object in bytes.
///
/// * **MD5**  The base64-encoded MD5 hash of the object.
///
///
/// For an example of a valid TSV file, see
/// [Transferring data from
/// URLs](https://cloud.google.com/storage-transfer/docs/create-url-list).
///
/// When transferring data based on a URL list, keep the following in mind:
///
/// * When an object located at `http(s)://hostname:port/<URL-path>` is
///   transferred to a data sink, the name of the object at the data sink is
///   `<hostname>/<URL-path>`.
///
/// * If the specified size of an object does not match the actual size of the
///   object fetched, the object is not transferred.
///
/// * If the specified MD5 does not match the MD5 computed from the transferred
///   bytes, the object transfer fails.
///
/// * Ensure that each URL you specify is publicly accessible. For
///   example, in Cloud Storage you can
///   [share an object publicly]
///   (/storage/docs/cloud-console#_sharingdata) and get a link to it.
///
/// * Storage Transfer Service obeys `robots.txt` rules and requires the source
///   HTTP server to support `Range` requests and to return a `Content-Length`
///   header in each response.
///
/// * [ObjectConditions][google.storagetransfer.v1.ObjectConditions] have no
///   effect when filtering objects to transfer.
///
///
/// [google.storagetransfer.v1.ObjectConditions]: crate::model::ObjectConditions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpData {
    /// Required. The URL that points to the file that stores the object list
    /// entries. This file must allow public access. The URL is either an
    /// HTTP/HTTPS address (e.g. `<https://example.com/urllist.tsv>`) or a Cloud
    /// Storage path (e.g. `gs://my-bucket/urllist.tsv`).
    pub list_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [list_url][crate::model::HttpData::list_url].
    pub fn set_list_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.list_url = v.into();
        self
    }
}

impl wkt::message::Message for HttpData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.HttpData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __list_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "listUrl" => Ok(__FieldTag::__list_url),
                            "list_url" => Ok(__FieldTag::__list_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__list_url => {
                            if !fields.insert(__FieldTag::__list_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for list_url",
                                ));
                            }
                            result.list_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.list_url.is_empty() {
            state.serialize_entry("listUrl", &self.list_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpData");
        debug_struct.field("list_url", &self.list_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A POSIX filesystem resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PosixFilesystem {
    /// Root directory path to the filesystem.
    pub root_directory: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PosixFilesystem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [root_directory][crate::model::PosixFilesystem::root_directory].
    pub fn set_root_directory<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_directory = v.into();
        self
    }
}

impl wkt::message::Message for PosixFilesystem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.PosixFilesystem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PosixFilesystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __root_directory,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PosixFilesystem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rootDirectory" => Ok(__FieldTag::__root_directory),
                            "root_directory" => Ok(__FieldTag::__root_directory),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PosixFilesystem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PosixFilesystem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__root_directory => {
                            if !fields.insert(__FieldTag::__root_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_directory",
                                ));
                            }
                            result.root_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PosixFilesystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.root_directory.is_empty() {
            state.serialize_entry("rootDirectory", &self.root_directory)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PosixFilesystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PosixFilesystem");
        debug_struct.field("root_directory", &self.root_directory);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An HdfsData resource specifies a path within an HDFS entity (e.g. a cluster).
/// All cluster-specific settings, such as namenodes and ports, are configured on
/// the transfer agents servicing requests, so HdfsData only contains the root
/// path to the data in our transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HdfsData {
    /// Root path to transfer files.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HdfsData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::HdfsData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for HdfsData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.HdfsData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HdfsData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HdfsData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HdfsData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HdfsData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HdfsData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HdfsData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HdfsData");
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An AwsS3CompatibleData resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsS3CompatibleData {
    /// Required. Specifies the name of the bucket.
    pub bucket_name: std::string::String,

    /// Specifies the root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This
    /// field is treated as an object prefix. As such, it should generally not
    /// begin with a '/'.
    pub path: std::string::String,

    /// Required. Specifies the endpoint of the storage service.
    pub endpoint: std::string::String,

    /// Specifies the region to sign requests with. This can be left blank if
    /// requests should be signed with an empty region.
    pub region: std::string::String,

    /// Specifies the metadata of the S3 compatible data provider. Each provider
    /// may contain some attributes that do not apply to all S3-compatible data
    /// providers. When not specified, S3CompatibleMetadata is used by default.
    pub data_provider: std::option::Option<crate::model::aws_s_3_compatible_data::DataProvider>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsS3CompatibleData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::AwsS3CompatibleData::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::AwsS3CompatibleData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::AwsS3CompatibleData::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [region][crate::model::AwsS3CompatibleData::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [data_provider][crate::model::AwsS3CompatibleData::data_provider].
    ///
    /// Note that all the setters affecting `data_provider` are mutually
    /// exclusive.
    pub fn set_data_provider<
        T: std::convert::Into<
                std::option::Option<crate::model::aws_s_3_compatible_data::DataProvider>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_provider = v.into();
        self
    }

    /// The value of [data_provider][crate::model::AwsS3CompatibleData::data_provider]
    /// if it holds a `S3Metadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn s3_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::S3CompatibleMetadata>> {
        #[allow(unreachable_patterns)]
        self.data_provider.as_ref().and_then(|v| match v {
            crate::model::aws_s_3_compatible_data::DataProvider::S3Metadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_provider][crate::model::AwsS3CompatibleData::data_provider]
    /// to hold a `S3Metadata`.
    ///
    /// Note that all the setters affecting `data_provider` are
    /// mutually exclusive.
    pub fn set_s3_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::S3CompatibleMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_provider = std::option::Option::Some(
            crate::model::aws_s_3_compatible_data::DataProvider::S3Metadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsS3CompatibleData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AwsS3CompatibleData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsS3CompatibleData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket_name,
            __path,
            __endpoint,
            __region,
            __s3_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsS3CompatibleData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "path" => Ok(__FieldTag::__path),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "region" => Ok(__FieldTag::__region),
                            "s3Metadata" => Ok(__FieldTag::__s3_metadata),
                            "s3_metadata" => Ok(__FieldTag::__s3_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsS3CompatibleData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsS3CompatibleData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__s3_metadata => {
                            if !fields.insert(__FieldTag::__s3_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for s3_metadata",
                                ));
                            }
                            if result.data_provider.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_provider`, a oneof with full ID .google.storagetransfer.v1.AwsS3CompatibleData.s3_metadata, latest field was s3Metadata",
                                ));
                            }
                            result.data_provider = std::option::Option::Some(
                                crate::model::aws_s_3_compatible_data::DataProvider::S3Metadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::S3CompatibleMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsS3CompatibleData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if let Some(value) = self.s3_metadata() {
            state.serialize_entry("s3Metadata", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsS3CompatibleData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsS3CompatibleData");
        debug_struct.field("bucket_name", &self.bucket_name);
        debug_struct.field("path", &self.path);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("region", &self.region);
        debug_struct.field("data_provider", &self.data_provider);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsS3CompatibleData].
pub mod aws_s_3_compatible_data {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the metadata of the S3 compatible data provider. Each provider
    /// may contain some attributes that do not apply to all S3-compatible data
    /// providers. When not specified, S3CompatibleMetadata is used by default.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataProvider {
        /// A S3 compatible metadata.
        S3Metadata(std::boxed::Box<crate::model::S3CompatibleMetadata>),
    }
}

/// S3CompatibleMetadata contains the metadata fields that apply to the basic
/// types of S3-compatible data providers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct S3CompatibleMetadata {
    /// Specifies the authentication and authorization method used by the storage
    /// service. When not specified, Transfer Service will attempt to determine
    /// right auth method to use.
    pub auth_method: crate::model::s_3_compatible_metadata::AuthMethod,

    /// Specifies the API request model used to call the storage service. When not
    /// specified, the default value of RequestModel
    /// REQUEST_MODEL_VIRTUAL_HOSTED_STYLE is used.
    pub request_model: crate::model::s_3_compatible_metadata::RequestModel,

    /// Specifies the network protocol of the agent. When not specified, the
    /// default value of NetworkProtocol NETWORK_PROTOCOL_HTTPS is used.
    pub protocol: crate::model::s_3_compatible_metadata::NetworkProtocol,

    /// The Listing API to use for discovering objects. When not specified,
    /// Transfer Service will attempt to determine the right API to use.
    pub list_api: crate::model::s_3_compatible_metadata::ListApi,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl S3CompatibleMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_method][crate::model::S3CompatibleMetadata::auth_method].
    pub fn set_auth_method<
        T: std::convert::Into<crate::model::s_3_compatible_metadata::AuthMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_method = v.into();
        self
    }

    /// Sets the value of [request_model][crate::model::S3CompatibleMetadata::request_model].
    pub fn set_request_model<
        T: std::convert::Into<crate::model::s_3_compatible_metadata::RequestModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_model = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::S3CompatibleMetadata::protocol].
    pub fn set_protocol<
        T: std::convert::Into<crate::model::s_3_compatible_metadata::NetworkProtocol>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [list_api][crate::model::S3CompatibleMetadata::list_api].
    pub fn set_list_api<T: std::convert::Into<crate::model::s_3_compatible_metadata::ListApi>>(
        mut self,
        v: T,
    ) -> Self {
        self.list_api = v.into();
        self
    }
}

impl wkt::message::Message for S3CompatibleMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.S3CompatibleMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for S3CompatibleMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auth_method,
            __request_model,
            __protocol,
            __list_api,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for S3CompatibleMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authMethod" => Ok(__FieldTag::__auth_method),
                            "auth_method" => Ok(__FieldTag::__auth_method),
                            "requestModel" => Ok(__FieldTag::__request_model),
                            "request_model" => Ok(__FieldTag::__request_model),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "listApi" => Ok(__FieldTag::__list_api),
                            "list_api" => Ok(__FieldTag::__list_api),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = S3CompatibleMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct S3CompatibleMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auth_method => {
                            if !fields.insert(__FieldTag::__auth_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auth_method",
                                ));
                            }
                            result.auth_method = map
                                .next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::AuthMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_model => {
                            if !fields.insert(__FieldTag::__request_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_model",
                                ));
                            }
                            result.request_model = map
                                .next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::RequestModel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::NetworkProtocol,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__list_api => {
                            if !fields.insert(__FieldTag::__list_api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for list_api",
                                ));
                            }
                            result.list_api =
                                map.next_value::<std::option::Option<
                                    crate::model::s_3_compatible_metadata::ListApi,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for S3CompatibleMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auth_method) {
            state.serialize_entry("authMethod", &self.auth_method)?;
        }
        if !wkt::internal::is_default(&self.request_model) {
            state.serialize_entry("requestModel", &self.request_model)?;
        }
        if !wkt::internal::is_default(&self.protocol) {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !wkt::internal::is_default(&self.list_api) {
            state.serialize_entry("listApi", &self.list_api)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for S3CompatibleMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("S3CompatibleMetadata");
        debug_struct.field("auth_method", &self.auth_method);
        debug_struct.field("request_model", &self.request_model);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("list_api", &self.list_api);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [S3CompatibleMetadata].
pub mod s_3_compatible_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The authentication and authorization method used by the storage service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthMethod {
        /// AuthMethod is not specified.
        Unspecified,
        /// Auth requests with AWS SigV4.
        AwsSignatureV4,
        /// Auth requests with AWS SigV2.
        AwsSignatureV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AuthMethod::value] or
        /// [AuthMethod::name].
        UnknownValue(auth_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod auth_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AuthMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AwsSignatureV4 => std::option::Option::Some(1),
                Self::AwsSignatureV2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTH_METHOD_UNSPECIFIED"),
                Self::AwsSignatureV4 => std::option::Option::Some("AUTH_METHOD_AWS_SIGNATURE_V4"),
                Self::AwsSignatureV2 => std::option::Option::Some("AUTH_METHOD_AWS_SIGNATURE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AuthMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AuthMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AuthMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AwsSignatureV4,
                2 => Self::AwsSignatureV2,
                _ => Self::UnknownValue(auth_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AuthMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTH_METHOD_UNSPECIFIED" => Self::Unspecified,
                "AUTH_METHOD_AWS_SIGNATURE_V4" => Self::AwsSignatureV4,
                "AUTH_METHOD_AWS_SIGNATURE_V2" => Self::AwsSignatureV2,
                _ => Self::UnknownValue(auth_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AuthMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AwsSignatureV4 => serializer.serialize_i32(1),
                Self::AwsSignatureV2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AuthMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthMethod>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.AuthMethod",
            ))
        }
    }

    /// The request model of the API.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RequestModel {
        /// RequestModel is not specified.
        Unspecified,
        /// Perform requests using Virtual Hosted Style.
        /// Example: <https://bucket-name.s3.region.amazonaws.com/key-name>
        VirtualHostedStyle,
        /// Perform requests using Path Style.
        /// Example: <https://s3.region.amazonaws.com/bucket-name/key-name>
        PathStyle,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RequestModel::value] or
        /// [RequestModel::name].
        UnknownValue(request_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod request_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RequestModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtualHostedStyle => std::option::Option::Some(1),
                Self::PathStyle => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REQUEST_MODEL_UNSPECIFIED"),
                Self::VirtualHostedStyle => {
                    std::option::Option::Some("REQUEST_MODEL_VIRTUAL_HOSTED_STYLE")
                }
                Self::PathStyle => std::option::Option::Some("REQUEST_MODEL_PATH_STYLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RequestModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RequestModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RequestModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtualHostedStyle,
                2 => Self::PathStyle,
                _ => Self::UnknownValue(request_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RequestModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REQUEST_MODEL_UNSPECIFIED" => Self::Unspecified,
                "REQUEST_MODEL_VIRTUAL_HOSTED_STYLE" => Self::VirtualHostedStyle,
                "REQUEST_MODEL_PATH_STYLE" => Self::PathStyle,
                _ => Self::UnknownValue(request_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RequestModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtualHostedStyle => serializer.serialize_i32(1),
                Self::PathStyle => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RequestModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RequestModel>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.RequestModel",
            ))
        }
    }

    /// The agent network protocol to access the storage service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkProtocol {
        /// NetworkProtocol is not specified.
        Unspecified,
        /// Perform requests using HTTPS.
        Https,
        /// Not recommended: This sends data in clear-text. This is only
        /// appropriate within a closed network or for publicly available data.
        /// Perform requests using HTTP.
        Http,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkProtocol::value] or
        /// [NetworkProtocol::name].
        UnknownValue(network_protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkProtocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Https => std::option::Option::Some(1),
                Self::Http => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NETWORK_PROTOCOL_UNSPECIFIED"),
                Self::Https => std::option::Option::Some("NETWORK_PROTOCOL_HTTPS"),
                Self::Http => std::option::Option::Some("NETWORK_PROTOCOL_HTTP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkProtocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkProtocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkProtocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Https,
                2 => Self::Http,
                _ => Self::UnknownValue(network_protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkProtocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORK_PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "NETWORK_PROTOCOL_HTTPS" => Self::Https,
                "NETWORK_PROTOCOL_HTTP" => Self::Http,
                _ => Self::UnknownValue(network_protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkProtocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Https => serializer.serialize_i32(1),
                Self::Http => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkProtocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkProtocol>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.NetworkProtocol",
            ))
        }
    }

    /// The Listing API to use for discovering objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ListApi {
        /// ListApi is not specified.
        Unspecified,
        /// Perform listing using ListObjectsV2 API.
        ListObjectsV2,
        /// Legacy ListObjects API.
        ListObjects,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ListApi::value] or
        /// [ListApi::name].
        UnknownValue(list_api::UnknownValue),
    }

    #[doc(hidden)]
    pub mod list_api {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ListApi {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ListObjectsV2 => std::option::Option::Some(1),
                Self::ListObjects => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LIST_API_UNSPECIFIED"),
                Self::ListObjectsV2 => std::option::Option::Some("LIST_OBJECTS_V2"),
                Self::ListObjects => std::option::Option::Some("LIST_OBJECTS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ListApi {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ListApi {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ListApi {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ListObjectsV2,
                2 => Self::ListObjects,
                _ => Self::UnknownValue(list_api::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ListApi {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LIST_API_UNSPECIFIED" => Self::Unspecified,
                "LIST_OBJECTS_V2" => Self::ListObjectsV2,
                "LIST_OBJECTS" => Self::ListObjects,
                _ => Self::UnknownValue(list_api::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ListApi {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ListObjectsV2 => serializer.serialize_i32(1),
                Self::ListObjects => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ListApi {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ListApi>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.ListApi",
            ))
        }
    }
}

/// Represents an agent pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AgentPool {
    /// Required. Specifies a unique string that identifies the agent pool.
    ///
    /// Format: `projects/{project_id}/agentPools/{agent_pool_id}`
    pub name: std::string::String,

    /// Specifies the client-specified AgentPool description.
    pub display_name: std::string::String,

    /// Output only. Specifies the state of the AgentPool.
    pub state: crate::model::agent_pool::State,

    /// Specifies the bandwidth limit details. If this field is unspecified, the
    /// default value is set as 'No Limit'.
    pub bandwidth_limit: std::option::Option<crate::model::agent_pool::BandwidthLimit>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AgentPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AgentPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AgentPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AgentPool::state].
    pub fn set_state<T: std::convert::Into<crate::model::agent_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [bandwidth_limit][crate::model::AgentPool::bandwidth_limit].
    pub fn set_bandwidth_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent_pool::BandwidthLimit>,
    {
        self.bandwidth_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bandwidth_limit][crate::model::AgentPool::bandwidth_limit].
    pub fn set_or_clear_bandwidth_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent_pool::BandwidthLimit>,
    {
        self.bandwidth_limit = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AgentPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AgentPool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AgentPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __bandwidth_limit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "bandwidthLimit" => Ok(__FieldTag::__bandwidth_limit),
                            "bandwidth_limit" => Ok(__FieldTag::__bandwidth_limit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AgentPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::agent_pool::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bandwidth_limit => {
                            if !fields.insert(__FieldTag::__bandwidth_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bandwidth_limit",
                                ));
                            }
                            result.bandwidth_limit = map.next_value::<std::option::Option<crate::model::agent_pool::BandwidthLimit>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AgentPool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.bandwidth_limit.is_some() {
            state.serialize_entry("bandwidthLimit", &self.bandwidth_limit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AgentPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AgentPool");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("bandwidth_limit", &self.bandwidth_limit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AgentPool].
pub mod agent_pool {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies a bandwidth limit for an agent pool.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BandwidthLimit {
        /// Bandwidth rate in megabytes per second, distributed across all the agents
        /// in the pool.
        pub limit_mbps: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BandwidthLimit {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [limit_mbps][crate::model::agent_pool::BandwidthLimit::limit_mbps].
        pub fn set_limit_mbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.limit_mbps = v.into();
            self
        }
    }

    impl wkt::message::Message for BandwidthLimit {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storagetransfer.v1.AgentPool.BandwidthLimit"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BandwidthLimit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __limit_mbps,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BandwidthLimit")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "limitMbps" => Ok(__FieldTag::__limit_mbps),
                                "limit_mbps" => Ok(__FieldTag::__limit_mbps),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BandwidthLimit;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BandwidthLimit")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__limit_mbps => {
                                if !fields.insert(__FieldTag::__limit_mbps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for limit_mbps",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.limit_mbps =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BandwidthLimit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.limit_mbps) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("limitMbps", &__With(&self.limit_mbps))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BandwidthLimit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BandwidthLimit");
            debug_struct.field("limit_mbps", &self.limit_mbps);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The state of an AgentPool.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// This is an initialization state. During this stage, resources are
        /// allocated for the AgentPool.
        Creating,
        /// Determines that the AgentPool is created for use. At this state, Agents
        /// can join the AgentPool and participate in the transfer jobs in that pool.
        Created,
        /// Determines that the AgentPool deletion has been initiated, and all the
        /// resources are scheduled to be cleaned up and freed.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Created => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Created,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "CREATED" => Self::Created,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Created => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.storagetransfer.v1.AgentPool.State",
            ))
        }
    }
}

/// TransferOptions define the actions to be performed on objects in a transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferOptions {
    /// When to overwrite objects that already exist in the sink. The default is
    /// that only objects that are different from the source are overwritten. If
    /// true, all objects in the sink whose name matches an object in the source
    /// are overwritten with the source object.
    pub overwrite_objects_already_existing_in_sink: bool,

    /// Whether objects that exist only in the sink should be deleted.
    ///
    /// **Note:** This option and
    /// [delete_objects_from_source_after_transfer][google.storagetransfer.v1.TransferOptions.delete_objects_from_source_after_transfer]
    /// are mutually exclusive.
    ///
    /// [google.storagetransfer.v1.TransferOptions.delete_objects_from_source_after_transfer]: crate::model::TransferOptions::delete_objects_from_source_after_transfer
    pub delete_objects_unique_in_sink: bool,

    /// Whether objects should be deleted from the source after they are
    /// transferred to the sink.
    ///
    /// **Note:** This option and
    /// [delete_objects_unique_in_sink][google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]
    /// are mutually exclusive.
    ///
    /// [google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]: crate::model::TransferOptions::delete_objects_unique_in_sink
    pub delete_objects_from_source_after_transfer: bool,

    /// When to overwrite objects that already exist in the sink. If not set,
    /// overwrite behavior is determined by
    /// [overwrite_objects_already_existing_in_sink][google.storagetransfer.v1.TransferOptions.overwrite_objects_already_existing_in_sink].
    ///
    /// [google.storagetransfer.v1.TransferOptions.overwrite_objects_already_existing_in_sink]: crate::model::TransferOptions::overwrite_objects_already_existing_in_sink
    pub overwrite_when: crate::model::transfer_options::OverwriteWhen,

    /// Represents the selected metadata options for a transfer job.
    pub metadata_options: std::option::Option<crate::model::MetadataOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overwrite_objects_already_existing_in_sink][crate::model::TransferOptions::overwrite_objects_already_existing_in_sink].
    pub fn set_overwrite_objects_already_existing_in_sink<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.overwrite_objects_already_existing_in_sink = v.into();
        self
    }

    /// Sets the value of [delete_objects_unique_in_sink][crate::model::TransferOptions::delete_objects_unique_in_sink].
    pub fn set_delete_objects_unique_in_sink<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.delete_objects_unique_in_sink = v.into();
        self
    }

    /// Sets the value of [delete_objects_from_source_after_transfer][crate::model::TransferOptions::delete_objects_from_source_after_transfer].
    pub fn set_delete_objects_from_source_after_transfer<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_objects_from_source_after_transfer = v.into();
        self
    }

    /// Sets the value of [overwrite_when][crate::model::TransferOptions::overwrite_when].
    pub fn set_overwrite_when<
        T: std::convert::Into<crate::model::transfer_options::OverwriteWhen>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overwrite_when = v.into();
        self
    }

    /// Sets the value of [metadata_options][crate::model::TransferOptions::metadata_options].
    pub fn set_metadata_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MetadataOptions>,
    {
        self.metadata_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata_options][crate::model::TransferOptions::metadata_options].
    pub fn set_or_clear_metadata_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MetadataOptions>,
    {
        self.metadata_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransferOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __overwrite_objects_already_existing_in_sink,
            __delete_objects_unique_in_sink,
            __delete_objects_from_source_after_transfer,
            __overwrite_when,
            __metadata_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "overwriteObjectsAlreadyExistingInSink" => {
                                Ok(__FieldTag::__overwrite_objects_already_existing_in_sink)
                            }
                            "overwrite_objects_already_existing_in_sink" => {
                                Ok(__FieldTag::__overwrite_objects_already_existing_in_sink)
                            }
                            "deleteObjectsUniqueInSink" => {
                                Ok(__FieldTag::__delete_objects_unique_in_sink)
                            }
                            "delete_objects_unique_in_sink" => {
                                Ok(__FieldTag::__delete_objects_unique_in_sink)
                            }
                            "deleteObjectsFromSourceAfterTransfer" => {
                                Ok(__FieldTag::__delete_objects_from_source_after_transfer)
                            }
                            "delete_objects_from_source_after_transfer" => {
                                Ok(__FieldTag::__delete_objects_from_source_after_transfer)
                            }
                            "overwriteWhen" => Ok(__FieldTag::__overwrite_when),
                            "overwrite_when" => Ok(__FieldTag::__overwrite_when),
                            "metadataOptions" => Ok(__FieldTag::__metadata_options),
                            "metadata_options" => Ok(__FieldTag::__metadata_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__overwrite_objects_already_existing_in_sink => {
                            if !fields
                                .insert(__FieldTag::__overwrite_objects_already_existing_in_sink)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overwrite_objects_already_existing_in_sink",
                                ));
                            }
                            result.overwrite_objects_already_existing_in_sink = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_objects_unique_in_sink => {
                            if !fields.insert(__FieldTag::__delete_objects_unique_in_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_objects_unique_in_sink",
                                ));
                            }
                            result.delete_objects_unique_in_sink = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_objects_from_source_after_transfer => {
                            if !fields
                                .insert(__FieldTag::__delete_objects_from_source_after_transfer)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_objects_from_source_after_transfer",
                                ));
                            }
                            result.delete_objects_from_source_after_transfer = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__overwrite_when => {
                            if !fields.insert(__FieldTag::__overwrite_when) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overwrite_when",
                                ));
                            }
                            result.overwrite_when =
                                map.next_value::<std::option::Option<
                                    crate::model::transfer_options::OverwriteWhen,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata_options => {
                            if !fields.insert(__FieldTag::__metadata_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_options",
                                ));
                            }
                            result.metadata_options = map
                                .next_value::<std::option::Option<crate::model::MetadataOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.overwrite_objects_already_existing_in_sink) {
            state.serialize_entry(
                "overwriteObjectsAlreadyExistingInSink",
                &self.overwrite_objects_already_existing_in_sink,
            )?;
        }
        if !wkt::internal::is_default(&self.delete_objects_unique_in_sink) {
            state.serialize_entry(
                "deleteObjectsUniqueInSink",
                &self.delete_objects_unique_in_sink,
            )?;
        }
        if !wkt::internal::is_default(&self.delete_objects_from_source_after_transfer) {
            state.serialize_entry(
                "deleteObjectsFromSourceAfterTransfer",
                &self.delete_objects_from_source_after_transfer,
            )?;
        }
        if !wkt::internal::is_default(&self.overwrite_when) {
            state.serialize_entry("overwriteWhen", &self.overwrite_when)?;
        }
        if self.metadata_options.is_some() {
            state.serialize_entry("metadataOptions", &self.metadata_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferOptions");
        debug_struct.field(
            "overwrite_objects_already_existing_in_sink",
            &self.overwrite_objects_already_existing_in_sink,
        );
        debug_struct.field(
            "delete_objects_unique_in_sink",
            &self.delete_objects_unique_in_sink,
        );
        debug_struct.field(
            "delete_objects_from_source_after_transfer",
            &self.delete_objects_from_source_after_transfer,
        );
        debug_struct.field("overwrite_when", &self.overwrite_when);
        debug_struct.field("metadata_options", &self.metadata_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferOptions].
pub mod transfer_options {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies when to overwrite an object in the sink when an object with
    /// matching name is found in the source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OverwriteWhen {
        /// Overwrite behavior is unspecified.
        Unspecified,
        /// Overwrites destination objects with the source objects, only if the
        /// objects have the same name but different HTTP ETags or checksum values.
        Different,
        /// Never overwrites a destination object if a source object has the
        /// same name. In this case, the source object is not transferred.
        Never,
        /// Always overwrite the destination object with the source object, even if
        /// the HTTP Etags or checksum values are the same.
        Always,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OverwriteWhen::value] or
        /// [OverwriteWhen::name].
        UnknownValue(overwrite_when::UnknownValue),
    }

    #[doc(hidden)]
    pub mod overwrite_when {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OverwriteWhen {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Different => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::Always => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OVERWRITE_WHEN_UNSPECIFIED"),
                Self::Different => std::option::Option::Some("DIFFERENT"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OverwriteWhen {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OverwriteWhen {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OverwriteWhen {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Different,
                2 => Self::Never,
                3 => Self::Always,
                _ => Self::UnknownValue(overwrite_when::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OverwriteWhen {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OVERWRITE_WHEN_UNSPECIFIED" => Self::Unspecified,
                "DIFFERENT" => Self::Different,
                "NEVER" => Self::Never,
                "ALWAYS" => Self::Always,
                _ => Self::UnknownValue(overwrite_when::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OverwriteWhen {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Different => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::Always => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OverwriteWhen {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OverwriteWhen>::new(
                ".google.storagetransfer.v1.TransferOptions.OverwriteWhen",
            ))
        }
    }
}

/// Configuration for running a transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferSpec {
    /// Only objects that satisfy these object conditions are included in the set
    /// of data source and data sink objects.  Object conditions based on
    /// objects' "last modification time" do not exclude objects in a data sink.
    pub object_conditions: std::option::Option<crate::model::ObjectConditions>,

    /// If the option
    /// [delete_objects_unique_in_sink][google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]
    /// is `true` and time-based object conditions such as 'last modification time'
    /// are specified, the request fails with an
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]: crate::model::TransferOptions::delete_objects_unique_in_sink
    pub transfer_options: std::option::Option<crate::model::TransferOptions>,

    /// A manifest file provides a list of objects to be transferred from the data
    /// source. This field points to the location of the manifest file.
    /// Otherwise, the entire source bucket is used. ObjectConditions still apply.
    pub transfer_manifest: std::option::Option<crate::model::TransferManifest>,

    /// Specifies the agent pool name associated with the posix data source. When
    /// unspecified, the default name is used.
    pub source_agent_pool_name: std::string::String,

    /// Specifies the agent pool name associated with the posix data sink. When
    /// unspecified, the default name is used.
    pub sink_agent_pool_name: std::string::String,

    /// The write sink for the data.
    pub data_sink: std::option::Option<crate::model::transfer_spec::DataSink>,

    /// The read source of the data.
    pub data_source: std::option::Option<crate::model::transfer_spec::DataSource>,

    pub intermediate_data_location:
        std::option::Option<crate::model::transfer_spec::IntermediateDataLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_conditions][crate::model::TransferSpec::object_conditions].
    pub fn set_object_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_conditions][crate::model::TransferSpec::object_conditions].
    pub fn set_or_clear_object_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_options][crate::model::TransferSpec::transfer_options].
    pub fn set_transfer_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_options][crate::model::TransferSpec::transfer_options].
    pub fn set_or_clear_transfer_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_manifest][crate::model::TransferSpec::transfer_manifest].
    pub fn set_transfer_manifest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferManifest>,
    {
        self.transfer_manifest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_manifest][crate::model::TransferSpec::transfer_manifest].
    pub fn set_or_clear_transfer_manifest<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferManifest>,
    {
        self.transfer_manifest = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_agent_pool_name][crate::model::TransferSpec::source_agent_pool_name].
    pub fn set_source_agent_pool_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_agent_pool_name = v.into();
        self
    }

    /// Sets the value of [sink_agent_pool_name][crate::model::TransferSpec::sink_agent_pool_name].
    pub fn set_sink_agent_pool_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sink_agent_pool_name = v.into();
        self
    }

    /// Sets the value of [data_sink][crate::model::TransferSpec::data_sink].
    ///
    /// Note that all the setters affecting `data_sink` are mutually
    /// exclusive.
    pub fn set_data_sink<
        T: std::convert::Into<std::option::Option<crate::model::transfer_spec::DataSink>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = v.into();
        self
    }

    /// The value of [data_sink][crate::model::TransferSpec::data_sink]
    /// if it holds a `GcsDataSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_sink(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_sink.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSink::GcsDataSink(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_sink][crate::model::TransferSpec::data_sink]
    /// to hold a `GcsDataSink`.
    ///
    /// Note that all the setters affecting `data_sink` are
    /// mutually exclusive.
    pub fn set_gcs_data_sink<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink =
            std::option::Option::Some(crate::model::transfer_spec::DataSink::GcsDataSink(v.into()));
        self
    }

    /// The value of [data_sink][crate::model::TransferSpec::data_sink]
    /// if it holds a `PosixDataSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn posix_data_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PosixFilesystem>> {
        #[allow(unreachable_patterns)]
        self.data_sink.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSink::PosixDataSink(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_sink][crate::model::TransferSpec::data_sink]
    /// to hold a `PosixDataSink`.
    ///
    /// Note that all the setters affecting `data_sink` are
    /// mutually exclusive.
    pub fn set_posix_data_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::PosixFilesystem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = std::option::Option::Some(
            crate::model::transfer_spec::DataSink::PosixDataSink(v.into()),
        );
        self
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source].
    ///
    /// Note that all the setters affecting `data_source` are mutually
    /// exclusive.
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::transfer_spec::DataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `GcsDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::GcsDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `GcsDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_gcs_data_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::GcsDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `AwsS3DataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_s3_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsS3Data>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::AwsS3DataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `AwsS3DataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_aws_s3_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsS3Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::AwsS3DataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `HttpDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::HttpDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `HttpDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_http_data_source<T: std::convert::Into<std::boxed::Box<crate::model::HttpData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::HttpDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `PosixDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn posix_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PosixFilesystem>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::PosixDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `PosixDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_posix_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::PosixFilesystem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::PosixDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `AzureBlobStorageDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_blob_storage_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureBlobStorageData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::AzureBlobStorageDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `AzureBlobStorageDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_azure_blob_storage_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureBlobStorageData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::AzureBlobStorageDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `AwsS3CompatibleDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_s3_compatible_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsS3CompatibleData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::AwsS3CompatibleDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `AwsS3CompatibleDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_aws_s3_compatible_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsS3CompatibleData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::AwsS3CompatibleDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `HdfsDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hdfs_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HdfsData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::HdfsDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `HdfsDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_hdfs_data_source<T: std::convert::Into<std::boxed::Box<crate::model::HdfsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::HdfsDataSource(v.into()),
        );
        self
    }

    /// Sets the value of [intermediate_data_location][crate::model::TransferSpec::intermediate_data_location].
    ///
    /// Note that all the setters affecting `intermediate_data_location` are mutually
    /// exclusive.
    pub fn set_intermediate_data_location<
        T: std::convert::Into<
                std::option::Option<crate::model::transfer_spec::IntermediateDataLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intermediate_data_location = v.into();
        self
    }

    /// The value of [intermediate_data_location][crate::model::TransferSpec::intermediate_data_location]
    /// if it holds a `GcsIntermediateDataLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_intermediate_data_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.intermediate_data_location.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::IntermediateDataLocation::GcsIntermediateDataLocation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intermediate_data_location][crate::model::TransferSpec::intermediate_data_location]
    /// to hold a `GcsIntermediateDataLocation`.
    ///
    /// Note that all the setters affecting `intermediate_data_location` are
    /// mutually exclusive.
    pub fn set_gcs_intermediate_data_location<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intermediate_data_location = std::option::Option::Some(
            crate::model::transfer_spec::IntermediateDataLocation::GcsIntermediateDataLocation(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TransferSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_data_sink,
            __posix_data_sink,
            __gcs_data_source,
            __aws_s3_data_source,
            __http_data_source,
            __posix_data_source,
            __azure_blob_storage_data_source,
            __aws_s3_compatible_data_source,
            __hdfs_data_source,
            __gcs_intermediate_data_location,
            __object_conditions,
            __transfer_options,
            __transfer_manifest,
            __source_agent_pool_name,
            __sink_agent_pool_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDataSink" => Ok(__FieldTag::__gcs_data_sink),
                            "gcs_data_sink" => Ok(__FieldTag::__gcs_data_sink),
                            "posixDataSink" => Ok(__FieldTag::__posix_data_sink),
                            "posix_data_sink" => Ok(__FieldTag::__posix_data_sink),
                            "gcsDataSource" => Ok(__FieldTag::__gcs_data_source),
                            "gcs_data_source" => Ok(__FieldTag::__gcs_data_source),
                            "awsS3DataSource" => Ok(__FieldTag::__aws_s3_data_source),
                            "aws_s3_data_source" => Ok(__FieldTag::__aws_s3_data_source),
                            "httpDataSource" => Ok(__FieldTag::__http_data_source),
                            "http_data_source" => Ok(__FieldTag::__http_data_source),
                            "posixDataSource" => Ok(__FieldTag::__posix_data_source),
                            "posix_data_source" => Ok(__FieldTag::__posix_data_source),
                            "azureBlobStorageDataSource" => {
                                Ok(__FieldTag::__azure_blob_storage_data_source)
                            }
                            "azure_blob_storage_data_source" => {
                                Ok(__FieldTag::__azure_blob_storage_data_source)
                            }
                            "awsS3CompatibleDataSource" => {
                                Ok(__FieldTag::__aws_s3_compatible_data_source)
                            }
                            "aws_s3_compatible_data_source" => {
                                Ok(__FieldTag::__aws_s3_compatible_data_source)
                            }
                            "hdfsDataSource" => Ok(__FieldTag::__hdfs_data_source),
                            "hdfs_data_source" => Ok(__FieldTag::__hdfs_data_source),
                            "gcsIntermediateDataLocation" => {
                                Ok(__FieldTag::__gcs_intermediate_data_location)
                            }
                            "gcs_intermediate_data_location" => {
                                Ok(__FieldTag::__gcs_intermediate_data_location)
                            }
                            "objectConditions" => Ok(__FieldTag::__object_conditions),
                            "object_conditions" => Ok(__FieldTag::__object_conditions),
                            "transferOptions" => Ok(__FieldTag::__transfer_options),
                            "transfer_options" => Ok(__FieldTag::__transfer_options),
                            "transferManifest" => Ok(__FieldTag::__transfer_manifest),
                            "transfer_manifest" => Ok(__FieldTag::__transfer_manifest),
                            "sourceAgentPoolName" => Ok(__FieldTag::__source_agent_pool_name),
                            "source_agent_pool_name" => Ok(__FieldTag::__source_agent_pool_name),
                            "sinkAgentPoolName" => Ok(__FieldTag::__sink_agent_pool_name),
                            "sink_agent_pool_name" => Ok(__FieldTag::__sink_agent_pool_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_data_sink => {
                            if !fields.insert(__FieldTag::__gcs_data_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_sink",
                                ));
                            }
                            if result.data_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_sink`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.gcs_data_sink, latest field was gcsDataSink",
                                ));
                            }
                            result.data_sink =
                                std::option::Option::Some(
                                    crate::model::transfer_spec::DataSink::GcsDataSink(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__posix_data_sink => {
                            if !fields.insert(__FieldTag::__posix_data_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posix_data_sink",
                                ));
                            }
                            if result.data_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_sink`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.posix_data_sink, latest field was posixDataSink",
                                ));
                            }
                            result.data_sink = std::option::Option::Some(
                                crate::model::transfer_spec::DataSink::PosixDataSink(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PosixFilesystem>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_data_source => {
                            if !fields.insert(__FieldTag::__gcs_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.gcs_data_source, latest field was gcsDataSource",
                                ));
                            }
                            result.data_source =
                                std::option::Option::Some(
                                    crate::model::transfer_spec::DataSource::GcsDataSource(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__aws_s3_data_source => {
                            if !fields.insert(__FieldTag::__aws_s3_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_s3_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.aws_s3_data_source, latest field was awsS3DataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::AwsS3DataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsS3Data>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__http_data_source => {
                            if !fields.insert(__FieldTag::__http_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.http_data_source, latest field was httpDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::HttpDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__posix_data_source => {
                            if !fields.insert(__FieldTag::__posix_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posix_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.posix_data_source, latest field was posixDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::PosixDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PosixFilesystem>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_blob_storage_data_source => {
                            if !fields.insert(__FieldTag::__azure_blob_storage_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_blob_storage_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.azure_blob_storage_data_source, latest field was azureBlobStorageDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::AzureBlobStorageDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureBlobStorageData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_s3_compatible_data_source => {
                            if !fields.insert(__FieldTag::__aws_s3_compatible_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_s3_compatible_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.aws_s3_compatible_data_source, latest field was awsS3CompatibleDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::AwsS3CompatibleDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsS3CompatibleData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__hdfs_data_source => {
                            if !fields.insert(__FieldTag::__hdfs_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hdfs_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.hdfs_data_source, latest field was hdfsDataSource",
                                ));
                            }
                            result.data_source = std::option::Option::Some(
                                crate::model::transfer_spec::DataSource::HdfsDataSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HdfsData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_intermediate_data_location => {
                            if !fields.insert(__FieldTag::__gcs_intermediate_data_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_intermediate_data_location",
                                ));
                            }
                            if result.intermediate_data_location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intermediate_data_location`, a oneof with full ID .google.storagetransfer.v1.TransferSpec.gcs_intermediate_data_location, latest field was gcsIntermediateDataLocation",
                                ));
                            }
                            result.intermediate_data_location = std::option::Option::Some(
                                crate::model::transfer_spec::IntermediateDataLocation::GcsIntermediateDataLocation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsData>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__object_conditions => {
                            if !fields.insert(__FieldTag::__object_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_conditions",
                                ));
                            }
                            result.object_conditions = map
                                .next_value::<std::option::Option<crate::model::ObjectConditions>>(
                                )?;
                        }
                        __FieldTag::__transfer_options => {
                            if !fields.insert(__FieldTag::__transfer_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_options",
                                ));
                            }
                            result.transfer_options = map
                                .next_value::<std::option::Option<crate::model::TransferOptions>>(
                                )?;
                        }
                        __FieldTag::__transfer_manifest => {
                            if !fields.insert(__FieldTag::__transfer_manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_manifest",
                                ));
                            }
                            result.transfer_manifest = map
                                .next_value::<std::option::Option<crate::model::TransferManifest>>(
                                )?;
                        }
                        __FieldTag::__source_agent_pool_name => {
                            if !fields.insert(__FieldTag::__source_agent_pool_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_agent_pool_name",
                                ));
                            }
                            result.source_agent_pool_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sink_agent_pool_name => {
                            if !fields.insert(__FieldTag::__sink_agent_pool_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink_agent_pool_name",
                                ));
                            }
                            result.sink_agent_pool_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_data_sink() {
            state.serialize_entry("gcsDataSink", value)?;
        }
        if let Some(value) = self.posix_data_sink() {
            state.serialize_entry("posixDataSink", value)?;
        }
        if let Some(value) = self.gcs_data_source() {
            state.serialize_entry("gcsDataSource", value)?;
        }
        if let Some(value) = self.aws_s3_data_source() {
            state.serialize_entry("awsS3DataSource", value)?;
        }
        if let Some(value) = self.http_data_source() {
            state.serialize_entry("httpDataSource", value)?;
        }
        if let Some(value) = self.posix_data_source() {
            state.serialize_entry("posixDataSource", value)?;
        }
        if let Some(value) = self.azure_blob_storage_data_source() {
            state.serialize_entry("azureBlobStorageDataSource", value)?;
        }
        if let Some(value) = self.aws_s3_compatible_data_source() {
            state.serialize_entry("awsS3CompatibleDataSource", value)?;
        }
        if let Some(value) = self.hdfs_data_source() {
            state.serialize_entry("hdfsDataSource", value)?;
        }
        if let Some(value) = self.gcs_intermediate_data_location() {
            state.serialize_entry("gcsIntermediateDataLocation", value)?;
        }
        if self.object_conditions.is_some() {
            state.serialize_entry("objectConditions", &self.object_conditions)?;
        }
        if self.transfer_options.is_some() {
            state.serialize_entry("transferOptions", &self.transfer_options)?;
        }
        if self.transfer_manifest.is_some() {
            state.serialize_entry("transferManifest", &self.transfer_manifest)?;
        }
        if !self.source_agent_pool_name.is_empty() {
            state.serialize_entry("sourceAgentPoolName", &self.source_agent_pool_name)?;
        }
        if !self.sink_agent_pool_name.is_empty() {
            state.serialize_entry("sinkAgentPoolName", &self.sink_agent_pool_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferSpec");
        debug_struct.field("object_conditions", &self.object_conditions);
        debug_struct.field("transfer_options", &self.transfer_options);
        debug_struct.field("transfer_manifest", &self.transfer_manifest);
        debug_struct.field("source_agent_pool_name", &self.source_agent_pool_name);
        debug_struct.field("sink_agent_pool_name", &self.sink_agent_pool_name);
        debug_struct.field("data_sink", &self.data_sink);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field(
            "intermediate_data_location",
            &self.intermediate_data_location,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferSpec].
pub mod transfer_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The write sink for the data.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSink {
        /// A Cloud Storage data sink.
        GcsDataSink(std::boxed::Box<crate::model::GcsData>),
        /// A POSIX Filesystem data sink.
        PosixDataSink(std::boxed::Box<crate::model::PosixFilesystem>),
    }

    /// The read source of the data.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSource {
        /// A Cloud Storage data source.
        GcsDataSource(std::boxed::Box<crate::model::GcsData>),
        /// An AWS S3 data source.
        AwsS3DataSource(std::boxed::Box<crate::model::AwsS3Data>),
        /// An HTTP URL data source.
        HttpDataSource(std::boxed::Box<crate::model::HttpData>),
        /// A POSIX Filesystem data source.
        PosixDataSource(std::boxed::Box<crate::model::PosixFilesystem>),
        /// An Azure Blob Storage data source.
        AzureBlobStorageDataSource(std::boxed::Box<crate::model::AzureBlobStorageData>),
        /// An AWS S3 compatible data source.
        AwsS3CompatibleDataSource(std::boxed::Box<crate::model::AwsS3CompatibleData>),
        /// An HDFS cluster data source.
        HdfsDataSource(std::boxed::Box<crate::model::HdfsData>),
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IntermediateDataLocation {
        /// For transfers between file systems, specifies a Cloud Storage bucket
        /// to be used as an intermediate location through which to transfer data.
        ///
        /// See [Transfer data between file
        /// systems](https://cloud.google.com/storage-transfer/docs/file-to-file) for
        /// more information.
        GcsIntermediateDataLocation(std::boxed::Box<crate::model::GcsData>),
    }
}

/// Specifies the configuration for a cross-bucket replication job. Cross-bucket
/// replication copies new or updated objects from a source Cloud Storage bucket
/// to a destination Cloud Storage bucket. Existing objects in the source bucket
/// are not copied by a new cross-bucket replication job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationSpec {
    /// Object conditions that determine which objects are transferred. For
    /// replication jobs, only `include_prefixes` and `exclude_prefixes` are
    /// supported.
    pub object_conditions: std::option::Option<crate::model::ObjectConditions>,

    /// Specifies the metadata options to be applied during replication.
    /// Delete options are not supported. If a delete option is specified, the
    /// request fails with an [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]
    /// error.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    pub transfer_options: std::option::Option<crate::model::TransferOptions>,

    /// The data source to be replicated.
    pub data_source: std::option::Option<crate::model::replication_spec::DataSource>,

    /// The destination for replicated objects.
    pub data_sink: std::option::Option<crate::model::replication_spec::DataSink>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_conditions][crate::model::ReplicationSpec::object_conditions].
    pub fn set_object_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_conditions][crate::model::ReplicationSpec::object_conditions].
    pub fn set_or_clear_object_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_options][crate::model::ReplicationSpec::transfer_options].
    pub fn set_transfer_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_options][crate::model::ReplicationSpec::transfer_options].
    pub fn set_or_clear_transfer_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_source][crate::model::ReplicationSpec::data_source].
    ///
    /// Note that all the setters affecting `data_source` are mutually
    /// exclusive.
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::replication_spec::DataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::ReplicationSpec::data_source]
    /// if it holds a `GcsDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::replication_spec::DataSource::GcsDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::ReplicationSpec::data_source]
    /// to hold a `GcsDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_gcs_data_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::replication_spec::DataSource::GcsDataSource(v.into()),
        );
        self
    }

    /// Sets the value of [data_sink][crate::model::ReplicationSpec::data_sink].
    ///
    /// Note that all the setters affecting `data_sink` are mutually
    /// exclusive.
    pub fn set_data_sink<
        T: std::convert::Into<std::option::Option<crate::model::replication_spec::DataSink>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = v.into();
        self
    }

    /// The value of [data_sink][crate::model::ReplicationSpec::data_sink]
    /// if it holds a `GcsDataSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_sink(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_sink.as_ref().and_then(|v| match v {
            crate::model::replication_spec::DataSink::GcsDataSink(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_sink][crate::model::ReplicationSpec::data_sink]
    /// to hold a `GcsDataSink`.
    ///
    /// Note that all the setters affecting `data_sink` are
    /// mutually exclusive.
    pub fn set_gcs_data_sink<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = std::option::Option::Some(
            crate::model::replication_spec::DataSink::GcsDataSink(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplicationSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ReplicationSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_data_source,
            __gcs_data_sink,
            __object_conditions,
            __transfer_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDataSource" => Ok(__FieldTag::__gcs_data_source),
                            "gcs_data_source" => Ok(__FieldTag::__gcs_data_source),
                            "gcsDataSink" => Ok(__FieldTag::__gcs_data_sink),
                            "gcs_data_sink" => Ok(__FieldTag::__gcs_data_sink),
                            "objectConditions" => Ok(__FieldTag::__object_conditions),
                            "object_conditions" => Ok(__FieldTag::__object_conditions),
                            "transferOptions" => Ok(__FieldTag::__transfer_options),
                            "transfer_options" => Ok(__FieldTag::__transfer_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_data_source => {
                            if !fields.insert(__FieldTag::__gcs_data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_source",
                                ));
                            }
                            if result.data_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_source`, a oneof with full ID .google.storagetransfer.v1.ReplicationSpec.gcs_data_source, latest field was gcsDataSource",
                                ));
                            }
                            result.data_source =
                                std::option::Option::Some(
                                    crate::model::replication_spec::DataSource::GcsDataSource(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__gcs_data_sink => {
                            if !fields.insert(__FieldTag::__gcs_data_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_data_sink",
                                ));
                            }
                            if result.data_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_sink`, a oneof with full ID .google.storagetransfer.v1.ReplicationSpec.gcs_data_sink, latest field was gcsDataSink",
                                ));
                            }
                            result.data_sink =
                                std::option::Option::Some(
                                    crate::model::replication_spec::DataSink::GcsDataSink(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::GcsData>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__object_conditions => {
                            if !fields.insert(__FieldTag::__object_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_conditions",
                                ));
                            }
                            result.object_conditions = map
                                .next_value::<std::option::Option<crate::model::ObjectConditions>>(
                                )?;
                        }
                        __FieldTag::__transfer_options => {
                            if !fields.insert(__FieldTag::__transfer_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_options",
                                ));
                            }
                            result.transfer_options = map
                                .next_value::<std::option::Option<crate::model::TransferOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_data_source() {
            state.serialize_entry("gcsDataSource", value)?;
        }
        if let Some(value) = self.gcs_data_sink() {
            state.serialize_entry("gcsDataSink", value)?;
        }
        if self.object_conditions.is_some() {
            state.serialize_entry("objectConditions", &self.object_conditions)?;
        }
        if self.transfer_options.is_some() {
            state.serialize_entry("transferOptions", &self.transfer_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicationSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationSpec");
        debug_struct.field("object_conditions", &self.object_conditions);
        debug_struct.field("transfer_options", &self.transfer_options);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field("data_sink", &self.data_sink);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReplicationSpec].
pub mod replication_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The data source to be replicated.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSource {
        /// The Cloud Storage bucket from which to replicate objects.
        GcsDataSource(std::boxed::Box<crate::model::GcsData>),
    }

    /// The destination for replicated objects.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSink {
        /// The Cloud Storage bucket to which to replicate objects.
        GcsDataSink(std::boxed::Box<crate::model::GcsData>),
    }
}

/// Specifies the metadata options for running a transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MetadataOptions {
    /// Specifies how symlinks should be handled by the transfer. By default,
    /// symlinks are not preserved. Only applicable to transfers involving
    /// POSIX file systems, and ignored for other transfers.
    pub symlink: crate::model::metadata_options::Symlink,

    /// Specifies how each file's mode attribute should be handled by the transfer.
    /// By default, mode is not preserved. Only applicable to transfers involving
    /// POSIX file systems, and ignored for other transfers.
    pub mode: crate::model::metadata_options::Mode,

    /// Specifies how each file's POSIX group ID (GID) attribute should be handled
    /// by the transfer. By default, GID is not preserved. Only applicable to
    /// transfers involving POSIX file systems, and ignored for other transfers.
    pub gid: crate::model::metadata_options::Gid,

    /// Specifies how each file's POSIX user ID (UID) attribute should be handled
    /// by the transfer. By default, UID is not preserved. Only applicable to
    /// transfers involving POSIX file systems, and ignored for other transfers.
    pub uid: crate::model::metadata_options::Uid,

    /// Specifies how each object's ACLs should be preserved for transfers between
    /// Google Cloud Storage buckets. If unspecified, the default behavior is the
    /// same as ACL_DESTINATION_BUCKET_DEFAULT.
    pub acl: crate::model::metadata_options::Acl,

    /// Specifies the storage class to set on objects being transferred to Google
    /// Cloud Storage buckets.  If unspecified, the default behavior is the same as
    /// [STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT][google.storagetransfer.v1.MetadataOptions.StorageClass.STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT].
    ///
    /// [google.storagetransfer.v1.MetadataOptions.StorageClass.STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT]: crate::model::metadata_options::StorageClass::DestinationBucketDefault
    pub storage_class: crate::model::metadata_options::StorageClass,

    /// Specifies how each object's temporary hold status should be preserved for
    /// transfers between Google Cloud Storage buckets.  If unspecified, the
    /// default behavior is the same as
    /// [TEMPORARY_HOLD_PRESERVE][google.storagetransfer.v1.MetadataOptions.TemporaryHold.TEMPORARY_HOLD_PRESERVE].
    ///
    /// [google.storagetransfer.v1.MetadataOptions.TemporaryHold.TEMPORARY_HOLD_PRESERVE]: crate::model::metadata_options::TemporaryHold::Preserve
    pub temporary_hold: crate::model::metadata_options::TemporaryHold,

    /// Specifies how each object's Cloud KMS customer-managed encryption key
    /// (CMEK) is preserved for transfers between Google Cloud Storage buckets.  If
    /// unspecified, the default behavior is the same as
    /// [KMS_KEY_DESTINATION_BUCKET_DEFAULT][google.storagetransfer.v1.MetadataOptions.KmsKey.KMS_KEY_DESTINATION_BUCKET_DEFAULT].
    ///
    /// [google.storagetransfer.v1.MetadataOptions.KmsKey.KMS_KEY_DESTINATION_BUCKET_DEFAULT]: crate::model::metadata_options::KmsKey::DestinationBucketDefault
    pub kms_key: crate::model::metadata_options::KmsKey,

    /// Specifies how each object's `timeCreated` metadata is preserved for
    /// transfers. If unspecified, the default behavior is the same as
    /// [TIME_CREATED_SKIP][google.storagetransfer.v1.MetadataOptions.TimeCreated.TIME_CREATED_SKIP].
    /// This behavior is supported for transfers to Cloud Storage buckets from
    /// Cloud Storage, Amazon S3, S3-compatible storage, and Azure sources.
    ///
    /// [google.storagetransfer.v1.MetadataOptions.TimeCreated.TIME_CREATED_SKIP]: crate::model::metadata_options::TimeCreated::Skip
    pub time_created: crate::model::metadata_options::TimeCreated,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetadataOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [symlink][crate::model::MetadataOptions::symlink].
    pub fn set_symlink<T: std::convert::Into<crate::model::metadata_options::Symlink>>(
        mut self,
        v: T,
    ) -> Self {
        self.symlink = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::MetadataOptions::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::metadata_options::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [gid][crate::model::MetadataOptions::gid].
    pub fn set_gid<T: std::convert::Into<crate::model::metadata_options::Gid>>(
        mut self,
        v: T,
    ) -> Self {
        self.gid = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::MetadataOptions::uid].
    pub fn set_uid<T: std::convert::Into<crate::model::metadata_options::Uid>>(
        mut self,
        v: T,
    ) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::MetadataOptions::acl].
    pub fn set_acl<T: std::convert::Into<crate::model::metadata_options::Acl>>(
        mut self,
        v: T,
    ) -> Self {
        self.acl = v.into();
        self
    }

    /// Sets the value of [storage_class][crate::model::MetadataOptions::storage_class].
    pub fn set_storage_class<
        T: std::convert::Into<crate::model::metadata_options::StorageClass>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_class = v.into();
        self
    }

    /// Sets the value of [temporary_hold][crate::model::MetadataOptions::temporary_hold].
    pub fn set_temporary_hold<
        T: std::convert::Into<crate::model::metadata_options::TemporaryHold>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.temporary_hold = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::MetadataOptions::kms_key].
    pub fn set_kms_key<T: std::convert::Into<crate::model::metadata_options::KmsKey>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [time_created][crate::model::MetadataOptions::time_created].
    pub fn set_time_created<T: std::convert::Into<crate::model::metadata_options::TimeCreated>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_created = v.into();
        self
    }
}

impl wkt::message::Message for MetadataOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.MetadataOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetadataOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __symlink,
            __mode,
            __gid,
            __uid,
            __acl,
            __storage_class,
            __temporary_hold,
            __kms_key,
            __time_created,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetadataOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "symlink" => Ok(__FieldTag::__symlink),
                            "mode" => Ok(__FieldTag::__mode),
                            "gid" => Ok(__FieldTag::__gid),
                            "uid" => Ok(__FieldTag::__uid),
                            "acl" => Ok(__FieldTag::__acl),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            "temporaryHold" => Ok(__FieldTag::__temporary_hold),
                            "temporary_hold" => Ok(__FieldTag::__temporary_hold),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "timeCreated" => Ok(__FieldTag::__time_created),
                            "time_created" => Ok(__FieldTag::__time_created),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetadataOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetadataOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__symlink => {
                            if !fields.insert(__FieldTag::__symlink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for symlink",
                                ));
                            }
                            result.symlink = map.next_value::<std::option::Option<crate::model::metadata_options::Symlink>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::metadata_options::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gid => {
                            if !fields.insert(__FieldTag::__gid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gid",
                                ));
                            }
                            result.gid = map.next_value::<std::option::Option<crate::model::metadata_options::Gid>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map.next_value::<std::option::Option<crate::model::metadata_options::Uid>>()?.unwrap_or_default();
                        }
                        __FieldTag::__acl => {
                            if !fields.insert(__FieldTag::__acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acl",
                                ));
                            }
                            result.acl = map.next_value::<std::option::Option<crate::model::metadata_options::Acl>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_class",
                                ));
                            }
                            result.storage_class =
                                map.next_value::<std::option::Option<
                                    crate::model::metadata_options::StorageClass,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__temporary_hold => {
                            if !fields.insert(__FieldTag::__temporary_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for temporary_hold",
                                ));
                            }
                            result.temporary_hold =
                                map.next_value::<std::option::Option<
                                    crate::model::metadata_options::TemporaryHold,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map.next_value::<std::option::Option<crate::model::metadata_options::KmsKey>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_created => {
                            if !fields.insert(__FieldTag::__time_created) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_created",
                                ));
                            }
                            result.time_created =
                                map.next_value::<std::option::Option<
                                    crate::model::metadata_options::TimeCreated,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetadataOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.symlink) {
            state.serialize_entry("symlink", &self.symlink)?;
        }
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !wkt::internal::is_default(&self.gid) {
            state.serialize_entry("gid", &self.gid)?;
        }
        if !wkt::internal::is_default(&self.uid) {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.acl) {
            state.serialize_entry("acl", &self.acl)?;
        }
        if !wkt::internal::is_default(&self.storage_class) {
            state.serialize_entry("storageClass", &self.storage_class)?;
        }
        if !wkt::internal::is_default(&self.temporary_hold) {
            state.serialize_entry("temporaryHold", &self.temporary_hold)?;
        }
        if !wkt::internal::is_default(&self.kms_key) {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !wkt::internal::is_default(&self.time_created) {
            state.serialize_entry("timeCreated", &self.time_created)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MetadataOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetadataOptions");
        debug_struct.field("symlink", &self.symlink);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("gid", &self.gid);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("acl", &self.acl);
        debug_struct.field("storage_class", &self.storage_class);
        debug_struct.field("temporary_hold", &self.temporary_hold);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("time_created", &self.time_created);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MetadataOptions].
pub mod metadata_options {
    #[allow(unused_imports)]
    use super::*;

    /// Whether symlinks should be skipped or preserved during a transfer job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Symlink {
        /// Symlink behavior is unspecified.
        Unspecified,
        /// Do not preserve symlinks during a transfer job.
        Skip,
        /// Preserve symlinks during a transfer job.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Symlink::value] or
        /// [Symlink::name].
        UnknownValue(symlink::UnknownValue),
    }

    #[doc(hidden)]
    pub mod symlink {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Symlink {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SYMLINK_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("SYMLINK_SKIP"),
                Self::Preserve => std::option::Option::Some("SYMLINK_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Symlink {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Symlink {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Symlink {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Preserve,
                _ => Self::UnknownValue(symlink::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Symlink {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SYMLINK_UNSPECIFIED" => Self::Unspecified,
                "SYMLINK_SKIP" => Self::Skip,
                "SYMLINK_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(symlink::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Symlink {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Symlink {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Symlink>::new(
                ".google.storagetransfer.v1.MetadataOptions.Symlink",
            ))
        }
    }

    /// Options for handling file mode attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode behavior is unspecified.
        Unspecified,
        /// Do not preserve mode during a transfer job.
        Skip,
        /// Preserve mode during a transfer job.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("MODE_SKIP"),
                Self::Preserve => std::option::Option::Some("MODE_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Preserve,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "MODE_SKIP" => Self::Skip,
                "MODE_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.storagetransfer.v1.MetadataOptions.Mode",
            ))
        }
    }

    /// Options for handling file GID attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Gid {
        /// GID behavior is unspecified.
        Unspecified,
        /// Do not preserve GID during a transfer job.
        Skip,
        /// Preserve GID during a transfer job.
        Number,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Gid::value] or
        /// [Gid::name].
        UnknownValue(gid::UnknownValue),
    }

    #[doc(hidden)]
    pub mod gid {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Gid {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Number => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GID_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("GID_SKIP"),
                Self::Number => std::option::Option::Some("GID_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Gid {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Gid {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Gid {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Number,
                _ => Self::UnknownValue(gid::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Gid {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GID_UNSPECIFIED" => Self::Unspecified,
                "GID_SKIP" => Self::Skip,
                "GID_NUMBER" => Self::Number,
                _ => Self::UnknownValue(gid::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Gid {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Number => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Gid {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Gid>::new(
                ".google.storagetransfer.v1.MetadataOptions.GID",
            ))
        }
    }

    /// Options for handling file UID attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Uid {
        /// UID behavior is unspecified.
        Unspecified,
        /// Do not preserve UID during a transfer job.
        Skip,
        /// Preserve UID during a transfer job.
        Number,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Uid::value] or
        /// [Uid::name].
        UnknownValue(uid::UnknownValue),
    }

    #[doc(hidden)]
    pub mod uid {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Uid {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Number => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UID_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("UID_SKIP"),
                Self::Number => std::option::Option::Some("UID_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Uid {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Uid {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Uid {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Number,
                _ => Self::UnknownValue(uid::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Uid {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UID_UNSPECIFIED" => Self::Unspecified,
                "UID_SKIP" => Self::Skip,
                "UID_NUMBER" => Self::Number,
                _ => Self::UnknownValue(uid::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Uid {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Number => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Uid {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Uid>::new(
                ".google.storagetransfer.v1.MetadataOptions.UID",
            ))
        }
    }

    /// Options for handling Cloud Storage object ACLs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Acl {
        /// ACL behavior is unspecified.
        Unspecified,
        /// Use the destination bucket's default object ACLS, if applicable.
        DestinationBucketDefault,
        /// Preserve the object's original ACLs. This requires the service account
        /// to have `storage.objects.getIamPolicy` permission for the source object.
        /// [Uniform bucket-level
        /// access](https://cloud.google.com/storage/docs/uniform-bucket-level-access)
        /// must not be enabled on either the source or destination buckets.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Acl::value] or
        /// [Acl::name].
        UnknownValue(acl::UnknownValue),
    }

    #[doc(hidden)]
    pub mod acl {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Acl {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DestinationBucketDefault => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACL_UNSPECIFIED"),
                Self::DestinationBucketDefault => {
                    std::option::Option::Some("ACL_DESTINATION_BUCKET_DEFAULT")
                }
                Self::Preserve => std::option::Option::Some("ACL_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Acl {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Acl {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Acl {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DestinationBucketDefault,
                2 => Self::Preserve,
                _ => Self::UnknownValue(acl::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Acl {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACL_UNSPECIFIED" => Self::Unspecified,
                "ACL_DESTINATION_BUCKET_DEFAULT" => Self::DestinationBucketDefault,
                "ACL_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(acl::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Acl {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DestinationBucketDefault => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Acl {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Acl>::new(
                ".google.storagetransfer.v1.MetadataOptions.Acl",
            ))
        }
    }

    /// Options for handling Google Cloud Storage object storage class.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageClass {
        /// Storage class behavior is unspecified.
        Unspecified,
        /// Use the destination bucket's default storage class.
        DestinationBucketDefault,
        /// Preserve the object's original storage class. This is only supported for
        /// transfers from Google Cloud Storage buckets. REGIONAL and MULTI_REGIONAL
        /// storage classes will be mapped to STANDARD to ensure they can be written
        /// to the destination bucket.
        Preserve,
        /// Set the storage class to STANDARD.
        Standard,
        /// Set the storage class to NEARLINE.
        Nearline,
        /// Set the storage class to COLDLINE.
        Coldline,
        /// Set the storage class to ARCHIVE.
        Archive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageClass::value] or
        /// [StorageClass::name].
        UnknownValue(storage_class::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_class {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageClass {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DestinationBucketDefault => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::Nearline => std::option::Option::Some(4),
                Self::Coldline => std::option::Option::Some(5),
                Self::Archive => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_CLASS_UNSPECIFIED"),
                Self::DestinationBucketDefault => {
                    std::option::Option::Some("STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT")
                }
                Self::Preserve => std::option::Option::Some("STORAGE_CLASS_PRESERVE"),
                Self::Standard => std::option::Option::Some("STORAGE_CLASS_STANDARD"),
                Self::Nearline => std::option::Option::Some("STORAGE_CLASS_NEARLINE"),
                Self::Coldline => std::option::Option::Some("STORAGE_CLASS_COLDLINE"),
                Self::Archive => std::option::Option::Some("STORAGE_CLASS_ARCHIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageClass {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageClass {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageClass {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DestinationBucketDefault,
                2 => Self::Preserve,
                3 => Self::Standard,
                4 => Self::Nearline,
                5 => Self::Coldline,
                6 => Self::Archive,
                _ => Self::UnknownValue(storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageClass {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_CLASS_UNSPECIFIED" => Self::Unspecified,
                "STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT" => Self::DestinationBucketDefault,
                "STORAGE_CLASS_PRESERVE" => Self::Preserve,
                "STORAGE_CLASS_STANDARD" => Self::Standard,
                "STORAGE_CLASS_NEARLINE" => Self::Nearline,
                "STORAGE_CLASS_COLDLINE" => Self::Coldline,
                "STORAGE_CLASS_ARCHIVE" => Self::Archive,
                _ => Self::UnknownValue(storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageClass {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DestinationBucketDefault => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::Standard => serializer.serialize_i32(3),
                Self::Nearline => serializer.serialize_i32(4),
                Self::Coldline => serializer.serialize_i32(5),
                Self::Archive => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageClass {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageClass>::new(
                ".google.storagetransfer.v1.MetadataOptions.StorageClass",
            ))
        }
    }

    /// Options for handling temporary holds for Google Cloud Storage objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TemporaryHold {
        /// Temporary hold behavior is unspecified.
        Unspecified,
        /// Do not set a temporary hold on the destination object.
        Skip,
        /// Preserve the object's original temporary hold status.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TemporaryHold::value] or
        /// [TemporaryHold::name].
        UnknownValue(temporary_hold::UnknownValue),
    }

    #[doc(hidden)]
    pub mod temporary_hold {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TemporaryHold {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TEMPORARY_HOLD_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("TEMPORARY_HOLD_SKIP"),
                Self::Preserve => std::option::Option::Some("TEMPORARY_HOLD_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TemporaryHold {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TemporaryHold {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TemporaryHold {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Preserve,
                _ => Self::UnknownValue(temporary_hold::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TemporaryHold {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TEMPORARY_HOLD_UNSPECIFIED" => Self::Unspecified,
                "TEMPORARY_HOLD_SKIP" => Self::Skip,
                "TEMPORARY_HOLD_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(temporary_hold::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TemporaryHold {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TemporaryHold {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TemporaryHold>::new(
                ".google.storagetransfer.v1.MetadataOptions.TemporaryHold",
            ))
        }
    }

    /// Options for handling the KmsKey setting for Google Cloud Storage objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KmsKey {
        /// KmsKey behavior is unspecified.
        Unspecified,
        /// Use the destination bucket's default encryption settings.
        DestinationBucketDefault,
        /// Preserve the object's original Cloud KMS customer-managed encryption key
        /// (CMEK) if present. Objects that do not use a Cloud KMS encryption key
        /// will be encrypted using the destination bucket's encryption settings.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KmsKey::value] or
        /// [KmsKey::name].
        UnknownValue(kms_key::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kms_key {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KmsKey {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DestinationBucketDefault => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KMS_KEY_UNSPECIFIED"),
                Self::DestinationBucketDefault => {
                    std::option::Option::Some("KMS_KEY_DESTINATION_BUCKET_DEFAULT")
                }
                Self::Preserve => std::option::Option::Some("KMS_KEY_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KmsKey {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KmsKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KmsKey {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DestinationBucketDefault,
                2 => Self::Preserve,
                _ => Self::UnknownValue(kms_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KmsKey {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KMS_KEY_UNSPECIFIED" => Self::Unspecified,
                "KMS_KEY_DESTINATION_BUCKET_DEFAULT" => Self::DestinationBucketDefault,
                "KMS_KEY_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(kms_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KmsKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DestinationBucketDefault => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KmsKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KmsKey>::new(
                ".google.storagetransfer.v1.MetadataOptions.KmsKey",
            ))
        }
    }

    /// Options for handling `timeCreated` metadata for Google Cloud Storage
    /// objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeCreated {
        /// TimeCreated behavior is unspecified.
        Unspecified,
        /// Do not preserve the `timeCreated` metadata from the source object.
        Skip,
        /// Preserves the source object's `timeCreated` or `lastModified` metadata in
        /// the `customTime` field in the destination object.  Note that any value
        /// stored in the source object's `customTime` field will not be propagated
        /// to the destination object.
        PreserveAsCustomTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeCreated::value] or
        /// [TimeCreated::name].
        UnknownValue(time_created::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_created {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeCreated {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::PreserveAsCustomTime => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_CREATED_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("TIME_CREATED_SKIP"),
                Self::PreserveAsCustomTime => {
                    std::option::Option::Some("TIME_CREATED_PRESERVE_AS_CUSTOM_TIME")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeCreated {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeCreated {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeCreated {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::PreserveAsCustomTime,
                _ => Self::UnknownValue(time_created::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeCreated {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_CREATED_UNSPECIFIED" => Self::Unspecified,
                "TIME_CREATED_SKIP" => Self::Skip,
                "TIME_CREATED_PRESERVE_AS_CUSTOM_TIME" => Self::PreserveAsCustomTime,
                _ => Self::UnknownValue(time_created::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeCreated {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::PreserveAsCustomTime => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeCreated {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeCreated>::new(
                ".google.storagetransfer.v1.MetadataOptions.TimeCreated",
            ))
        }
    }
}

/// Specifies where the manifest is located.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferManifest {
    /// Specifies the path to the manifest in Cloud Storage. The Google-managed
    /// service account for the transfer must have `storage.objects.get`
    /// permission for this object. An example path is
    /// `gs://bucket_name/path/manifest.csv`.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferManifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::TransferManifest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for TransferManifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferManifest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferManifest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferManifest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferManifest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferManifest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferManifest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferManifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferManifest");
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Transfers can be scheduled to recur or to run just once.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schedule {
    /// Required. The start date of a transfer. Date boundaries are determined
    /// relative to UTC time. If `schedule_start_date` and
    /// [start_time_of_day][google.storagetransfer.v1.Schedule.start_time_of_day]
    /// are in the past relative to the job's creation time, the transfer starts
    /// the day after you schedule the transfer request.
    ///
    /// **Note:** When starting jobs at or near midnight UTC it is possible that
    /// a job starts later than expected. For example, if you send an outbound
    /// request on June 1 one millisecond prior to midnight UTC and the Storage
    /// Transfer Service server receives the request on June 2, then it creates
    /// a TransferJob with `schedule_start_date` set to June 2 and a
    /// `start_time_of_day` set to midnight UTC. The first scheduled
    /// [TransferOperation][google.storagetransfer.v1.TransferOperation] takes
    /// place on June 3 at midnight UTC.
    ///
    /// [google.storagetransfer.v1.Schedule.start_time_of_day]: crate::model::Schedule::start_time_of_day
    /// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
    pub schedule_start_date: std::option::Option<gtype::model::Date>,

    /// The last day a transfer runs. Date boundaries are determined relative to
    /// UTC time. A job runs once per 24 hours within the following guidelines:
    ///
    /// * If `schedule_end_date` and
    ///   [schedule_start_date][google.storagetransfer.v1.Schedule.schedule_start_date]
    ///   are the same and in
    ///   the future relative to UTC, the transfer is executed only one time.
    /// * If `schedule_end_date` is later than `schedule_start_date`  and
    ///   `schedule_end_date` is in the future relative to UTC, the job runs each
    ///   day at
    ///   [start_time_of_day][google.storagetransfer.v1.Schedule.start_time_of_day]
    ///   through `schedule_end_date`.
    ///
    /// [google.storagetransfer.v1.Schedule.schedule_start_date]: crate::model::Schedule::schedule_start_date
    /// [google.storagetransfer.v1.Schedule.start_time_of_day]: crate::model::Schedule::start_time_of_day
    pub schedule_end_date: std::option::Option<gtype::model::Date>,

    /// The time in UTC that a transfer job is scheduled to run. Transfers may
    /// start later than this time.
    ///
    /// If `start_time_of_day` is not specified:
    ///
    /// * One-time transfers run immediately.
    /// * Recurring transfers run immediately, and each day at midnight UTC,
    ///   through
    ///   [schedule_end_date][google.storagetransfer.v1.Schedule.schedule_end_date].
    ///
    /// If `start_time_of_day` is specified:
    ///
    /// * One-time transfers run at the specified time.
    /// * Recurring transfers run at the specified time each day, through
    ///   `schedule_end_date`.
    ///
    /// [google.storagetransfer.v1.Schedule.schedule_end_date]: crate::model::Schedule::schedule_end_date
    pub start_time_of_day: std::option::Option<gtype::model::TimeOfDay>,

    /// The time in UTC that no further transfer operations are scheduled. Combined
    /// with
    /// [schedule_end_date][google.storagetransfer.v1.Schedule.schedule_end_date],
    /// `end_time_of_day` specifies the end date and time for starting new transfer
    /// operations. This field must be greater than or equal to the timestamp
    /// corresponding to the combination of
    /// [schedule_start_date][google.storagetransfer.v1.Schedule.schedule_start_date]
    /// and
    /// [start_time_of_day][google.storagetransfer.v1.Schedule.start_time_of_day],
    /// and is subject to the following:
    ///
    /// * If `end_time_of_day` is not set and `schedule_end_date` is set, then
    ///   a default value of `23:59:59` is used for `end_time_of_day`.
    ///
    /// * If `end_time_of_day` is set and `schedule_end_date` is not set, then
    ///   [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] is returned.
    ///
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.Schedule.schedule_end_date]: crate::model::Schedule::schedule_end_date
    /// [google.storagetransfer.v1.Schedule.schedule_start_date]: crate::model::Schedule::schedule_start_date
    /// [google.storagetransfer.v1.Schedule.start_time_of_day]: crate::model::Schedule::start_time_of_day
    pub end_time_of_day: std::option::Option<gtype::model::TimeOfDay>,

    /// Interval between the start of each scheduled TransferOperation. If
    /// unspecified, the default value is 24 hours. This value may not be less than
    /// 1 hour.
    pub repeat_interval: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule_start_date][crate::model::Schedule::schedule_start_date].
    pub fn set_schedule_start_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_start_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_start_date][crate::model::Schedule::schedule_start_date].
    pub fn set_or_clear_schedule_start_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_start_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule_end_date][crate::model::Schedule::schedule_end_date].
    pub fn set_schedule_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_end_date][crate::model::Schedule::schedule_end_date].
    pub fn set_or_clear_schedule_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_end_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time_of_day][crate::model::Schedule::start_time_of_day].
    pub fn set_start_time_of_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time_of_day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time_of_day][crate::model::Schedule::start_time_of_day].
    pub fn set_or_clear_start_time_of_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time_of_day = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time_of_day][crate::model::Schedule::end_time_of_day].
    pub fn set_end_time_of_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time_of_day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time_of_day][crate::model::Schedule::end_time_of_day].
    pub fn set_or_clear_end_time_of_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time_of_day = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repeat_interval][crate::model::Schedule::repeat_interval].
    pub fn set_repeat_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.repeat_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repeat_interval][crate::model::Schedule::repeat_interval].
    pub fn set_or_clear_repeat_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.repeat_interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.Schedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schedule_start_date,
            __schedule_end_date,
            __start_time_of_day,
            __end_time_of_day,
            __repeat_interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scheduleStartDate" => Ok(__FieldTag::__schedule_start_date),
                            "schedule_start_date" => Ok(__FieldTag::__schedule_start_date),
                            "scheduleEndDate" => Ok(__FieldTag::__schedule_end_date),
                            "schedule_end_date" => Ok(__FieldTag::__schedule_end_date),
                            "startTimeOfDay" => Ok(__FieldTag::__start_time_of_day),
                            "start_time_of_day" => Ok(__FieldTag::__start_time_of_day),
                            "endTimeOfDay" => Ok(__FieldTag::__end_time_of_day),
                            "end_time_of_day" => Ok(__FieldTag::__end_time_of_day),
                            "repeatInterval" => Ok(__FieldTag::__repeat_interval),
                            "repeat_interval" => Ok(__FieldTag::__repeat_interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schedule_start_date => {
                            if !fields.insert(__FieldTag::__schedule_start_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_start_date",
                                ));
                            }
                            result.schedule_start_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__schedule_end_date => {
                            if !fields.insert(__FieldTag::__schedule_end_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_end_date",
                                ));
                            }
                            result.schedule_end_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__start_time_of_day => {
                            if !fields.insert(__FieldTag::__start_time_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time_of_day",
                                ));
                            }
                            result.start_time_of_day =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__end_time_of_day => {
                            if !fields.insert(__FieldTag::__end_time_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time_of_day",
                                ));
                            }
                            result.end_time_of_day =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__repeat_interval => {
                            if !fields.insert(__FieldTag::__repeat_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeat_interval",
                                ));
                            }
                            result.repeat_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.schedule_start_date.is_some() {
            state.serialize_entry("scheduleStartDate", &self.schedule_start_date)?;
        }
        if self.schedule_end_date.is_some() {
            state.serialize_entry("scheduleEndDate", &self.schedule_end_date)?;
        }
        if self.start_time_of_day.is_some() {
            state.serialize_entry("startTimeOfDay", &self.start_time_of_day)?;
        }
        if self.end_time_of_day.is_some() {
            state.serialize_entry("endTimeOfDay", &self.end_time_of_day)?;
        }
        if self.repeat_interval.is_some() {
            state.serialize_entry("repeatInterval", &self.repeat_interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Schedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Schedule");
        debug_struct.field("schedule_start_date", &self.schedule_start_date);
        debug_struct.field("schedule_end_date", &self.schedule_end_date);
        debug_struct.field("start_time_of_day", &self.start_time_of_day);
        debug_struct.field("end_time_of_day", &self.end_time_of_day);
        debug_struct.field("repeat_interval", &self.repeat_interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies the Event-driven transfer options. Event-driven transfers listen to
/// an event stream to transfer updated files.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EventStream {
    /// Required. Specifies a unique name of the resource such as AWS SQS
    /// ARN in the form 'arn:aws:sqs:region:account_id:queue_name',
    /// or Pub/Sub subscription resource name in the form
    /// 'projects/{project}/subscriptions/{sub}'.
    pub name: std::string::String,

    /// Specifies the date and time that Storage Transfer Service starts
    /// listening for events from this stream. If no start time is specified or
    /// start time is in the past, Storage Transfer Service starts listening
    /// immediately.
    pub event_stream_start_time: std::option::Option<wkt::Timestamp>,

    /// Specifies the data and time at which Storage Transfer Service stops
    /// listening for events from this stream. After this time, any transfers in
    /// progress will complete, but no new transfers are initiated.
    pub event_stream_expiration_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventStream::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event_stream_start_time][crate::model::EventStream::event_stream_start_time].
    pub fn set_event_stream_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_stream_start_time][crate::model::EventStream::event_stream_start_time].
    pub fn set_or_clear_event_stream_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_stream_expiration_time][crate::model::EventStream::event_stream_expiration_time].
    pub fn set_event_stream_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_stream_expiration_time][crate::model::EventStream::event_stream_expiration_time].
    pub fn set_or_clear_event_stream_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EventStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.EventStream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __event_stream_start_time,
            __event_stream_expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "eventStreamStartTime" => Ok(__FieldTag::__event_stream_start_time),
                            "event_stream_start_time" => Ok(__FieldTag::__event_stream_start_time),
                            "eventStreamExpirationTime" => {
                                Ok(__FieldTag::__event_stream_expiration_time)
                            }
                            "event_stream_expiration_time" => {
                                Ok(__FieldTag::__event_stream_expiration_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_stream_start_time => {
                            if !fields.insert(__FieldTag::__event_stream_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_stream_start_time",
                                ));
                            }
                            result.event_stream_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__event_stream_expiration_time => {
                            if !fields.insert(__FieldTag::__event_stream_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_stream_expiration_time",
                                ));
                            }
                            result.event_stream_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EventStream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.event_stream_start_time.is_some() {
            state.serialize_entry("eventStreamStartTime", &self.event_stream_start_time)?;
        }
        if self.event_stream_expiration_time.is_some() {
            state.serialize_entry(
                "eventStreamExpirationTime",
                &self.event_stream_expiration_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EventStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventStream");
        debug_struct.field("name", &self.name);
        debug_struct.field("event_stream_start_time", &self.event_stream_start_time);
        debug_struct.field(
            "event_stream_expiration_time",
            &self.event_stream_expiration_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// This resource represents the configuration of a transfer job that runs
/// periodically.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferJob {
    /// A unique name (within the transfer project) assigned when the job is
    /// created.  If this field is empty in a CreateTransferJobRequest, Storage
    /// Transfer Service assigns a unique name. Otherwise, the specified name
    /// is used as the unique name for this job.
    ///
    /// If the specified name is in use by a job, the creation request fails with
    /// an [ALREADY_EXISTS][google.rpc.Code.ALREADY_EXISTS] error.
    ///
    /// This name must start with `"transferJobs/"` prefix and end with a letter or
    /// a number, and should be no more than 128 characters. For transfers
    /// involving PosixFilesystem, this name must start with `transferJobs/OPI`
    /// specifically. For all other transfer types, this name must not start with
    /// `transferJobs/OPI`.
    ///
    /// Non-PosixFilesystem example:
    /// `"transferJobs/^(?!OPI)[A-Za-z0-9-._~]*[A-Za-z0-9]$"`
    ///
    /// PosixFilesystem example:
    /// `"transferJobs/OPI^[A-Za-z0-9-._~]*[A-Za-z0-9]$"`
    ///
    /// Applications must not rely on the enforcement of naming requirements
    /// involving OPI.
    ///
    /// Invalid job names fail with an
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error.
    ///
    /// [google.rpc.Code.ALREADY_EXISTS]: rpc::model::Code::AlreadyExists
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    pub name: std::string::String,

    /// A description provided by the user for the job. Its max length is 1024
    /// bytes when Unicode-encoded.
    pub description: std::string::String,

    /// The ID of the Google Cloud project that owns the job.
    pub project_id: std::string::String,

    /// Optional. The user-managed service account to which to delegate service
    /// agent permissions. You can grant Cloud Storage bucket permissions to this
    /// service account instead of to the Transfer Service service agent.
    ///
    /// Format is
    /// `projects/-/serviceAccounts/ACCOUNT_EMAIL_OR_UNIQUEID`
    ///
    /// Either the service account email
    /// (`SERVICE_ACCOUNT_NAME@PROJECT_ID.iam.gserviceaccount.com`) or the unique
    /// ID (`123456789012345678901`) are accepted in the string. The `-`
    /// wildcard character is required; replacing it with a project ID is invalid.
    ///
    /// See
    /// <https://cloud.google.com//storage-transfer/docs/delegate-service-agent-permissions>
    /// for required permissions.
    pub service_account: std::string::String,

    /// Transfer specification.
    pub transfer_spec: std::option::Option<crate::model::TransferSpec>,

    /// Replication specification.
    pub replication_spec: std::option::Option<crate::model::ReplicationSpec>,

    /// Notification configuration.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Logging configuration.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Specifies schedule for the transfer job.
    /// This is an optional field. When the field is not set, the job never
    /// executes a transfer, unless you invoke RunTransferJob or update the job to
    /// have a non-empty schedule.
    pub schedule: std::option::Option<crate::model::Schedule>,

    /// Specifies the event stream for the transfer job for event-driven transfers.
    /// When EventStream is specified, the Schedule fields are ignored.
    pub event_stream: std::option::Option<crate::model::EventStream>,

    /// Status of the job. This value MUST be specified for
    /// `CreateTransferJobRequests`.
    ///
    /// **Note:** The effect of the new job status takes place during a subsequent
    /// job run. For example, if you change the job status from
    /// [ENABLED][google.storagetransfer.v1.TransferJob.Status.ENABLED] to
    /// [DISABLED][google.storagetransfer.v1.TransferJob.Status.DISABLED], and an
    /// operation spawned by the transfer is running, the status change would not
    /// affect the current operation.
    ///
    /// [google.storagetransfer.v1.TransferJob.Status.DISABLED]: crate::model::transfer_job::Status::Disabled
    /// [google.storagetransfer.v1.TransferJob.Status.ENABLED]: crate::model::transfer_job::Status::Enabled
    pub status: crate::model::transfer_job::Status,

    /// Output only. The time that the transfer job was created.
    pub creation_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that the transfer job was last modified.
    pub last_modification_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that the transfer job was deleted.
    pub deletion_time: std::option::Option<wkt::Timestamp>,

    /// The name of the most recently started TransferOperation of this JobConfig.
    /// Present if a TransferOperation has been created for this JobConfig.
    pub latest_operation_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransferJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TransferJob::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::TransferJob::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::TransferJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [transfer_spec][crate::model::TransferJob::transfer_spec].
    pub fn set_transfer_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_spec][crate::model::TransferJob::transfer_spec].
    pub fn set_or_clear_transfer_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_spec][crate::model::TransferJob::replication_spec].
    pub fn set_replication_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSpec>,
    {
        self.replication_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_spec][crate::model::TransferJob::replication_spec].
    pub fn set_or_clear_replication_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSpec>,
    {
        self.replication_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_config][crate::model::TransferJob::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::TransferJob::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::TransferJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::TransferJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::TransferJob::schedule].
    pub fn set_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schedule>,
    {
        self.schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule][crate::model::TransferJob::schedule].
    pub fn set_or_clear_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schedule>,
    {
        self.schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_stream][crate::model::TransferJob::event_stream].
    pub fn set_event_stream<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EventStream>,
    {
        self.event_stream = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_stream][crate::model::TransferJob::event_stream].
    pub fn set_or_clear_event_stream<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EventStream>,
    {
        self.event_stream = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::TransferJob::status].
    pub fn set_status<T: std::convert::Into<crate::model::transfer_job::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::TransferJob::creation_time].
    pub fn set_creation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_time][crate::model::TransferJob::creation_time].
    pub fn set_or_clear_creation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modification_time][crate::model::TransferJob::last_modification_time].
    pub fn set_last_modification_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modification_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modification_time][crate::model::TransferJob::last_modification_time].
    pub fn set_or_clear_last_modification_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modification_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_time][crate::model::TransferJob::deletion_time].
    pub fn set_deletion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deletion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_time][crate::model::TransferJob::deletion_time].
    pub fn set_or_clear_deletion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deletion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_operation_name][crate::model::TransferJob::latest_operation_name].
    pub fn set_latest_operation_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_operation_name = v.into();
        self
    }
}

impl wkt::message::Message for TransferJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __project_id,
            __service_account,
            __transfer_spec,
            __replication_spec,
            __notification_config,
            __logging_config,
            __schedule,
            __event_stream,
            __status,
            __creation_time,
            __last_modification_time,
            __deletion_time,
            __latest_operation_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "transferSpec" => Ok(__FieldTag::__transfer_spec),
                            "transfer_spec" => Ok(__FieldTag::__transfer_spec),
                            "replicationSpec" => Ok(__FieldTag::__replication_spec),
                            "replication_spec" => Ok(__FieldTag::__replication_spec),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "eventStream" => Ok(__FieldTag::__event_stream),
                            "event_stream" => Ok(__FieldTag::__event_stream),
                            "status" => Ok(__FieldTag::__status),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModificationTime" => Ok(__FieldTag::__last_modification_time),
                            "last_modification_time" => Ok(__FieldTag::__last_modification_time),
                            "deletionTime" => Ok(__FieldTag::__deletion_time),
                            "deletion_time" => Ok(__FieldTag::__deletion_time),
                            "latestOperationName" => Ok(__FieldTag::__latest_operation_name),
                            "latest_operation_name" => Ok(__FieldTag::__latest_operation_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_spec => {
                            if !fields.insert(__FieldTag::__transfer_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_spec",
                                ));
                            }
                            result.transfer_spec = map
                                .next_value::<std::option::Option<crate::model::TransferSpec>>()?;
                        }
                        __FieldTag::__replication_spec => {
                            if !fields.insert(__FieldTag::__replication_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_spec",
                                ));
                            }
                            result.replication_spec = map
                                .next_value::<std::option::Option<crate::model::ReplicationSpec>>(
                                )?;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule =
                                map.next_value::<std::option::Option<crate::model::Schedule>>()?;
                        }
                        __FieldTag::__event_stream => {
                            if !fields.insert(__FieldTag::__event_stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_stream",
                                ));
                            }
                            result.event_stream =
                                map.next_value::<std::option::Option<crate::model::EventStream>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::transfer_job::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modification_time => {
                            if !fields.insert(__FieldTag::__last_modification_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modification_time",
                                ));
                            }
                            result.last_modification_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__deletion_time => {
                            if !fields.insert(__FieldTag::__deletion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_time",
                                ));
                            }
                            result.deletion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__latest_operation_name => {
                            if !fields.insert(__FieldTag::__latest_operation_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_operation_name",
                                ));
                            }
                            result.latest_operation_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.transfer_spec.is_some() {
            state.serialize_entry("transferSpec", &self.transfer_spec)?;
        }
        if self.replication_spec.is_some() {
            state.serialize_entry("replicationSpec", &self.replication_spec)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.schedule.is_some() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if self.event_stream.is_some() {
            state.serialize_entry("eventStream", &self.event_stream)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if self.creation_time.is_some() {
            state.serialize_entry("creationTime", &self.creation_time)?;
        }
        if self.last_modification_time.is_some() {
            state.serialize_entry("lastModificationTime", &self.last_modification_time)?;
        }
        if self.deletion_time.is_some() {
            state.serialize_entry("deletionTime", &self.deletion_time)?;
        }
        if !self.latest_operation_name.is_empty() {
            state.serialize_entry("latestOperationName", &self.latest_operation_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("transfer_spec", &self.transfer_spec);
        debug_struct.field("replication_spec", &self.replication_spec);
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("event_stream", &self.event_stream);
        debug_struct.field("status", &self.status);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modification_time", &self.last_modification_time);
        debug_struct.field("deletion_time", &self.deletion_time);
        debug_struct.field("latest_operation_name", &self.latest_operation_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferJob].
pub mod transfer_job {
    #[allow(unused_imports)]
    use super::*;

    /// The status of the transfer job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Zero is an illegal value.
        Unspecified,
        /// New transfers are performed based on the schedule.
        Enabled,
        /// New transfers are not scheduled.
        Disabled,
        /// This is a soft delete state. After a transfer job is set to this
        /// state, the job and all the transfer executions are subject to
        /// garbage collection. Transfer jobs become eligible for garbage collection
        /// 30 days after their status is set to `DELETED`.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Deleted,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.storagetransfer.v1.TransferJob.Status",
            ))
        }
    }
}

/// An entry describing an error that has occurred.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorLogEntry {
    /// Required. A URL that refers to the target (a data source, a data sink,
    /// or an object) with which the error is associated.
    pub url: std::string::String,

    /// A list of messages that carry the error details.
    pub error_details: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::ErrorLogEntry::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [error_details][crate::model::ErrorLogEntry::error_details].
    pub fn set_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ErrorLogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorLogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __error_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorLogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "errorDetails" => Ok(__FieldTag::__error_details),
                            "error_details" => Ok(__FieldTag::__error_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorLogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorLogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_details => {
                            if !fields.insert(__FieldTag::__error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_details",
                                ));
                            }
                            result.error_details = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorLogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ErrorLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorLogEntry");
        debug_struct.field("url", &self.url);
        debug_struct.field("error_details", &self.error_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A summary of errors by error code, plus a count and sample error log
/// entries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorSummary {
    /// Required.
    pub error_code: rpc::model::Code,

    /// Required. Count of this type of error.
    pub error_count: i64,

    /// Error samples.
    ///
    /// At most 5 error log entries are recorded for a given
    /// error code for a single transfer operation.
    pub error_log_entries: std::vec::Vec<crate::model::ErrorLogEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::ErrorSummary::error_code].
    pub fn set_error_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [error_count][crate::model::ErrorSummary::error_count].
    pub fn set_error_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.error_count = v.into();
        self
    }

    /// Sets the value of [error_log_entries][crate::model::ErrorSummary::error_log_entries].
    pub fn set_error_log_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorLogEntry>,
    {
        use std::iter::Iterator;
        self.error_log_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ErrorSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_code,
            __error_count,
            __error_log_entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorCode" => Ok(__FieldTag::__error_code),
                            "error_code" => Ok(__FieldTag::__error_code),
                            "errorCount" => Ok(__FieldTag::__error_count),
                            "error_count" => Ok(__FieldTag::__error_count),
                            "errorLogEntries" => Ok(__FieldTag::__error_log_entries),
                            "error_log_entries" => Ok(__FieldTag::__error_log_entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_code => {
                            if !fields.insert(__FieldTag::__error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_code",
                                ));
                            }
                            result.error_code = map
                                .next_value::<std::option::Option<rpc::model::Code>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_count => {
                            if !fields.insert(__FieldTag::__error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.error_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error_log_entries => {
                            if !fields.insert(__FieldTag::__error_log_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_log_entries",
                                ));
                            }
                            result.error_log_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorLogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.error_code) {
            state.serialize_entry("errorCode", &self.error_code)?;
        }
        if !wkt::internal::is_default(&self.error_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("errorCount", &__With(&self.error_count))?;
        }
        if !self.error_log_entries.is_empty() {
            state.serialize_entry("errorLogEntries", &self.error_log_entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ErrorSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorSummary");
        debug_struct.field("error_code", &self.error_code);
        debug_struct.field("error_count", &self.error_count);
        debug_struct.field("error_log_entries", &self.error_log_entries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A collection of counters that report the progress of a transfer operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferCounters {
    /// Objects found in the data source that are scheduled to be transferred,
    /// excluding any that are filtered based on object conditions or skipped due
    /// to sync.
    pub objects_found_from_source: i64,

    /// Bytes found in the data source that are scheduled to be transferred,
    /// excluding any that are filtered based on object conditions or skipped due
    /// to sync.
    pub bytes_found_from_source: i64,

    /// Objects found only in the data sink that are scheduled to be deleted.
    pub objects_found_only_from_sink: i64,

    /// Bytes found only in the data sink that are scheduled to be deleted.
    pub bytes_found_only_from_sink: i64,

    /// Objects in the data source that are not transferred because they already
    /// exist in the data sink.
    pub objects_from_source_skipped_by_sync: i64,

    /// Bytes in the data source that are not transferred because they already
    /// exist in the data sink.
    pub bytes_from_source_skipped_by_sync: i64,

    /// Objects that are copied to the data sink.
    pub objects_copied_to_sink: i64,

    /// Bytes that are copied to the data sink.
    pub bytes_copied_to_sink: i64,

    /// Objects that are deleted from the data source.
    pub objects_deleted_from_source: i64,

    /// Bytes that are deleted from the data source.
    pub bytes_deleted_from_source: i64,

    /// Objects that are deleted from the data sink.
    pub objects_deleted_from_sink: i64,

    /// Bytes that are deleted from the data sink.
    pub bytes_deleted_from_sink: i64,

    /// Objects in the data source that failed to be transferred or that failed
    /// to be deleted after being transferred.
    pub objects_from_source_failed: i64,

    /// Bytes in the data source that failed to be transferred or that failed to
    /// be deleted after being transferred.
    pub bytes_from_source_failed: i64,

    /// Objects that failed to be deleted from the data sink.
    pub objects_failed_to_delete_from_sink: i64,

    /// Bytes that failed to be deleted from the data sink.
    pub bytes_failed_to_delete_from_sink: i64,

    /// For transfers involving PosixFilesystem only.
    ///
    /// Number of directories found while listing. For example, if the root
    /// directory of the transfer is `base/` and there are two other directories,
    /// `a/` and `b/` under this directory, the count after listing `base/`,
    /// `base/a/` and `base/b/` is 3.
    pub directories_found_from_source: i64,

    /// For transfers involving PosixFilesystem only.
    ///
    /// Number of listing failures for each directory found at the source.
    /// Potential failures when listing a directory include permission failure or
    /// block failure. If listing a directory fails, no files in the directory are
    /// transferred.
    pub directories_failed_to_list_from_source: i64,

    /// For transfers involving PosixFilesystem only.
    ///
    /// Number of successful listings for each directory found at the source.
    pub directories_successfully_listed_from_source: i64,

    /// Number of successfully cleaned up intermediate objects.
    pub intermediate_objects_cleaned_up: i64,

    /// Number of intermediate objects failed cleaned up.
    pub intermediate_objects_failed_cleaned_up: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferCounters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objects_found_from_source][crate::model::TransferCounters::objects_found_from_source].
    pub fn set_objects_found_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_found_from_source = v.into();
        self
    }

    /// Sets the value of [bytes_found_from_source][crate::model::TransferCounters::bytes_found_from_source].
    pub fn set_bytes_found_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_found_from_source = v.into();
        self
    }

    /// Sets the value of [objects_found_only_from_sink][crate::model::TransferCounters::objects_found_only_from_sink].
    pub fn set_objects_found_only_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_found_only_from_sink = v.into();
        self
    }

    /// Sets the value of [bytes_found_only_from_sink][crate::model::TransferCounters::bytes_found_only_from_sink].
    pub fn set_bytes_found_only_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_found_only_from_sink = v.into();
        self
    }

    /// Sets the value of [objects_from_source_skipped_by_sync][crate::model::TransferCounters::objects_from_source_skipped_by_sync].
    pub fn set_objects_from_source_skipped_by_sync<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.objects_from_source_skipped_by_sync = v.into();
        self
    }

    /// Sets the value of [bytes_from_source_skipped_by_sync][crate::model::TransferCounters::bytes_from_source_skipped_by_sync].
    pub fn set_bytes_from_source_skipped_by_sync<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.bytes_from_source_skipped_by_sync = v.into();
        self
    }

    /// Sets the value of [objects_copied_to_sink][crate::model::TransferCounters::objects_copied_to_sink].
    pub fn set_objects_copied_to_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_copied_to_sink = v.into();
        self
    }

    /// Sets the value of [bytes_copied_to_sink][crate::model::TransferCounters::bytes_copied_to_sink].
    pub fn set_bytes_copied_to_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_copied_to_sink = v.into();
        self
    }

    /// Sets the value of [objects_deleted_from_source][crate::model::TransferCounters::objects_deleted_from_source].
    pub fn set_objects_deleted_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_deleted_from_source = v.into();
        self
    }

    /// Sets the value of [bytes_deleted_from_source][crate::model::TransferCounters::bytes_deleted_from_source].
    pub fn set_bytes_deleted_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_deleted_from_source = v.into();
        self
    }

    /// Sets the value of [objects_deleted_from_sink][crate::model::TransferCounters::objects_deleted_from_sink].
    pub fn set_objects_deleted_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_deleted_from_sink = v.into();
        self
    }

    /// Sets the value of [bytes_deleted_from_sink][crate::model::TransferCounters::bytes_deleted_from_sink].
    pub fn set_bytes_deleted_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_deleted_from_sink = v.into();
        self
    }

    /// Sets the value of [objects_from_source_failed][crate::model::TransferCounters::objects_from_source_failed].
    pub fn set_objects_from_source_failed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_from_source_failed = v.into();
        self
    }

    /// Sets the value of [bytes_from_source_failed][crate::model::TransferCounters::bytes_from_source_failed].
    pub fn set_bytes_from_source_failed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_from_source_failed = v.into();
        self
    }

    /// Sets the value of [objects_failed_to_delete_from_sink][crate::model::TransferCounters::objects_failed_to_delete_from_sink].
    pub fn set_objects_failed_to_delete_from_sink<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.objects_failed_to_delete_from_sink = v.into();
        self
    }

    /// Sets the value of [bytes_failed_to_delete_from_sink][crate::model::TransferCounters::bytes_failed_to_delete_from_sink].
    pub fn set_bytes_failed_to_delete_from_sink<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.bytes_failed_to_delete_from_sink = v.into();
        self
    }

    /// Sets the value of [directories_found_from_source][crate::model::TransferCounters::directories_found_from_source].
    pub fn set_directories_found_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.directories_found_from_source = v.into();
        self
    }

    /// Sets the value of [directories_failed_to_list_from_source][crate::model::TransferCounters::directories_failed_to_list_from_source].
    pub fn set_directories_failed_to_list_from_source<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.directories_failed_to_list_from_source = v.into();
        self
    }

    /// Sets the value of [directories_successfully_listed_from_source][crate::model::TransferCounters::directories_successfully_listed_from_source].
    pub fn set_directories_successfully_listed_from_source<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.directories_successfully_listed_from_source = v.into();
        self
    }

    /// Sets the value of [intermediate_objects_cleaned_up][crate::model::TransferCounters::intermediate_objects_cleaned_up].
    pub fn set_intermediate_objects_cleaned_up<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.intermediate_objects_cleaned_up = v.into();
        self
    }

    /// Sets the value of [intermediate_objects_failed_cleaned_up][crate::model::TransferCounters::intermediate_objects_failed_cleaned_up].
    pub fn set_intermediate_objects_failed_cleaned_up<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.intermediate_objects_failed_cleaned_up = v.into();
        self
    }
}

impl wkt::message::Message for TransferCounters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferCounters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferCounters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __objects_found_from_source,
            __bytes_found_from_source,
            __objects_found_only_from_sink,
            __bytes_found_only_from_sink,
            __objects_from_source_skipped_by_sync,
            __bytes_from_source_skipped_by_sync,
            __objects_copied_to_sink,
            __bytes_copied_to_sink,
            __objects_deleted_from_source,
            __bytes_deleted_from_source,
            __objects_deleted_from_sink,
            __bytes_deleted_from_sink,
            __objects_from_source_failed,
            __bytes_from_source_failed,
            __objects_failed_to_delete_from_sink,
            __bytes_failed_to_delete_from_sink,
            __directories_found_from_source,
            __directories_failed_to_list_from_source,
            __directories_successfully_listed_from_source,
            __intermediate_objects_cleaned_up,
            __intermediate_objects_failed_cleaned_up,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferCounters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectsFoundFromSource" => Ok(__FieldTag::__objects_found_from_source),
                            "objects_found_from_source" => {
                                Ok(__FieldTag::__objects_found_from_source)
                            }
                            "bytesFoundFromSource" => Ok(__FieldTag::__bytes_found_from_source),
                            "bytes_found_from_source" => Ok(__FieldTag::__bytes_found_from_source),
                            "objectsFoundOnlyFromSink" => {
                                Ok(__FieldTag::__objects_found_only_from_sink)
                            }
                            "objects_found_only_from_sink" => {
                                Ok(__FieldTag::__objects_found_only_from_sink)
                            }
                            "bytesFoundOnlyFromSink" => {
                                Ok(__FieldTag::__bytes_found_only_from_sink)
                            }
                            "bytes_found_only_from_sink" => {
                                Ok(__FieldTag::__bytes_found_only_from_sink)
                            }
                            "objectsFromSourceSkippedBySync" => {
                                Ok(__FieldTag::__objects_from_source_skipped_by_sync)
                            }
                            "objects_from_source_skipped_by_sync" => {
                                Ok(__FieldTag::__objects_from_source_skipped_by_sync)
                            }
                            "bytesFromSourceSkippedBySync" => {
                                Ok(__FieldTag::__bytes_from_source_skipped_by_sync)
                            }
                            "bytes_from_source_skipped_by_sync" => {
                                Ok(__FieldTag::__bytes_from_source_skipped_by_sync)
                            }
                            "objectsCopiedToSink" => Ok(__FieldTag::__objects_copied_to_sink),
                            "objects_copied_to_sink" => Ok(__FieldTag::__objects_copied_to_sink),
                            "bytesCopiedToSink" => Ok(__FieldTag::__bytes_copied_to_sink),
                            "bytes_copied_to_sink" => Ok(__FieldTag::__bytes_copied_to_sink),
                            "objectsDeletedFromSource" => {
                                Ok(__FieldTag::__objects_deleted_from_source)
                            }
                            "objects_deleted_from_source" => {
                                Ok(__FieldTag::__objects_deleted_from_source)
                            }
                            "bytesDeletedFromSource" => Ok(__FieldTag::__bytes_deleted_from_source),
                            "bytes_deleted_from_source" => {
                                Ok(__FieldTag::__bytes_deleted_from_source)
                            }
                            "objectsDeletedFromSink" => Ok(__FieldTag::__objects_deleted_from_sink),
                            "objects_deleted_from_sink" => {
                                Ok(__FieldTag::__objects_deleted_from_sink)
                            }
                            "bytesDeletedFromSink" => Ok(__FieldTag::__bytes_deleted_from_sink),
                            "bytes_deleted_from_sink" => Ok(__FieldTag::__bytes_deleted_from_sink),
                            "objectsFromSourceFailed" => {
                                Ok(__FieldTag::__objects_from_source_failed)
                            }
                            "objects_from_source_failed" => {
                                Ok(__FieldTag::__objects_from_source_failed)
                            }
                            "bytesFromSourceFailed" => Ok(__FieldTag::__bytes_from_source_failed),
                            "bytes_from_source_failed" => {
                                Ok(__FieldTag::__bytes_from_source_failed)
                            }
                            "objectsFailedToDeleteFromSink" => {
                                Ok(__FieldTag::__objects_failed_to_delete_from_sink)
                            }
                            "objects_failed_to_delete_from_sink" => {
                                Ok(__FieldTag::__objects_failed_to_delete_from_sink)
                            }
                            "bytesFailedToDeleteFromSink" => {
                                Ok(__FieldTag::__bytes_failed_to_delete_from_sink)
                            }
                            "bytes_failed_to_delete_from_sink" => {
                                Ok(__FieldTag::__bytes_failed_to_delete_from_sink)
                            }
                            "directoriesFoundFromSource" => {
                                Ok(__FieldTag::__directories_found_from_source)
                            }
                            "directories_found_from_source" => {
                                Ok(__FieldTag::__directories_found_from_source)
                            }
                            "directoriesFailedToListFromSource" => {
                                Ok(__FieldTag::__directories_failed_to_list_from_source)
                            }
                            "directories_failed_to_list_from_source" => {
                                Ok(__FieldTag::__directories_failed_to_list_from_source)
                            }
                            "directoriesSuccessfullyListedFromSource" => {
                                Ok(__FieldTag::__directories_successfully_listed_from_source)
                            }
                            "directories_successfully_listed_from_source" => {
                                Ok(__FieldTag::__directories_successfully_listed_from_source)
                            }
                            "intermediateObjectsCleanedUp" => {
                                Ok(__FieldTag::__intermediate_objects_cleaned_up)
                            }
                            "intermediate_objects_cleaned_up" => {
                                Ok(__FieldTag::__intermediate_objects_cleaned_up)
                            }
                            "intermediateObjectsFailedCleanedUp" => {
                                Ok(__FieldTag::__intermediate_objects_failed_cleaned_up)
                            }
                            "intermediate_objects_failed_cleaned_up" => {
                                Ok(__FieldTag::__intermediate_objects_failed_cleaned_up)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferCounters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferCounters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__objects_found_from_source => {
                            if !fields.insert(__FieldTag::__objects_found_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_found_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_found_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_found_from_source => {
                            if !fields.insert(__FieldTag::__bytes_found_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_found_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_found_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_found_only_from_sink => {
                            if !fields.insert(__FieldTag::__objects_found_only_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_found_only_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_found_only_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_found_only_from_sink => {
                            if !fields.insert(__FieldTag::__bytes_found_only_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_found_only_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_found_only_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_from_source_skipped_by_sync => {
                            if !fields.insert(__FieldTag::__objects_from_source_skipped_by_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_from_source_skipped_by_sync",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_from_source_skipped_by_sync =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_from_source_skipped_by_sync => {
                            if !fields.insert(__FieldTag::__bytes_from_source_skipped_by_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_from_source_skipped_by_sync",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_from_source_skipped_by_sync =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_copied_to_sink => {
                            if !fields.insert(__FieldTag::__objects_copied_to_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_copied_to_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_copied_to_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_copied_to_sink => {
                            if !fields.insert(__FieldTag::__bytes_copied_to_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_copied_to_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_copied_to_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_deleted_from_source => {
                            if !fields.insert(__FieldTag::__objects_deleted_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_deleted_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_deleted_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_deleted_from_source => {
                            if !fields.insert(__FieldTag::__bytes_deleted_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_deleted_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_deleted_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_deleted_from_sink => {
                            if !fields.insert(__FieldTag::__objects_deleted_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_deleted_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_deleted_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_deleted_from_sink => {
                            if !fields.insert(__FieldTag::__bytes_deleted_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_deleted_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_deleted_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_from_source_failed => {
                            if !fields.insert(__FieldTag::__objects_from_source_failed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_from_source_failed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_from_source_failed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_from_source_failed => {
                            if !fields.insert(__FieldTag::__bytes_from_source_failed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_from_source_failed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_from_source_failed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__objects_failed_to_delete_from_sink => {
                            if !fields.insert(__FieldTag::__objects_failed_to_delete_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects_failed_to_delete_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.objects_failed_to_delete_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bytes_failed_to_delete_from_sink => {
                            if !fields.insert(__FieldTag::__bytes_failed_to_delete_from_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_failed_to_delete_from_sink",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_failed_to_delete_from_sink =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__directories_found_from_source => {
                            if !fields.insert(__FieldTag::__directories_found_from_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directories_found_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.directories_found_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__directories_failed_to_list_from_source => {
                            if !fields.insert(__FieldTag::__directories_failed_to_list_from_source)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directories_failed_to_list_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.directories_failed_to_list_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__directories_successfully_listed_from_source => {
                            if !fields
                                .insert(__FieldTag::__directories_successfully_listed_from_source)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directories_successfully_listed_from_source",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.directories_successfully_listed_from_source =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__intermediate_objects_cleaned_up => {
                            if !fields.insert(__FieldTag::__intermediate_objects_cleaned_up) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intermediate_objects_cleaned_up",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intermediate_objects_cleaned_up =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__intermediate_objects_failed_cleaned_up => {
                            if !fields.insert(__FieldTag::__intermediate_objects_failed_cleaned_up)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intermediate_objects_failed_cleaned_up",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intermediate_objects_failed_cleaned_up =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferCounters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.objects_found_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsFoundFromSource",
                &__With(&self.objects_found_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_found_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesFoundFromSource",
                &__With(&self.bytes_found_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.objects_found_only_from_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsFoundOnlyFromSink",
                &__With(&self.objects_found_only_from_sink),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_found_only_from_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesFoundOnlyFromSink",
                &__With(&self.bytes_found_only_from_sink),
            )?;
        }
        if !wkt::internal::is_default(&self.objects_from_source_skipped_by_sync) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsFromSourceSkippedBySync",
                &__With(&self.objects_from_source_skipped_by_sync),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_from_source_skipped_by_sync) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesFromSourceSkippedBySync",
                &__With(&self.bytes_from_source_skipped_by_sync),
            )?;
        }
        if !wkt::internal::is_default(&self.objects_copied_to_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("objectsCopiedToSink", &__With(&self.objects_copied_to_sink))?;
        }
        if !wkt::internal::is_default(&self.bytes_copied_to_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bytesCopiedToSink", &__With(&self.bytes_copied_to_sink))?;
        }
        if !wkt::internal::is_default(&self.objects_deleted_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsDeletedFromSource",
                &__With(&self.objects_deleted_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_deleted_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesDeletedFromSource",
                &__With(&self.bytes_deleted_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.objects_deleted_from_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsDeletedFromSink",
                &__With(&self.objects_deleted_from_sink),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_deleted_from_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesDeletedFromSink",
                &__With(&self.bytes_deleted_from_sink),
            )?;
        }
        if !wkt::internal::is_default(&self.objects_from_source_failed) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsFromSourceFailed",
                &__With(&self.objects_from_source_failed),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_from_source_failed) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesFromSourceFailed",
                &__With(&self.bytes_from_source_failed),
            )?;
        }
        if !wkt::internal::is_default(&self.objects_failed_to_delete_from_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "objectsFailedToDeleteFromSink",
                &__With(&self.objects_failed_to_delete_from_sink),
            )?;
        }
        if !wkt::internal::is_default(&self.bytes_failed_to_delete_from_sink) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "bytesFailedToDeleteFromSink",
                &__With(&self.bytes_failed_to_delete_from_sink),
            )?;
        }
        if !wkt::internal::is_default(&self.directories_found_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "directoriesFoundFromSource",
                &__With(&self.directories_found_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.directories_failed_to_list_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "directoriesFailedToListFromSource",
                &__With(&self.directories_failed_to_list_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.directories_successfully_listed_from_source) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "directoriesSuccessfullyListedFromSource",
                &__With(&self.directories_successfully_listed_from_source),
            )?;
        }
        if !wkt::internal::is_default(&self.intermediate_objects_cleaned_up) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "intermediateObjectsCleanedUp",
                &__With(&self.intermediate_objects_cleaned_up),
            )?;
        }
        if !wkt::internal::is_default(&self.intermediate_objects_failed_cleaned_up) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "intermediateObjectsFailedCleanedUp",
                &__With(&self.intermediate_objects_failed_cleaned_up),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferCounters");
        debug_struct.field("objects_found_from_source", &self.objects_found_from_source);
        debug_struct.field("bytes_found_from_source", &self.bytes_found_from_source);
        debug_struct.field(
            "objects_found_only_from_sink",
            &self.objects_found_only_from_sink,
        );
        debug_struct.field(
            "bytes_found_only_from_sink",
            &self.bytes_found_only_from_sink,
        );
        debug_struct.field(
            "objects_from_source_skipped_by_sync",
            &self.objects_from_source_skipped_by_sync,
        );
        debug_struct.field(
            "bytes_from_source_skipped_by_sync",
            &self.bytes_from_source_skipped_by_sync,
        );
        debug_struct.field("objects_copied_to_sink", &self.objects_copied_to_sink);
        debug_struct.field("bytes_copied_to_sink", &self.bytes_copied_to_sink);
        debug_struct.field(
            "objects_deleted_from_source",
            &self.objects_deleted_from_source,
        );
        debug_struct.field("bytes_deleted_from_source", &self.bytes_deleted_from_source);
        debug_struct.field("objects_deleted_from_sink", &self.objects_deleted_from_sink);
        debug_struct.field("bytes_deleted_from_sink", &self.bytes_deleted_from_sink);
        debug_struct.field(
            "objects_from_source_failed",
            &self.objects_from_source_failed,
        );
        debug_struct.field("bytes_from_source_failed", &self.bytes_from_source_failed);
        debug_struct.field(
            "objects_failed_to_delete_from_sink",
            &self.objects_failed_to_delete_from_sink,
        );
        debug_struct.field(
            "bytes_failed_to_delete_from_sink",
            &self.bytes_failed_to_delete_from_sink,
        );
        debug_struct.field(
            "directories_found_from_source",
            &self.directories_found_from_source,
        );
        debug_struct.field(
            "directories_failed_to_list_from_source",
            &self.directories_failed_to_list_from_source,
        );
        debug_struct.field(
            "directories_successfully_listed_from_source",
            &self.directories_successfully_listed_from_source,
        );
        debug_struct.field(
            "intermediate_objects_cleaned_up",
            &self.intermediate_objects_cleaned_up,
        );
        debug_struct.field(
            "intermediate_objects_failed_cleaned_up",
            &self.intermediate_objects_failed_cleaned_up,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specification to configure notifications published to Pub/Sub.
/// Notifications are published to the customer-provided topic using the
/// following `PubsubMessage.attributes`:
///
/// * `"eventType"`: one of the
///   [EventType][google.storagetransfer.v1.NotificationConfig.EventType] values
/// * `"payloadFormat"`: one of the
///   [PayloadFormat][google.storagetransfer.v1.NotificationConfig.PayloadFormat]
///   values
/// * `"projectId"`: the
///   [project_id][google.storagetransfer.v1.TransferOperation.project_id] of the
///   `TransferOperation`
/// * `"transferJobName"`: the
///   [transfer_job_name][google.storagetransfer.v1.TransferOperation.transfer_job_name]
///   of the `TransferOperation`
/// * `"transferOperationName"`: the
///   [name][google.storagetransfer.v1.TransferOperation.name] of the
///   `TransferOperation`
///
/// The `PubsubMessage.data` contains a
/// [TransferOperation][google.storagetransfer.v1.TransferOperation] resource
/// formatted according to the specified `PayloadFormat`.
///
/// [google.storagetransfer.v1.NotificationConfig.EventType]: crate::model::notification_config::EventType
/// [google.storagetransfer.v1.NotificationConfig.PayloadFormat]: crate::model::notification_config::PayloadFormat
/// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
/// [google.storagetransfer.v1.TransferOperation.name]: crate::model::TransferOperation::name
/// [google.storagetransfer.v1.TransferOperation.project_id]: crate::model::TransferOperation::project_id
/// [google.storagetransfer.v1.TransferOperation.transfer_job_name]: crate::model::TransferOperation::transfer_job_name
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationConfig {
    /// Required. The `Topic.name` of the Pub/Sub topic to which to publish
    /// notifications. Must be of the format: `projects/{project}/topics/{topic}`.
    /// Not matching this format results in an
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    pub pubsub_topic: std::string::String,

    /// Event types for which a notification is desired. If empty, send
    /// notifications for all event types.
    pub event_types: std::vec::Vec<crate::model::notification_config::EventType>,

    /// Required. The desired format of the notification message payloads.
    pub payload_format: crate::model::notification_config::PayloadFormat,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pubsub_topic][crate::model::NotificationConfig::pubsub_topic].
    pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pubsub_topic = v.into();
        self
    }

    /// Sets the value of [event_types][crate::model::NotificationConfig::event_types].
    pub fn set_event_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::notification_config::EventType>,
    {
        use std::iter::Iterator;
        self.event_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [payload_format][crate::model::NotificationConfig::payload_format].
    pub fn set_payload_format<
        T: std::convert::Into<crate::model::notification_config::PayloadFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload_format = v.into();
        self
    }
}

impl wkt::message::Message for NotificationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.NotificationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub_topic,
            __event_types,
            __payload_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsubTopic" => Ok(__FieldTag::__pubsub_topic),
                            "pubsub_topic" => Ok(__FieldTag::__pubsub_topic),
                            "eventTypes" => Ok(__FieldTag::__event_types),
                            "event_types" => Ok(__FieldTag::__event_types),
                            "payloadFormat" => Ok(__FieldTag::__payload_format),
                            "payload_format" => Ok(__FieldTag::__payload_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub_topic => {
                            if !fields.insert(__FieldTag::__pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_topic",
                                ));
                            }
                            result.pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_types => {
                            if !fields.insert(__FieldTag::__event_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_types",
                                ));
                            }
                            result.event_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::notification_config::EventType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload_format => {
                            if !fields.insert(__FieldTag::__payload_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload_format",
                                ));
                            }
                            result.payload_format = map
                                .next_value::<std::option::Option<
                                    crate::model::notification_config::PayloadFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotificationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pubsub_topic.is_empty() {
            state.serialize_entry("pubsubTopic", &self.pubsub_topic)?;
        }
        if !self.event_types.is_empty() {
            state.serialize_entry("eventTypes", &self.event_types)?;
        }
        if !wkt::internal::is_default(&self.payload_format) {
            state.serialize_entry("payloadFormat", &self.payload_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NotificationConfig");
        debug_struct.field("pubsub_topic", &self.pubsub_topic);
        debug_struct.field("event_types", &self.event_types);
        debug_struct.field("payload_format", &self.payload_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NotificationConfig].
pub mod notification_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for specifying event types for which notifications are to be
    /// published.
    ///
    /// Additional event types may be added in the future. Clients should either
    /// safely ignore unrecognized event types or explicitly specify which event
    /// types they are prepared to accept.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Illegal value, to avoid allowing a default.
        Unspecified,
        /// `TransferOperation` completed with status
        /// [SUCCESS][google.storagetransfer.v1.TransferOperation.Status.SUCCESS].
        ///
        /// [google.storagetransfer.v1.TransferOperation.Status.SUCCESS]: crate::model::transfer_operation::Status::Success
        TransferOperationSuccess,
        /// `TransferOperation` completed with status
        /// [FAILED][google.storagetransfer.v1.TransferOperation.Status.FAILED].
        ///
        /// [google.storagetransfer.v1.TransferOperation.Status.FAILED]: crate::model::transfer_operation::Status::Failed
        TransferOperationFailed,
        /// `TransferOperation` completed with status
        /// [ABORTED][google.storagetransfer.v1.TransferOperation.Status.ABORTED].
        ///
        /// [google.storagetransfer.v1.TransferOperation.Status.ABORTED]: crate::model::transfer_operation::Status::Aborted
        TransferOperationAborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TransferOperationSuccess => std::option::Option::Some(1),
                Self::TransferOperationFailed => std::option::Option::Some(2),
                Self::TransferOperationAborted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::TransferOperationSuccess => {
                    std::option::Option::Some("TRANSFER_OPERATION_SUCCESS")
                }
                Self::TransferOperationFailed => {
                    std::option::Option::Some("TRANSFER_OPERATION_FAILED")
                }
                Self::TransferOperationAborted => {
                    std::option::Option::Some("TRANSFER_OPERATION_ABORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TransferOperationSuccess,
                2 => Self::TransferOperationFailed,
                3 => Self::TransferOperationAborted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TRANSFER_OPERATION_SUCCESS" => Self::TransferOperationSuccess,
                "TRANSFER_OPERATION_FAILED" => Self::TransferOperationFailed,
                "TRANSFER_OPERATION_ABORTED" => Self::TransferOperationAborted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TransferOperationSuccess => serializer.serialize_i32(1),
                Self::TransferOperationFailed => serializer.serialize_i32(2),
                Self::TransferOperationAborted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.storagetransfer.v1.NotificationConfig.EventType",
            ))
        }
    }

    /// Enum for specifying the format of a notification message's payload.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PayloadFormat {
        /// Illegal value, to avoid allowing a default.
        Unspecified,
        /// No payload is included with the notification.
        None,
        /// `TransferOperation` is [formatted as a JSON
        /// response](https://developers.google.com/protocol-buffers/docs/proto3#json),
        /// in application/json.
        Json,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PayloadFormat::value] or
        /// [PayloadFormat::name].
        UnknownValue(payload_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod payload_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PayloadFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PAYLOAD_FORMAT_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PayloadFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PayloadFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PayloadFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Json,
                _ => Self::UnknownValue(payload_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PayloadFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PAYLOAD_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "JSON" => Self::Json,
                _ => Self::UnknownValue(payload_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PayloadFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PayloadFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PayloadFormat>::new(
                ".google.storagetransfer.v1.NotificationConfig.PayloadFormat",
            ))
        }
    }
}

/// Specifies the logging behavior for transfer operations.
///
/// Logs can be sent to Cloud Logging for all transfer types. See
/// [Read transfer
/// logs](https://cloud.google.com/storage-transfer/docs/read-transfer-logs) for
/// details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Specifies the actions to be logged. If empty, no logs are generated.
    pub log_actions: std::vec::Vec<crate::model::logging_config::LoggableAction>,

    /// States in which `log_actions` are logged. If empty, no logs are generated.
    pub log_action_states: std::vec::Vec<crate::model::logging_config::LoggableActionState>,

    /// For PosixFilesystem transfers, enables
    /// [file system transfer
    /// logs](https://cloud.google.com/storage-transfer/docs/on-prem-transfer-log-format)
    /// instead of, or in addition to, Cloud Logging.
    ///
    /// This option ignores [LoggableAction] and [LoggableActionState]. If these
    /// are set, Cloud Logging will also be enabled for this transfer.
    pub enable_onprem_gcs_transfer_logs: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_actions][crate::model::LoggingConfig::log_actions].
    pub fn set_log_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_config::LoggableAction>,
    {
        use std::iter::Iterator;
        self.log_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [log_action_states][crate::model::LoggingConfig::log_action_states].
    pub fn set_log_action_states<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_config::LoggableActionState>,
    {
        use std::iter::Iterator;
        self.log_action_states = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_onprem_gcs_transfer_logs][crate::model::LoggingConfig::enable_onprem_gcs_transfer_logs].
    pub fn set_enable_onprem_gcs_transfer_logs<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_onprem_gcs_transfer_logs = v.into();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.LoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_actions,
            __log_action_states,
            __enable_onprem_gcs_transfer_logs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logActions" => Ok(__FieldTag::__log_actions),
                            "log_actions" => Ok(__FieldTag::__log_actions),
                            "logActionStates" => Ok(__FieldTag::__log_action_states),
                            "log_action_states" => Ok(__FieldTag::__log_action_states),
                            "enableOnpremGcsTransferLogs" => {
                                Ok(__FieldTag::__enable_onprem_gcs_transfer_logs)
                            }
                            "enable_onprem_gcs_transfer_logs" => {
                                Ok(__FieldTag::__enable_onprem_gcs_transfer_logs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_actions => {
                            if !fields.insert(__FieldTag::__log_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_actions",
                                ));
                            }
                            result.log_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::logging_config::LoggableAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_action_states => {
                            if !fields.insert(__FieldTag::__log_action_states) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_action_states",
                                ));
                            }
                            result.log_action_states = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::logging_config::LoggableActionState,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_onprem_gcs_transfer_logs => {
                            if !fields.insert(__FieldTag::__enable_onprem_gcs_transfer_logs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_onprem_gcs_transfer_logs",
                                ));
                            }
                            result.enable_onprem_gcs_transfer_logs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_actions.is_empty() {
            state.serialize_entry("logActions", &self.log_actions)?;
        }
        if !self.log_action_states.is_empty() {
            state.serialize_entry("logActionStates", &self.log_action_states)?;
        }
        if !wkt::internal::is_default(&self.enable_onprem_gcs_transfer_logs) {
            state.serialize_entry(
                "enableOnpremGcsTransferLogs",
                &self.enable_onprem_gcs_transfer_logs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingConfig");
        debug_struct.field("log_actions", &self.log_actions);
        debug_struct.field("log_action_states", &self.log_action_states);
        debug_struct.field(
            "enable_onprem_gcs_transfer_logs",
            &self.enable_onprem_gcs_transfer_logs,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LoggingConfig].
pub mod logging_config {
    #[allow(unused_imports)]
    use super::*;

    /// Loggable actions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoggableAction {
        /// Default value. This value is unused.
        Unspecified,
        /// Listing objects in a bucket.
        Find,
        /// Deleting objects at the source or the destination.
        Delete,
        /// Copying objects to the destination.
        Copy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoggableAction::value] or
        /// [LoggableAction::name].
        UnknownValue(loggable_action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod loggable_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoggableAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Find => std::option::Option::Some(1),
                Self::Delete => std::option::Option::Some(2),
                Self::Copy => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOGGABLE_ACTION_UNSPECIFIED"),
                Self::Find => std::option::Option::Some("FIND"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Copy => std::option::Option::Some("COPY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoggableAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoggableAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoggableAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Find,
                2 => Self::Delete,
                3 => Self::Copy,
                _ => Self::UnknownValue(loggable_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoggableAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOGGABLE_ACTION_UNSPECIFIED" => Self::Unspecified,
                "FIND" => Self::Find,
                "DELETE" => Self::Delete,
                "COPY" => Self::Copy,
                _ => Self::UnknownValue(loggable_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoggableAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Find => serializer.serialize_i32(1),
                Self::Delete => serializer.serialize_i32(2),
                Self::Copy => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoggableAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoggableAction>::new(
                ".google.storagetransfer.v1.LoggingConfig.LoggableAction",
            ))
        }
    }

    /// Loggable action states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoggableActionState {
        /// Default value. This value is unused.
        Unspecified,
        /// `LoggableAction` completed successfully. `SUCCEEDED` actions are
        /// logged as [INFO][google.logging.type.LogSeverity.INFO].
        Succeeded,
        /// `LoggableAction` terminated in an error state. `FAILED` actions are
        /// logged as [ERROR][google.logging.type.LogSeverity.ERROR].
        Failed,
        /// The `COPY` action was skipped for this file. Only supported for
        /// agent-based transfers. `SKIPPED` actions are
        /// logged as [INFO][google.logging.type.LogSeverity.INFO].
        Skipped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoggableActionState::value] or
        /// [LoggableActionState::name].
        UnknownValue(loggable_action_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod loggable_action_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoggableActionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Skipped => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOGGABLE_ACTION_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoggableActionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoggableActionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoggableActionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::Skipped,
                _ => Self::UnknownValue(loggable_action_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoggableActionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOGGABLE_ACTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "SKIPPED" => Self::Skipped,
                _ => Self::UnknownValue(loggable_action_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoggableActionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Skipped => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoggableActionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoggableActionState>::new(
                ".google.storagetransfer.v1.LoggingConfig.LoggableActionState",
            ))
        }
    }
}

/// A description of the execution of a transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferOperation {
    /// A globally unique ID assigned by the system.
    pub name: std::string::String,

    /// The ID of the Google Cloud project that owns the operation.
    pub project_id: std::string::String,

    /// Transfer specification.
    pub transfer_spec: std::option::Option<crate::model::TransferSpec>,

    /// Notification configuration.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Cloud Logging configuration.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Start time of this transfer execution.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of this transfer execution.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Status of the transfer operation.
    pub status: crate::model::transfer_operation::Status,

    /// Information about the progress of the transfer operation.
    pub counters: std::option::Option<crate::model::TransferCounters>,

    /// Summarizes errors encountered with sample error log entries.
    pub error_breakdowns: std::vec::Vec<crate::model::ErrorSummary>,

    /// The name of the transfer job that triggers this transfer operation.
    pub transfer_job_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransferOperation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::TransferOperation::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [transfer_spec][crate::model::TransferOperation::transfer_spec].
    pub fn set_transfer_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_spec][crate::model::TransferOperation::transfer_spec].
    pub fn set_or_clear_transfer_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_config][crate::model::TransferOperation::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::TransferOperation::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::TransferOperation::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::TransferOperation::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::TransferOperation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TransferOperation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TransferOperation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TransferOperation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::TransferOperation::status].
    pub fn set_status<T: std::convert::Into<crate::model::transfer_operation::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [counters][crate::model::TransferOperation::counters].
    pub fn set_counters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferCounters>,
    {
        self.counters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [counters][crate::model::TransferOperation::counters].
    pub fn set_or_clear_counters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferCounters>,
    {
        self.counters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_breakdowns][crate::model::TransferOperation::error_breakdowns].
    pub fn set_error_breakdowns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorSummary>,
    {
        use std::iter::Iterator;
        self.error_breakdowns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transfer_job_name][crate::model::TransferOperation::transfer_job_name].
    pub fn set_transfer_job_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_job_name = v.into();
        self
    }
}

impl wkt::message::Message for TransferOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __transfer_spec,
            __notification_config,
            __logging_config,
            __start_time,
            __end_time,
            __status,
            __counters,
            __error_breakdowns,
            __transfer_job_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "transferSpec" => Ok(__FieldTag::__transfer_spec),
                            "transfer_spec" => Ok(__FieldTag::__transfer_spec),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "status" => Ok(__FieldTag::__status),
                            "counters" => Ok(__FieldTag::__counters),
                            "errorBreakdowns" => Ok(__FieldTag::__error_breakdowns),
                            "error_breakdowns" => Ok(__FieldTag::__error_breakdowns),
                            "transferJobName" => Ok(__FieldTag::__transfer_job_name),
                            "transfer_job_name" => Ok(__FieldTag::__transfer_job_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_spec => {
                            if !fields.insert(__FieldTag::__transfer_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_spec",
                                ));
                            }
                            result.transfer_spec = map
                                .next_value::<std::option::Option<crate::model::TransferSpec>>()?;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::transfer_operation::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::__counters => {
                            if !fields.insert(__FieldTag::__counters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for counters",
                                ));
                            }
                            result.counters = map
                                .next_value::<std::option::Option<crate::model::TransferCounters>>(
                                )?;
                        }
                        __FieldTag::__error_breakdowns => {
                            if !fields.insert(__FieldTag::__error_breakdowns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_breakdowns",
                                ));
                            }
                            result.error_breakdowns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorSummary>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transfer_job_name => {
                            if !fields.insert(__FieldTag::__transfer_job_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_job_name",
                                ));
                            }
                            result.transfer_job_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.transfer_spec.is_some() {
            state.serialize_entry("transferSpec", &self.transfer_spec)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if self.counters.is_some() {
            state.serialize_entry("counters", &self.counters)?;
        }
        if !self.error_breakdowns.is_empty() {
            state.serialize_entry("errorBreakdowns", &self.error_breakdowns)?;
        }
        if !self.transfer_job_name.is_empty() {
            state.serialize_entry("transferJobName", &self.transfer_job_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferOperation");
        debug_struct.field("name", &self.name);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("transfer_spec", &self.transfer_spec);
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("status", &self.status);
        debug_struct.field("counters", &self.counters);
        debug_struct.field("error_breakdowns", &self.error_breakdowns);
        debug_struct.field("transfer_job_name", &self.transfer_job_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferOperation].
pub mod transfer_operation {
    #[allow(unused_imports)]
    use super::*;

    /// The status of a TransferOperation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Zero is an illegal value.
        Unspecified,
        /// In progress.
        InProgress,
        /// Paused.
        Paused,
        /// Completed successfully.
        Success,
        /// Terminated due to an unrecoverable failure.
        Failed,
        /// Aborted by the user.
        Aborted,
        /// Temporarily delayed by the system. No user action is required.
        Queued,
        /// The operation is suspending and draining the ongoing work to completion.
        Suspending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Success => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Aborted => std::option::Option::Some(5),
                Self::Queued => std::option::Option::Some(6),
                Self::Suspending => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Paused,
                3 => Self::Success,
                4 => Self::Failed,
                5 => Self::Aborted,
                6 => Self::Queued,
                7 => Self::Suspending,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "PAUSED" => Self::Paused,
                "SUCCESS" => Self::Success,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                "QUEUED" => Self::Queued,
                "SUSPENDING" => Self::Suspending,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Success => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Aborted => serializer.serialize_i32(5),
                Self::Queued => serializer.serialize_i32(6),
                Self::Suspending => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.storagetransfer.v1.TransferOperation.Status",
            ))
        }
    }
}
