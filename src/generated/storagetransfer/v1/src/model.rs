// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request passed to GetGoogleServiceAccount.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGoogleServiceAccountRequest {
    /// Required. The ID of the Google Cloud project that the Google service
    /// account is associated with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGoogleServiceAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetGoogleServiceAccountRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GetGoogleServiceAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GetGoogleServiceAccountRequest"
    }
}

/// Request passed to CreateTransferJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTransferJobRequest {
    /// Required. The job to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_job: std::option::Option<crate::model::TransferJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_job][crate::model::CreateTransferJobRequest::transfer_job].
    pub fn set_transfer_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_job][crate::model::CreateTransferJobRequest::transfer_job].
    pub fn set_or_clear_transfer_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.CreateTransferJobRequest"
    }
}

/// Request passed to UpdateTransferJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTransferJobRequest {
    /// Required. The name of job to update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The job to update. `transferJob` is expected to specify one or
    /// more of five fields:
    /// [description][google.storagetransfer.v1.TransferJob.description],
    /// [transfer_spec][google.storagetransfer.v1.TransferJob.transfer_spec],
    /// [notification_config][google.storagetransfer.v1.TransferJob.notification_config],
    /// [logging_config][google.storagetransfer.v1.TransferJob.logging_config], and
    /// [status][google.storagetransfer.v1.TransferJob.status].  An
    /// `UpdateTransferJobRequest` that specifies other fields are rejected with
    /// the error [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. Updating a
    /// job status to
    /// [DELETED][google.storagetransfer.v1.TransferJob.Status.DELETED] requires
    /// `storagetransfer.jobs.delete` permission.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.TransferJob.Status.DELETED]: crate::model::transfer_job::Status::Deleted
    /// [google.storagetransfer.v1.TransferJob.description]: crate::model::TransferJob::description
    /// [google.storagetransfer.v1.TransferJob.logging_config]: crate::model::TransferJob::logging_config
    /// [google.storagetransfer.v1.TransferJob.notification_config]: crate::model::TransferJob::notification_config
    /// [google.storagetransfer.v1.TransferJob.status]: crate::model::TransferJob::status
    /// [google.storagetransfer.v1.TransferJob.transfer_spec]: crate::model::TransferJob::transfer_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_job: std::option::Option<crate::model::TransferJob>,

    /// The field mask of the fields in `transferJob` that are to be updated in
    /// this request.  Fields in `transferJob` that can be updated are:
    /// [description][google.storagetransfer.v1.TransferJob.description],
    /// [transfer_spec][google.storagetransfer.v1.TransferJob.transfer_spec],
    /// [notification_config][google.storagetransfer.v1.TransferJob.notification_config],
    /// [logging_config][google.storagetransfer.v1.TransferJob.logging_config], and
    /// [status][google.storagetransfer.v1.TransferJob.status].  To update the
    /// `transfer_spec` of the job, a complete transfer specification must be
    /// provided. An incomplete specification missing any required fields is
    /// rejected with the error
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.TransferJob.description]: crate::model::TransferJob::description
    /// [google.storagetransfer.v1.TransferJob.logging_config]: crate::model::TransferJob::logging_config
    /// [google.storagetransfer.v1.TransferJob.notification_config]: crate::model::TransferJob::notification_config
    /// [google.storagetransfer.v1.TransferJob.status]: crate::model::TransferJob::status
    /// [google.storagetransfer.v1.TransferJob.transfer_spec]: crate::model::TransferJob::transfer_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_transfer_job_field_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::UpdateTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::UpdateTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [transfer_job][crate::model::UpdateTransferJobRequest::transfer_job].
    pub fn set_transfer_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_job][crate::model::UpdateTransferJobRequest::transfer_job].
    pub fn set_or_clear_transfer_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferJob>,
    {
        self.transfer_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_transfer_job_field_mask][crate::model::UpdateTransferJobRequest::update_transfer_job_field_mask].
    pub fn set_update_transfer_job_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_transfer_job_field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_transfer_job_field_mask][crate::model::UpdateTransferJobRequest::update_transfer_job_field_mask].
    pub fn set_or_clear_update_transfer_job_field_mask<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_transfer_job_field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.UpdateTransferJobRequest"
    }
}

/// Request passed to GetTransferJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTransferJobRequest {
    /// Required. The job to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::GetTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::GetTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GetTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GetTransferJobRequest"
    }
}

/// Request passed to DeleteTransferJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTransferJobRequest {
    /// Required. The job to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::DeleteTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DeleteTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.DeleteTransferJobRequest"
    }
}

/// `projectId`, `jobNames`, and `jobStatuses` are query parameters that can
/// be specified when listing transfer jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTransferJobsRequest {
    /// Required. A list of query parameters specified as JSON text in the form of:
    ///
    /// ```norust
    /// {
    ///   "projectId":"my_project_id",
    ///   "jobNames":["jobid1","jobid2",...],
    ///   "jobStatuses":["status1","status2",...],
    ///   "dataBackend":"QUERY_REPLICATION_CONFIGS",
    ///   "sourceBucket":"source-bucket-name",
    ///   "sinkBucket":"sink-bucket-name",
    /// }
    /// ```
    ///
    /// The JSON formatting in the example is for display only; provide the
    /// query parameters without spaces or line breaks.
    ///
    /// * `projectId` is required.
    /// * Since `jobNames` and `jobStatuses` support multiple values, their values
    ///   must be specified with array notation. `jobNames` and `jobStatuses` are
    ///   optional. Valid values are case-insensitive:
    ///   * [ENABLED][google.storagetransfer.v1.TransferJob.Status.ENABLED]
    ///   * [DISABLED][google.storagetransfer.v1.TransferJob.Status.DISABLED]
    ///   * [DELETED][google.storagetransfer.v1.TransferJob.Status.DELETED]
    /// * Specify `"dataBackend":"QUERY_REPLICATION_CONFIGS"` to return a list of
    ///   cross-bucket replication jobs.
    /// * Limit the results to jobs from a particular bucket with `sourceBucket`
    ///   and/or to a particular bucket with `sinkBucket`.
    ///
    /// [google.storagetransfer.v1.TransferJob.Status.DELETED]: crate::model::transfer_job::Status::Deleted
    /// [google.storagetransfer.v1.TransferJob.Status.DISABLED]: crate::model::transfer_job::Status::Disabled
    /// [google.storagetransfer.v1.TransferJob.Status.ENABLED]: crate::model::transfer_job::Status::Enabled
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The list page size. The max allowed value is 256.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// The list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::ListTransferJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTransferJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTransferJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListTransferJobsRequest"
    }
}

/// Response from ListTransferJobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTransferJobsResponse {
    /// A list of transfer jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transfer_jobs: std::vec::Vec<crate::model::TransferJob>,

    /// The list next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_jobs][crate::model::ListTransferJobsResponse::transfer_jobs].
    pub fn set_transfer_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferJob>,
    {
        use std::iter::Iterator;
        self.transfer_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTransferJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListTransferJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTransferJobsResponse {
    type PageItem = crate::model::TransferJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.transfer_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request passed to PauseTransferOperation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseTransferOperationRequest {
    /// Required. The name of the transfer operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseTransferOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseTransferOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseTransferOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.PauseTransferOperationRequest"
    }
}

/// Request passed to ResumeTransferOperation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeTransferOperationRequest {
    /// Required. The name of the transfer operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeTransferOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeTransferOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeTransferOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ResumeTransferOperationRequest"
    }
}

/// Request passed to RunTransferJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunTransferJobRequest {
    /// Required. The name of the transfer job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_name: std::string::String,

    /// Required. The ID of the Google Cloud project that owns the transfer
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTransferJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_name][crate::model::RunTransferJobRequest::job_name].
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::RunTransferJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for RunTransferJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.RunTransferJobRequest"
    }
}

/// Specifies the request passed to CreateAgentPool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAgentPoolRequest {
    /// Required. The ID of the Google Cloud project that owns the
    /// agent pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The agent pool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub agent_pool: std::option::Option<crate::model::AgentPool>,

    /// Required. The ID of the agent pool to create.
    ///
    /// The `agent_pool_id` must meet the following requirements:
    ///
    /// * Length of 128 characters or less.
    /// * Not start with the string `goog`.
    /// * Start with a lowercase ASCII character, followed by:
    ///   * Zero or more: lowercase Latin alphabet characters, numerals,
    ///     hyphens (`-`), periods (`.`), underscores (`_`), or tildes (`~`).
    ///   * One or more numerals or lowercase ASCII characters.
    ///
    /// As expressed by the regular expression:
    /// `^(?!goog)[a-z]([a-z0-9-._~]*[a-z0-9])?$`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub agent_pool_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateAgentPoolRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [agent_pool][crate::model::CreateAgentPoolRequest::agent_pool].
    pub fn set_agent_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent_pool][crate::model::CreateAgentPoolRequest::agent_pool].
    pub fn set_or_clear_agent_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [agent_pool_id][crate::model::CreateAgentPoolRequest::agent_pool_id].
    pub fn set_agent_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_pool_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.CreateAgentPoolRequest"
    }
}

/// Specifies the request passed to UpdateAgentPool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAgentPoolRequest {
    /// Required. The agent pool to update. `agent_pool` is expected to specify
    /// following fields:
    ///
    /// * [name][google.storagetransfer.v1.AgentPool.name]
    ///
    /// * [display_name][google.storagetransfer.v1.AgentPool.display_name]
    ///
    /// * [bandwidth_limit][google.storagetransfer.v1.AgentPool.bandwidth_limit]
    ///   An `UpdateAgentPoolRequest` with any other fields is rejected
    ///   with the error [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
    ///
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.AgentPool.bandwidth_limit]: crate::model::AgentPool::bandwidth_limit
    /// [google.storagetransfer.v1.AgentPool.display_name]: crate::model::AgentPool::display_name
    /// [google.storagetransfer.v1.AgentPool.name]: crate::model::AgentPool::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub agent_pool: std::option::Option<crate::model::AgentPool>,

    /// The [field mask]
    /// (<https://developers.google.com/protocol-buffers/docs/reference/google.protobuf>)
    /// of the fields in `agentPool` to update in this request.
    /// The following `agentPool` fields can be updated:
    ///
    /// * [display_name][google.storagetransfer.v1.AgentPool.display_name]
    ///
    /// * [bandwidth_limit][google.storagetransfer.v1.AgentPool.bandwidth_limit]
    ///
    ///
    /// [google.storagetransfer.v1.AgentPool.bandwidth_limit]: crate::model::AgentPool::bandwidth_limit
    /// [google.storagetransfer.v1.AgentPool.display_name]: crate::model::AgentPool::display_name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent_pool][crate::model::UpdateAgentPoolRequest::agent_pool].
    pub fn set_agent_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent_pool][crate::model::UpdateAgentPoolRequest::agent_pool].
    pub fn set_or_clear_agent_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AgentPool>,
    {
        self.agent_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAgentPoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAgentPoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.UpdateAgentPoolRequest"
    }
}

/// Specifies the request passed to GetAgentPool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAgentPoolRequest {
    /// Required. The name of the agent pool to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAgentPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GetAgentPoolRequest"
    }
}

/// Specifies the request passed to DeleteAgentPool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAgentPoolRequest {
    /// Required. The name of the agent pool to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAgentPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAgentPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAgentPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.DeleteAgentPoolRequest"
    }
}

/// The request passed to ListAgentPools.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAgentPoolsRequest {
    /// Required. The ID of the Google Cloud project that owns the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// An optional list of query parameters specified as JSON text in the
    /// form of:
    ///
    /// `{"agentPoolNames":["agentpool1","agentpool2",...]}`
    ///
    /// Since `agentPoolNames` support multiple values, its values must be
    /// specified with array notation. When the filter is either empty or not
    /// provided, the list returns all agent pools for the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The list page size. The max allowed value is `256`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// The list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAgentPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListAgentPoolsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAgentPoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAgentPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAgentPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAgentPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListAgentPoolsRequest"
    }
}

/// Response from ListAgentPools.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAgentPoolsResponse {
    /// A list of agent pools.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub agent_pools: std::vec::Vec<crate::model::AgentPool>,

    /// The list next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAgentPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent_pools][crate::model::ListAgentPoolsResponse::agent_pools].
    pub fn set_agent_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AgentPool>,
    {
        use std::iter::Iterator;
        self.agent_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAgentPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAgentPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ListAgentPoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAgentPoolsResponse {
    type PageItem = crate::model::AgentPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.agent_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Google service account
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleServiceAccount {
    /// Email address of the service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_email: std::string::String,

    /// Unique identifier for the service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_email][crate::model::GoogleServiceAccount::account_email].
    pub fn set_account_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_email = v.into();
        self
    }

    /// Sets the value of [subject_id][crate::model::GoogleServiceAccount::subject_id].
    pub fn set_subject_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_id = v.into();
        self
    }
}

impl wkt::message::Message for GoogleServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GoogleServiceAccount"
    }
}

/// AWS access key (see
/// [AWS Security
/// Credentials](https://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html)).
///
/// For information on our data retention policy for user credentials, see
/// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAccessKey {
    /// Required. AWS access key ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_key_id: std::string::String,

    /// Required. AWS secret access key. This field is not returned in RPC
    /// responses.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_access_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccessKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_key_id][crate::model::AwsAccessKey::access_key_id].
    pub fn set_access_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_key_id = v.into();
        self
    }

    /// Sets the value of [secret_access_key][crate::model::AwsAccessKey::secret_access_key].
    pub fn set_secret_access_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_access_key = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccessKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AwsAccessKey"
    }
}

/// Azure credentials
///
/// For information on our data retention policy for user credentials, see
/// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureCredentials {
    /// Required. Azure shared access signature (SAS).
    ///
    /// For more information about SAS, see
    /// [Grant limited access to Azure Storage resources using shared access
    /// signatures
    /// (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sas_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureCredentials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sas_token][crate::model::AzureCredentials::sas_token].
    pub fn set_sas_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sas_token = v.into();
        self
    }
}

impl wkt::message::Message for AzureCredentials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AzureCredentials"
    }
}

/// Conditions that determine which objects are transferred. Applies only
/// to Cloud Data Sources such as S3, Azure, and Cloud Storage.
///
/// The "last modification time" refers to the time of the
/// last change to the object's content or metadata â€” specifically, this is
/// the `updated` property of Cloud Storage objects, the `LastModified` field
/// of S3 objects, and the `Last-Modified` header of Azure blobs.
///
/// Transfers with a [PosixFilesystem][google.storagetransfer.v1.PosixFilesystem]
/// source or destination don't support `ObjectConditions`.
///
/// [google.storagetransfer.v1.PosixFilesystem]: crate::model::PosixFilesystem
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ObjectConditions {
    /// Ensures that objects are not transferred until a specific minimum time
    /// has elapsed after the "last modification time". When a
    /// [TransferOperation][google.storagetransfer.v1.TransferOperation] begins,
    /// objects with a "last modification time" are transferred only if the elapsed
    /// time between the
    /// [start_time][google.storagetransfer.v1.TransferOperation.start_time] of the
    /// `TransferOperation` and the "last modification time" of the object is equal
    /// to or greater than the value of min_time_elapsed_since_last_modification`.
    /// Objects that do not have a "last modification time" are also transferred.
    ///
    /// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
    /// [google.storagetransfer.v1.TransferOperation.start_time]: crate::model::TransferOperation::start_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_time_elapsed_since_last_modification: std::option::Option<wkt::Duration>,

    /// Ensures that objects are not transferred if a specific maximum time
    /// has elapsed since the "last modification time".
    /// When a [TransferOperation][google.storagetransfer.v1.TransferOperation]
    /// begins, objects with a "last modification time" are transferred only if the
    /// elapsed time between the
    /// [start_time][google.storagetransfer.v1.TransferOperation.start_time] of the
    /// `TransferOperation`and the "last modification time" of the object
    /// is less than the value of max_time_elapsed_since_last_modification`.
    /// Objects that do not have a "last modification time" are also transferred.
    ///
    /// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
    /// [google.storagetransfer.v1.TransferOperation.start_time]: crate::model::TransferOperation::start_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_time_elapsed_since_last_modification: std::option::Option<wkt::Duration>,

    /// If you specify `include_prefixes`, Storage Transfer Service uses the items
    /// in the `include_prefixes` array to determine which objects to include in a
    /// transfer. Objects must start with one of the matching `include_prefixes`
    /// for inclusion in the transfer. If
    /// [exclude_prefixes][google.storagetransfer.v1.ObjectConditions.exclude_prefixes]
    /// is specified, objects must not start with any of the `exclude_prefixes`
    /// specified for inclusion in the transfer.
    ///
    /// The following are requirements of `include_prefixes`:
    ///
    /// * Each include-prefix can contain any sequence of Unicode characters, to
    ///   a max length of 1024 bytes when UTF8-encoded, and must not contain
    ///   Carriage Return or Line Feed characters.  Wildcard matching and regular
    ///   expression matching are not supported.
    ///
    /// * Each include-prefix must omit the leading slash. For example, to
    ///   include the object `s3://my-aws-bucket/logs/y=2015/requests.gz`,
    ///   specify the include-prefix as `logs/y=2015/requests.gz`.
    ///
    /// * None of the include-prefix values can be empty, if specified.
    ///
    /// * Each include-prefix must include a distinct portion of the object
    ///   namespace. No include-prefix may be a prefix of another
    ///   include-prefix.
    ///
    ///
    /// The max size of `include_prefixes` is 1000.
    ///
    /// For more information, see [Filtering objects from
    /// transfers](/storage-transfer/docs/filtering-objects-from-transfers).
    ///
    /// [google.storagetransfer.v1.ObjectConditions.exclude_prefixes]: crate::model::ObjectConditions::exclude_prefixes
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub include_prefixes: std::vec::Vec<std::string::String>,

    /// If you specify `exclude_prefixes`, Storage Transfer Service uses the items
    /// in the `exclude_prefixes` array to determine which objects to exclude from
    /// a transfer. Objects must not start with one of the matching
    /// `exclude_prefixes` for inclusion in a transfer.
    ///
    /// The following are requirements of `exclude_prefixes`:
    ///
    /// * Each exclude-prefix can contain any sequence of Unicode characters, to
    ///   a max length of 1024 bytes when UTF8-encoded, and must not contain
    ///   Carriage Return or Line Feed characters.  Wildcard matching and regular
    ///   expression matching are not supported.
    ///
    /// * Each exclude-prefix must omit the leading slash. For example, to
    ///   exclude the object `s3://my-aws-bucket/logs/y=2015/requests.gz`,
    ///   specify the exclude-prefix as `logs/y=2015/requests.gz`.
    ///
    /// * None of the exclude-prefix values can be empty, if specified.
    ///
    /// * Each exclude-prefix must exclude a distinct portion of the object
    ///   namespace. No exclude-prefix may be a prefix of another
    ///   exclude-prefix.
    ///
    /// * If
    ///   [include_prefixes][google.storagetransfer.v1.ObjectConditions.include_prefixes]
    ///   is specified, then each exclude-prefix must start with the value of a
    ///   path explicitly included by `include_prefixes`.
    ///
    ///
    /// The max size of `exclude_prefixes` is 1000.
    ///
    /// For more information, see [Filtering objects from
    /// transfers](/storage-transfer/docs/filtering-objects-from-transfers).
    ///
    /// [google.storagetransfer.v1.ObjectConditions.include_prefixes]: crate::model::ObjectConditions::include_prefixes
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclude_prefixes: std::vec::Vec<std::string::String>,

    /// If specified, only objects with a "last modification time" on or after
    /// this timestamp and objects that don't have a "last modification time" are
    /// transferred.
    ///
    /// The `last_modified_since` and `last_modified_before` fields can be used
    /// together for chunked data processing. For example, consider a script that
    /// processes each day's worth of data at a time. For that you'd set each
    /// of the fields as follows:
    ///
    /// * `last_modified_since` to the start of the day
    ///
    /// * `last_modified_before` to the end of the day
    ///
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_since: std::option::Option<wkt::Timestamp>,

    /// If specified, only objects with a "last modification time" before this
    /// timestamp and objects that don't have a "last modification time" are
    /// transferred.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_before: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectConditions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_time_elapsed_since_last_modification][crate::model::ObjectConditions::min_time_elapsed_since_last_modification].
    pub fn set_min_time_elapsed_since_last_modification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_time_elapsed_since_last_modification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_time_elapsed_since_last_modification][crate::model::ObjectConditions::min_time_elapsed_since_last_modification].
    pub fn set_or_clear_min_time_elapsed_since_last_modification<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_time_elapsed_since_last_modification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_time_elapsed_since_last_modification][crate::model::ObjectConditions::max_time_elapsed_since_last_modification].
    pub fn set_max_time_elapsed_since_last_modification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_time_elapsed_since_last_modification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_time_elapsed_since_last_modification][crate::model::ObjectConditions::max_time_elapsed_since_last_modification].
    pub fn set_or_clear_max_time_elapsed_since_last_modification<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_time_elapsed_since_last_modification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [include_prefixes][crate::model::ObjectConditions::include_prefixes].
    pub fn set_include_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_prefixes][crate::model::ObjectConditions::exclude_prefixes].
    pub fn set_exclude_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [last_modified_since][crate::model::ObjectConditions::last_modified_since].
    pub fn set_last_modified_since<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_since = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_since][crate::model::ObjectConditions::last_modified_since].
    pub fn set_or_clear_last_modified_since<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_since = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified_before][crate::model::ObjectConditions::last_modified_before].
    pub fn set_last_modified_before<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_before = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_before][crate::model::ObjectConditions::last_modified_before].
    pub fn set_or_clear_last_modified_before<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_before = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ObjectConditions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ObjectConditions"
    }
}

/// In a GcsData resource, an object's name is the Cloud Storage object's
/// name and its "last modification time" refers to the object's `updated`
/// property of Cloud Storage objects, which changes when the content or the
/// metadata of the object is updated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsData {
    /// Required. Cloud Storage bucket name. Must meet
    /// [Bucket Name Requirements](/storage/docs/naming#requirements).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// Root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This field
    /// is treated as an object prefix. As such, it should generally not begin with
    /// a '/'.
    ///
    /// The root path value must meet
    /// [Object Name Requirements](/storage/docs/naming#objectnames).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Preview. Enables the transfer of managed folders between Cloud Storage
    /// buckets. Set this option on the gcs_data_source.
    ///
    /// If set to true:
    ///
    /// - Managed folders in the source bucket are transferred to the
    ///   destination bucket.
    /// - Managed folders in the destination bucket are overwritten. Other
    ///   OVERWRITE options are not supported.
    ///
    /// See
    /// [Transfer Cloud Storage managed
    /// folders](/storage-transfer/docs/managed-folders).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub managed_folder_transfer_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::GcsData::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::GcsData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [managed_folder_transfer_enabled][crate::model::GcsData::managed_folder_transfer_enabled].
    pub fn set_managed_folder_transfer_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.managed_folder_transfer_enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcsData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.GcsData"
    }
}

/// An AwsS3Data resource can be a data source, but not a data sink.
/// In an AwsS3Data resource, an object's name is the S3 object's key name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsS3Data {
    /// Required. S3 Bucket name (see
    /// [Creating a
    /// bucket](https://docs.aws.amazon.com/AmazonS3/latest/dev/create-bucket-get-location-example.html)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// Input only. AWS access key used to sign the API requests to the AWS S3
    /// bucket. Permissions on the bucket must be granted to the access ID of the
    /// AWS access key.
    ///
    /// For information on our data retention policy for user credentials, see
    /// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_access_key: std::option::Option<crate::model::AwsAccessKey>,

    /// Root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This field
    /// is treated as an object prefix. As such, it should generally not begin with
    /// a '/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// The Amazon Resource Name (ARN) of the role to support temporary
    /// credentials via `AssumeRoleWithWebIdentity`. For more information about
    /// ARNs, see [IAM
    /// ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
    ///
    /// When a role ARN is provided, Transfer Service fetches temporary
    /// credentials for the session using a `AssumeRoleWithWebIdentity` call for
    /// the provided role using the
    /// [GoogleServiceAccount][google.storagetransfer.v1.GoogleServiceAccount] for
    /// this project.
    ///
    /// [google.storagetransfer.v1.GoogleServiceAccount]: crate::model::GoogleServiceAccount
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role_arn: std::string::String,

    /// Optional. The CloudFront distribution domain name pointing to this bucket,
    /// to use when fetching.
    ///
    /// See
    /// [Transfer from S3 via
    /// CloudFront](https://cloud.google.com/storage-transfer/docs/s3-cloudfront)
    /// for more information.
    ///
    /// Format: `https://{id}.cloudfront.net` or any valid custom domain. Must
    /// begin with `https://`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloudfront_domain: std::string::String,

    /// Optional. The Resource name of a secret in Secret Manager.
    ///
    /// AWS credentials must be stored in Secret Manager in JSON format:
    ///
    /// {
    /// "access_key_id": "ACCESS_KEY_ID",
    /// "secret_access_key": "SECRET_ACCESS_KEY"
    /// }
    ///
    /// [GoogleServiceAccount][google.storagetransfer.v1.GoogleServiceAccount] must
    /// be granted `roles/secretmanager.secretAccessor` for the resource.
    ///
    /// See [Configure access to a source: Amazon S3]
    /// (<https://cloud.google.com/storage-transfer/docs/source-amazon-s3#secret_manager>)
    /// for more information.
    ///
    /// If `credentials_secret` is specified, do not specify
    /// [role_arn][google.storagetransfer.v1.AwsS3Data.role_arn] or
    /// [aws_access_key][google.storagetransfer.v1.AwsS3Data.aws_access_key].
    ///
    /// Format: `projects/{project_number}/secrets/{secret_name}`
    ///
    /// [google.storagetransfer.v1.AwsS3Data.aws_access_key]: crate::model::AwsS3Data::aws_access_key
    /// [google.storagetransfer.v1.AwsS3Data.role_arn]: crate::model::AwsS3Data::role_arn
    /// [google.storagetransfer.v1.GoogleServiceAccount]: crate::model::GoogleServiceAccount
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub credentials_secret: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub private_network: std::option::Option<crate::model::aws_s_3_data::PrivateNetwork>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsS3Data {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::AwsS3Data::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [aws_access_key][crate::model::AwsS3Data::aws_access_key].
    pub fn set_aws_access_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccessKey>,
    {
        self.aws_access_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_access_key][crate::model::AwsS3Data::aws_access_key].
    pub fn set_or_clear_aws_access_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsAccessKey>,
    {
        self.aws_access_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [path][crate::model::AwsS3Data::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [role_arn][crate::model::AwsS3Data::role_arn].
    pub fn set_role_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role_arn = v.into();
        self
    }

    /// Sets the value of [cloudfront_domain][crate::model::AwsS3Data::cloudfront_domain].
    pub fn set_cloudfront_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloudfront_domain = v.into();
        self
    }

    /// Sets the value of [credentials_secret][crate::model::AwsS3Data::credentials_secret].
    pub fn set_credentials_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_secret = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::AwsS3Data::private_network].
    ///
    /// Note that all the setters affecting `private_network` are mutually
    /// exclusive.
    pub fn set_private_network<
        T: std::convert::Into<std::option::Option<crate::model::aws_s_3_data::PrivateNetwork>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_network = v.into();
        self
    }

    /// The value of [private_network][crate::model::AwsS3Data::private_network]
    /// if it holds a `ManagedPrivateNetwork`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_private_network(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.private_network.as_ref().and_then(|v| match v {
            crate::model::aws_s_3_data::PrivateNetwork::ManagedPrivateNetwork(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [private_network][crate::model::AwsS3Data::private_network]
    /// to hold a `ManagedPrivateNetwork`.
    ///
    /// Note that all the setters affecting `private_network` are
    /// mutually exclusive.
    pub fn set_managed_private_network<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.private_network = std::option::Option::Some(
            crate::model::aws_s_3_data::PrivateNetwork::ManagedPrivateNetwork(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsS3Data {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AwsS3Data"
    }
}

/// Defines additional types related to [AwsS3Data].
pub mod aws_s_3_data {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PrivateNetwork {
        /// Egress bytes over a Google-managed private network.
        /// This network is shared between other users of Storage Transfer Service.
        ManagedPrivateNetwork(bool),
    }
}

/// An AzureBlobStorageData resource can be a data source, but not a data sink.
/// An AzureBlobStorageData resource represents one Azure container. The storage
/// account determines the [Azure
/// endpoint](https://docs.microsoft.com/en-us/azure/storage/common/storage-create-storage-account#storage-account-endpoints).
/// In an AzureBlobStorageData resource, a blobs's name is the [Azure Blob
/// Storage blob's key
/// name](https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata#blob-names).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureBlobStorageData {
    /// Required. The name of the Azure Storage account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_account: std::string::String,

    /// Required. Input only. Credentials used to authenticate API requests to
    /// Azure.
    ///
    /// For information on our data retention policy for user credentials, see
    /// [User credentials](/storage-transfer/docs/data-retention#user-credentials).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_credentials: std::option::Option<crate::model::AzureCredentials>,

    /// Required. The container to transfer from the Azure Storage account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container: std::string::String,

    /// Root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This field
    /// is treated as an object prefix. As such, it should generally not begin with
    /// a '/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Optional. The Resource name of a secret in Secret Manager.
    ///
    /// The Azure SAS token must be stored in Secret Manager in JSON format:
    ///
    /// {
    /// "sas_token" : "SAS_TOKEN"
    /// }
    ///
    /// [GoogleServiceAccount][google.storagetransfer.v1.GoogleServiceAccount] must
    /// be granted `roles/secretmanager.secretAccessor` for the resource.
    ///
    /// See [Configure access to a source: Microsoft Azure Blob Storage]
    /// (<https://cloud.google.com/storage-transfer/docs/source-microsoft-azure#secret_manager>)
    /// for more information.
    ///
    /// If `credentials_secret` is specified, do not specify
    /// [azure_credentials][google.storagetransfer.v1.AzureBlobStorageData.azure_credentials].
    ///
    /// Format: `projects/{project_number}/secrets/{secret_name}`
    ///
    /// [google.storagetransfer.v1.AzureBlobStorageData.azure_credentials]: crate::model::AzureBlobStorageData::azure_credentials
    /// [google.storagetransfer.v1.GoogleServiceAccount]: crate::model::GoogleServiceAccount
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub credentials_secret: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureBlobStorageData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_account][crate::model::AzureBlobStorageData::storage_account].
    pub fn set_storage_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_account = v.into();
        self
    }

    /// Sets the value of [azure_credentials][crate::model::AzureBlobStorageData::azure_credentials].
    pub fn set_azure_credentials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureCredentials>,
    {
        self.azure_credentials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_credentials][crate::model::AzureBlobStorageData::azure_credentials].
    pub fn set_or_clear_azure_credentials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureCredentials>,
    {
        self.azure_credentials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [container][crate::model::AzureBlobStorageData::container].
    pub fn set_container<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container = v.into();
        self
    }

    /// Sets the value of [path][crate::model::AzureBlobStorageData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [credentials_secret][crate::model::AzureBlobStorageData::credentials_secret].
    pub fn set_credentials_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_secret = v.into();
        self
    }
}

impl wkt::message::Message for AzureBlobStorageData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AzureBlobStorageData"
    }
}

/// An HttpData resource specifies a list of objects on the web to be
/// transferred over HTTP.  The information of the objects to be transferred is
/// contained in a file referenced by a URL. The first line in the file must be
/// `"TsvHttpData-1.0"`, which specifies the format of the file.  Subsequent
/// lines specify the information of the list of objects, one object per list
/// entry. Each entry has the following tab-delimited fields:
///
/// * **HTTP URL** â€” The location of the object.
///
/// * **Length** â€” The size of the object in bytes.
///
/// * **MD5** â€” The base64-encoded MD5 hash of the object.
///
///
/// For an example of a valid TSV file, see
/// [Transferring data from
/// URLs](https://cloud.google.com/storage-transfer/docs/create-url-list).
///
/// When transferring data based on a URL list, keep the following in mind:
///
/// * When an object located at `http(s)://hostname:port/<URL-path>` is
///   transferred to a data sink, the name of the object at the data sink is
///   `<hostname>/<URL-path>`.
///
/// * If the specified size of an object does not match the actual size of the
///   object fetched, the object is not transferred.
///
/// * If the specified MD5 does not match the MD5 computed from the transferred
///   bytes, the object transfer fails.
///
/// * Ensure that each URL you specify is publicly accessible. For
///   example, in Cloud Storage you can
///   [share an object publicly]
///   (/storage/docs/cloud-console#_sharingdata) and get a link to it.
///
/// * Storage Transfer Service obeys `robots.txt` rules and requires the source
///   HTTP server to support `Range` requests and to return a `Content-Length`
///   header in each response.
///
/// * [ObjectConditions][google.storagetransfer.v1.ObjectConditions] have no
///   effect when filtering objects to transfer.
///
///
/// [google.storagetransfer.v1.ObjectConditions]: crate::model::ObjectConditions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpData {
    /// Required. The URL that points to the file that stores the object list
    /// entries. This file must allow public access.  Currently, only URLs with
    /// HTTP and HTTPS schemes are supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub list_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [list_url][crate::model::HttpData::list_url].
    pub fn set_list_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.list_url = v.into();
        self
    }
}

impl wkt::message::Message for HttpData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.HttpData"
    }
}

/// A POSIX filesystem resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PosixFilesystem {
    /// Root directory path to the filesystem.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_directory: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PosixFilesystem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [root_directory][crate::model::PosixFilesystem::root_directory].
    pub fn set_root_directory<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_directory = v.into();
        self
    }
}

impl wkt::message::Message for PosixFilesystem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.PosixFilesystem"
    }
}

/// An HdfsData resource specifies a path within an HDFS entity (e.g. a cluster).
/// All cluster-specific settings, such as namenodes and ports, are configured on
/// the transfer agents servicing requests, so HdfsData only contains the root
/// path to the data in our transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HdfsData {
    /// Root path to transfer files.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HdfsData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::HdfsData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for HdfsData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.HdfsData"
    }
}

/// An AwsS3CompatibleData resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsS3CompatibleData {
    /// Required. Specifies the name of the bucket.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// Specifies the root path to transfer objects.
    ///
    /// Must be an empty string or full path name that ends with a '/'. This
    /// field is treated as an object prefix. As such, it should generally not
    /// begin with a '/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Required. Specifies the endpoint of the storage service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Specifies the region to sign requests with. This can be left blank if
    /// requests should be signed with an empty region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Specifies the metadata of the S3 compatible data provider. Each provider
    /// may contain some attributes that do not apply to all S3-compatible data
    /// providers. When not specified, S3CompatibleMetadata is used by default.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_provider: std::option::Option<crate::model::aws_s_3_compatible_data::DataProvider>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsS3CompatibleData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket_name][crate::model::AwsS3CompatibleData::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [path][crate::model::AwsS3CompatibleData::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::AwsS3CompatibleData::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [region][crate::model::AwsS3CompatibleData::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [data_provider][crate::model::AwsS3CompatibleData::data_provider].
    ///
    /// Note that all the setters affecting `data_provider` are mutually
    /// exclusive.
    pub fn set_data_provider<
        T: std::convert::Into<
                std::option::Option<crate::model::aws_s_3_compatible_data::DataProvider>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_provider = v.into();
        self
    }

    /// The value of [data_provider][crate::model::AwsS3CompatibleData::data_provider]
    /// if it holds a `S3Metadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn s3_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::S3CompatibleMetadata>> {
        #[allow(unreachable_patterns)]
        self.data_provider.as_ref().and_then(|v| match v {
            crate::model::aws_s_3_compatible_data::DataProvider::S3Metadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_provider][crate::model::AwsS3CompatibleData::data_provider]
    /// to hold a `S3Metadata`.
    ///
    /// Note that all the setters affecting `data_provider` are
    /// mutually exclusive.
    pub fn set_s3_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::S3CompatibleMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_provider = std::option::Option::Some(
            crate::model::aws_s_3_compatible_data::DataProvider::S3Metadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsS3CompatibleData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AwsS3CompatibleData"
    }
}

/// Defines additional types related to [AwsS3CompatibleData].
pub mod aws_s_3_compatible_data {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the metadata of the S3 compatible data provider. Each provider
    /// may contain some attributes that do not apply to all S3-compatible data
    /// providers. When not specified, S3CompatibleMetadata is used by default.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataProvider {
        /// A S3 compatible metadata.
        S3Metadata(std::boxed::Box<crate::model::S3CompatibleMetadata>),
    }
}

/// S3CompatibleMetadata contains the metadata fields that apply to the basic
/// types of S3-compatible data providers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct S3CompatibleMetadata {
    /// Specifies the authentication and authorization method used by the storage
    /// service. When not specified, Transfer Service will attempt to determine
    /// right auth method to use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auth_method: crate::model::s_3_compatible_metadata::AuthMethod,

    /// Specifies the API request model used to call the storage service. When not
    /// specified, the default value of RequestModel
    /// REQUEST_MODEL_VIRTUAL_HOSTED_STYLE is used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub request_model: crate::model::s_3_compatible_metadata::RequestModel,

    /// Specifies the network protocol of the agent. When not specified, the
    /// default value of NetworkProtocol NETWORK_PROTOCOL_HTTPS is used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub protocol: crate::model::s_3_compatible_metadata::NetworkProtocol,

    /// The Listing API to use for discovering objects. When not specified,
    /// Transfer Service will attempt to determine the right API to use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub list_api: crate::model::s_3_compatible_metadata::ListApi,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl S3CompatibleMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_method][crate::model::S3CompatibleMetadata::auth_method].
    pub fn set_auth_method<
        T: std::convert::Into<crate::model::s_3_compatible_metadata::AuthMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_method = v.into();
        self
    }

    /// Sets the value of [request_model][crate::model::S3CompatibleMetadata::request_model].
    pub fn set_request_model<
        T: std::convert::Into<crate::model::s_3_compatible_metadata::RequestModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_model = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::S3CompatibleMetadata::protocol].
    pub fn set_protocol<
        T: std::convert::Into<crate::model::s_3_compatible_metadata::NetworkProtocol>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [list_api][crate::model::S3CompatibleMetadata::list_api].
    pub fn set_list_api<T: std::convert::Into<crate::model::s_3_compatible_metadata::ListApi>>(
        mut self,
        v: T,
    ) -> Self {
        self.list_api = v.into();
        self
    }
}

impl wkt::message::Message for S3CompatibleMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.S3CompatibleMetadata"
    }
}

/// Defines additional types related to [S3CompatibleMetadata].
pub mod s_3_compatible_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The authentication and authorization method used by the storage service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthMethod {
        /// AuthMethod is not specified.
        Unspecified,
        /// Auth requests with AWS SigV4.
        AwsSignatureV4,
        /// Auth requests with AWS SigV2.
        AwsSignatureV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AuthMethod::value] or
        /// [AuthMethod::name].
        UnknownValue(auth_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod auth_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AuthMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AwsSignatureV4 => std::option::Option::Some(1),
                Self::AwsSignatureV2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTH_METHOD_UNSPECIFIED"),
                Self::AwsSignatureV4 => std::option::Option::Some("AUTH_METHOD_AWS_SIGNATURE_V4"),
                Self::AwsSignatureV2 => std::option::Option::Some("AUTH_METHOD_AWS_SIGNATURE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AuthMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AuthMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AuthMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AwsSignatureV4,
                2 => Self::AwsSignatureV2,
                _ => Self::UnknownValue(auth_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AuthMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTH_METHOD_UNSPECIFIED" => Self::Unspecified,
                "AUTH_METHOD_AWS_SIGNATURE_V4" => Self::AwsSignatureV4,
                "AUTH_METHOD_AWS_SIGNATURE_V2" => Self::AwsSignatureV2,
                _ => Self::UnknownValue(auth_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AuthMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AwsSignatureV4 => serializer.serialize_i32(1),
                Self::AwsSignatureV2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AuthMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthMethod>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.AuthMethod",
            ))
        }
    }

    /// The request model of the API.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RequestModel {
        /// RequestModel is not specified.
        Unspecified,
        /// Perform requests using Virtual Hosted Style.
        /// Example: <https://bucket-name.s3.region.amazonaws.com/key-name>
        VirtualHostedStyle,
        /// Perform requests using Path Style.
        /// Example: <https://s3.region.amazonaws.com/bucket-name/key-name>
        PathStyle,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RequestModel::value] or
        /// [RequestModel::name].
        UnknownValue(request_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod request_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RequestModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtualHostedStyle => std::option::Option::Some(1),
                Self::PathStyle => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REQUEST_MODEL_UNSPECIFIED"),
                Self::VirtualHostedStyle => {
                    std::option::Option::Some("REQUEST_MODEL_VIRTUAL_HOSTED_STYLE")
                }
                Self::PathStyle => std::option::Option::Some("REQUEST_MODEL_PATH_STYLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RequestModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RequestModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RequestModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtualHostedStyle,
                2 => Self::PathStyle,
                _ => Self::UnknownValue(request_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RequestModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REQUEST_MODEL_UNSPECIFIED" => Self::Unspecified,
                "REQUEST_MODEL_VIRTUAL_HOSTED_STYLE" => Self::VirtualHostedStyle,
                "REQUEST_MODEL_PATH_STYLE" => Self::PathStyle,
                _ => Self::UnknownValue(request_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RequestModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtualHostedStyle => serializer.serialize_i32(1),
                Self::PathStyle => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RequestModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RequestModel>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.RequestModel",
            ))
        }
    }

    /// The agent network protocol to access the storage service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkProtocol {
        /// NetworkProtocol is not specified.
        Unspecified,
        /// Perform requests using HTTPS.
        Https,
        /// Not recommended: This sends data in clear-text. This is only
        /// appropriate within a closed network or for publicly available data.
        /// Perform requests using HTTP.
        Http,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkProtocol::value] or
        /// [NetworkProtocol::name].
        UnknownValue(network_protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkProtocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Https => std::option::Option::Some(1),
                Self::Http => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NETWORK_PROTOCOL_UNSPECIFIED"),
                Self::Https => std::option::Option::Some("NETWORK_PROTOCOL_HTTPS"),
                Self::Http => std::option::Option::Some("NETWORK_PROTOCOL_HTTP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkProtocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkProtocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkProtocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Https,
                2 => Self::Http,
                _ => Self::UnknownValue(network_protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkProtocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORK_PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "NETWORK_PROTOCOL_HTTPS" => Self::Https,
                "NETWORK_PROTOCOL_HTTP" => Self::Http,
                _ => Self::UnknownValue(network_protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkProtocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Https => serializer.serialize_i32(1),
                Self::Http => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkProtocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkProtocol>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.NetworkProtocol",
            ))
        }
    }

    /// The Listing API to use for discovering objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ListApi {
        /// ListApi is not specified.
        Unspecified,
        /// Perform listing using ListObjectsV2 API.
        ListObjectsV2,
        /// Legacy ListObjects API.
        ListObjects,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ListApi::value] or
        /// [ListApi::name].
        UnknownValue(list_api::UnknownValue),
    }

    #[doc(hidden)]
    pub mod list_api {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ListApi {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ListObjectsV2 => std::option::Option::Some(1),
                Self::ListObjects => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LIST_API_UNSPECIFIED"),
                Self::ListObjectsV2 => std::option::Option::Some("LIST_OBJECTS_V2"),
                Self::ListObjects => std::option::Option::Some("LIST_OBJECTS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ListApi {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ListApi {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ListApi {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ListObjectsV2,
                2 => Self::ListObjects,
                _ => Self::UnknownValue(list_api::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ListApi {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LIST_API_UNSPECIFIED" => Self::Unspecified,
                "LIST_OBJECTS_V2" => Self::ListObjectsV2,
                "LIST_OBJECTS" => Self::ListObjects,
                _ => Self::UnknownValue(list_api::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ListApi {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ListObjectsV2 => serializer.serialize_i32(1),
                Self::ListObjects => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ListApi {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ListApi>::new(
                ".google.storagetransfer.v1.S3CompatibleMetadata.ListApi",
            ))
        }
    }
}

/// Represents an agent pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AgentPool {
    /// Required. Specifies a unique string that identifies the agent pool.
    ///
    /// Format: `projects/{project_id}/agentPools/{agent_pool_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Specifies the client-specified AgentPool description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Specifies the state of the AgentPool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::agent_pool::State,

    /// Specifies the bandwidth limit details. If this field is unspecified, the
    /// default value is set as 'No Limit'.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bandwidth_limit: std::option::Option<crate::model::agent_pool::BandwidthLimit>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AgentPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AgentPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AgentPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AgentPool::state].
    pub fn set_state<T: std::convert::Into<crate::model::agent_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [bandwidth_limit][crate::model::AgentPool::bandwidth_limit].
    pub fn set_bandwidth_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent_pool::BandwidthLimit>,
    {
        self.bandwidth_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bandwidth_limit][crate::model::AgentPool::bandwidth_limit].
    pub fn set_or_clear_bandwidth_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent_pool::BandwidthLimit>,
    {
        self.bandwidth_limit = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AgentPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.AgentPool"
    }
}

/// Defines additional types related to [AgentPool].
pub mod agent_pool {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies a bandwidth limit for an agent pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BandwidthLimit {
        /// Bandwidth rate in megabytes per second, distributed across all the agents
        /// in the pool.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub limit_mbps: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BandwidthLimit {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [limit_mbps][crate::model::agent_pool::BandwidthLimit::limit_mbps].
        pub fn set_limit_mbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.limit_mbps = v.into();
            self
        }
    }

    impl wkt::message::Message for BandwidthLimit {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storagetransfer.v1.AgentPool.BandwidthLimit"
        }
    }

    /// The state of an AgentPool.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// This is an initialization state. During this stage, resources are
        /// allocated for the AgentPool.
        Creating,
        /// Determines that the AgentPool is created for use. At this state, Agents
        /// can join the AgentPool and participate in the transfer jobs in that pool.
        Created,
        /// Determines that the AgentPool deletion has been initiated, and all the
        /// resources are scheduled to be cleaned up and freed.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Created => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Created,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "CREATED" => Self::Created,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Created => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.storagetransfer.v1.AgentPool.State",
            ))
        }
    }
}

/// TransferOptions define the actions to be performed on objects in a transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferOptions {
    /// When to overwrite objects that already exist in the sink. The default is
    /// that only objects that are different from the source are ovewritten. If
    /// true, all objects in the sink whose name matches an object in the source
    /// are overwritten with the source object.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub overwrite_objects_already_existing_in_sink: bool,

    /// Whether objects that exist only in the sink should be deleted.
    ///
    /// **Note:** This option and
    /// [delete_objects_from_source_after_transfer][google.storagetransfer.v1.TransferOptions.delete_objects_from_source_after_transfer]
    /// are mutually exclusive.
    ///
    /// [google.storagetransfer.v1.TransferOptions.delete_objects_from_source_after_transfer]: crate::model::TransferOptions::delete_objects_from_source_after_transfer
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub delete_objects_unique_in_sink: bool,

    /// Whether objects should be deleted from the source after they are
    /// transferred to the sink.
    ///
    /// **Note:** This option and
    /// [delete_objects_unique_in_sink][google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]
    /// are mutually exclusive.
    ///
    /// [google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]: crate::model::TransferOptions::delete_objects_unique_in_sink
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub delete_objects_from_source_after_transfer: bool,

    /// When to overwrite objects that already exist in the sink. If not set,
    /// overwrite behavior is determined by
    /// [overwrite_objects_already_existing_in_sink][google.storagetransfer.v1.TransferOptions.overwrite_objects_already_existing_in_sink].
    ///
    /// [google.storagetransfer.v1.TransferOptions.overwrite_objects_already_existing_in_sink]: crate::model::TransferOptions::overwrite_objects_already_existing_in_sink
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub overwrite_when: crate::model::transfer_options::OverwriteWhen,

    /// Represents the selected metadata options for a transfer job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_options: std::option::Option<crate::model::MetadataOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overwrite_objects_already_existing_in_sink][crate::model::TransferOptions::overwrite_objects_already_existing_in_sink].
    pub fn set_overwrite_objects_already_existing_in_sink<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.overwrite_objects_already_existing_in_sink = v.into();
        self
    }

    /// Sets the value of [delete_objects_unique_in_sink][crate::model::TransferOptions::delete_objects_unique_in_sink].
    pub fn set_delete_objects_unique_in_sink<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.delete_objects_unique_in_sink = v.into();
        self
    }

    /// Sets the value of [delete_objects_from_source_after_transfer][crate::model::TransferOptions::delete_objects_from_source_after_transfer].
    pub fn set_delete_objects_from_source_after_transfer<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_objects_from_source_after_transfer = v.into();
        self
    }

    /// Sets the value of [overwrite_when][crate::model::TransferOptions::overwrite_when].
    pub fn set_overwrite_when<
        T: std::convert::Into<crate::model::transfer_options::OverwriteWhen>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overwrite_when = v.into();
        self
    }

    /// Sets the value of [metadata_options][crate::model::TransferOptions::metadata_options].
    pub fn set_metadata_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MetadataOptions>,
    {
        self.metadata_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata_options][crate::model::TransferOptions::metadata_options].
    pub fn set_or_clear_metadata_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MetadataOptions>,
    {
        self.metadata_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransferOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferOptions"
    }
}

/// Defines additional types related to [TransferOptions].
pub mod transfer_options {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies when to overwrite an object in the sink when an object with
    /// matching name is found in the source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OverwriteWhen {
        /// Overwrite behavior is unspecified.
        Unspecified,
        /// Overwrites destination objects with the source objects, only if the
        /// objects have the same name but different HTTP ETags or checksum values.
        Different,
        /// Never overwrites a destination object if a source object has the
        /// same name. In this case, the source object is not transferred.
        Never,
        /// Always overwrite the destination object with the source object, even if
        /// the HTTP Etags or checksum values are the same.
        Always,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OverwriteWhen::value] or
        /// [OverwriteWhen::name].
        UnknownValue(overwrite_when::UnknownValue),
    }

    #[doc(hidden)]
    pub mod overwrite_when {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OverwriteWhen {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Different => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::Always => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OVERWRITE_WHEN_UNSPECIFIED"),
                Self::Different => std::option::Option::Some("DIFFERENT"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OverwriteWhen {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OverwriteWhen {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OverwriteWhen {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Different,
                2 => Self::Never,
                3 => Self::Always,
                _ => Self::UnknownValue(overwrite_when::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OverwriteWhen {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OVERWRITE_WHEN_UNSPECIFIED" => Self::Unspecified,
                "DIFFERENT" => Self::Different,
                "NEVER" => Self::Never,
                "ALWAYS" => Self::Always,
                _ => Self::UnknownValue(overwrite_when::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OverwriteWhen {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Different => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::Always => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OverwriteWhen {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OverwriteWhen>::new(
                ".google.storagetransfer.v1.TransferOptions.OverwriteWhen",
            ))
        }
    }
}

/// Configuration for running a transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferSpec {
    /// Only objects that satisfy these object conditions are included in the set
    /// of data source and data sink objects.  Object conditions based on
    /// objects' "last modification time" do not exclude objects in a data sink.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_conditions: std::option::Option<crate::model::ObjectConditions>,

    /// If the option
    /// [delete_objects_unique_in_sink][google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]
    /// is `true` and time-based object conditions such as 'last modification time'
    /// are specified, the request fails with an
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.TransferOptions.delete_objects_unique_in_sink]: crate::model::TransferOptions::delete_objects_unique_in_sink
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_options: std::option::Option<crate::model::TransferOptions>,

    /// A manifest file provides a list of objects to be transferred from the data
    /// source. This field points to the location of the manifest file.
    /// Otherwise, the entire source bucket is used. ObjectConditions still apply.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_manifest: std::option::Option<crate::model::TransferManifest>,

    /// Specifies the agent pool name associated with the posix data source. When
    /// unspecified, the default name is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_agent_pool_name: std::string::String,

    /// Specifies the agent pool name associated with the posix data sink. When
    /// unspecified, the default name is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sink_agent_pool_name: std::string::String,

    /// The write sink for the data.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_sink: std::option::Option<crate::model::transfer_spec::DataSink>,

    /// The read source of the data.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::transfer_spec::DataSource>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub intermediate_data_location:
        std::option::Option<crate::model::transfer_spec::IntermediateDataLocation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_conditions][crate::model::TransferSpec::object_conditions].
    pub fn set_object_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_conditions][crate::model::TransferSpec::object_conditions].
    pub fn set_or_clear_object_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_options][crate::model::TransferSpec::transfer_options].
    pub fn set_transfer_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_options][crate::model::TransferSpec::transfer_options].
    pub fn set_or_clear_transfer_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_manifest][crate::model::TransferSpec::transfer_manifest].
    pub fn set_transfer_manifest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferManifest>,
    {
        self.transfer_manifest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_manifest][crate::model::TransferSpec::transfer_manifest].
    pub fn set_or_clear_transfer_manifest<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferManifest>,
    {
        self.transfer_manifest = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_agent_pool_name][crate::model::TransferSpec::source_agent_pool_name].
    pub fn set_source_agent_pool_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_agent_pool_name = v.into();
        self
    }

    /// Sets the value of [sink_agent_pool_name][crate::model::TransferSpec::sink_agent_pool_name].
    pub fn set_sink_agent_pool_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sink_agent_pool_name = v.into();
        self
    }

    /// Sets the value of [data_sink][crate::model::TransferSpec::data_sink].
    ///
    /// Note that all the setters affecting `data_sink` are mutually
    /// exclusive.
    pub fn set_data_sink<
        T: std::convert::Into<std::option::Option<crate::model::transfer_spec::DataSink>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = v.into();
        self
    }

    /// The value of [data_sink][crate::model::TransferSpec::data_sink]
    /// if it holds a `GcsDataSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_sink(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_sink.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSink::GcsDataSink(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_sink][crate::model::TransferSpec::data_sink]
    /// to hold a `GcsDataSink`.
    ///
    /// Note that all the setters affecting `data_sink` are
    /// mutually exclusive.
    pub fn set_gcs_data_sink<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink =
            std::option::Option::Some(crate::model::transfer_spec::DataSink::GcsDataSink(v.into()));
        self
    }

    /// The value of [data_sink][crate::model::TransferSpec::data_sink]
    /// if it holds a `PosixDataSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn posix_data_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PosixFilesystem>> {
        #[allow(unreachable_patterns)]
        self.data_sink.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSink::PosixDataSink(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_sink][crate::model::TransferSpec::data_sink]
    /// to hold a `PosixDataSink`.
    ///
    /// Note that all the setters affecting `data_sink` are
    /// mutually exclusive.
    pub fn set_posix_data_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::PosixFilesystem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = std::option::Option::Some(
            crate::model::transfer_spec::DataSink::PosixDataSink(v.into()),
        );
        self
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source].
    ///
    /// Note that all the setters affecting `data_source` are mutually
    /// exclusive.
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::transfer_spec::DataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `GcsDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::GcsDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `GcsDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_gcs_data_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::GcsDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `AwsS3DataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_s3_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsS3Data>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::AwsS3DataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `AwsS3DataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_aws_s3_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsS3Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::AwsS3DataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `HttpDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::HttpDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `HttpDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_http_data_source<T: std::convert::Into<std::boxed::Box<crate::model::HttpData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::HttpDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `PosixDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn posix_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PosixFilesystem>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::PosixDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `PosixDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_posix_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::PosixFilesystem>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::PosixDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `AzureBlobStorageDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_blob_storage_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureBlobStorageData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::AzureBlobStorageDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `AzureBlobStorageDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_azure_blob_storage_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureBlobStorageData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::AzureBlobStorageDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `AwsS3CompatibleDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_s3_compatible_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsS3CompatibleData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::AwsS3CompatibleDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `AwsS3CompatibleDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_aws_s3_compatible_data_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsS3CompatibleData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::AwsS3CompatibleDataSource(v.into()),
        );
        self
    }

    /// The value of [data_source][crate::model::TransferSpec::data_source]
    /// if it holds a `HdfsDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hdfs_data_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HdfsData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::DataSource::HdfsDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::TransferSpec::data_source]
    /// to hold a `HdfsDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_hdfs_data_source<T: std::convert::Into<std::boxed::Box<crate::model::HdfsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::transfer_spec::DataSource::HdfsDataSource(v.into()),
        );
        self
    }

    /// Sets the value of [intermediate_data_location][crate::model::TransferSpec::intermediate_data_location].
    ///
    /// Note that all the setters affecting `intermediate_data_location` are mutually
    /// exclusive.
    pub fn set_intermediate_data_location<
        T: std::convert::Into<
                std::option::Option<crate::model::transfer_spec::IntermediateDataLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intermediate_data_location = v.into();
        self
    }

    /// The value of [intermediate_data_location][crate::model::TransferSpec::intermediate_data_location]
    /// if it holds a `GcsIntermediateDataLocation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_intermediate_data_location(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.intermediate_data_location.as_ref().and_then(|v| match v {
            crate::model::transfer_spec::IntermediateDataLocation::GcsIntermediateDataLocation(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intermediate_data_location][crate::model::TransferSpec::intermediate_data_location]
    /// to hold a `GcsIntermediateDataLocation`.
    ///
    /// Note that all the setters affecting `intermediate_data_location` are
    /// mutually exclusive.
    pub fn set_gcs_intermediate_data_location<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intermediate_data_location = std::option::Option::Some(
            crate::model::transfer_spec::IntermediateDataLocation::GcsIntermediateDataLocation(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TransferSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferSpec"
    }
}

/// Defines additional types related to [TransferSpec].
pub mod transfer_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The write sink for the data.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSink {
        /// A Cloud Storage data sink.
        GcsDataSink(std::boxed::Box<crate::model::GcsData>),
        /// A POSIX Filesystem data sink.
        PosixDataSink(std::boxed::Box<crate::model::PosixFilesystem>),
    }

    /// The read source of the data.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSource {
        /// A Cloud Storage data source.
        GcsDataSource(std::boxed::Box<crate::model::GcsData>),
        /// An AWS S3 data source.
        AwsS3DataSource(std::boxed::Box<crate::model::AwsS3Data>),
        /// An HTTP URL data source.
        HttpDataSource(std::boxed::Box<crate::model::HttpData>),
        /// A POSIX Filesystem data source.
        PosixDataSource(std::boxed::Box<crate::model::PosixFilesystem>),
        /// An Azure Blob Storage data source.
        AzureBlobStorageDataSource(std::boxed::Box<crate::model::AzureBlobStorageData>),
        /// An AWS S3 compatible data source.
        AwsS3CompatibleDataSource(std::boxed::Box<crate::model::AwsS3CompatibleData>),
        /// An HDFS cluster data source.
        HdfsDataSource(std::boxed::Box<crate::model::HdfsData>),
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum IntermediateDataLocation {
        /// For transfers between file systems, specifies a Cloud Storage bucket
        /// to be used as an intermediate location through which to transfer data.
        ///
        /// See [Transfer data between file
        /// systems](https://cloud.google.com/storage-transfer/docs/file-to-file) for
        /// more information.
        GcsIntermediateDataLocation(std::boxed::Box<crate::model::GcsData>),
    }
}

/// Specifies the configuration for a cross-bucket replication job. Cross-bucket
/// replication copies new or updated objects from a source Cloud Storage bucket
/// to a destination Cloud Storage bucket. Existing objects in the source bucket
/// are not copied by a new cross-bucket replication job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicationSpec {
    /// Object conditions that determine which objects are transferred. For
    /// replication jobs, only `include_prefixes` and `exclude_prefixes` are
    /// supported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_conditions: std::option::Option<crate::model::ObjectConditions>,

    /// Specifies the metadata options to be applied during replication.
    /// Delete options are not supported. If a delete option is specified, the
    /// request fails with an [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]
    /// error.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_options: std::option::Option<crate::model::TransferOptions>,

    /// The data source to be replicated.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::replication_spec::DataSource>,

    /// The destination for replicated objects.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_sink: std::option::Option<crate::model::replication_spec::DataSink>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_conditions][crate::model::ReplicationSpec::object_conditions].
    pub fn set_object_conditions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_conditions][crate::model::ReplicationSpec::object_conditions].
    pub fn set_or_clear_object_conditions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectConditions>,
    {
        self.object_conditions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transfer_options][crate::model::ReplicationSpec::transfer_options].
    pub fn set_transfer_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_options][crate::model::ReplicationSpec::transfer_options].
    pub fn set_or_clear_transfer_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferOptions>,
    {
        self.transfer_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_source][crate::model::ReplicationSpec::data_source].
    ///
    /// Note that all the setters affecting `data_source` are mutually
    /// exclusive.
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::replication_spec::DataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::ReplicationSpec::data_source]
    /// if it holds a `GcsDataSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::replication_spec::DataSource::GcsDataSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::ReplicationSpec::data_source]
    /// to hold a `GcsDataSource`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_gcs_data_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::replication_spec::DataSource::GcsDataSource(v.into()),
        );
        self
    }

    /// Sets the value of [data_sink][crate::model::ReplicationSpec::data_sink].
    ///
    /// Note that all the setters affecting `data_sink` are mutually
    /// exclusive.
    pub fn set_data_sink<
        T: std::convert::Into<std::option::Option<crate::model::replication_spec::DataSink>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = v.into();
        self
    }

    /// The value of [data_sink][crate::model::ReplicationSpec::data_sink]
    /// if it holds a `GcsDataSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_data_sink(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsData>> {
        #[allow(unreachable_patterns)]
        self.data_sink.as_ref().and_then(|v| match v {
            crate::model::replication_spec::DataSink::GcsDataSink(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_sink][crate::model::ReplicationSpec::data_sink]
    /// to hold a `GcsDataSink`.
    ///
    /// Note that all the setters affecting `data_sink` are
    /// mutually exclusive.
    pub fn set_gcs_data_sink<T: std::convert::Into<std::boxed::Box<crate::model::GcsData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_sink = std::option::Option::Some(
            crate::model::replication_spec::DataSink::GcsDataSink(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplicationSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ReplicationSpec"
    }
}

/// Defines additional types related to [ReplicationSpec].
pub mod replication_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The data source to be replicated.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSource {
        /// The Cloud Storage bucket from which to replicate objects.
        GcsDataSource(std::boxed::Box<crate::model::GcsData>),
    }

    /// The destination for replicated objects.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSink {
        /// The Cloud Storage bucket to which to replicate objects.
        GcsDataSink(std::boxed::Box<crate::model::GcsData>),
    }
}

/// Specifies the metadata options for running a transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataOptions {
    /// Specifies how symlinks should be handled by the transfer. By default,
    /// symlinks are not preserved. Only applicable to transfers involving
    /// POSIX file systems, and ignored for other transfers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub symlink: crate::model::metadata_options::Symlink,

    /// Specifies how each file's mode attribute should be handled by the transfer.
    /// By default, mode is not preserved. Only applicable to transfers involving
    /// POSIX file systems, and ignored for other transfers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub mode: crate::model::metadata_options::Mode,

    /// Specifies how each file's POSIX group ID (GID) attribute should be handled
    /// by the transfer. By default, GID is not preserved. Only applicable to
    /// transfers involving POSIX file systems, and ignored for other transfers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub gid: crate::model::metadata_options::Gid,

    /// Specifies how each file's POSIX user ID (UID) attribute should be handled
    /// by the transfer. By default, UID is not preserved. Only applicable to
    /// transfers involving POSIX file systems, and ignored for other transfers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub uid: crate::model::metadata_options::Uid,

    /// Specifies how each object's ACLs should be preserved for transfers between
    /// Google Cloud Storage buckets. If unspecified, the default behavior is the
    /// same as ACL_DESTINATION_BUCKET_DEFAULT.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub acl: crate::model::metadata_options::Acl,

    /// Specifies the storage class to set on objects being transferred to Google
    /// Cloud Storage buckets.  If unspecified, the default behavior is the same as
    /// [STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT][google.storagetransfer.v1.MetadataOptions.StorageClass.STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT].
    ///
    /// [google.storagetransfer.v1.MetadataOptions.StorageClass.STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT]: crate::model::metadata_options::StorageClass::DestinationBucketDefault
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub storage_class: crate::model::metadata_options::StorageClass,

    /// Specifies how each object's temporary hold status should be preserved for
    /// transfers between Google Cloud Storage buckets.  If unspecified, the
    /// default behavior is the same as
    /// [TEMPORARY_HOLD_PRESERVE][google.storagetransfer.v1.MetadataOptions.TemporaryHold.TEMPORARY_HOLD_PRESERVE].
    ///
    /// [google.storagetransfer.v1.MetadataOptions.TemporaryHold.TEMPORARY_HOLD_PRESERVE]: crate::model::metadata_options::TemporaryHold::Preserve
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub temporary_hold: crate::model::metadata_options::TemporaryHold,

    /// Specifies how each object's Cloud KMS customer-managed encryption key
    /// (CMEK) is preserved for transfers between Google Cloud Storage buckets.  If
    /// unspecified, the default behavior is the same as
    /// [KMS_KEY_DESTINATION_BUCKET_DEFAULT][google.storagetransfer.v1.MetadataOptions.KmsKey.KMS_KEY_DESTINATION_BUCKET_DEFAULT].
    ///
    /// [google.storagetransfer.v1.MetadataOptions.KmsKey.KMS_KEY_DESTINATION_BUCKET_DEFAULT]: crate::model::metadata_options::KmsKey::DestinationBucketDefault
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kms_key: crate::model::metadata_options::KmsKey,

    /// Specifies how each object's `timeCreated` metadata is preserved for
    /// transfers. If unspecified, the default behavior is the same as
    /// [TIME_CREATED_SKIP][google.storagetransfer.v1.MetadataOptions.TimeCreated.TIME_CREATED_SKIP].
    /// This behavior is supported for transfers to Cloud Storage buckets from
    /// Cloud Storage, Amazon S3, S3-compatible storage, and Azure sources.
    ///
    /// [google.storagetransfer.v1.MetadataOptions.TimeCreated.TIME_CREATED_SKIP]: crate::model::metadata_options::TimeCreated::Skip
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub time_created: crate::model::metadata_options::TimeCreated,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetadataOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [symlink][crate::model::MetadataOptions::symlink].
    pub fn set_symlink<T: std::convert::Into<crate::model::metadata_options::Symlink>>(
        mut self,
        v: T,
    ) -> Self {
        self.symlink = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::MetadataOptions::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::metadata_options::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [gid][crate::model::MetadataOptions::gid].
    pub fn set_gid<T: std::convert::Into<crate::model::metadata_options::Gid>>(
        mut self,
        v: T,
    ) -> Self {
        self.gid = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::MetadataOptions::uid].
    pub fn set_uid<T: std::convert::Into<crate::model::metadata_options::Uid>>(
        mut self,
        v: T,
    ) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::MetadataOptions::acl].
    pub fn set_acl<T: std::convert::Into<crate::model::metadata_options::Acl>>(
        mut self,
        v: T,
    ) -> Self {
        self.acl = v.into();
        self
    }

    /// Sets the value of [storage_class][crate::model::MetadataOptions::storage_class].
    pub fn set_storage_class<
        T: std::convert::Into<crate::model::metadata_options::StorageClass>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_class = v.into();
        self
    }

    /// Sets the value of [temporary_hold][crate::model::MetadataOptions::temporary_hold].
    pub fn set_temporary_hold<
        T: std::convert::Into<crate::model::metadata_options::TemporaryHold>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.temporary_hold = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::MetadataOptions::kms_key].
    pub fn set_kms_key<T: std::convert::Into<crate::model::metadata_options::KmsKey>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [time_created][crate::model::MetadataOptions::time_created].
    pub fn set_time_created<T: std::convert::Into<crate::model::metadata_options::TimeCreated>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_created = v.into();
        self
    }
}

impl wkt::message::Message for MetadataOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.MetadataOptions"
    }
}

/// Defines additional types related to [MetadataOptions].
pub mod metadata_options {
    #[allow(unused_imports)]
    use super::*;

    /// Whether symlinks should be skipped or preserved during a transfer job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Symlink {
        /// Symlink behavior is unspecified.
        Unspecified,
        /// Do not preserve symlinks during a transfer job.
        Skip,
        /// Preserve symlinks during a transfer job.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Symlink::value] or
        /// [Symlink::name].
        UnknownValue(symlink::UnknownValue),
    }

    #[doc(hidden)]
    pub mod symlink {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Symlink {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SYMLINK_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("SYMLINK_SKIP"),
                Self::Preserve => std::option::Option::Some("SYMLINK_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Symlink {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Symlink {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Symlink {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Preserve,
                _ => Self::UnknownValue(symlink::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Symlink {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SYMLINK_UNSPECIFIED" => Self::Unspecified,
                "SYMLINK_SKIP" => Self::Skip,
                "SYMLINK_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(symlink::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Symlink {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Symlink {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Symlink>::new(
                ".google.storagetransfer.v1.MetadataOptions.Symlink",
            ))
        }
    }

    /// Options for handling file mode attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode behavior is unspecified.
        Unspecified,
        /// Do not preserve mode during a transfer job.
        Skip,
        /// Preserve mode during a transfer job.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("MODE_SKIP"),
                Self::Preserve => std::option::Option::Some("MODE_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Preserve,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "MODE_SKIP" => Self::Skip,
                "MODE_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.storagetransfer.v1.MetadataOptions.Mode",
            ))
        }
    }

    /// Options for handling file GID attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Gid {
        /// GID behavior is unspecified.
        Unspecified,
        /// Do not preserve GID during a transfer job.
        Skip,
        /// Preserve GID during a transfer job.
        Number,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Gid::value] or
        /// [Gid::name].
        UnknownValue(gid::UnknownValue),
    }

    #[doc(hidden)]
    pub mod gid {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Gid {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Number => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GID_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("GID_SKIP"),
                Self::Number => std::option::Option::Some("GID_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Gid {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Gid {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Gid {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Number,
                _ => Self::UnknownValue(gid::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Gid {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GID_UNSPECIFIED" => Self::Unspecified,
                "GID_SKIP" => Self::Skip,
                "GID_NUMBER" => Self::Number,
                _ => Self::UnknownValue(gid::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Gid {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Number => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Gid {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Gid>::new(
                ".google.storagetransfer.v1.MetadataOptions.GID",
            ))
        }
    }

    /// Options for handling file UID attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Uid {
        /// UID behavior is unspecified.
        Unspecified,
        /// Do not preserve UID during a transfer job.
        Skip,
        /// Preserve UID during a transfer job.
        Number,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Uid::value] or
        /// [Uid::name].
        UnknownValue(uid::UnknownValue),
    }

    #[doc(hidden)]
    pub mod uid {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Uid {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Number => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UID_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("UID_SKIP"),
                Self::Number => std::option::Option::Some("UID_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Uid {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Uid {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Uid {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Number,
                _ => Self::UnknownValue(uid::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Uid {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UID_UNSPECIFIED" => Self::Unspecified,
                "UID_SKIP" => Self::Skip,
                "UID_NUMBER" => Self::Number,
                _ => Self::UnknownValue(uid::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Uid {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Number => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Uid {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Uid>::new(
                ".google.storagetransfer.v1.MetadataOptions.UID",
            ))
        }
    }

    /// Options for handling Cloud Storage object ACLs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Acl {
        /// ACL behavior is unspecified.
        Unspecified,
        /// Use the destination bucket's default object ACLS, if applicable.
        DestinationBucketDefault,
        /// Preserve the object's original ACLs. This requires the service account
        /// to have `storage.objects.getIamPolicy` permission for the source object.
        /// [Uniform bucket-level
        /// access](https://cloud.google.com/storage/docs/uniform-bucket-level-access)
        /// must not be enabled on either the source or destination buckets.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Acl::value] or
        /// [Acl::name].
        UnknownValue(acl::UnknownValue),
    }

    #[doc(hidden)]
    pub mod acl {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Acl {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DestinationBucketDefault => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACL_UNSPECIFIED"),
                Self::DestinationBucketDefault => {
                    std::option::Option::Some("ACL_DESTINATION_BUCKET_DEFAULT")
                }
                Self::Preserve => std::option::Option::Some("ACL_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Acl {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Acl {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Acl {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DestinationBucketDefault,
                2 => Self::Preserve,
                _ => Self::UnknownValue(acl::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Acl {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACL_UNSPECIFIED" => Self::Unspecified,
                "ACL_DESTINATION_BUCKET_DEFAULT" => Self::DestinationBucketDefault,
                "ACL_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(acl::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Acl {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DestinationBucketDefault => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Acl {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Acl>::new(
                ".google.storagetransfer.v1.MetadataOptions.Acl",
            ))
        }
    }

    /// Options for handling Google Cloud Storage object storage class.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageClass {
        /// Storage class behavior is unspecified.
        Unspecified,
        /// Use the destination bucket's default storage class.
        DestinationBucketDefault,
        /// Preserve the object's original storage class. This is only supported for
        /// transfers from Google Cloud Storage buckets. REGIONAL and MULTI_REGIONAL
        /// storage classes will be mapped to STANDARD to ensure they can be written
        /// to the destination bucket.
        Preserve,
        /// Set the storage class to STANDARD.
        Standard,
        /// Set the storage class to NEARLINE.
        Nearline,
        /// Set the storage class to COLDLINE.
        Coldline,
        /// Set the storage class to ARCHIVE.
        Archive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageClass::value] or
        /// [StorageClass::name].
        UnknownValue(storage_class::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_class {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageClass {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DestinationBucketDefault => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::Nearline => std::option::Option::Some(4),
                Self::Coldline => std::option::Option::Some(5),
                Self::Archive => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_CLASS_UNSPECIFIED"),
                Self::DestinationBucketDefault => {
                    std::option::Option::Some("STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT")
                }
                Self::Preserve => std::option::Option::Some("STORAGE_CLASS_PRESERVE"),
                Self::Standard => std::option::Option::Some("STORAGE_CLASS_STANDARD"),
                Self::Nearline => std::option::Option::Some("STORAGE_CLASS_NEARLINE"),
                Self::Coldline => std::option::Option::Some("STORAGE_CLASS_COLDLINE"),
                Self::Archive => std::option::Option::Some("STORAGE_CLASS_ARCHIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageClass {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageClass {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageClass {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DestinationBucketDefault,
                2 => Self::Preserve,
                3 => Self::Standard,
                4 => Self::Nearline,
                5 => Self::Coldline,
                6 => Self::Archive,
                _ => Self::UnknownValue(storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageClass {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_CLASS_UNSPECIFIED" => Self::Unspecified,
                "STORAGE_CLASS_DESTINATION_BUCKET_DEFAULT" => Self::DestinationBucketDefault,
                "STORAGE_CLASS_PRESERVE" => Self::Preserve,
                "STORAGE_CLASS_STANDARD" => Self::Standard,
                "STORAGE_CLASS_NEARLINE" => Self::Nearline,
                "STORAGE_CLASS_COLDLINE" => Self::Coldline,
                "STORAGE_CLASS_ARCHIVE" => Self::Archive,
                _ => Self::UnknownValue(storage_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageClass {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DestinationBucketDefault => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::Standard => serializer.serialize_i32(3),
                Self::Nearline => serializer.serialize_i32(4),
                Self::Coldline => serializer.serialize_i32(5),
                Self::Archive => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageClass {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageClass>::new(
                ".google.storagetransfer.v1.MetadataOptions.StorageClass",
            ))
        }
    }

    /// Options for handling temporary holds for Google Cloud Storage objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TemporaryHold {
        /// Temporary hold behavior is unspecified.
        Unspecified,
        /// Do not set a temporary hold on the destination object.
        Skip,
        /// Preserve the object's original temporary hold status.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TemporaryHold::value] or
        /// [TemporaryHold::name].
        UnknownValue(temporary_hold::UnknownValue),
    }

    #[doc(hidden)]
    pub mod temporary_hold {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TemporaryHold {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TEMPORARY_HOLD_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("TEMPORARY_HOLD_SKIP"),
                Self::Preserve => std::option::Option::Some("TEMPORARY_HOLD_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TemporaryHold {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TemporaryHold {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TemporaryHold {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Preserve,
                _ => Self::UnknownValue(temporary_hold::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TemporaryHold {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TEMPORARY_HOLD_UNSPECIFIED" => Self::Unspecified,
                "TEMPORARY_HOLD_SKIP" => Self::Skip,
                "TEMPORARY_HOLD_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(temporary_hold::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TemporaryHold {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TemporaryHold {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TemporaryHold>::new(
                ".google.storagetransfer.v1.MetadataOptions.TemporaryHold",
            ))
        }
    }

    /// Options for handling the KmsKey setting for Google Cloud Storage objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KmsKey {
        /// KmsKey behavior is unspecified.
        Unspecified,
        /// Use the destination bucket's default encryption settings.
        DestinationBucketDefault,
        /// Preserve the object's original Cloud KMS customer-managed encryption key
        /// (CMEK) if present. Objects that do not use a Cloud KMS encryption key
        /// will be encrypted using the destination bucket's encryption settings.
        Preserve,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KmsKey::value] or
        /// [KmsKey::name].
        UnknownValue(kms_key::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kms_key {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KmsKey {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DestinationBucketDefault => std::option::Option::Some(1),
                Self::Preserve => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KMS_KEY_UNSPECIFIED"),
                Self::DestinationBucketDefault => {
                    std::option::Option::Some("KMS_KEY_DESTINATION_BUCKET_DEFAULT")
                }
                Self::Preserve => std::option::Option::Some("KMS_KEY_PRESERVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KmsKey {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KmsKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KmsKey {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DestinationBucketDefault,
                2 => Self::Preserve,
                _ => Self::UnknownValue(kms_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KmsKey {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KMS_KEY_UNSPECIFIED" => Self::Unspecified,
                "KMS_KEY_DESTINATION_BUCKET_DEFAULT" => Self::DestinationBucketDefault,
                "KMS_KEY_PRESERVE" => Self::Preserve,
                _ => Self::UnknownValue(kms_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KmsKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DestinationBucketDefault => serializer.serialize_i32(1),
                Self::Preserve => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KmsKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KmsKey>::new(
                ".google.storagetransfer.v1.MetadataOptions.KmsKey",
            ))
        }
    }

    /// Options for handling `timeCreated` metadata for Google Cloud Storage
    /// objects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeCreated {
        /// TimeCreated behavior is unspecified.
        Unspecified,
        /// Do not preserve the `timeCreated` metadata from the source object.
        Skip,
        /// Preserves the source object's `timeCreated` or `lastModified` metadata in
        /// the `customTime` field in the destination object.  Note that any value
        /// stored in the source object's `customTime` field will not be propagated
        /// to the destination object.
        PreserveAsCustomTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeCreated::value] or
        /// [TimeCreated::name].
        UnknownValue(time_created::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_created {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeCreated {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::PreserveAsCustomTime => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_CREATED_UNSPECIFIED"),
                Self::Skip => std::option::Option::Some("TIME_CREATED_SKIP"),
                Self::PreserveAsCustomTime => {
                    std::option::Option::Some("TIME_CREATED_PRESERVE_AS_CUSTOM_TIME")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeCreated {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeCreated {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeCreated {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::PreserveAsCustomTime,
                _ => Self::UnknownValue(time_created::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeCreated {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_CREATED_UNSPECIFIED" => Self::Unspecified,
                "TIME_CREATED_SKIP" => Self::Skip,
                "TIME_CREATED_PRESERVE_AS_CUSTOM_TIME" => Self::PreserveAsCustomTime,
                _ => Self::UnknownValue(time_created::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeCreated {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::PreserveAsCustomTime => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeCreated {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeCreated>::new(
                ".google.storagetransfer.v1.MetadataOptions.TimeCreated",
            ))
        }
    }
}

/// Specifies where the manifest is located.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferManifest {
    /// Specifies the path to the manifest in Cloud Storage. The Google-managed
    /// service account for the transfer must have `storage.objects.get`
    /// permission for this object. An example path is
    /// `gs://bucket_name/path/manifest.csv`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferManifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::TransferManifest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for TransferManifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferManifest"
    }
}

/// Transfers can be scheduled to recur or to run just once.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schedule {
    /// Required. The start date of a transfer. Date boundaries are determined
    /// relative to UTC time. If `schedule_start_date` and
    /// [start_time_of_day][google.storagetransfer.v1.Schedule.start_time_of_day]
    /// are in the past relative to the job's creation time, the transfer starts
    /// the day after you schedule the transfer request.
    ///
    /// **Note:** When starting jobs at or near midnight UTC it is possible that
    /// a job starts later than expected. For example, if you send an outbound
    /// request on June 1 one millisecond prior to midnight UTC and the Storage
    /// Transfer Service server receives the request on June 2, then it creates
    /// a TransferJob with `schedule_start_date` set to June 2 and a
    /// `start_time_of_day` set to midnight UTC. The first scheduled
    /// [TransferOperation][google.storagetransfer.v1.TransferOperation] takes
    /// place on June 3 at midnight UTC.
    ///
    /// [google.storagetransfer.v1.Schedule.start_time_of_day]: crate::model::Schedule::start_time_of_day
    /// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_start_date: std::option::Option<gtype::model::Date>,

    /// The last day a transfer runs. Date boundaries are determined relative to
    /// UTC time. A job runs once per 24 hours within the following guidelines:
    ///
    /// * If `schedule_end_date` and
    ///   [schedule_start_date][google.storagetransfer.v1.Schedule.schedule_start_date]
    ///   are the same and in
    ///   the future relative to UTC, the transfer is executed only one time.
    /// * If `schedule_end_date` is later than `schedule_start_date`  and
    ///   `schedule_end_date` is in the future relative to UTC, the job runs each
    ///   day at
    ///   [start_time_of_day][google.storagetransfer.v1.Schedule.start_time_of_day]
    ///   through `schedule_end_date`.
    ///
    /// [google.storagetransfer.v1.Schedule.schedule_start_date]: crate::model::Schedule::schedule_start_date
    /// [google.storagetransfer.v1.Schedule.start_time_of_day]: crate::model::Schedule::start_time_of_day
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_end_date: std::option::Option<gtype::model::Date>,

    /// The time in UTC that a transfer job is scheduled to run. Transfers may
    /// start later than this time.
    ///
    /// If `start_time_of_day` is not specified:
    ///
    /// * One-time transfers run immediately.
    /// * Recurring transfers run immediately, and each day at midnight UTC,
    ///   through
    ///   [schedule_end_date][google.storagetransfer.v1.Schedule.schedule_end_date].
    ///
    /// If `start_time_of_day` is specified:
    ///
    /// * One-time transfers run at the specified time.
    /// * Recurring transfers run at the specified time each day, through
    ///   `schedule_end_date`.
    ///
    /// [google.storagetransfer.v1.Schedule.schedule_end_date]: crate::model::Schedule::schedule_end_date
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time_of_day: std::option::Option<gtype::model::TimeOfDay>,

    /// The time in UTC that no further transfer operations are scheduled. Combined
    /// with
    /// [schedule_end_date][google.storagetransfer.v1.Schedule.schedule_end_date],
    /// `end_time_of_day` specifies the end date and time for starting new transfer
    /// operations. This field must be greater than or equal to the timestamp
    /// corresponding to the combintation of
    /// [schedule_start_date][google.storagetransfer.v1.Schedule.schedule_start_date]
    /// and
    /// [start_time_of_day][google.storagetransfer.v1.Schedule.start_time_of_day],
    /// and is subject to the following:
    ///
    /// * If `end_time_of_day` is not set and `schedule_end_date` is set, then
    ///   a default value of `23:59:59` is used for `end_time_of_day`.
    ///
    /// * If `end_time_of_day` is set and `schedule_end_date` is not set, then
    ///   [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] is returned.
    ///
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    /// [google.storagetransfer.v1.Schedule.schedule_end_date]: crate::model::Schedule::schedule_end_date
    /// [google.storagetransfer.v1.Schedule.schedule_start_date]: crate::model::Schedule::schedule_start_date
    /// [google.storagetransfer.v1.Schedule.start_time_of_day]: crate::model::Schedule::start_time_of_day
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time_of_day: std::option::Option<gtype::model::TimeOfDay>,

    /// Interval between the start of each scheduled TransferOperation. If
    /// unspecified, the default value is 24 hours. This value may not be less than
    /// 1 hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repeat_interval: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule_start_date][crate::model::Schedule::schedule_start_date].
    pub fn set_schedule_start_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_start_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_start_date][crate::model::Schedule::schedule_start_date].
    pub fn set_or_clear_schedule_start_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_start_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule_end_date][crate::model::Schedule::schedule_end_date].
    pub fn set_schedule_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_end_date][crate::model::Schedule::schedule_end_date].
    pub fn set_or_clear_schedule_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.schedule_end_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time_of_day][crate::model::Schedule::start_time_of_day].
    pub fn set_start_time_of_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time_of_day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time_of_day][crate::model::Schedule::start_time_of_day].
    pub fn set_or_clear_start_time_of_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time_of_day = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time_of_day][crate::model::Schedule::end_time_of_day].
    pub fn set_end_time_of_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time_of_day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time_of_day][crate::model::Schedule::end_time_of_day].
    pub fn set_or_clear_end_time_of_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time_of_day = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repeat_interval][crate::model::Schedule::repeat_interval].
    pub fn set_repeat_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.repeat_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repeat_interval][crate::model::Schedule::repeat_interval].
    pub fn set_or_clear_repeat_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.repeat_interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.Schedule"
    }
}

/// Specifies the Event-driven transfer options. Event-driven transfers listen to
/// an event stream to transfer updated files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventStream {
    /// Required. Specifies a unique name of the resource such as AWS SQS
    /// ARN in the form 'arn:aws:sqs:region:account_id:queue_name',
    /// or Pub/Sub subscription resource name in the form
    /// 'projects/{project}/subscriptions/{sub}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Specifies the date and time that Storage Transfer Service starts
    /// listening for events from this stream. If no start time is specified or
    /// start time is in the past, Storage Transfer Service starts listening
    /// immediately.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_stream_start_time: std::option::Option<wkt::Timestamp>,

    /// Specifies the data and time at which Storage Transfer Service stops
    /// listening for events from this stream. After this time, any transfers in
    /// progress will complete, but no new transfers are initiated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_stream_expiration_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventStream::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event_stream_start_time][crate::model::EventStream::event_stream_start_time].
    pub fn set_event_stream_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_stream_start_time][crate::model::EventStream::event_stream_start_time].
    pub fn set_or_clear_event_stream_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_stream_expiration_time][crate::model::EventStream::event_stream_expiration_time].
    pub fn set_event_stream_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_stream_expiration_time][crate::model::EventStream::event_stream_expiration_time].
    pub fn set_or_clear_event_stream_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_stream_expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EventStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.EventStream"
    }
}

/// This resource represents the configuration of a transfer job that runs
/// periodically.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferJob {
    /// A unique name (within the transfer project) assigned when the job is
    /// created.  If this field is empty in a CreateTransferJobRequest, Storage
    /// Transfer Service assigns a unique name. Otherwise, the specified name
    /// is used as the unique name for this job.
    ///
    /// If the specified name is in use by a job, the creation request fails with
    /// an [ALREADY_EXISTS][google.rpc.Code.ALREADY_EXISTS] error.
    ///
    /// This name must start with `"transferJobs/"` prefix and end with a letter or
    /// a number, and should be no more than 128 characters. For transfers
    /// involving PosixFilesystem, this name must start with `transferJobs/OPI`
    /// specifically. For all other transfer types, this name must not start with
    /// `transferJobs/OPI`.
    ///
    /// Non-PosixFilesystem example:
    /// `"transferJobs/^(?!OPI)[A-Za-z0-9-._~]*[A-Za-z0-9]$"`
    ///
    /// PosixFilesystem example:
    /// `"transferJobs/OPI^[A-Za-z0-9-._~]*[A-Za-z0-9]$"`
    ///
    /// Applications must not rely on the enforcement of naming requirements
    /// involving OPI.
    ///
    /// Invalid job names fail with an
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error.
    ///
    /// [google.rpc.Code.ALREADY_EXISTS]: rpc::model::Code::AlreadyExists
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A description provided by the user for the job. Its max length is 1024
    /// bytes when Unicode-encoded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The ID of the Google Cloud project that owns the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Transfer specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_spec: std::option::Option<crate::model::TransferSpec>,

    /// Replication specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_spec: std::option::Option<crate::model::ReplicationSpec>,

    /// Notification configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Logging configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Specifies schedule for the transfer job.
    /// This is an optional field. When the field is not set, the job never
    /// executes a transfer, unless you invoke RunTransferJob or update the job to
    /// have a non-empty schedule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::Schedule>,

    /// Specifies the event stream for the transfer job for event-driven transfers.
    /// When EventStream is specified, the Schedule fields are ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_stream: std::option::Option<crate::model::EventStream>,

    /// Status of the job. This value MUST be specified for
    /// `CreateTransferJobRequests`.
    ///
    /// **Note:** The effect of the new job status takes place during a subsequent
    /// job run. For example, if you change the job status from
    /// [ENABLED][google.storagetransfer.v1.TransferJob.Status.ENABLED] to
    /// [DISABLED][google.storagetransfer.v1.TransferJob.Status.DISABLED], and an
    /// operation spawned by the transfer is running, the status change would not
    /// affect the current operation.
    ///
    /// [google.storagetransfer.v1.TransferJob.Status.DISABLED]: crate::model::transfer_job::Status::Disabled
    /// [google.storagetransfer.v1.TransferJob.Status.ENABLED]: crate::model::transfer_job::Status::Enabled
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub status: crate::model::transfer_job::Status,

    /// Output only. The time that the transfer job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creation_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that the transfer job was last modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modification_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that the transfer job was deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_time: std::option::Option<wkt::Timestamp>,

    /// The name of the most recently started TransferOperation of this JobConfig.
    /// Present if a TransferOperation has been created for this JobConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latest_operation_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransferJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TransferJob::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::TransferJob::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [transfer_spec][crate::model::TransferJob::transfer_spec].
    pub fn set_transfer_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_spec][crate::model::TransferJob::transfer_spec].
    pub fn set_or_clear_transfer_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_spec][crate::model::TransferJob::replication_spec].
    pub fn set_replication_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSpec>,
    {
        self.replication_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_spec][crate::model::TransferJob::replication_spec].
    pub fn set_or_clear_replication_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSpec>,
    {
        self.replication_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_config][crate::model::TransferJob::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::TransferJob::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::TransferJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::TransferJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::TransferJob::schedule].
    pub fn set_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schedule>,
    {
        self.schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule][crate::model::TransferJob::schedule].
    pub fn set_or_clear_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schedule>,
    {
        self.schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_stream][crate::model::TransferJob::event_stream].
    pub fn set_event_stream<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EventStream>,
    {
        self.event_stream = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_stream][crate::model::TransferJob::event_stream].
    pub fn set_or_clear_event_stream<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EventStream>,
    {
        self.event_stream = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::TransferJob::status].
    pub fn set_status<T: std::convert::Into<crate::model::transfer_job::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::TransferJob::creation_time].
    pub fn set_creation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_time][crate::model::TransferJob::creation_time].
    pub fn set_or_clear_creation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modification_time][crate::model::TransferJob::last_modification_time].
    pub fn set_last_modification_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modification_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modification_time][crate::model::TransferJob::last_modification_time].
    pub fn set_or_clear_last_modification_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modification_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_time][crate::model::TransferJob::deletion_time].
    pub fn set_deletion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deletion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_time][crate::model::TransferJob::deletion_time].
    pub fn set_or_clear_deletion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deletion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_operation_name][crate::model::TransferJob::latest_operation_name].
    pub fn set_latest_operation_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_operation_name = v.into();
        self
    }
}

impl wkt::message::Message for TransferJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferJob"
    }
}

/// Defines additional types related to [TransferJob].
pub mod transfer_job {
    #[allow(unused_imports)]
    use super::*;

    /// The status of the transfer job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Zero is an illegal value.
        Unspecified,
        /// New transfers are performed based on the schedule.
        Enabled,
        /// New transfers are not scheduled.
        Disabled,
        /// This is a soft delete state. After a transfer job is set to this
        /// state, the job and all the transfer executions are subject to
        /// garbage collection. Transfer jobs become eligible for garbage collection
        /// 30 days after their status is set to `DELETED`.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Deleted,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.storagetransfer.v1.TransferJob.Status",
            ))
        }
    }
}

/// An entry describing an error that has occurred.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorLogEntry {
    /// Required. A URL that refers to the target (a data source, a data sink,
    /// or an object) with which the error is associated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// A list of messages that carry the error details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_details: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::ErrorLogEntry::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [error_details][crate::model::ErrorLogEntry::error_details].
    pub fn set_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ErrorLogEntry"
    }
}

/// A summary of errors by error code, plus a count and sample error log
/// entries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorSummary {
    /// Required.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub error_code: rpc::model::Code,

    /// Required. Count of this type of error.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub error_count: i64,

    /// Error samples.
    ///
    /// At most 5 error log entries are recorded for a given
    /// error code for a single transfer operation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_log_entries: std::vec::Vec<crate::model::ErrorLogEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::ErrorSummary::error_code].
    pub fn set_error_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [error_count][crate::model::ErrorSummary::error_count].
    pub fn set_error_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.error_count = v.into();
        self
    }

    /// Sets the value of [error_log_entries][crate::model::ErrorSummary::error_log_entries].
    pub fn set_error_log_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorLogEntry>,
    {
        use std::iter::Iterator;
        self.error_log_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.ErrorSummary"
    }
}

/// A collection of counters that report the progress of a transfer operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferCounters {
    /// Objects found in the data source that are scheduled to be transferred,
    /// excluding any that are filtered based on object conditions or skipped due
    /// to sync.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_found_from_source: i64,

    /// Bytes found in the data source that are scheduled to be transferred,
    /// excluding any that are filtered based on object conditions or skipped due
    /// to sync.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_found_from_source: i64,

    /// Objects found only in the data sink that are scheduled to be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_found_only_from_sink: i64,

    /// Bytes found only in the data sink that are scheduled to be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_found_only_from_sink: i64,

    /// Objects in the data source that are not transferred because they already
    /// exist in the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_from_source_skipped_by_sync: i64,

    /// Bytes in the data source that are not transferred because they already
    /// exist in the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_from_source_skipped_by_sync: i64,

    /// Objects that are copied to the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_copied_to_sink: i64,

    /// Bytes that are copied to the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_copied_to_sink: i64,

    /// Objects that are deleted from the data source.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_deleted_from_source: i64,

    /// Bytes that are deleted from the data source.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_deleted_from_source: i64,

    /// Objects that are deleted from the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_deleted_from_sink: i64,

    /// Bytes that are deleted from the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_deleted_from_sink: i64,

    /// Objects in the data source that failed to be transferred or that failed
    /// to be deleted after being transferred.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_from_source_failed: i64,

    /// Bytes in the data source that failed to be transferred or that failed to
    /// be deleted after being transferred.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_from_source_failed: i64,

    /// Objects that failed to be deleted from the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub objects_failed_to_delete_from_sink: i64,

    /// Bytes that failed to be deleted from the data sink.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub bytes_failed_to_delete_from_sink: i64,

    /// For transfers involving PosixFilesystem only.
    ///
    /// Number of directories found while listing. For example, if the root
    /// directory of the transfer is `base/` and there are two other directories,
    /// `a/` and `b/` under this directory, the count after listing `base/`,
    /// `base/a/` and `base/b/` is 3.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub directories_found_from_source: i64,

    /// For transfers involving PosixFilesystem only.
    ///
    /// Number of listing failures for each directory found at the source.
    /// Potential failures when listing a directory include permission failure or
    /// block failure. If listing a directory fails, no files in the directory are
    /// transferred.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub directories_failed_to_list_from_source: i64,

    /// For transfers involving PosixFilesystem only.
    ///
    /// Number of successful listings for each directory found at the source.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub directories_successfully_listed_from_source: i64,

    /// Number of successfully cleaned up intermediate objects.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub intermediate_objects_cleaned_up: i64,

    /// Number of intermediate objects failed cleaned up.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub intermediate_objects_failed_cleaned_up: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferCounters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objects_found_from_source][crate::model::TransferCounters::objects_found_from_source].
    pub fn set_objects_found_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_found_from_source = v.into();
        self
    }

    /// Sets the value of [bytes_found_from_source][crate::model::TransferCounters::bytes_found_from_source].
    pub fn set_bytes_found_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_found_from_source = v.into();
        self
    }

    /// Sets the value of [objects_found_only_from_sink][crate::model::TransferCounters::objects_found_only_from_sink].
    pub fn set_objects_found_only_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_found_only_from_sink = v.into();
        self
    }

    /// Sets the value of [bytes_found_only_from_sink][crate::model::TransferCounters::bytes_found_only_from_sink].
    pub fn set_bytes_found_only_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_found_only_from_sink = v.into();
        self
    }

    /// Sets the value of [objects_from_source_skipped_by_sync][crate::model::TransferCounters::objects_from_source_skipped_by_sync].
    pub fn set_objects_from_source_skipped_by_sync<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.objects_from_source_skipped_by_sync = v.into();
        self
    }

    /// Sets the value of [bytes_from_source_skipped_by_sync][crate::model::TransferCounters::bytes_from_source_skipped_by_sync].
    pub fn set_bytes_from_source_skipped_by_sync<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.bytes_from_source_skipped_by_sync = v.into();
        self
    }

    /// Sets the value of [objects_copied_to_sink][crate::model::TransferCounters::objects_copied_to_sink].
    pub fn set_objects_copied_to_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_copied_to_sink = v.into();
        self
    }

    /// Sets the value of [bytes_copied_to_sink][crate::model::TransferCounters::bytes_copied_to_sink].
    pub fn set_bytes_copied_to_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_copied_to_sink = v.into();
        self
    }

    /// Sets the value of [objects_deleted_from_source][crate::model::TransferCounters::objects_deleted_from_source].
    pub fn set_objects_deleted_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_deleted_from_source = v.into();
        self
    }

    /// Sets the value of [bytes_deleted_from_source][crate::model::TransferCounters::bytes_deleted_from_source].
    pub fn set_bytes_deleted_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_deleted_from_source = v.into();
        self
    }

    /// Sets the value of [objects_deleted_from_sink][crate::model::TransferCounters::objects_deleted_from_sink].
    pub fn set_objects_deleted_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_deleted_from_sink = v.into();
        self
    }

    /// Sets the value of [bytes_deleted_from_sink][crate::model::TransferCounters::bytes_deleted_from_sink].
    pub fn set_bytes_deleted_from_sink<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_deleted_from_sink = v.into();
        self
    }

    /// Sets the value of [objects_from_source_failed][crate::model::TransferCounters::objects_from_source_failed].
    pub fn set_objects_from_source_failed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.objects_from_source_failed = v.into();
        self
    }

    /// Sets the value of [bytes_from_source_failed][crate::model::TransferCounters::bytes_from_source_failed].
    pub fn set_bytes_from_source_failed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_from_source_failed = v.into();
        self
    }

    /// Sets the value of [objects_failed_to_delete_from_sink][crate::model::TransferCounters::objects_failed_to_delete_from_sink].
    pub fn set_objects_failed_to_delete_from_sink<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.objects_failed_to_delete_from_sink = v.into();
        self
    }

    /// Sets the value of [bytes_failed_to_delete_from_sink][crate::model::TransferCounters::bytes_failed_to_delete_from_sink].
    pub fn set_bytes_failed_to_delete_from_sink<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.bytes_failed_to_delete_from_sink = v.into();
        self
    }

    /// Sets the value of [directories_found_from_source][crate::model::TransferCounters::directories_found_from_source].
    pub fn set_directories_found_from_source<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.directories_found_from_source = v.into();
        self
    }

    /// Sets the value of [directories_failed_to_list_from_source][crate::model::TransferCounters::directories_failed_to_list_from_source].
    pub fn set_directories_failed_to_list_from_source<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.directories_failed_to_list_from_source = v.into();
        self
    }

    /// Sets the value of [directories_successfully_listed_from_source][crate::model::TransferCounters::directories_successfully_listed_from_source].
    pub fn set_directories_successfully_listed_from_source<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.directories_successfully_listed_from_source = v.into();
        self
    }

    /// Sets the value of [intermediate_objects_cleaned_up][crate::model::TransferCounters::intermediate_objects_cleaned_up].
    pub fn set_intermediate_objects_cleaned_up<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.intermediate_objects_cleaned_up = v.into();
        self
    }

    /// Sets the value of [intermediate_objects_failed_cleaned_up][crate::model::TransferCounters::intermediate_objects_failed_cleaned_up].
    pub fn set_intermediate_objects_failed_cleaned_up<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.intermediate_objects_failed_cleaned_up = v.into();
        self
    }
}

impl wkt::message::Message for TransferCounters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferCounters"
    }
}

/// Specification to configure notifications published to Pub/Sub.
/// Notifications are published to the customer-provided topic using the
/// following `PubsubMessage.attributes`:
///
/// * `"eventType"`: one of the
///   [EventType][google.storagetransfer.v1.NotificationConfig.EventType] values
/// * `"payloadFormat"`: one of the
///   [PayloadFormat][google.storagetransfer.v1.NotificationConfig.PayloadFormat]
///   values
/// * `"projectId"`: the
///   [project_id][google.storagetransfer.v1.TransferOperation.project_id] of the
///   `TransferOperation`
/// * `"transferJobName"`: the
///   [transfer_job_name][google.storagetransfer.v1.TransferOperation.transfer_job_name]
///   of the `TransferOperation`
/// * `"transferOperationName"`: the
///   [name][google.storagetransfer.v1.TransferOperation.name] of the
///   `TransferOperation`
///
/// The `PubsubMessage.data` contains a
/// [TransferOperation][google.storagetransfer.v1.TransferOperation] resource
/// formatted according to the specified `PayloadFormat`.
///
/// [google.storagetransfer.v1.NotificationConfig.EventType]: crate::model::notification_config::EventType
/// [google.storagetransfer.v1.NotificationConfig.PayloadFormat]: crate::model::notification_config::PayloadFormat
/// [google.storagetransfer.v1.TransferOperation]: crate::model::TransferOperation
/// [google.storagetransfer.v1.TransferOperation.name]: crate::model::TransferOperation::name
/// [google.storagetransfer.v1.TransferOperation.project_id]: crate::model::TransferOperation::project_id
/// [google.storagetransfer.v1.TransferOperation.transfer_job_name]: crate::model::TransferOperation::transfer_job_name
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotificationConfig {
    /// Required. The `Topic.name` of the Pub/Sub topic to which to publish
    /// notifications. Must be of the format: `projects/{project}/topics/{topic}`.
    /// Not matching this format results in an
    /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error.
    ///
    /// [google.rpc.Code.INVALID_ARGUMENT]: rpc::model::Code::InvalidArgument
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pubsub_topic: std::string::String,

    /// Event types for which a notification is desired. If empty, send
    /// notifications for all event types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub event_types: std::vec::Vec<crate::model::notification_config::EventType>,

    /// Required. The desired format of the notification message payloads.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub payload_format: crate::model::notification_config::PayloadFormat,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pubsub_topic][crate::model::NotificationConfig::pubsub_topic].
    pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pubsub_topic = v.into();
        self
    }

    /// Sets the value of [event_types][crate::model::NotificationConfig::event_types].
    pub fn set_event_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::notification_config::EventType>,
    {
        use std::iter::Iterator;
        self.event_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [payload_format][crate::model::NotificationConfig::payload_format].
    pub fn set_payload_format<
        T: std::convert::Into<crate::model::notification_config::PayloadFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload_format = v.into();
        self
    }
}

impl wkt::message::Message for NotificationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.NotificationConfig"
    }
}

/// Defines additional types related to [NotificationConfig].
pub mod notification_config {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for specifying event types for which notifications are to be
    /// published.
    ///
    /// Additional event types may be added in the future. Clients should either
    /// safely ignore unrecognized event types or explicitly specify which event
    /// types they are prepared to accept.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Illegal value, to avoid allowing a default.
        Unspecified,
        /// `TransferOperation` completed with status
        /// [SUCCESS][google.storagetransfer.v1.TransferOperation.Status.SUCCESS].
        ///
        /// [google.storagetransfer.v1.TransferOperation.Status.SUCCESS]: crate::model::transfer_operation::Status::Success
        TransferOperationSuccess,
        /// `TransferOperation` completed with status
        /// [FAILED][google.storagetransfer.v1.TransferOperation.Status.FAILED].
        ///
        /// [google.storagetransfer.v1.TransferOperation.Status.FAILED]: crate::model::transfer_operation::Status::Failed
        TransferOperationFailed,
        /// `TransferOperation` completed with status
        /// [ABORTED][google.storagetransfer.v1.TransferOperation.Status.ABORTED].
        ///
        /// [google.storagetransfer.v1.TransferOperation.Status.ABORTED]: crate::model::transfer_operation::Status::Aborted
        TransferOperationAborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TransferOperationSuccess => std::option::Option::Some(1),
                Self::TransferOperationFailed => std::option::Option::Some(2),
                Self::TransferOperationAborted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::TransferOperationSuccess => {
                    std::option::Option::Some("TRANSFER_OPERATION_SUCCESS")
                }
                Self::TransferOperationFailed => {
                    std::option::Option::Some("TRANSFER_OPERATION_FAILED")
                }
                Self::TransferOperationAborted => {
                    std::option::Option::Some("TRANSFER_OPERATION_ABORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TransferOperationSuccess,
                2 => Self::TransferOperationFailed,
                3 => Self::TransferOperationAborted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TRANSFER_OPERATION_SUCCESS" => Self::TransferOperationSuccess,
                "TRANSFER_OPERATION_FAILED" => Self::TransferOperationFailed,
                "TRANSFER_OPERATION_ABORTED" => Self::TransferOperationAborted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TransferOperationSuccess => serializer.serialize_i32(1),
                Self::TransferOperationFailed => serializer.serialize_i32(2),
                Self::TransferOperationAborted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.storagetransfer.v1.NotificationConfig.EventType",
            ))
        }
    }

    /// Enum for specifying the format of a notification message's payload.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PayloadFormat {
        /// Illegal value, to avoid allowing a default.
        Unspecified,
        /// No payload is included with the notification.
        None,
        /// `TransferOperation` is [formatted as a JSON
        /// response](https://developers.google.com/protocol-buffers/docs/proto3#json),
        /// in application/json.
        Json,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PayloadFormat::value] or
        /// [PayloadFormat::name].
        UnknownValue(payload_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod payload_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PayloadFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PAYLOAD_FORMAT_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PayloadFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PayloadFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PayloadFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Json,
                _ => Self::UnknownValue(payload_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PayloadFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PAYLOAD_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "JSON" => Self::Json,
                _ => Self::UnknownValue(payload_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PayloadFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PayloadFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PayloadFormat>::new(
                ".google.storagetransfer.v1.NotificationConfig.PayloadFormat",
            ))
        }
    }
}

/// Specifies the logging behavior for transfer operations.
///
/// Logs can be sent to Cloud Logging for all transfer types. See
/// [Read transfer
/// logs](https://cloud.google.com/storage-transfer/docs/read-transfer-logs) for
/// details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Specifies the actions to be logged. If empty, no logs are generated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub log_actions: std::vec::Vec<crate::model::logging_config::LoggableAction>,

    /// States in which `log_actions` are logged. If empty, no logs are generated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub log_action_states: std::vec::Vec<crate::model::logging_config::LoggableActionState>,

    /// For PosixFilesystem transfers, enables
    /// [file system transfer
    /// logs](https://cloud.google.com/storage-transfer/docs/on-prem-transfer-log-format)
    /// instead of, or in addition to, Cloud Logging.
    ///
    /// This option ignores [LoggableAction] and [LoggableActionState]. If these
    /// are set, Cloud Logging will also be enabled for this transfer.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_onprem_gcs_transfer_logs: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_actions][crate::model::LoggingConfig::log_actions].
    pub fn set_log_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_config::LoggableAction>,
    {
        use std::iter::Iterator;
        self.log_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [log_action_states][crate::model::LoggingConfig::log_action_states].
    pub fn set_log_action_states<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_config::LoggableActionState>,
    {
        use std::iter::Iterator;
        self.log_action_states = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_onprem_gcs_transfer_logs][crate::model::LoggingConfig::enable_onprem_gcs_transfer_logs].
    pub fn set_enable_onprem_gcs_transfer_logs<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_onprem_gcs_transfer_logs = v.into();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.LoggingConfig"
    }
}

/// Defines additional types related to [LoggingConfig].
pub mod logging_config {
    #[allow(unused_imports)]
    use super::*;

    /// Loggable actions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoggableAction {
        /// Default value. This value is unused.
        Unspecified,
        /// Listing objects in a bucket.
        Find,
        /// Deleting objects at the source or the destination.
        Delete,
        /// Copying objects to Google Cloud Storage.
        Copy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoggableAction::value] or
        /// [LoggableAction::name].
        UnknownValue(loggable_action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod loggable_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoggableAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Find => std::option::Option::Some(1),
                Self::Delete => std::option::Option::Some(2),
                Self::Copy => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOGGABLE_ACTION_UNSPECIFIED"),
                Self::Find => std::option::Option::Some("FIND"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Copy => std::option::Option::Some("COPY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoggableAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoggableAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoggableAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Find,
                2 => Self::Delete,
                3 => Self::Copy,
                _ => Self::UnknownValue(loggable_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoggableAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOGGABLE_ACTION_UNSPECIFIED" => Self::Unspecified,
                "FIND" => Self::Find,
                "DELETE" => Self::Delete,
                "COPY" => Self::Copy,
                _ => Self::UnknownValue(loggable_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoggableAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Find => serializer.serialize_i32(1),
                Self::Delete => serializer.serialize_i32(2),
                Self::Copy => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoggableAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoggableAction>::new(
                ".google.storagetransfer.v1.LoggingConfig.LoggableAction",
            ))
        }
    }

    /// Loggable action states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoggableActionState {
        /// Default value. This value is unused.
        Unspecified,
        /// `LoggableAction` completed successfully. `SUCCEEDED` actions are
        /// logged as [INFO][google.logging.type.LogSeverity.INFO].
        Succeeded,
        /// `LoggableAction` terminated in an error state. `FAILED` actions are
        /// logged as [ERROR][google.logging.type.LogSeverity.ERROR].
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoggableActionState::value] or
        /// [LoggableActionState::name].
        UnknownValue(loggable_action_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod loggable_action_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoggableActionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOGGABLE_ACTION_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoggableActionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoggableActionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoggableActionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                _ => Self::UnknownValue(loggable_action_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoggableActionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOGGABLE_ACTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(loggable_action_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoggableActionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoggableActionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoggableActionState>::new(
                ".google.storagetransfer.v1.LoggingConfig.LoggableActionState",
            ))
        }
    }
}

/// A description of the execution of a transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferOperation {
    /// A globally unique ID assigned by the system.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The ID of the Google Cloud project that owns the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Transfer specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_spec: std::option::Option<crate::model::TransferSpec>,

    /// Notification configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Cloud Logging configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Start time of this transfer execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of this transfer execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Status of the transfer operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub status: crate::model::transfer_operation::Status,

    /// Information about the progress of the transfer operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub counters: std::option::Option<crate::model::TransferCounters>,

    /// Summarizes errors encountered with sample error log entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_breakdowns: std::vec::Vec<crate::model::ErrorSummary>,

    /// The name of the transfer job that triggers this transfer operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub transfer_job_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransferOperation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::TransferOperation::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [transfer_spec][crate::model::TransferOperation::transfer_spec].
    pub fn set_transfer_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_spec][crate::model::TransferOperation::transfer_spec].
    pub fn set_or_clear_transfer_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferSpec>,
    {
        self.transfer_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_config][crate::model::TransferOperation::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::TransferOperation::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::TransferOperation::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::TransferOperation::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::TransferOperation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TransferOperation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TransferOperation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TransferOperation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::TransferOperation::status].
    pub fn set_status<T: std::convert::Into<crate::model::transfer_operation::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [counters][crate::model::TransferOperation::counters].
    pub fn set_counters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferCounters>,
    {
        self.counters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [counters][crate::model::TransferOperation::counters].
    pub fn set_or_clear_counters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferCounters>,
    {
        self.counters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_breakdowns][crate::model::TransferOperation::error_breakdowns].
    pub fn set_error_breakdowns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorSummary>,
    {
        use std::iter::Iterator;
        self.error_breakdowns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transfer_job_name][crate::model::TransferOperation::transfer_job_name].
    pub fn set_transfer_job_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_job_name = v.into();
        self
    }
}

impl wkt::message::Message for TransferOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storagetransfer.v1.TransferOperation"
    }
}

/// Defines additional types related to [TransferOperation].
pub mod transfer_operation {
    #[allow(unused_imports)]
    use super::*;

    /// The status of a TransferOperation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Zero is an illegal value.
        Unspecified,
        /// In progress.
        InProgress,
        /// Paused.
        Paused,
        /// Completed successfully.
        Success,
        /// Terminated due to an unrecoverable failure.
        Failed,
        /// Aborted by the user.
        Aborted,
        /// Temporarily delayed by the system. No user action is required.
        Queued,
        /// The operation is suspending and draining the ongoing work to completion.
        Suspending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Success => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Aborted => std::option::Option::Some(5),
                Self::Queued => std::option::Option::Some(6),
                Self::Suspending => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Paused,
                3 => Self::Success,
                4 => Self::Failed,
                5 => Self::Aborted,
                6 => Self::Queued,
                7 => Self::Suspending,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "PAUSED" => Self::Paused,
                "SUCCESS" => Self::Success,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                "QUEUED" => Self::Queued,
                "SUSPENDING" => Self::Suspending,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Success => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Aborted => serializer.serialize_i32(5),
                Self::Queued => serializer.serialize_i32(6),
                Self::Suspending => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.storagetransfer.v1.TransferOperation.Status",
            ))
        }
    }
}
